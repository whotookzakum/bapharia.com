#ifndef UE4SS_SDK_SkyBlue_HPP
#define UE4SS_SDK_SkyBlue_HPP

#include "SkyBlue_enums.hpp"

struct FAcceptedQuestInfo
{
    int32 QuestIndex;                                                                 // 0x0000 (size: 0x4)
    EQuestStatus Status;                                                              // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 CurStep;                                                                    // 0x0008 (size: 0x4)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    FString Progress;                                                                 // 0x0010 (size: 0x10)
    FQuestProgressInfo ProgressInfo;                                                  // 0x0020 (size: 0x10)
    int32 ClearCount;                                                                 // 0x0030 (size: 0x4)
    int32 SelfContributionPoint;                                                      // 0x0034 (size: 0x4)
    int32 TeamContributionPoint;                                                      // 0x0038 (size: 0x4)
    int32 DamageRate;                                                                 // 0x003C (size: 0x4)
    int32 RankingRank;                                                                // 0x0040 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0044 (size: 0x4)
    int64 UpdatedAt;                                                                  // 0x0048 (size: 0x8)
    int64 RevivalAt;                                                                  // 0x0050 (size: 0x8)
    int32 ResponseCode;                                                               // 0x0058 (size: 0x4)

}; // Size: 0x60

struct FAchievementMasterData
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    int32 SortId;                                                                     // 0x0004 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0008 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x000C (size: 0x4)
    int32 LargeCategoryId;                                                            // 0x0010 (size: 0x4)
    int32 MediumCategoryId;                                                           // 0x0014 (size: 0x4)
    bool Flag;                                                                        // 0x0018 (size: 0x1)
    ESBAchievementMasterTitleFlag TitleFlag;                                          // 0x0019 (size: 0x1)
    char padding_0[0x2];                                                              // 0x001A (size: 0x2)
    int32 Rank;                                                                       // 0x001C (size: 0x4)
    int32 ObjectKind;                                                                 // 0x0020 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0024 (size: 0x4)
    FString ObjectId;                                                                 // 0x0028 (size: 0x10)
    int32 ObjectNum;                                                                  // 0x0038 (size: 0x4)
    int32 ValidConditionId;                                                           // 0x003C (size: 0x4)
    int32 ValidConditionKind;                                                         // 0x0040 (size: 0x4)
    int32 ValidConditionKindValue;                                                    // 0x0044 (size: 0x4)
    FString TermId;                                                                   // 0x0048 (size: 0x10)
    int32 EvaluationType;                                                             // 0x0058 (size: 0x4)
    char padding_2[0x4];                                                              // 0x005C (size: 0x4)
    FDateTime Date;                                                                   // 0x0060 (size: 0x8)
    TArray<FString> RewardIdList;                                                     // 0x0068 (size: 0x10)

}; // Size: 0x78

struct FAkEventSwitch
{
    class UAkAudioEvent* Event;                                                       // 0x0000 (size: 0x8)
    TArray<FAkSwitch> Switch;                                                         // 0x0008 (size: 0x10)
    ESBAkEventLOD LOD;                                                                // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    float DelayTime;                                                                  // 0x001C (size: 0x4)

}; // Size: 0x20

struct FAkEventVariables
{
    class UAkAudioEvent* Event;                                                       // 0x0000 (size: 0x8)
    TArray<FAkSwitch> Switch;                                                         // 0x0008 (size: 0x10)
    FName AttachName;                                                                 // 0x0018 (size: 0x8)
    bool AutoDestroy;                                                                 // 0x0020 (size: 0x1)
    bool StopWhenOwnerDestroyed;                                                      // 0x0021 (size: 0x1)
    ESBAkEventLOD LOD;                                                                // 0x0022 (size: 0x1)
    char padding_0[0x5];                                                              // 0x0023 (size: 0x5)
    TArray<FSBAkRTPC> RTPC;                                                           // 0x0028 (size: 0x10)
    float DelayTime;                                                                  // 0x0038 (size: 0x4)
    bool bCanReuseAkComponent;                                                        // 0x003C (size: 0x1)

}; // Size: 0x40

struct FAkSwitch
{
    FString SwitchGroup;                                                              // 0x0000 (size: 0x10)
    FString SwitchState;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAlbumImageInfoData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString ImagePath;                                                                // 0x0010 (size: 0x10)
    FString ThumbnailPath;                                                            // 0x0020 (size: 0x10)
    bool isUsed;                                                                      // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FAnimalWaitParamInfo
{
    FName AnimalName;                                                                 // 0x0000 (size: 0x8)
    class UDataTable* WaitParamTable;                                                 // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FAppearanceWeaponSticker
{
    int32 AppearanceWeaponId;                                                         // 0x0000 (size: 0x4)
    EAppearanceWeaponStickerType StickerType;                                         // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 DurationHours;                                                              // 0x0008 (size: 0x4)
    int32 DurationMinutes;                                                            // 0x000C (size: 0x4)

}; // Size: 0x10

struct FArenaMissionAchieve
{
    EArenaMissionAchieveType Type;                                                    // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float TotalDealDamage;                                                            // 0x0004 (size: 0x4)
    int32 DealDamageAmount;                                                           // 0x0008 (size: 0x4)
    int32 CriticalAmount;                                                             // 0x000C (size: 0x4)
    int32 SkillAmount;                                                                // 0x0010 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0014 (size: 0x4)
    FString KillEnemyId;                                                              // 0x0018 (size: 0x10)
    int32 KillEnemyAmount;                                                            // 0x0028 (size: 0x4)
    int32 ImagineAmount;                                                              // 0x002C (size: 0x4)
    int32 CastSkill;                                                                  // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FArenaMissionInfo
{
    TArray<FArenaMissionAchieve> Achieves;                                            // 0x0000 (size: 0x10)
    TArray<FDataTableRowHandle> StatusAlimentHandle;                                  // 0x0010 (size: 0x10)
    float TimeLimit;                                                                  // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    FText RewardText;                                                                 // 0x0028 (size: 0x18)
    bool bCleared;                                                                    // 0x0040 (size: 0x1)

}; // Size: 0x48

struct FArenaMissionProgressInfo
{
    float TotalDealDamage;                                                            // 0x0000 (size: 0x4)
    int32 DealDamageAmount;                                                           // 0x0004 (size: 0x4)
    int32 CriticalHitAmount;                                                          // 0x0008 (size: 0x4)
    int32 SkillHitAmount;                                                             // 0x000C (size: 0x4)
    int32 KillEnemyAmount;                                                            // 0x0010 (size: 0x4)
    int32 ImagineAmount;                                                              // 0x0014 (size: 0x4)
    int32 CastSkill;                                                                  // 0x0018 (size: 0x4)
    bool bCleared;                                                                    // 0x001C (size: 0x1)

}; // Size: 0x20

struct FAutoStampWordData
{
    FString StampId;                                                                  // 0x0000 (size: 0x10)
    FString FixedPhraseId;                                                            // 0x0010 (size: 0x10)
    ESBAutoMessageTarget MessageTarget;                                               // 0x0020 (size: 0x1)
    bool bIsActive;                                                                   // 0x0021 (size: 0x1)

}; // Size: 0x28

struct FAutoWordUserSetting
{
    TMap<class EAutoWordEventType, class FAutoStampWordData> WordDataList;            // 0x0000 (size: 0x50)
    bool IsDisableAutoStamp;                                                          // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FBattleLevelSyncCommonInfo
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    int32 StackBNum;                                                                  // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FBattleMemberInfoSend
{
    FString UserId;                                                                   // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FBattleMemberLevelSyncInfo
{
    FString UserId;                                                                   // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)
    TArray<FBattleLevelSyncCommonInfo> Weapons;                                       // 0x0020 (size: 0x10)
    TArray<FBattleLevelSyncCommonInfo> ImagineActives;                                // 0x0030 (size: 0x10)
    TArray<FBattleLevelSyncCommonInfo> ImaginePassives;                               // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FBeamCollisionOverrideSection
{
    float OverrideSectionEndDist;                                                     // 0x0000 (size: 0x4)
    float OverrideSectionRadius;                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FBerserkerComponentSettings
{
    char padding_0[0x2];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x2

struct FBlockingCollisionActor
{
    char padding_0[0x4];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x4

struct FCameraComponentLocationData
{
    FName SocketName;                                                                 // 0x0000 (size: 0x8)
    float OffsetZ;                                                                    // 0x0008 (size: 0x4)
    bool bIsLocationWeightedAverage;                                                  // 0x000C (size: 0x1)

}; // Size: 0x10

struct FCameraComponentLocationOffsetParam
{
    float ElapsedDeltaTime;                                                           // 0x0000 (size: 0x4)
    float DeltaTime;                                                                  // 0x0004 (size: 0x4)
    FVector Location;                                                                 // 0x0008 (size: 0xC)

}; // Size: 0x14

struct FCameraZoomLevelParam
{
    FString CameraID;                                                                 // 0x0000 (size: 0x10)
    float ZoomLevel;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FCharaClassInfo
{
    ESBClassType Role;                                                                // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 Exp;                                                                        // 0x0004 (size: 0x4)
    int32 ClassMaxDamage;                                                             // 0x0008 (size: 0x4)
    int32 ExtraExp;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FCharaConfigInfo
{
    ESBOperateMode OperateMode;                                                       // 0x0000 (size: 0x1)
    bool OperateModeHelpVisibility;                                                   // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FCharaCreateBoneScaleList
{
    class USBCharaCreateBoneScaleData* C000;                                          // 0x0000 (size: 0x8)
    class USBCharaCreateBoneScaleData* M000;                                          // 0x0008 (size: 0x8)
    class USBCharaCreateBoneScaleData* M100;                                          // 0x0010 (size: 0x8)
    class USBCharaCreateBoneScaleData* M200;                                          // 0x0018 (size: 0x8)
    class USBCharaCreateBoneScaleData* M300;                                          // 0x0020 (size: 0x8)
    class USBCharaCreateBoneScaleData* M400;                                          // 0x0028 (size: 0x8)
    class USBCharaCreateBoneScaleData* M500;                                          // 0x0030 (size: 0x8)
    class USBCharaCreateBoneScaleData* F000;                                          // 0x0038 (size: 0x8)
    class USBCharaCreateBoneScaleData* F100;                                          // 0x0040 (size: 0x8)
    class USBCharaCreateBoneScaleData* F200;                                          // 0x0048 (size: 0x8)
    class USBCharaCreateBoneScaleData* F300;                                          // 0x0050 (size: 0x8)
    class USBCharaCreateBoneScaleData* F400;                                          // 0x0058 (size: 0x8)
    class USBCharaCreateBoneScaleData* F500;                                          // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FCharaEquipInfo
{
    TArray<FCharaEquipItemInfo> EquipItems;                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCharaEquipItemCharaCreateInfo
{
    ESBCharaEquipType EquipType;                                                      // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString PartsName;                                                                // 0x0008 (size: 0x10)
    int32 ColorIndex;                                                                 // 0x0018 (size: 0x4)
    int32 ColorSaturation;                                                            // 0x001C (size: 0x4)
    int32 ColorValue;                                                                 // 0x0020 (size: 0x4)
    int32 MaterialId;                                                                 // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FCharaEquipItemInfo
{
    bool EquipFlag;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ItemIndex;                                                                  // 0x0004 (size: 0x4)
    int32 ColorIndex;                                                                 // 0x0008 (size: 0x4)
    int32 ColorSaturation;                                                            // 0x000C (size: 0x4)
    int32 ColorValue;                                                                 // 0x0010 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0014 (size: 0x4)
    FString ItemUniqueId;                                                             // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FCharaSkillMasteryInfo
{
    int32 SkillId;                                                                    // 0x0000 (size: 0x4)
    int32 SkillLevel;                                                                 // 0x0004 (size: 0x4)
    ESkillTreeAbilityType AbilityType;                                                // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FCharacterCraftRecepi
{
    int32 RecepiId;                                                                   // 0x0000 (size: 0x4)
    bool IsCrafted;                                                                   // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FCircleEffectParameter
{
    float CircleRadius;                                                               // 0x0000 (size: 0x4)
    FVector CircleSoundOffset;                                                        // 0x0004 (size: 0xC)

}; // Size: 0x10

struct FClimbingPoint
{
    int32 PointID;                                                                    // 0x0000 (size: 0x4)
    int32 GroupId;                                                                    // 0x0004 (size: 0x4)
    FVector LocationOffset;                                                           // 0x0008 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x0014 (size: 0xC)
    float SearchRadius;                                                               // 0x0020 (size: 0x4)
    bool IsSwimmingSearch;                                                            // 0x0024 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0025 (size: 0x3)
    TArray<int32> LinkPointIDList;                                                    // 0x0028 (size: 0x10)
    TEnumAsByte<EClimbingEndPointType> ExitPointType;                                 // 0x0038 (size: 0x1)
    bool Active;                                                                      // 0x0039 (size: 0x1)

}; // Size: 0x40

struct FCollisionHitSetting
{
    bool bIsDisableSelfHit;                                                           // 0x0000 (size: 0x1)
    bool bIsOnlyTargetHit;                                                            // 0x0001 (size: 0x1)
    bool bIsInfinitePierce;                                                           // 0x0002 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0003 (size: 0x1)
    uint8 bIsEnableBlockingHitCheck;                                                  // 0x0004 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0005 (size: 0x3)
    bool bIsEnableHitCover;                                                           // 0x0008 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0009 (size: 0x3)
    FProjectileHitCoverConfig HitCoverConfig;                                         // 0x000C (size: 0x4)
    uint8 bIsHitTargetLimitOnlyOverlap;                                               // 0x0010 (size: 0x1)
    uint8 bIsDisableReHitDelay;                                                       // 0x0010 (size: 0x1)
    uint8 bIsShareHit;                                                                // 0x0010 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0011 (size: 0x3)
    FProjectileShareHitSetting ShareHitConfig;                                        // 0x0014 (size: 0x8)
    uint8 bIsEnableHitForCharacterGround;                                             // 0x001C (size: 0x1)
    uint8 bIsEnableHitFromGroundDist;                                                 // 0x001C (size: 0x1)
    char padding_4[0x3];                                                              // 0x001D (size: 0x3)
    float EnableHitFromGroundDist;                                                    // 0x0020 (size: 0x4)
    uint8 bIsHitOnlyFirstFrame;                                                       // 0x0024 (size: 0x1)
    uint8 bIsEnableSelfHitSlow;                                                       // 0x0024 (size: 0x1)
    uint8 bIsEnableWeakPointHit;                                                      // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FCollisionHitSettingExtended : public FCollisionHitSetting
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

struct FCollisionOnOffData
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    ECollisionOnOff OnOff;                                                            // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FCommonCharacterSave
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    FCraftSave CraftSave;                                                             // 0x0010 (size: 0x18)

}; // Size: 0x28

struct FCommunicateSettingInfo
{
    FString Comment;                                                                  // 0x0000 (size: 0x10)
    ESBTensionTagType TensionTag;                                                     // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    FString CharacterId;                                                              // 0x0018 (size: 0x10)
    FString CharacterShortId;                                                         // 0x0028 (size: 0x10)
    FString CharacterName;                                                            // 0x0038 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0048 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0049 (size: 0x7)
    TArray<FSBActivityData> Activities;                                               // 0x0050 (size: 0x10)
    ESBProfilePublicSettingType GlobalPublicSetting;                                  // 0x0060 (size: 0x1)
    ESBProfilePublicSettingType BattleInfoPublicSetting;                              // 0x0061 (size: 0x1)
    ESBProfilePublicSettingType ActivitiesPublicSetting;                              // 0x0062 (size: 0x1)
    char padding_2[0x1];                                                              // 0x0063 (size: 0x1)
    int32 AchievementSelected;                                                        // 0x0064 (size: 0x4)
    TArray<FPlayerProfilePhotoTrimmingInfo> PhotoTrimmingInfo;                        // 0x0068 (size: 0x10)
    FString LocationName;                                                             // 0x0078 (size: 0x10)
    FString ZoneId;                                                                   // 0x0088 (size: 0x10)
    FPlayerProfileClassListData ClassDataList;                                        // 0x0098 (size: 0x10)
    bool SendCardFromParty;                                                           // 0x00A8 (size: 0x1)
    bool SendCardReceiveCard;                                                         // 0x00A9 (size: 0x1)
    char padding_3[0x2];                                                              // 0x00AA (size: 0x2)
    int32 ReceiveLikePoint;                                                           // 0x00AC (size: 0x4)
    FSBPlatformInfo PlatformInfo;                                                     // 0x00B0 (size: 0x20)
    TArray<int32> AwardIdList;                                                        // 0x00D0 (size: 0x10)
    int32 AdventureCardFrameId;                                                       // 0x00E0 (size: 0x4)
    int32 CharacterCardFrameId;                                                       // 0x00E4 (size: 0x4)
    int32 AdventureCardBackGroundColorId;                                             // 0x00E8 (size: 0x4)
    bool IsHidden;                                                                    // 0x00EC (size: 0x1)

}; // Size: 0xF0

struct FCompleteQuestDelegateParam
{
    int32 QuestIndex;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FAcceptedQuestInfo AcceptedQuestInfo;                                             // 0x0008 (size: 0x60)
    int32 Exp;                                                                        // 0x0068 (size: 0x4)
    int32 Money;                                                                      // 0x006C (size: 0x4)
    int32 Energy;                                                                     // 0x0070 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0074 (size: 0x4)
    TMap<int32, int32> Items;                                                         // 0x0078 (size: 0x50)
    TArray<FUnlockedQuestInfo> UnlockQuests;                                          // 0x00C8 (size: 0x10)

}; // Size: 0xD8

struct FCompleteQuestResponseData
{
    int32 QuestIndex;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    uint64 UpdatedAt;                                                                 // 0x0008 (size: 0x8)
    int32 ClearCount;                                                                 // 0x0010 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0014 (size: 0x4)
    int64 RevivalAt;                                                                  // 0x0018 (size: 0x8)
    TArray<FOwnItemInfo> Items;                                                       // 0x0020 (size: 0x10)
    int32 Money;                                                                      // 0x0030 (size: 0x4)
    int32 Engram;                                                                     // 0x0034 (size: 0x4)
    int32 BP;                                                                         // 0x0038 (size: 0x4)
    int32 ClassExp;                                                                   // 0x003C (size: 0x4)
    FSBExtraExpParse ClassExtraExp;                                                   // 0x0040 (size: 0x18)
    int32 BPPoint;                                                                    // 0x0058 (size: 0x4)
    int32 RoseOrbFree;                                                                // 0x005C (size: 0x4)
    TArray<FSBMailStampCategories> Stamps;                                            // 0x0060 (size: 0x10)
    TArray<FSBOwnEmoteData> Emotes;                                                   // 0x0070 (size: 0x10)
    TArray<FCharacterCraftRecepi> ImagineRecipes;                                     // 0x0080 (size: 0x10)
    TArray<FCharacterCraftRecepi> CraftRecipes;                                       // 0x0090 (size: 0x10)
    TArray<int32> RecipeSet;                                                          // 0x00A0 (size: 0x10)
    TArray<int32> GainedAchievementIds;                                               // 0x00B0 (size: 0x10)
    TArray<FSBCharacterToken> Tokens;                                                 // 0x00C0 (size: 0x10)
    TArray<FSBLiquidMemoryInfo> LiquidMemory;                                         // 0x00D0 (size: 0x10)
    TArray<int32> AdventureBoardIds;                                                  // 0x00E0 (size: 0x10)
    int32 VanishedMoney;                                                              // 0x00F0 (size: 0x4)
    int32 VanishedExp;                                                                // 0x00F4 (size: 0x4)
    int32 VanishedCoins;                                                              // 0x00F8 (size: 0x4)
    int32 VanishedCurrencies;                                                         // 0x00FC (size: 0x4)
    int32 VanishedGc;                                                                 // 0x0100 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0104 (size: 0x4)
    TArray<int32> VanishedAchievements;                                               // 0x0108 (size: 0x10)
    TArray<FSBCharacterToken> VanishedTokens;                                         // 0x0118 (size: 0x10)
    TArray<FOwnItemInfo> SoldItems;                                                   // 0x0128 (size: 0x10)
    int32 SoldProfit;                                                                 // 0x0138 (size: 0x4)
    char padding_3[0x4];                                                              // 0x013C (size: 0x4)
    int32 ResponseCode;                                                               // 0x0140 (size: 0x4)

}; // Size: 0x148

struct FConfigSaveData_GraphicsUser
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    bool bIsShowNamePlateParty;                                                       // 0x0010 (size: 0x1)
    bool bIsShowNamePlateOther;                                                       // 0x0011 (size: 0x1)
    bool bIsAlwaysShowFieldHUD;                                                       // 0x0012 (size: 0x1)
    TEnumAsByte<ESBPlayerVisibleLimit::Type> PlayerVisibleType;                       // 0x0013 (size: 0x1)
    bool bIsTeamTagVisible;                                                           // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FConfigSaveData_VFX
{
    TMap<class ESBBattleEffectVisibleCategory, class FConfigSaveData_VFXItem> VisibleType; // 0x0000 (size: 0x50)
    bool IsCustom;                                                                    // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FConfigSaveData_VFXItem
{
    bool Category;                                                                    // 0x0000 (size: 0x1)
    bool AttackDirectingVfx;                                                          // 0x0001 (size: 0x1)
    bool AreaAttackVfx;                                                               // 0x0002 (size: 0x1)
    bool AreaHealVfx;                                                                 // 0x0003 (size: 0x1)
    bool RangeAttackVfx;                                                              // 0x0004 (size: 0x1)
    bool BattleImagineVfx;                                                            // 0x0005 (size: 0x1)
    bool ULTVfx;                                                                      // 0x0006 (size: 0x1)

}; // Size: 0x7

struct FContactListData
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)
    FString CharacterName;                                                            // 0x0020 (size: 0x10)
    FString FaceIconUrl;                                                              // 0x0030 (size: 0x10)
    int32 ClassLevel;                                                                 // 0x0040 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0044 (size: 0x1)
    bool bIsFriend;                                                                   // 0x0045 (size: 0x1)
    bool bIsActive;                                                                   // 0x0046 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0047 (size: 0x1)
    FString ShotComment;                                                              // 0x0048 (size: 0x10)
    int32 LeftDay;                                                                    // 0x0058 (size: 0x4)
    char padding_1[0x4];                                                              // 0x005C (size: 0x4)
    FString TimesLeft;                                                                // 0x0060 (size: 0x10)
    ESBTensionTagType TensionTag;                                                     // 0x0070 (size: 0x1)
    bool IsOnline;                                                                    // 0x0071 (size: 0x1)
    bool CanSendCard;                                                                 // 0x0072 (size: 0x1)
    bool bSendLike;                                                                   // 0x0073 (size: 0x1)
    int32 OnlineStatus;                                                               // 0x0074 (size: 0x4)
    FSBPlatformInfo PlatformInfo;                                                     // 0x0078 (size: 0x20)
    bool bPartyMember;                                                                // 0x0098 (size: 0x1)
    bool bPartyLeader;                                                                // 0x0099 (size: 0x1)
    char padding_2[0x6];                                                              // 0x009A (size: 0x6)
    FString LastLogin;                                                                // 0x00A0 (size: 0x10)
    FDateTime LastExchangeDate;                                                       // 0x00B0 (size: 0x8)
    FDateTime FriendRegistratedDate;                                                  // 0x00B8 (size: 0x8)

}; // Size: 0xC0

struct FCostumeData
{
    int32 ColorIndex;                                                                 // 0x0000 (size: 0x4)
    int32 MaterialId;                                                                 // 0x0004 (size: 0x4)
    int32 ColorSaturation;                                                            // 0x0008 (size: 0x4)
    int32 ColorValue;                                                                 // 0x000C (size: 0x4)
    bool IsTermLimited;                                                               // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    FDateTime ExpiryDateTime;                                                         // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FCraftMasterData
{
    int32 RecepiId;                                                                   // 0x0000 (size: 0x4)
    bool IsItem;                                                                      // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 OutItemId;                                                                  // 0x0008 (size: 0x4)
    int32 OutItemNum;                                                                 // 0x000C (size: 0x4)
    int32 UseTicketUnit;                                                              // 0x0010 (size: 0x4)
    int32 MinLevel;                                                                   // 0x0014 (size: 0x4)
    int32 MaxLevel;                                                                   // 0x0018 (size: 0x4)
    int32 BonusRate;                                                                  // 0x001C (size: 0x4)
    int32 GrateSuccessGrantsFloor;                                                    // 0x0020 (size: 0x4)
    int32 GrateSuccessGrantsCeil;                                                     // 0x0024 (size: 0x4)
    int32 Money;                                                                      // 0x0028 (size: 0x4)
    int32 Difficulty;                                                                 // 0x002C (size: 0x4)
    bool IsAutoRelease;                                                               // 0x0030 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0031 (size: 0x7)
    FString KillerPerkPickId;                                                         // 0x0038 (size: 0x10)
    FCraftSlotRate SlotRate;                                                          // 0x0048 (size: 0x20)
    TArray<FCraftNeedItems> NeedItems;                                                // 0x0068 (size: 0x10)
    FString EventTermId;                                                              // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FCraftNeedItems
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    int32 Num;                                                                        // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FCraftSave
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    bool CraftMachineStorage;                                                         // 0x0010 (size: 0x1)
    bool ImagineCraftStorage;                                                         // 0x0011 (size: 0x1)

}; // Size: 0x18

struct FCraftSlotRate
{
    int32 Slot1BaseRate;                                                              // 0x0000 (size: 0x4)
    int32 Slot2BaseRate;                                                              // 0x0004 (size: 0x4)
    int32 Slot3BaseRate;                                                              // 0x0008 (size: 0x4)
    int32 Slot4BaseRate;                                                              // 0x000C (size: 0x4)
    int32 Slot1BonusRate;                                                             // 0x0010 (size: 0x4)
    int32 Slot2BonusRate;                                                             // 0x0014 (size: 0x4)
    int32 Slot3BonusRate;                                                             // 0x0018 (size: 0x4)
    int32 Slot4BonusRate;                                                             // 0x001C (size: 0x4)

}; // Size: 0x20

struct FCraftToken
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBCraftTokenType Type;                                                           // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 Ratio;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FCustomFlagInfo
{
    FString Name;                                                                     // 0x0000 (size: 0x10)

}; // Size: 0x18

struct FDelayValidHitOverlapCauseInfo
{
    char padding_0[0xA8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xA8

struct FDemoSoundData
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

struct FDigitalSignageMasterData
{
    FString GroupId;                                                                  // 0x0000 (size: 0x10)
    FString TermId;                                                                   // 0x0010 (size: 0x10)
    FString TextureName;                                                              // 0x0020 (size: 0x10)
    EDigitalSignageDataType DataType;                                                 // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    int32 TextureCnt;                                                                 // 0x0034 (size: 0x4)
    int32 Priority;                                                                   // 0x0038 (size: 0x4)

}; // Size: 0x40

struct FDigitalSignageTextrueParam
{
    FString TextureName;                                                              // 0x0000 (size: 0x10)
    EDigitalSignageDataType DataType;                                                 // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 TextureCnt;                                                                 // 0x0014 (size: 0x4)
    FString TarmId;                                                                   // 0x0018 (size: 0x10)
    int32 Priority;                                                                   // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FDungeonClearConditionInfo
{
    TArray<FDungeonClearConditionStepInfo> Steps;                                     // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FDungeonClearConditionItemInfo
{
    EDungeonClearConditionType Type;                                                  // 0x0000 (size: 0x1)
    bool bProgressTextOverride;                                                       // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    FName EnemyId;                                                                    // 0x0004 (size: 0x8)
    int32 EnemyAmount;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FDungeonClearConditionProgressInfo
{
    TArray<FDungeonClearConditionProgressStepInfo> Steps;                             // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FDungeonClearConditionProgressItemInfo
{
    int32 KillEnemyCount;                                                             // 0x0000 (size: 0x4)
    bool bCleared;                                                                    // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FDungeonClearConditionProgressStepInfo
{
    TArray<FDungeonClearConditionProgressItemInfo> ProgressItems;                     // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FDungeonClearConditionStepInfo
{
    TArray<FDungeonClearConditionItemInfo> ConditionItems;                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FEditorStreamingDependencies
{
    FName BaseLevel;                                                                  // 0x0000 (size: 0x8)
    TArray<FName> DependentLevels;                                                    // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FEffectActorParameter
{
    uint8 bIsEnable;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftClassPtr<ASBProjectileEffect> EffectActor;                                   // 0x0008 (size: 0x28)
    uint8 bIsAttach;                                                                  // 0x0030 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0031 (size: 0x3)
    EProjectileEffectAttachTargetType AttachTargetType;                               // 0x0034 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0035 (size: 0x3)
    FName AttachPointName;                                                            // 0x0038 (size: 0x8)
    FVector Offset;                                                                   // 0x0040 (size: 0xC)
    FRotator RotOffset;                                                               // 0x004C (size: 0xC)
    uint8 bIsLinkDestroyOnAttached;                                                   // 0x0058 (size: 0x1)
    uint8 bIsLinkDestroy;                                                             // 0x0058 (size: 0x1)

}; // Size: 0x60

struct FEnemyDeadNotifyInfo
{
    FString EnemyId;                                                                  // 0x0000 (size: 0x10)
    int32 EnemyLevel;                                                                 // 0x0010 (size: 0x4)
    int32 Engram;                                                                     // 0x0014 (size: 0x4)
    int32 Exp;                                                                        // 0x0018 (size: 0x4)
    int32 ExtraExp;                                                                   // 0x001C (size: 0x4)
    int32 Money;                                                                      // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    TArray<FEnemyDropItemInfo> PassiveDropItems;                                      // 0x0028 (size: 0x10)
    TArray<FSBCharacterToken> DropEventTokens;                                        // 0x0038 (size: 0x10)
    TArray<FOwnItemInfo> IgnoredItems;                                                // 0x0048 (size: 0x10)
    FDateTime Timestamp;                                                              // 0x0058 (size: 0x8)
    TArray<FSBDungeonSupply> PassiveDropSupply;                                       // 0x0060 (size: 0x10)
    bool IsDropRateUpLiquidMemoryEfficacyApplied;                                     // 0x0070 (size: 0x1)
    bool IsExpUpLiquidMemoryEfficacyApplied;                                          // 0x0071 (size: 0x1)

}; // Size: 0x78

struct FEnemyDropItemInfo
{
    FString UniqueId;                                                                 // 0x0000 (size: 0x10)
    int32 StorageNumber;                                                              // 0x0010 (size: 0x4)
    EItemType ItemType;                                                               // 0x0014 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0015 (size: 0x3)
    int32 ItemIndex;                                                                  // 0x0018 (size: 0x4)
    int32 Amount;                                                                     // 0x001C (size: 0x4)
    int32 DiffAmount;                                                                 // 0x0020 (size: 0x4)
    bool bIsIdentified;                                                               // 0x0024 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0025 (size: 0x3)
    double DefaultOrder;                                                              // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FEnemyParamMasterData
{
    FName EnemyId;                                                                    // 0x0000 (size: 0x8)
    FSBTextTableHash NameId;                                                          // 0x0008 (size: 0x4)
    FName AppearanceId;                                                               // 0x000C (size: 0x8)
    FSBEnemyAppearanceData AppearanceData;                                            // 0x0014 (size: 0x74)
    TArray<FSBEnemyLevelParamData> LevelParams;                                       // 0x0088 (size: 0x10)
    TArray<FSBEnemyDropItemData> DropItems;                                           // 0x0098 (size: 0x10)
    TArray<FSBEnemySkillParamData> SkillParams;                                       // 0x00A8 (size: 0x10)
    int32 BossClass;                                                                  // 0x00B8 (size: 0x4)
    float ElemDmgBias;                                                                // 0x00BC (size: 0x4)
    float DurabilityScale;                                                            // 0x00C0 (size: 0x4)
    int32 ResistRate;                                                                 // 0x00C4 (size: 0x4)
    int32 ResistDot;                                                                  // 0x00C8 (size: 0x4)
    int32 EnemyLibActiveTime;                                                         // 0x00CC (size: 0x4)
    ESBBattleBGMType BattleBGMType;                                                   // 0x00D0 (size: 0x1)

}; // Size: 0xD8

struct FEquipableClass
{
    TArray<bool> Classes;                                                             // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FEquipedArtsInfo
{
    ESBClassType ClassType;                                                           // 0x0000 (size: 0x1)
    ESBPlayerArtsType ArtsType;                                                       // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    int32 ArtsId;                                                                     // 0x0004 (size: 0x4)
    int32 SlotId;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FEquipedArtsListInfo
{
    TArray<FEquipedArtsInfo> InfoList;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FExchangeShopExchangingItemInfo
{
    FExchangeShopItemInfo ExchangeItemInfo;                                           // 0x0000 (size: 0x28)
    int32 ExchangeNum;                                                                // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FExchangeShopItemInfo
{
    FString ShopId;                                                                   // 0x0000 (size: 0x10)
    int32 Index;                                                                      // 0x0010 (size: 0x4)
    EItemType ItemType;                                                               // 0x0014 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0015 (size: 0x3)
    int32 ItemIndex;                                                                  // 0x0018 (size: 0x4)
    int32 ItemNum;                                                                    // 0x001C (size: 0x4)
    int32 BravePointCost;                                                             // 0x0020 (size: 0x4)
    int32 ExchangeLimit;                                                              // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FFieldActorBuffPointByMapNotifyInfo
{
    int32 FreeBuffPointId;                                                            // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString FreeBuffTag;                                                              // 0x0008 (size: 0x10)
    FString GameContentId;                                                            // 0x0018 (size: 0x10)
    char padding_1[0x10];                                                             // 0x0028 (size: 0x10)
    ESBFreeBuffPointView PointView;                                                   // 0x0038 (size: 0x1)
    bool IsActivate;                                                                  // 0x0039 (size: 0x1)
    char padding_2[0x6];                                                              // 0x003A (size: 0x6)
    FDateTime UpdateAt;                                                               // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FFieldActorBuffPointNotifyInfo
{
    FString MapName;                                                                  // 0x0000 (size: 0x10)
    FString FreeBuffPointId;                                                          // 0x0010 (size: 0x10)
    FDateTime InteractAt;                                                             // 0x0020 (size: 0x8)
    TArray<ESBFreeBuffPointType> BuffTypes;                                           // 0x0028 (size: 0x10)
    FDateTime EndBuffAt;                                                              // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FFieldActorBuffPointRespawnCheckResult
{
    FString MapName;                                                                  // 0x0000 (size: 0x10)
    FString FreeBuffPointId;                                                          // 0x0010 (size: 0x10)
    TArray<FSBLiquidMemoryInfo> LiquidMemoryInfos;                                    // 0x0020 (size: 0x10)
    bool bIsLiquidMemoryInfoValid;                                                    // 0x0030 (size: 0x1)
    bool IsReturnCity;                                                                // 0x0031 (size: 0x1)
    bool IsInteracted;                                                                // 0x0032 (size: 0x1)

}; // Size: 0x38

struct FFieldActorPickupNotifyInfo
{
    FString MapName;                                                                  // 0x0000 (size: 0x10)
    FString GatherPointId;                                                            // 0x0010 (size: 0x10)
    FDateTime GatheredAt;                                                             // 0x0020 (size: 0x8)
    FDateTime RespawnAt;                                                              // 0x0028 (size: 0x8)
    int32 Money;                                                                      // 0x0030 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0034 (size: 0x4)
    TArray<FOwnItemInfo> PassiveDropItems;                                            // 0x0038 (size: 0x10)
    TArray<FOwnItemInfo> IgnoredItems;                                                // 0x0048 (size: 0x10)
    int32 OverLimitCurrencies;                                                        // 0x0058 (size: 0x4)
    int32 OverLimitBPCoin;                                                            // 0x005C (size: 0x4)
    TArray<FSBLiquidMemoryInfo> LiquidMemoryInfos;                                    // 0x0060 (size: 0x10)
    bool bIsLiquidMemoryInfoValid;                                                    // 0x0070 (size: 0x1)
    ESBTreasureBoxRarity GatherType;                                                  // 0x0071 (size: 0x1)
    ESBDayTime TimeZone;                                                              // 0x0072 (size: 0x1)
    bool bIsBonusAdd;                                                                 // 0x0073 (size: 0x1)

}; // Size: 0x78

struct FFieldActorRespawnCheckResult
{
    FString MapName;                                                                  // 0x0000 (size: 0x10)
    FString GatherPointId;                                                            // 0x0010 (size: 0x10)
    TArray<FSBLiquidMemoryInfo> LiquidMemoryInfos;                                    // 0x0020 (size: 0x10)
    bool bIsLiquidMemoryInfoValid;                                                    // 0x0030 (size: 0x1)
    bool IsFiexedRespawn;                                                             // 0x0031 (size: 0x1)
    bool IsReturnCity;                                                                // 0x0032 (size: 0x1)
    bool IsGathered;                                                                  // 0x0033 (size: 0x1)

}; // Size: 0x38

struct FFilterGroup
{
    TArray<TEnumAsByte<EItemFilterType::Type>> Filters;                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FGameServerMasterData
{
    FString MapName;                                                                  // 0x0000 (size: 0x10)
    FString Address;                                                                  // 0x0010 (size: 0x10)
    FString Name;                                                                     // 0x0020 (size: 0x10)
    bool bIsAlive;                                                                    // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    int32 ClientCount;                                                                // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FGameplayCameraSettings : public FTableRowBase
{
    bool Active;                                                                      // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    FString CameraID;                                                                 // 0x0010 (size: 0x10)
    FPlayerCameraData CameraData;                                                     // 0x0020 (size: 0x178)
    TEnumAsByte<ECameraPriority> CameraPriority;                                      // 0x0198 (size: 0x1)

}; // Size: 0x1B0

struct FGatherPointLotResult
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)
    ESBTreasureBoxRewardType Type;                                                    // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FGroundHitEffectByMaterial
{
    TEnumAsByte<EPhysicalSurface> SurfaceType;                                        // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> HitParticle;                                      // 0x0008 (size: 0x28)
    TSoftClassPtr<ASBProjectileEffect> HitActor;                                      // 0x0030 (size: 0x28)
    FAkEventSwitch AkEventSwitch;                                                     // 0x0058 (size: 0x20)

}; // Size: 0x78

struct FGuildActivity
{
    EGuildActivityType Kind;                                                          // 0x0000 (size: 0x1)
    char padding_0[0x97];                                                             // 0x0001 (size: 0x97)
    FDateTime CreatedAt;                                                              // 0x0098 (size: 0x8)

}; // Size: 0xA0

struct FGuildChangeData
{
    FString Comment;                                                                  // 0x0000 (size: 0x10)
    TArray<ESBGuildActivityTime> ActivityTime;                                        // 0x0010 (size: 0x10)
    TEnumAsByte<EGuildAcceptType::Type> AcceptType;                                   // 0x0020 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0021 (size: 0x7)
    TArray<TEnumAsByte<EGuildAttribute::Type>> Attributes;                            // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FGuildData
{
    FString GuildId;                                                                  // 0x0000 (size: 0x10)
    FString GuildShortId;                                                             // 0x0010 (size: 0x10)
    FString GuildName;                                                                // 0x0020 (size: 0x10)
    FString GuildShortName;                                                           // 0x0030 (size: 0x10)
    FString Comment;                                                                  // 0x0040 (size: 0x10)
    bool IsEntry;                                                                     // 0x0050 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0051 (size: 0x7)
    FString LeaderName;                                                               // 0x0058 (size: 0x10)
    TArray<ESBGuildActivityTime> ActivityTime;                                        // 0x0068 (size: 0x10)
    TEnumAsByte<EGuildAcceptType::Type> AcceptType;                                   // 0x0078 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0079 (size: 0x7)
    TArray<TEnumAsByte<EGuildAttribute::Type>> Attributes;                            // 0x0080 (size: 0x10)
    int32 MemberNow;                                                                  // 0x0090 (size: 0x4)
    int32 MemberMax;                                                                  // 0x0094 (size: 0x4)
    int32 Experience;                                                                 // 0x0098 (size: 0x4)
    char padding_2[0x4];                                                              // 0x009C (size: 0x4)
    FDateTime CreatedAt;                                                              // 0x00A0 (size: 0x8)
    int32 RenameTokenNum;                                                             // 0x00A8 (size: 0x4)
    int32 leader_ps_only;                                                             // 0x00AC (size: 0x4)
    int32 ps_only;                                                                    // 0x00B0 (size: 0x4)

}; // Size: 0xB8

struct FGuildData_CS
{
    ESBPlatformType LastGuildNameEditorPlatformType;                                  // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString LastGuildNameEditorPlatformOnlineID;                                      // 0x0008 (size: 0x10)
    FString LastGuildNameEditorUserId;                                                // 0x0018 (size: 0x10)
    FString LastGuildNameEditorCharacterId;                                           // 0x0028 (size: 0x10)
    ESBPlatformType LeaderPlatformType;                                               // 0x0038 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0039 (size: 0x7)
    FString LeaderPlatformOnlineID;                                                   // 0x0040 (size: 0x10)
    ESBPlatformType LastCommentEditorPlatformType;                                    // 0x0050 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0051 (size: 0x7)
    FString LastCommentEditorPlatformOnlineID;                                        // 0x0058 (size: 0x10)
    FString LastCommentEditorUserId;                                                  // 0x0068 (size: 0x10)
    FString LastCommentEditorCharacterId;                                             // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FGuildEntryData
{
    FString EntryId;                                                                  // 0x0000 (size: 0x10)
    FString GuildId;                                                                  // 0x0010 (size: 0x10)
    FString GuildName;                                                                // 0x0020 (size: 0x10)
    FString GuildTag;                                                                 // 0x0030 (size: 0x10)
    FString UserId;                                                                   // 0x0040 (size: 0x10)
    FString CharacterId;                                                              // 0x0050 (size: 0x10)
    FString CharacterName;                                                            // 0x0060 (size: 0x10)
    int32 ClassLevel;                                                                 // 0x0070 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0074 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0075 (size: 0x3)
    FString Comment;                                                                  // 0x0078 (size: 0x10)
    bool IsInvite;                                                                    // 0x0088 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0089 (size: 0x3)
    int32 DaysLeft;                                                                   // 0x008C (size: 0x4)
    FString TimesLeft;                                                                // 0x0090 (size: 0x10)
    bool IsPSOnly_Target;                                                             // 0x00A0 (size: 0x1)

}; // Size: 0xA8

struct FGuildMemberData
{
    FString GuildId;                                                                  // 0x0000 (size: 0x10)
    FString MemberUserId;                                                             // 0x0010 (size: 0x10)
    FString MemberCharacterId;                                                        // 0x0020 (size: 0x10)
    FString CharacterName;                                                            // 0x0030 (size: 0x10)
    int32 ClassLevel;                                                                 // 0x0040 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0044 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0045 (size: 0x3)
    FString FaceIcon;                                                                 // 0x0048 (size: 0x10)
    FString Comment;                                                                  // 0x0058 (size: 0x10)
    TEnumAsByte<EGuildMemberRole::Type> GuildMemberRole;                              // 0x0068 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0069 (size: 0x7)
    FString LastLogin;                                                                // 0x0070 (size: 0x10)
    bool bNowOnline;                                                                  // 0x0080 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0081 (size: 0x3)
    int32 OnlineStatus;                                                               // 0x0084 (size: 0x4)
    FString EntryId;                                                                  // 0x0088 (size: 0x10)
    bool bSendLike;                                                                   // 0x0098 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0099 (size: 0x7)
    FSBPlatformInfo PlatformInfo;                                                     // 0x00A0 (size: 0x20)
    bool bPartyMember;                                                                // 0x00C0 (size: 0x1)
    bool bPartyLeader;                                                                // 0x00C1 (size: 0x1)
    bool bFriend;                                                                     // 0x00C2 (size: 0x1)
    ESBTensionTagType TensionTag;                                                     // 0x00C3 (size: 0x1)
    bool isAdventureCardSend;                                                         // 0x00C4 (size: 0x1)
    bool isAdventureCardDoneSend;                                                     // 0x00C5 (size: 0x1)
    char padding_4[0x2];                                                              // 0x00C6 (size: 0x2)
    FDateTime LastLogInDataTime;                                                      // 0x00C8 (size: 0x8)
    FDateTime FriendRegistratedDate;                                                  // 0x00D0 (size: 0x8)

}; // Size: 0xD8

struct FGuildRank
{
    int32 Rank;                                                                       // 0x0000 (size: 0x4)
    int32 NeedExp;                                                                    // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FGuildRankUnlockMaster
{
    int32 Rank;                                                                       // 0x0000 (size: 0x4)
    FSBTextTableHash TextId;                                                          // 0x0004 (size: 0x4)
    FSBTextTableHash DescID;                                                          // 0x0008 (size: 0x4)

}; // Size: 0x20

struct FGuildRepData
{
    FString GuildId;                                                                  // 0x0000 (size: 0x10)
    FString GuildName;                                                                // 0x0010 (size: 0x10)
    FString GuildShortName;                                                           // 0x0020 (size: 0x10)
    FString LastGuildNameEditorCharacterId;                                           // 0x0030 (size: 0x10)
    FString LastCommentEditorCharacterId;                                             // 0x0040 (size: 0x10)
    TEnumAsByte<EGuildMemberRole::Type> GuildMemberRole;                              // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FHairColorByRegion
{
    ESBCharaCreateColorHue Hue;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 MinValue;                                                                   // 0x0004 (size: 0x4)
    int32 MaxValue;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FHairColorLUT
{
    TArray<FColor> Color;                                                             // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FHoldingArrowEffectSetting
{
    FSBPlayingEffect PlayingEffect;                                                   // 0x0010 (size: 0xC8)

}; // Size: 0xE0

struct FImagineLevelData
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    int32 NextExp;                                                                    // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FImagineParameter
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    int32 Attack;                                                                     // 0x0004 (size: 0x4)
    int32 Defense;                                                                    // 0x0008 (size: 0x4)
    int32 STR;                                                                        // 0x000C (size: 0x4)
    int32 VIT;                                                                        // 0x0010 (size: 0x4)
    int32 DEX;                                                                        // 0x0014 (size: 0x4)
    int32 INT;                                                                        // 0x0018 (size: 0x4)
    int32 MND;                                                                        // 0x001C (size: 0x4)
    int32 Skill;                                                                      // 0x0020 (size: 0x4)
    int32 Attribute;                                                                  // 0x0024 (size: 0x4)
    float StatusTimescale;                                                            // 0x0028 (size: 0x4)
    int32 StatusId1;                                                                  // 0x002C (size: 0x4)
    float AbilityScale1;                                                              // 0x0030 (size: 0x4)
    int32 StatusId2;                                                                  // 0x0034 (size: 0x4)
    float AbilityScale2;                                                              // 0x0038 (size: 0x4)
    int32 StatusId3;                                                                  // 0x003C (size: 0x4)
    float AbilityScale3;                                                              // 0x0040 (size: 0x4)
    int32 StatusId4;                                                                  // 0x0044 (size: 0x4)
    float AbilityScale4;                                                              // 0x0048 (size: 0x4)
    int32 HyouiStatusId1;                                                             // 0x004C (size: 0x4)
    float HyouiAbilityScale1;                                                         // 0x0050 (size: 0x4)
    int32 HyouiStatusId2;                                                             // 0x0054 (size: 0x4)
    float HyouiAbilityScale2;                                                         // 0x0058 (size: 0x4)
    int32 HyouiStatusId3;                                                             // 0x005C (size: 0x4)
    float HyouiAbilityScale3;                                                         // 0x0060 (size: 0x4)
    int32 HyouiStatusId4;                                                             // 0x0064 (size: 0x4)
    float HyouiAbilityScale4;                                                         // 0x0068 (size: 0x4)

}; // Size: 0x6C

struct FItemEfficacy
{
    EItemEfficacyType Type;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 EfficacyId;                                                                 // 0x0004 (size: 0x4)
    FItemEfficacyTypeMasterData TypeData;                                             // 0x0008 (size: 0xC)
    int32 PerkId;                                                                     // 0x0014 (size: 0x4)
    int32 Value;                                                                      // 0x0018 (size: 0x4)
    int32 Value2;                                                                     // 0x001C (size: 0x4)
    FString ProjectileId;                                                             // 0x0020 (size: 0x10)
    int32 Time;                                                                       // 0x0030 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0034 (size: 0x4)
    FString EffectId;                                                                 // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FItemEfficacyTypeMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    EItemEfficacyType EfficacyType;                                                   // 0x0004 (size: 0x1)
    EItemEffictionType EffictionType;                                                 // 0x0005 (size: 0x1)
    bool bCanUseCity;                                                                 // 0x0006 (size: 0x1)
    bool bCanUseStorage;                                                              // 0x0007 (size: 0x1)
    bool bAllowUseOtherItem;                                                          // 0x0008 (size: 0x1)
    bool bRegisterShortcut;                                                           // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FItemMasterData
{
    bool CanUse;                                                                      // 0x0000 (size: 0x1)
    bool bDungeonOnly;                                                                // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    int32 Index;                                                                      // 0x0004 (size: 0x4)
    EItemType Type;                                                                   // 0x0008 (size: 0x1)
    ESBRarity Rarity;                                                                 // 0x0009 (size: 0x1)
    char padding_1[0x2];                                                              // 0x000A (size: 0x2)
    FSBTextTableHash Name;                                                            // 0x000C (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x0010 (size: 0x4)
    int32 ItemLevel;                                                                  // 0x0014 (size: 0x4)
    int32 ItemExp;                                                                    // 0x0018 (size: 0x4)
    int32 PricePlayerSells;                                                           // 0x001C (size: 0x4)
    int32 PricePlayerBuys;                                                            // 0x0020 (size: 0x4)
    int32 StackStorageNum;                                                            // 0x0024 (size: 0x4)
    FItemEfficacy Efficacy;                                                           // 0x0028 (size: 0x48)
    float RecastTime;                                                                 // 0x0070 (size: 0x4)
    FSBTextTableHash ItemEffectDescTextId;                                            // 0x0074 (size: 0x4)
    bool IsNoDissolution;                                                             // 0x0078 (size: 0x1)
    bool IsAccounting;                                                                // 0x0079 (size: 0x1)
    bool NoSaleFlag;                                                                  // 0x007A (size: 0x1)
    bool IsSupplyItem;                                                                // 0x007B (size: 0x1)
    bool IsFusionItem;                                                                // 0x007C (size: 0x1)
    char padding_2[0x3];                                                              // 0x007D (size: 0x3)
    int32 SortId;                                                                     // 0x0080 (size: 0x4)
    int32 AdventurerRank;                                                             // 0x0084 (size: 0x4)
    EItemObtainRouteType ObtainRoute;                                                 // 0x0088 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0089 (size: 0x3)
    FSBTextTableHash ObtainRouteId;                                                   // 0x008C (size: 0x4)
    bool IdentifiedByDefault;                                                         // 0x0090 (size: 0x1)
    char padding_4[0x3];                                                              // 0x0091 (size: 0x3)
    FName UnidentifiedIconName;                                                       // 0x0094 (size: 0x8)
    FSBTextTableHash UnidentifiedName;                                                // 0x009C (size: 0x4)
    FSBTextTableHash UnidentifiedDesc;                                                // 0x00A0 (size: 0x4)
    EItemCategory Category;                                                           // 0x00A4 (size: 0x1)
    char padding_5[0x3];                                                              // 0x00A5 (size: 0x3)
    FAppearanceWeaponSticker AppearanceWeaponSticker;                                 // 0x00A8 (size: 0x10)
    FString EventTermId;                                                              // 0x00B8 (size: 0x10)
    ESBClassType LimitClass;                                                          // 0x00C8 (size: 0x1)
    bool bRareProduction;                                                             // 0x00C9 (size: 0x1)

}; // Size: 0xD0

struct FLikeSend
{
    FString UserId;                                                                   // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FLineEffectPointParameter
{
    FVector StartPointOffset;                                                         // 0x0000 (size: 0xC)
    FVector EndPointOffset;                                                           // 0x000C (size: 0xC)

}; // Size: 0x18

struct FLockOnCameraInfo
{
    bool bUseFarInfo;                                                                 // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FLockOnCameraRotateInfo NearInfo;                                                 // 0x0008 (size: 0x40)
    FLockOnCameraRotateInfo FarInfo;                                                  // 0x0048 (size: 0x40)

}; // Size: 0x88

struct FLockOnCameraRotateInfo
{
    float Offset;                                                                     // 0x0000 (size: 0x4)
    float RotateStartAngle;                                                           // 0x0004 (size: 0x4)
    bool bUseRotateSpeedCurve;                                                        // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TSoftObjectPtr<UCurveFloat> RotateSpeedCurve;                                     // 0x0010 (size: 0x28)
    float RotateSpeed;                                                                // 0x0038 (size: 0x4)

}; // Size: 0x40

struct FLockOnCameraSettings : public FGameplayCameraSettings
{
    ESBLockOnCameraLookPoint LookPoint;                                               // 0x01B0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x01B1 (size: 0x7)
    FLockOnCameraInfo PitchCameraInfo;                                                // 0x01B8 (size: 0x88)
    FLockOnCameraInfo YawCameraInfo;                                                  // 0x0240 (size: 0x88)

}; // Size: 0x2C8

struct FMagicianModifyMaxHPMP
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    float ModifyPercentMaxHP;                                                         // 0x0004 (size: 0x4)
    float ModifyAddMaxMP;                                                             // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FMapInterruptQuestInfo
{
    FName QuestID;                                                                    // 0x0000 (size: 0x8)
    FString QuestName;                                                                // 0x0008 (size: 0x10)
    FVector QuestPointActorLocation;                                                  // 0x0018 (size: 0xC)

}; // Size: 0x28

struct FMapPinInfo
{
    int32 PinIndex;                                                                   // 0x0000 (size: 0x4)
    EMapPinType PinType;                                                              // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FString PinnedMapZoneId;                                                          // 0x0008 (size: 0x10)
    FVector2D PinnedLocationXY;                                                       // 0x0018 (size: 0x8)
    FVector PinnedWorldPosition;                                                      // 0x0020 (size: 0xC)
    char padding_1[0x4];                                                              // 0x002C (size: 0x4)
    FString Comment;                                                                  // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FMapPinListInfo
{
    TArray<FMapPinInfo> MapPinList;                                                   // 0x0000 (size: 0x10)
    bool IsPinDataLoadedFromDB;                                                       // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FMasterImagineLevel
{
    FString LevelType;                                                                // 0x0000 (size: 0x10)
    TArray<FImagineLevelData> LevelData;                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FMasterImagineMaterial
{
    EItemType ItemType;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    int32 Amount;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FMasterImagineParams
{
    FString ParamType;                                                                // 0x0000 (size: 0x10)
    TArray<FImagineParameter> Params;                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FMasterImaginePerkTable
{
    FString TableId;                                                                  // 0x0000 (size: 0x10)
    TArray<int32> Perks;                                                              // 0x0010 (size: 0x10)
    TArray<float> Rates;                                                              // 0x0020 (size: 0x10)
    char padding_0[0x8];                                                              // 0x0030 (size: 0x8)
    TArray<int32> PerkWeights;                                                        // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FMasterImagineRecepi
{
    int32 RecepiId;                                                                   // 0x0000 (size: 0x4)
    int32 ImagineId;                                                                  // 0x0004 (size: 0x4)
    int32 AdventurerRank;                                                             // 0x0008 (size: 0x4)
    bool AutoRelease;                                                                 // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    int32 Price;                                                                      // 0x0010 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0014 (size: 0x4)
    TArray<FMasterImagineMaterial> Materials;                                         // 0x0018 (size: 0x10)
    FString EventTermId;                                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FMasterToken
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0004 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x0008 (size: 0x4)
    ESBTokenPossessionType PossessionType;                                            // 0x000C (size: 0x1)
    ESBTokenCategory Category;                                                        // 0x000D (size: 0x1)
    char padding_0[0x2];                                                              // 0x000E (size: 0x2)
    int32 SortId;                                                                     // 0x0010 (size: 0x4)
    ESBTokenPurchaseType PurchaseType;                                                // 0x0014 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0015 (size: 0x3)
    int32 MaxAmount;                                                                  // 0x0018 (size: 0x4)
    char padding_2[0x4];                                                              // 0x001C (size: 0x4)
    FString PlaceToConsume;                                                           // 0x0020 (size: 0x10)
    FString TermId;                                                                   // 0x0030 (size: 0x10)
    ESBTokenRecoveryType RecoveryType;                                                // 0x0040 (size: 0x1)
    ESBTokenDayOfWeek RecoveryDayOfWeek;                                              // 0x0041 (size: 0x1)
    char padding_3[0x2];                                                              // 0x0042 (size: 0x2)
    int32 RecoveryMin;                                                                // 0x0044 (size: 0x4)
    int32 RecoverySec;                                                                // 0x0048 (size: 0x4)
    int32 RecoveryAmount;                                                             // 0x004C (size: 0x4)
    ESBTokenOverflowType OverflowType;                                                // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FMasterTokenUse
{
    int32 TokenID;                                                                    // 0x0000 (size: 0x4)
    ESBTokenPlaceToConsumeType PlaceToConsume;                                        // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FMovieSceneChoiceDialogSectionData : public FMovieSceneChannel
{
    TArray<FFrameNumber> Times;                                                       // 0x0008 (size: 0x10)
    TArray<FSBChoiceDialogPayload> KeyValues;                                         // 0x0018 (size: 0x10)

}; // Size: 0x88

struct FMssageRestrictionParam
{
    int32 RestrictionFromLogNum;                                                      // 0x0000 (size: 0x4)
    float RestrictionFromLogSec;                                                      // 0x0004 (size: 0x4)
    float RestrictionMessageSec;                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FMultiCraftData
{
    TArray<FOwnItemInfo> OutItems;                                                    // 0x0000 (size: 0x10)
    TArray<FOwnItemInfo> UseMaterials;                                                // 0x0010 (size: 0x10)
    bool IsCritical;                                                                  // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FMyCharacterWeaponData
{
    FString WeaponItemUniqueId;                                                       // 0x0000 (size: 0x10)
    int32 WeaponItemIndex;                                                            // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FString WeaponName;                                                               // 0x0018 (size: 0x10)
    int32 WeaponLevel;                                                                // 0x0028 (size: 0x4)
    float WeaponAura;                                                                 // 0x002C (size: 0x4)
    ESBRarity WeaponRarity;                                                           // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FNavDataInfo
{
    FName NavMeshName;                                                                // 0x0000 (size: 0x8)
    int32 VolatileNavMeshVersion;                                                     // 0x0008 (size: 0x4)
    int32 CachedPolyBaseNum;                                                          // 0x000C (size: 0x4)
    int32 CachedPolyNum;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FNavMeshInWaterDepthSetting
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FNotifyProjectileByCondition
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    FNotityProjectile NotifyConfig;                                                   // 0x0010 (size: 0x20)

}; // Size: 0x30

struct FNotifyProjectileByTag
{
    FName AnimationTagName;                                                           // 0x0000 (size: 0x8)
    FNotityProjectile NotifyConfig;                                                   // 0x0008 (size: 0x20)

}; // Size: 0x28

struct FNotifyProjectileConfigPackage
{
    FNotityProjectile NotifyConfig;                                                   // 0x0000 (size: 0x20)
    TArray<FNotifyProjectileByTag> NotifyByTagArray;                                  // 0x0020 (size: 0x10)
    TArray<FNotifyProjectileByCondition> NotifyByConditionArray;                      // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FNotifyStateChangeEmissiveColorTarget
{
    int32 WeaponIndex;                                                                // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<int32> MaterialIndex;                                                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FNotifySwitchVisibilityTarget
{
    bool bChangeToVisible;                                                            // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FName> TargetComponentName;                                                // 0x0008 (size: 0x10)
    TArray<FName> TargetComponentTag;                                                 // 0x0018 (size: 0x10)
    TArray<int32> TargetMaterialID;                                                   // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FNotityProjectile
{
    FSBProjectileSelectHandle ProjectileSelectHandle;                                 // 0x0000 (size: 0x18)
    FName SpawnSocketName;                                                            // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FNpcColorByRegion
{
    TArray<FHairColorByRegion> HairColor;                                             // 0x0000 (size: 0x10)
    TArray<FSkinColorByRegion> SkinColor;                                             // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FNpcInSensorActor
{
    class AActor* Actor;                                                              // 0x0000 (size: 0x8)
    float Length;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FNpcNavPathData
{
    FVector Point;                                                                    // 0x0000 (size: 0xC)
    float SnapRadius;                                                                 // 0x000C (size: 0x4)
    float SnapHeight;                                                                 // 0x0010 (size: 0x4)
    uint8 bUseSnapHeight;                                                             // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FNpcPathPointData
{
    FVector Point;                                                                    // 0x0000 (size: 0xC)
    FVector Tangent;                                                                  // 0x000C (size: 0xC)

}; // Size: 0x18

struct FOtherMessageRenderTarget
{
    class UTextureRenderTarget2D* RenderTarget;                                       // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FOwnItemInfo
{
    FString UniqueId;                                                                 // 0x0000 (size: 0x10)
    int32 ItemIndex;                                                                  // 0x0010 (size: 0x4)
    int32 Amount;                                                                     // 0x0014 (size: 0x4)
    int32 AmountBonus;                                                                // 0x0018 (size: 0x4)
    int32 AddedAmount;                                                                // 0x001C (size: 0x4)
    int32 StorageNumber;                                                              // 0x0020 (size: 0x4)
    EItemType ItemType;                                                               // 0x0024 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0025 (size: 0x3)
    double DefaultOrder;                                                              // 0x0028 (size: 0x8)
    FSBWeaponItemData WeaponData;                                                     // 0x0030 (size: 0x50)
    FCostumeData CostumeData;                                                         // 0x0080 (size: 0x20)
    FSBCharacterImagineData ImagineData;                                              // 0x00A0 (size: 0x18)
    FSBCharacterMountImagineData MountImagineData;                                    // 0x00B8 (size: 0x28)
    TArray<FSBTokenOverLimit> TokenData;                                              // 0x00E0 (size: 0x10)
    bool bItemLock;                                                                   // 0x00F0 (size: 0x1)
    bool bIsIdentified;                                                               // 0x00F1 (size: 0x1)
    char padding_1[0x1];                                                              // 0x00F2 (size: 0x1)
    bool bUsed;                                                                       // 0x00F3 (size: 0x1)
    bool bBilling;                                                                    // 0x00F4 (size: 0x1)
    bool bIsNew;                                                                      // 0x00F5 (size: 0x1)
    bool bIsBppIrredeemable;                                                          // 0x00F6 (size: 0x1)

}; // Size: 0xF8

struct FParticleParameter
{
    uint8 bIsEnable;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> Particle;                                         // 0x0008 (size: 0x28)
    TSoftObjectPtr<UParticleSystem> SimulatedParticle;                                // 0x0030 (size: 0x28)
    uint8 bIsAttach;                                                                  // 0x0058 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0059 (size: 0x3)
    EProjectileEffectAttachTargetType AttachTargetType;                               // 0x005C (size: 0x1)
    char padding_2[0x3];                                                              // 0x005D (size: 0x3)
    FName AttachPointName;                                                            // 0x0060 (size: 0x8)
    FVector Offset;                                                                   // 0x0068 (size: 0xC)
    FRotator RotOffset;                                                               // 0x0074 (size: 0xC)
    uint8 bIsAutoDestroy;                                                             // 0x0080 (size: 0x1)
    uint8 bIsLinkDestroy;                                                             // 0x0080 (size: 0x1)
    uint8 bIsDisableAutoDestroyWhenProjectileDestroy;                                 // 0x0080 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0081 (size: 0x3)
    float InitialScale;                                                               // 0x0084 (size: 0x4)
    uint8 bIsNotInheritanceScale;                                                     // 0x0088 (size: 0x1)
    char padding_4[0x3];                                                              // 0x0089 (size: 0x3)
    ESBEColorOverride OverrideEColor;                                                 // 0x008C (size: 0x1)

}; // Size: 0x90

struct FPathConfig
{
    EPathDirection PathDirection;                                                     // 0x0000 (size: 0x1)
    EPathTarget PathTarget;                                                           // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    float Width;                                                                      // 0x0004 (size: 0x4)
    uint8 LinkBeginEnd;                                                               // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FPhotoModeSaveUploadImage
{
    class UTexture2DDynamic* Texture;                                                 // 0x0000 (size: 0x8)
    TArray<uint8> PNGData;                                                            // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FPhotoModeUploadedImageInfo
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    FString ImagePath;                                                                // 0x0010 (size: 0x10)
    bool bIsLocked;                                                                   // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FPioneerAbilityList
{
    TArray<FSBWarehouseAbilityListUIInfo> AbilityList;                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPlayerAwardData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDateTime CreateAt;                                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FPlayerCameraArmLengthData
{
    float MinArmLength;                                                               // 0x0000 (size: 0x4)
    float MaxArmLength;                                                               // 0x0004 (size: 0x4)
    float DefaultArmLength;                                                           // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FPlayerCameraBlendCurveData
{
    TSoftObjectPtr<UCurveFloat> BlendInCurve;                                         // 0x0000 (size: 0x28)
    bool UseBlendOutCurve;                                                            // 0x0028 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0029 (size: 0x7)
    TSoftObjectPtr<UCurveFloat> BlendOutCurve;                                        // 0x0030 (size: 0x28)

}; // Size: 0x58

struct FPlayerCameraBlendTimeData
{
    float BlendInTime;                                                                // 0x0000 (size: 0x4)
    bool UseBlendOutTime;                                                             // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    float BlendOutTime;                                                               // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FPlayerCameraData : public FTableRowBase
{
    ESBCameraType CameraType;                                                         // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    float FOV;                                                                        // 0x000C (size: 0x4)
    FCameraComponentLocationData ComponentLocationData;                               // 0x0010 (size: 0x10)
    FPlayerCameraZoomData ZoomData;                                                   // 0x0020 (size: 0x10)
    FPlayerCameraOffsetData CameraOffsetData;                                         // 0x0030 (size: 0x18)
    FSBPitchRotationOffsetData PitchRotationOffsetData;                               // 0x0048 (size: 0x30)
    FPlayerCameraArmLengthData ArmLengthData;                                         // 0x0078 (size: 0xC)
    FPlayerCameraLagData LagData;                                                     // 0x0084 (size: 0x20)
    FPlayerCameraBlendTimeData BlendTimeData;                                         // 0x00A4 (size: 0xC)
    FPlayerCameraBlendCurveData BlendCurveData;                                       // 0x00B0 (size: 0x58)
    FPlayerCameraPitchData PitchData;                                                 // 0x0108 (size: 0x8)
    FPlayerCameraResetYawData ResetYawData;                                           // 0x0110 (size: 0x3)
    char padding_1[0x1];                                                              // 0x0113 (size: 0x1)
    FPlayerCameraRotationLimitData RotationLimitData;                                 // 0x0114 (size: 0x10)
    FPlayerCameraRotationSpeedData RotationSpeedData;                                 // 0x0124 (size: 0x10)
    FPlayerCameraTransparentDistanceData TransparentDistanceData;                     // 0x0134 (size: 0x10)
    char padding_2[0x4];                                                              // 0x0144 (size: 0x4)
    FPlayerCameraEndData EndData;                                                     // 0x0148 (size: 0x18)
    ESBKeepCameraAimLocation KeepAimLocation;                                         // 0x0160 (size: 0x1)
    bool IsLockonSuspend;                                                             // 0x0161 (size: 0x1)

}; // Size: 0x178

struct FPlayerCameraEndData
{
    TArray<FName> KeepCameraAnimTags;                                                 // 0x0000 (size: 0x10)
    float WaitTagCheckDeltaTime;                                                      // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FPlayerCameraLagData
{
    bool EnableCameraLag;                                                             // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float MinLengthCameraLagSpeed;                                                    // 0x0004 (size: 0x4)
    float MaxLengthCameraLagSpeed;                                                    // 0x0008 (size: 0x4)
    bool EnableCameraRotationLag;                                                     // 0x000C (size: 0x1)
    char padding_1[0x3];                                                              // 0x000D (size: 0x3)
    float MinLengthCameraRotationLagSpeed;                                            // 0x0010 (size: 0x4)
    float MaxLengthCameraRotationLagSpeed;                                            // 0x0014 (size: 0x4)
    float MinLengthCameraLagMaxDistance;                                              // 0x0018 (size: 0x4)
    float MaxLengthCameraLagMaxDistance;                                              // 0x001C (size: 0x4)

}; // Size: 0x20

struct FPlayerCameraOffsetData
{
    FVector MinLengthCameraOffset;                                                    // 0x0000 (size: 0xC)
    FVector MaxLengthCameraOffset;                                                    // 0x000C (size: 0xC)

}; // Size: 0x18

struct FPlayerCameraPitchData
{
    bool UseDefaultPitch;                                                             // 0x0000 (size: 0x1)
    bool UseResetPitch;                                                               // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    float Pitch;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FPlayerCameraResetYawData
{
    bool BlendInResetYaw;                                                             // 0x0000 (size: 0x1)
    bool UseBlendOutResetYaw;                                                         // 0x0001 (size: 0x1)
    bool BlendOutResetYaw;                                                            // 0x0002 (size: 0x1)

}; // Size: 0x3

struct FPlayerCameraRotationLimitData
{
    float PitchLimitMax;                                                              // 0x0000 (size: 0x4)
    float PitchLimitMin;                                                              // 0x0004 (size: 0x4)
    float YawLimitMax;                                                                // 0x0008 (size: 0x4)
    float YawLimitMin;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FPlayerCameraRotationSpeedData
{
    float RotationSpeedYaw;                                                           // 0x0000 (size: 0x4)
    float RotationSpeedPitch;                                                         // 0x0004 (size: 0x4)
    float RotationSpeedYaw_Mouse;                                                     // 0x0008 (size: 0x4)
    float RotationSpeedPitch_Mouse;                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FPlayerCameraTransparentDistanceData
{
    bool UseCameraDistanceTransparentParam;                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FSBCameraDistanceTransparentParam CameraDistanceTransparentParam;                 // 0x0004 (size: 0xC)

}; // Size: 0x10

struct FPlayerCameraZoomData
{
    float ZoomDuration;                                                               // 0x0000 (size: 0x4)
    float ZoomStep;                                                                   // 0x0004 (size: 0x4)
    float ZoomStick;                                                                  // 0x0008 (size: 0x4)
    bool IsBlendInOverwriteZoomLevel;                                                 // 0x000C (size: 0x1)
    bool IsBlendOutOverwriteZoomLevel;                                                // 0x000D (size: 0x1)
    bool IsZoomLevelSave;                                                             // 0x000E (size: 0x1)

}; // Size: 0x10

struct FPlayerCastSkillInfo
{
    char padding_0[0xC];                                                              // 0x0000 (size: 0x0)
}; // Size: 0xC

struct FPlayerProfileBgImageInfo
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    EPhotoType PhotoType;                                                             // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FString BgImagePath;                                                              // 0x0008 (size: 0x10)
    FVector2D BgImageSelectedAreaPos;                                                 // 0x0018 (size: 0x8)
    FVector2D BgImageSize;                                                            // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FPlayerProfileClassData
{
    ESBClassType ClassType;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ClassExp;                                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FPlayerProfileClassListData
{
    TArray<FPlayerProfileClassData> DataList;                                         // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPlayerProfileMenuDetailData
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    FString LocationName;                                                             // 0x0010 (size: 0x10)
    FString Comment;                                                                  // 0x0020 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0030 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0031 (size: 0x7)
    FString PlayerId;                                                                 // 0x0038 (size: 0x10)
    FString CharacterId;                                                              // 0x0048 (size: 0x10)
    FString CharacterShortId;                                                         // 0x0058 (size: 0x10)
    FString ZoneId;                                                                   // 0x0068 (size: 0x10)
    bool Active;                                                                      // 0x0078 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0079 (size: 0x7)
    FOwnItemInfo EquipItemWepaon;                                                     // 0x0080 (size: 0xF8)
    TArray<FOwnItemInfo> EquipItemCostumes;                                           // 0x0178 (size: 0x10)
    TArray<FOwnItemInfo> EquipItemAccessories;                                        // 0x0188 (size: 0x10)
    TArray<FOwnItemInfo> EquipItemUnderWear;                                          // 0x0198 (size: 0x10)
    ESBProfilePublicSettingType GlobalPublicSetting;                                  // 0x01A8 (size: 0x1)
    char padding_2[0x7];                                                              // 0x01A9 (size: 0x7)
    FString ContentId;                                                                // 0x01B0 (size: 0x10)
    int32 AchievementSelected;                                                        // 0x01C0 (size: 0x4)
    char padding_3[0x4];                                                              // 0x01C4 (size: 0x4)
    TArray<FPlayerProfilePhotoTrimmingInfo> PhotoTrimmingInfo;                        // 0x01C8 (size: 0x10)
    FString SessionId;                                                                // 0x01D8 (size: 0x10)
    FString GameContentId;                                                            // 0x01E8 (size: 0x10)
    char padding_4[0x10];                                                             // 0x01F8 (size: 0x10)
    int32 OnlineStatus;                                                               // 0x0208 (size: 0x4)
    char padding_5[0x4];                                                              // 0x020C (size: 0x4)
    FPlayerProfileClassListData ClassDataList;                                        // 0x0210 (size: 0x10)
    int32 AdventurerRank;                                                             // 0x0220 (size: 0x4)
    int32 TotalPower;                                                                 // 0x0224 (size: 0x4)
    bool IsSendLIke;                                                                  // 0x0228 (size: 0x1)
    ESBTensionTagType TensionTag;                                                     // 0x0229 (size: 0x1)
    bool isFriend;                                                                    // 0x022A (size: 0x1)
    bool IsDoneSendAdvCard;                                                           // 0x022B (size: 0x1)
    bool IsCanSendAdvCard;                                                            // 0x022C (size: 0x1)
    char padding_6[0x3];                                                              // 0x022D (size: 0x3)
    FString GuildName;                                                                // 0x0230 (size: 0x10)
    FString GuildId;                                                                  // 0x0240 (size: 0x10)
    FSBPlatformInfo PlatformInfo;                                                     // 0x0250 (size: 0x20)
    int32 Warning;                                                                    // 0x0270 (size: 0x4)
    char padding_7[0x4];                                                              // 0x0274 (size: 0x4)
    TArray<int32> AwardIdList;                                                        // 0x0278 (size: 0x10)
    int32 AdventureCardFrameId;                                                       // 0x0288 (size: 0x4)
    int32 FaceFrameId;                                                                // 0x028C (size: 0x4)
    int32 BackGroundColorId;                                                          // 0x0290 (size: 0x4)

}; // Size: 0x298

struct FPlayerProfilePhotoTrimmingInfo
{
    EPhotoType TrimmingType;                                                          // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString PhotoModeImageId;                                                         // 0x0008 (size: 0x10)
    FVector2D TrimmingCoordinate;                                                     // 0x0018 (size: 0x8)
    float Scale;                                                                      // 0x0020 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0024 (size: 0x4)
    FString ImagePath;                                                                // 0x0028 (size: 0x10)
    FString ThumbnailPath;                                                            // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FPlayerProfileSummaryData
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    FString LocationName;                                                             // 0x0010 (size: 0x10)
    ESBTensionTagType TensionTag;                                                     // 0x0020 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0021 (size: 0x7)
    FString Comment;                                                                  // 0x0028 (size: 0x10)
    int32 ClassLevel;                                                                 // 0x0038 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x003C (size: 0x1)
    char padding_1[0x3];                                                              // 0x003D (size: 0x3)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FString CharacterId;                                                              // 0x0050 (size: 0x10)
    FString ZoneId;                                                                   // 0x0060 (size: 0x10)
    bool Active;                                                                      // 0x0070 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0071 (size: 0x7)
    FString ContentId;                                                                // 0x0078 (size: 0x10)
    char padding_3[0x10];                                                             // 0x0088 (size: 0x10)
    bool Friend;                                                                      // 0x0098 (size: 0x1)
    bool DoneSend;                                                                    // 0x0099 (size: 0x1)
    bool CanBeSend;                                                                   // 0x009A (size: 0x1)
    bool Blocked;                                                                     // 0x009B (size: 0x1)
    char padding_4[0x4];                                                              // 0x009C (size: 0x4)
    FString FaceIconUrl;                                                              // 0x00A0 (size: 0x10)
    int32 LeftDay;                                                                    // 0x00B0 (size: 0x4)
    char padding_5[0x4];                                                              // 0x00B4 (size: 0x4)
    FString TimesLeft;                                                                // 0x00B8 (size: 0x10)
    bool bSendLike;                                                                   // 0x00C8 (size: 0x1)
    char padding_6[0x3];                                                              // 0x00C9 (size: 0x3)
    int32 OnlineStatus;                                                               // 0x00CC (size: 0x4)
    FSBPlatformInfo PlatformInfo;                                                     // 0x00D0 (size: 0x20)
    bool bPartyMember;                                                                // 0x00F0 (size: 0x1)
    bool bPartyLeader;                                                                // 0x00F1 (size: 0x1)
    char padding_7[0x6];                                                              // 0x00F2 (size: 0x6)
    FString LastLogin;                                                                // 0x00F8 (size: 0x10)
    FDateTime FriendRegistratedDate;                                                  // 0x0108 (size: 0x8)
    bool to_blocked;                                                                  // 0x0110 (size: 0x1)

}; // Size: 0x118

struct FPlayerScore
{
    TMap<ASBPlayerCharacter*, float> PlayerScoreMap;                                  // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FProjectileAreaAttackConfig
{
    FSBProjectileSelectHandle RapidProjectileSelectHandle;                            // 0x0000 (size: 0x18)
    int32 RapidNum;                                                                   // 0x0018 (size: 0x4)
    float RapidInterval;                                                              // 0x001C (size: 0x4)
    float EffectiveRadius;                                                            // 0x0020 (size: 0x4)
    uint8 bIsUpperSphere;                                                             // 0x0024 (size: 0x1)
    uint8 bIsAdjustGround;                                                            // 0x0024 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0025 (size: 0x3)
    EProjectileAreaAttackSpawnOrder Order;                                            // 0x0028 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0029 (size: 0x3)
    uint8 bIsDestroyWhenCantLaunch;                                                   // 0x002C (size: 0x1)

}; // Size: 0x30

struct FProjectileAttachInfo
{
    uint8 bIsAttach;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0xB];                                                              // 0x0001 (size: 0xB)
    uint8 bIsAttachBone;                                                              // 0x000C (size: 0x1)
    char padding_1[0x3];                                                              // 0x000D (size: 0x3)
    int16 AttachSocketIndex;                                                          // 0x0010 (size: 0x2)
    char padding_2[0x6];                                                              // 0x0012 (size: 0x6)
    class USceneComponent* AttachComp;                                                // 0x0018 (size: 0x8)
    int8 WeaponIndex;                                                                 // 0x0020 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0021 (size: 0x3)
    FVector_NetQuantize AttachTransLocation;                                          // 0x0024 (size: 0xC)
    FRotator AttachTransRotator;                                                      // 0x0030 (size: 0xC)

}; // Size: 0x40

struct FProjectileBaseParameter
{
    class AActor* Spawner;                                                            // 0x0068 (size: 0x8)

}; // Size: 0x70

struct FProjectileBeamConfig
{
    FProjectileRapidConfig ImpactSpawnProjectile;                                     // 0x0000 (size: 0x48)
    FProjectileBeamDirection BeamDirectionType;                                       // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FProjectileBeamEffectConfig
{
    ESBProjectileBeamDirectingType BeamType;                                          // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName TargetVectorName;                                                           // 0x0004 (size: 0x8)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    TSoftObjectPtr<UParticleSystem> BeamParticle;                                     // 0x0010 (size: 0x28)
    TSoftClassPtr<ASBProjectileEffect> BeamActor;                                     // 0x0038 (size: 0x28)
    TSoftObjectPtr<UParticleSystem> BeamEndParticle;                                  // 0x0060 (size: 0x28)
    uint8 bIsGenerateImpactPointParticle;                                             // 0x0088 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0089 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> ImpactPointParticle;                              // 0x0090 (size: 0x28)
    TSoftClassPtr<ASBProjectileEffect> ImpactPointActor;                              // 0x00B8 (size: 0x28)
    uint8 bIsDeactivateImpactPointParticle;                                           // 0x00E0 (size: 0x1)
    char padding_3[0x7];                                                              // 0x00E1 (size: 0x7)
    FAkEventSwitch ImpactStartAkEventSwitch;                                          // 0x00E8 (size: 0x20)
    FAkEventSwitch ImpactEndAkEventSwitch;                                            // 0x0108 (size: 0x20)
    FProjectileBeamImpactTrailConfig BeamImpactTrailConfig;                           // 0x0128 (size: 0x50)
    FAkEventSwitch StartAkEventSwitch;                                                // 0x0178 (size: 0x20)
    FAkEventSwitch EndAkEventSwitch;                                                  // 0x0198 (size: 0x20)

}; // Size: 0x1B8

struct FProjectileBeamImpactTrailConfig
{
    uint8 bIsTrailDecal;                                                              // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UMaterialInterface> DecalMaterial;                                 // 0x0008 (size: 0x28)
    float PaintDecalLength;                                                           // 0x0030 (size: 0x4)
    FRotator PaintDecalOffsetRot;                                                     // 0x0034 (size: 0xC)
    FVector PaintDecalSize;                                                           // 0x0040 (size: 0xC)
    float PaintDecalLifeTime;                                                         // 0x004C (size: 0x4)

}; // Size: 0x50

struct FProjectileBoxCollisionParam : public FProjectileCollisionParamBase
{
    FVector BoxExtent;                                                                // 0x001C (size: 0xC)
    TArray<FSBConditionCheckFloatParam> ModifySizeList;                               // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FProjectileCameraShake
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TSubclassOf<class UCameraShakeBase> ShakeClass;                                   // 0x0008 (size: 0x8)
    float Scale;                                                                      // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FProjectileCapsuleCollisionParam : public FProjectileCollisionParamBase
{
    float Radius;                                                                     // 0x001C (size: 0x4)
    float Height;                                                                     // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FProjectileChainConfigBase
{
    FDataTableRowHandle ProjectileConfigHandle1;                                      // 0x0008 (size: 0x10)
    FDataTableRowHandle ProjectileConfigHandle2;                                      // 0x0018 (size: 0x10)
    uint8 bIsGenerate;                                                                // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FProjectileCollisionParamBase
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    FRotator Rotation;                                                                // 0x000C (size: 0xC)
    ESBProjectileCollisionSpecificUseType SpecificUseType;                            // 0x0018 (size: 0x1)
    ESBProjectileCollisionSpecificGroup SpecificGroup;                                // 0x0019 (size: 0x1)

}; // Size: 0x1C

struct FProjectileCylinderMeshConfig
{
    float Radius;                                                                     // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> ModifyRadiusList;                             // 0x0008 (size: 0x10)
    float Height;                                                                     // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FProjectileDelayPlay
{
    char padding_0[0x150];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x150

struct FProjectileDestroyConditionConfig
{
    uint8 bIsEnableLifeCheck;                                                         // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float LifeTime;                                                                   // 0x0004 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> AddLifeTimeList;                              // 0x0008 (size: 0x10)
    uint8 bIsEnableDistanceCheck;                                                     // 0x0018 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0019 (size: 0x3)
    float DestroyDistance;                                                            // 0x001C (size: 0x4)
    TArray<FSBConditionCheckIntParam> DestroyDistanceAdjustList;                      // 0x0020 (size: 0x10)
    uint8 bIsEnableHeightCheck;                                                       // 0x0030 (size: 0x1)
    uint8 bIsEnableTotalDistance;                                                     // 0x0030 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0031 (size: 0x3)
    float DestroyTotalDistance;                                                       // 0x0034 (size: 0x4)
    uint8 bIsEnableGroundHitCheck;                                                    // 0x0038 (size: 0x1)
    uint8 bIsEnableAliveAnimTag;                                                      // 0x0038 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0039 (size: 0x7)
    TArray<FName> AliveAnimTagArray;                                                  // 0x0040 (size: 0x10)
    uint8 bIsDestroyTogeghterWithSpawner;                                             // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FProjectileDynamicBeamCollision
{
    float BeamCollisionRadius;                                                        // 0x0000 (size: 0x4)
    float BeamCollisionLength;                                                        // 0x0004 (size: 0x4)
    uint8 bDontExpandBeam;                                                            // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    float BeamCollisionExpandSpeed;                                                   // 0x000C (size: 0x4)
    TArray<FBeamCollisionOverrideSection> OverrideSectionData;                        // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FProjectileDynamicCollision
{
    TArray<FProjectileSphereCollisionParam> SphereArray;                              // 0x0000 (size: 0x10)
    TArray<FProjectileCapsuleCollisionParam> CapsuleArray;                            // 0x0010 (size: 0x10)
    TArray<FProjectileBoxCollisionParam> BoxArray;                                    // 0x0020 (size: 0x10)
    TArray<FSBProjectileMeshCollision> MeshArray;                                     // 0x0030 (size: 0x10)
    FProjectileDynamicBeamCollision BeamCollision;                                    // 0x0040 (size: 0x20)

}; // Size: 0x60

struct FProjectileEffectParam
{
    uint8 bRequestAuthorityLocalSpawn;                                                // 0x0000 (size: 0x1)
    uint8 bAlreadySpawnEffect;                                                        // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FProjectileEffectParamVector> VectorParamArray;                            // 0x0008 (size: 0x10)
    class AActor* ActorParamTarget;                                                   // 0x0018 (size: 0x8)
    TArray<FProjectileEffectParamActor> ActorParamArray;                              // 0x0020 (size: 0x10)

}; // Size: 0x38

struct FProjectileEffectParamActor
{
    FName ActorParamName;                                                             // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FProjectileEffectParamVector
{
    FName VectorParamName;                                                            // 0x0000 (size: 0x8)
    FVector_NetQuantize VectorParam;                                                  // 0x0008 (size: 0xC)

}; // Size: 0x14

struct FProjectileForecastConfig
{
    float ForecastDelayTime;                                                          // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FSBProjectileSelectHandle ForecastSelectProjectile;                               // 0x0008 (size: 0x18)
    float DelayTime;                                                                  // 0x0020 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0024 (size: 0x4)
    FSBProjectileSelectHandle MainSelectProjectile;                                   // 0x0028 (size: 0x18)

}; // Size: 0x40

struct FProjectileGroundCollisionConfig
{
    uint8 bIsEnableGroundCollision;                                                   // 0x0000 (size: 0x1)
    uint8 bIsUseBImagineCollisionPreset;                                              // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float HalfHeight;                                                                 // 0x0004 (size: 0x4)
    float Radius;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FProjectileGroundHitEffectConfig
{
    uint8 bIsGenerateGroundHitEffect;                                                 // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    EHitEffectSpawnPosType SpawnPosType;                                              // 0x0004 (size: 0x1)
    EHitEffectSpawnRotType SpawnRotType;                                              // 0x0005 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0006 (size: 0x2)
    FVector SpawnPosOffset;                                                           // 0x0008 (size: 0xC)
    FRotator SpawnRotOffset;                                                          // 0x0014 (size: 0xC)
    uint8 bIsAdjustGroundPos;                                                         // 0x0020 (size: 0x1)
    uint8 bIsReverseRotation;                                                         // 0x0020 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0021 (size: 0x3)
    FName HitActorSocketName;                                                         // 0x0024 (size: 0x8)
    float InitialScale;                                                               // 0x002C (size: 0x4)
    uint8 bIsNotInheritanceScale;                                                     // 0x0030 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0031 (size: 0x7)
    TArray<FGroundHitEffectByMaterial> SwitchEffect;                                  // 0x0038 (size: 0x10)
    uint8 bIsNotExistPlayDefault;                                                     // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FProjectileHitChainConfig : public FProjectileChainConfigBase
{
    uint8 bIsGenerateAttackHit;                                                       // 0x0030 (size: 0x1)
    uint8 bIsOnlyGenerateSBCharacterHit;                                              // 0x0030 (size: 0x1)
    uint8 bIsGenerateGroundHit;                                                       // 0x0030 (size: 0x1)
    uint8 bIsGenerateBattleAreaWall;                                                  // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    EHitEffectSpawnPosType SpawnPosType;                                              // 0x0034 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0035 (size: 0x3)
    FVector SpawnPosOffset;                                                           // 0x0038 (size: 0xC)
    uint8 bIsAdjustGroundPos;                                                         // 0x0044 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0045 (size: 0x3)
    EHitEffectSpawnRotType SpawnRotType;                                              // 0x0048 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0049 (size: 0x3)
    uint8 bIsReverseRotation;                                                         // 0x004C (size: 0x1)
    uint8 bIsExcludeHitFromChainHitActor;                                             // 0x004C (size: 0x1)
    uint8 bIsRepeatChainOnAttackHit;                                                  // 0x004C (size: 0x1)
    char padding_4[0x3];                                                              // 0x004D (size: 0x3)
    TArray<FSBConditionCheckParam> PermitConditionList;                               // 0x0050 (size: 0x10)
    FName HitActorSocketName;                                                         // 0x0060 (size: 0x8)
    EProjectileHitChainChangeTarget TargetSelectRule;                                 // 0x0068 (size: 0x1)

}; // Size: 0x70

struct FProjectileHitCoverConfig
{
    uint8 bIsExclusiveSpawner;                                                        // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FProjectileHitEffectConfig
{
    uint8 bIsGenerateHitEffect;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> HitParticle;                                      // 0x0008 (size: 0x28)
    EHitEffectSpawnPosType SpawnType;                                                 // 0x0030 (size: 0x1)
    EHitEffectSpawnRotType SpawnRotType;                                              // 0x0031 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0032 (size: 0x2)
    FVector HitEffectOffset;                                                          // 0x0034 (size: 0xC)
    uint8 bIsEnableHitPositionGround;                                                 // 0x0040 (size: 0x1)
    uint8 bIsReverseRotation;                                                         // 0x0040 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0041 (size: 0x3)
    FName HitActorSocketName;                                                         // 0x0044 (size: 0x8)
    FName HitActorParameterName;                                                      // 0x004C (size: 0x8)
    float InitialScale;                                                               // 0x0054 (size: 0x4)
    uint8 bIsNotInheritanceScale;                                                     // 0x0058 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0059 (size: 0x7)
    FAkEventSwitch AkEventSwitch;                                                     // 0x0060 (size: 0x20)

}; // Size: 0x80

struct FProjectileHitResult
{
    FHitResult HitResult;                                                             // 0x0000 (size: 0x88)
    class AActor* ShieldHitActor;                                                     // 0x0088 (size: 0x8)
    class UPrimitiveComponent* ShieldHitComponent;                                    // 0x0090 (size: 0x8)
    uint8 bIsGuardHit;                                                                // 0x0098 (size: 0x1)
    uint8 bIsGuardFailed;                                                             // 0x0098 (size: 0x1)
    uint8 bIsWeakPointHit;                                                            // 0x0098 (size: 0x1)

}; // Size: 0xA0

struct FProjectileHomingConfig
{
    uint8 bIsHoming;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    EHomingType HomingType;                                                           // 0x0004 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0005 (size: 0x3)
    float HomingAccelerationMagnitude;                                                // 0x0008 (size: 0x4)
    float HomingBeginTime;                                                            // 0x000C (size: 0x4)
    float HomingEndTime;                                                              // 0x0010 (size: 0x4)
    FVector HomingOffsetPos;                                                          // 0x0014 (size: 0xC)
    float HomingCorrectionAngle;                                                      // 0x0020 (size: 0x4)
    float HomingCorrectionAngle2;                                                     // 0x0024 (size: 0x4)
    float HomingEffectiveCorrectionAngle;                                             // 0x0028 (size: 0x4)
    float HomingEffectiveCorrectionAngle2;                                            // 0x002C (size: 0x4)
    uint8 bIsCancelHomingEffectiveCorrectionAngle;                                    // 0x0030 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0031 (size: 0x3)
    float CancelHomingBeginTime;                                                      // 0x0034 (size: 0x4)
    float CancelHomingEndTime;                                                        // 0x0038 (size: 0x4)
    uint8 bIsDisableHomingHeight;                                                     // 0x003C (size: 0x1)
    uint8 bIsEnableTargetStop;                                                        // 0x003C (size: 0x1)

}; // Size: 0x40

struct FProjectileMeshConfig
{
    TSoftObjectPtr<USkeletalMesh> SetMesh;                                            // 0x0000 (size: 0x28)
    FVector Location;                                                                 // 0x0028 (size: 0xC)
    FRotator Rotation;                                                                // 0x0034 (size: 0xC)
    FVector Scale;                                                                    // 0x0040 (size: 0xC)
    FRotator RotateSpeed;                                                             // 0x004C (size: 0xC)
    uint8 bIsUseInstigatorActiveWeapon;                                               // 0x0058 (size: 0x1)
    uint8 bIsUseWeaponIndex;                                                          // 0x0058 (size: 0x1)

}; // Size: 0x60

struct FProjectileMoveBaseConfig
{
    float InitialSpeed;                                                               // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> InitialSpeedModifyRateList;                   // 0x0008 (size: 0x10)
    float MinSpeed;                                                                   // 0x0018 (size: 0x4)
    float MaxSpeed;                                                                   // 0x001C (size: 0x4)
    uint8 bIsEnableGravity;                                                           // 0x0020 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0021 (size: 0x3)
    float GravityScale;                                                               // 0x0024 (size: 0x4)
    float BeginEffectiveGravityTime;                                                  // 0x0028 (size: 0x4)
    float EndEffectiveGravityTime;                                                    // 0x002C (size: 0x4)
    uint8 bRotationFollowsVelocity;                                                   // 0x0030 (size: 0x1)
    uint8 bRotationFollowsVelocityOwnerYawAtBegin;                                    // 0x0030 (size: 0x1)
    uint8 bLimitDistance;                                                             // 0x0030 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0031 (size: 0x3)
    float LimitTotalDistance;                                                         // 0x0034 (size: 0x4)
    uint8 bStopMoveWhenGroundHit;                                                     // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FProjectileMuzzleEffectConfig
{
    uint8 bIsGenerateMuzzleEffect;                                                    // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> MuzzleEffect;                                     // 0x0008 (size: 0x28)
    uint8 bIsAttach;                                                                  // 0x0030 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0031 (size: 0x3)
    EMuzzleEffectSpawnPosType SpawnType;                                              // 0x0034 (size: 0x1)
    EMuzzleEffectSpawnRotType SpawnRotType;                                           // 0x0035 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0036 (size: 0x2)
    FName SocketName;                                                                 // 0x0038 (size: 0x8)
    FVector SpawnPosOffset;                                                           // 0x0040 (size: 0xC)
    FRotator SpawnRotOffset;                                                          // 0x004C (size: 0xC)
    uint8 bIsReverseRotation;                                                         // 0x0058 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0059 (size: 0x3)
    float InitialScale;                                                               // 0x005C (size: 0x4)
    uint8 bIsNotInheritanceScale;                                                     // 0x0060 (size: 0x1)
    char padding_4[0x7];                                                              // 0x0061 (size: 0x7)
    FAkEventSwitch AkEventSwitch;                                                     // 0x0068 (size: 0x20)

}; // Size: 0x88

struct FProjectileOrderedChainConfig : public FProjectileChainConfigBase
{
    EProjectileOrderedChainType OrderedChainType;                                     // 0x0030 (size: 0x1)
    uint8 bIsExclueOtherChainProjectile;                                              // 0x0031 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0032 (size: 0x6)
    FDataTableRowHandle HandleOfOrderedChainHitProjectile;                            // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FProjectilePartyShotRapidConfig
{
    FProjectilePartyShotTargetType TargetPartyType;                                   // 0x0000 (size: 0x1)
    bool bIsIncludeInstantParty;                                                      // 0x0001 (size: 0x1)
    uint8 TargetPartyNum;                                                             // 0x0002 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0003 (size: 0x1)
    float TargetPartyDistanceLimit;                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FProjectilePredictParameter
{
    TArray<class APawn*> PredictCharaList;                                            // 0x0000 (size: 0x10)
    TArray<float> ReachTimeList;                                                      // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FProjectileRapidConfig
{
    FSBProjectileSelectHandle RapidProjectileSelectHandle;                            // 0x0000 (size: 0x18)
    int32 SimultaneousNum;                                                            // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    TArray<FSBConditionCheckIntParam> SimultaneousNumModifyList;                      // 0x0020 (size: 0x10)
    int32 RapidNum;                                                                   // 0x0030 (size: 0x4)
    uint8 bIsInfiniteRapidNum;                                                        // 0x0034 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0035 (size: 0x3)
    float RapidInterval;                                                              // 0x0038 (size: 0x4)
    uint8 bIsDestroyWhenCantLaunch;                                                   // 0x003C (size: 0x1)
    char padding_2[0x3];                                                              // 0x003D (size: 0x3)
    float DestroyWhenCantLaunchDelayTime;                                             // 0x0040 (size: 0x4)
    ESBTargetSelectRule TargetSelectRule;                                             // 0x0044 (size: 0x1)
    ESBTargetChangRule TargetChangeRule;                                              // 0x0045 (size: 0x1)

}; // Size: 0x48

struct FProjectileRapidParam
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

struct FProjectileSelfDeadChainConfig : public FProjectileChainConfigBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

struct FProjectileSelfDeadEffectConfig
{
    uint8 bIsGenerateSelfDeadEffect;                                                  // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> SelfDeadParticle;                                 // 0x0008 (size: 0x28)
    uint8 bIsGenerateDurabilityZeroEffect;                                            // 0x0030 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0031 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> DurabilityZeroParticle;                           // 0x0038 (size: 0x28)
    ESelfDeadEffectSpawnRotType SpawnRotType;                                         // 0x0060 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0061 (size: 0x3)
    FRotator RotOffset;                                                               // 0x0064 (size: 0xC)
    uint8 bIsReverseRotation;                                                         // 0x0070 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0071 (size: 0x3)
    float InitialScale;                                                               // 0x0074 (size: 0x4)
    uint8 bIsNotInheritanceScale;                                                     // 0x0078 (size: 0x1)
    char padding_4[0x7];                                                              // 0x0079 (size: 0x7)
    FAkEventSwitch AkEventSwitch;                                                     // 0x0080 (size: 0x20)

}; // Size: 0xA0

struct FProjectileShareHitSetting
{
    float ShareHitTime;                                                               // 0x0000 (size: 0x4)
    EProjectileShareGroup ShareGroup;                                                 // 0x0004 (size: 0x1)
    bool bIsIndependentBySpawner;                                                     // 0x0005 (size: 0x1)

}; // Size: 0x8

struct FProjectileShieldHitEffectConfig
{
    uint8 bIsGenerateHitEffect;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> HitParticle;                                      // 0x0008 (size: 0x28)
    float InitialScale;                                                               // 0x0030 (size: 0x4)
    uint8 bIsNotInheritanceScale;                                                     // 0x0034 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0035 (size: 0x3)
    FAkEventSwitch AkEventSwitch;                                                     // 0x0038 (size: 0x20)

}; // Size: 0x58

struct FProjectileShotAngleLimit
{
    uint8 bIsEnable;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    EProjectileBaseDir BaseDirType;                                                   // 0x0004 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0005 (size: 0x3)
    float HalfAngle;                                                                  // 0x0008 (size: 0x4)
    float UpAngle;                                                                    // 0x000C (size: 0x4)
    float DownAngle;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FProjectileSpawnInfo
{
    ESpawnType SpawnType;                                                             // 0x0000 (size: 0x1)
    ESpawnRotType SpawnRotType;                                                       // 0x0001 (size: 0x1)
    EProjectileDirection DirectionType;                                               // 0x0002 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0003 (size: 0x1)
    FName SpawnSocketName;                                                            // 0x0004 (size: 0x8)
    FVector SpawnOffset;                                                              // 0x000C (size: 0xC)
    FRotator SpawnRotOffset;                                                          // 0x0018 (size: 0xC)
    FVector SpawnTargetOffset;                                                        // 0x0024 (size: 0xC)
    uint8 bIsAttach;                                                                  // 0x0030 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0031 (size: 0x3)
    EProjectileNonTargetAction NonTargetAction;                                       // 0x0034 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0035 (size: 0x3)
    float NonTargetSpawnDistanceFront;                                                // 0x0038 (size: 0x4)
    uint8 bIsPenetrateInObstacle;                                                     // 0x003C (size: 0x1)
    uint8 bIsDestroyInObstacle;                                                       // 0x003C (size: 0x1)
    uint8 isObstaclePushedBackToSpawner;                                              // 0x003C (size: 0x1)
    uint8 bIsCheckGround;                                                             // 0x003C (size: 0x1)
    uint8 isDisalbeScreenViewDirectionObstacleAttackHit;                              // 0x003C (size: 0x1)
    uint8 isOnNaviMeshConnedtedFromOwner;                                             // 0x003C (size: 0x1)
    uint8 bIsReacquireSpawnTransformOnLocal;                                          // 0x003C (size: 0x1)
    char padding_3[0x3];                                                              // 0x003D (size: 0x3)
    FSBProjectileStability Stability;                                                 // 0x0040 (size: 0xC)
    FProjectileShotAngleLimit ShotAngleLimit;                                         // 0x004C (size: 0x14)
    int32 MaxSpawnNum;                                                                // 0x0060 (size: 0x4)
    float SpawnDelayTime;                                                             // 0x0064 (size: 0x4)
    uint8 bIsInheritanceInstigatorScale;                                              // 0x0068 (size: 0x1)

}; // Size: 0x6C

struct FProjectileSpawnNonTargetAction
{
    EProjectileNonTargetAction NonTargetAction;                                       // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float NonTargetSpawnDistanceFront;                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FProjectileSpawnParameter : public FProjectileBaseParameter
{
    FProjectileTargetInfoSet TargetInfoSet;                                           // 0x0070 (size: 0x20)
    char padding_0[0x20];                                                             // 0x0090 (size: 0x20)
    TArray<class AActor*> IgnoreHitActorList;                                         // 0x00B0 (size: 0x10)

}; // Size: 0x108

struct FProjectileSpawnRapidParameter
{
    FVector_NetQuantize TransLocation;                                                // 0x0000 (size: 0xC)
    FRotator TransRotator;                                                            // 0x000C (size: 0xC)
    FVector_NetQuantizeNormal Direction;                                              // 0x0018 (size: 0xC)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    int64 RequestAuthorityID;                                                         // 0x0028 (size: 0x8)

}; // Size: 0x38

struct FProjectileSpawnRelayParameter
{
    FProjectileSpawnParameter SpawnParam;                                             // 0x0000 (size: 0x108)
    char padding_0[0x10];                                                             // 0x0108 (size: 0x10)
    class USceneComponent* AuthorityClientPlayerTargetComp;                           // 0x0118 (size: 0x8)

}; // Size: 0x138

struct FProjectileSpawnRequiredParameter
{
    FSBProjectileSelectHandle Handle;                                                 // 0x0000 (size: 0x18)
    class AActor* Spawner;                                                            // 0x0018 (size: 0x8)
    class AActor* LastHitActor;                                                       // 0x0020 (size: 0x8)
    FProjectileTargetInfoSet TargetInfoSet;                                           // 0x0028 (size: 0x20)
    TArray<class AActor*> IgnoreHitActorList;                                         // 0x0048 (size: 0x10)

}; // Size: 0x58

struct FProjectileSphereCollisionParam : public FProjectileCollisionParamBase
{
    float Radius;                                                                     // 0x001C (size: 0x4)
    TArray<FSBConditionCheckFloatParam> ModifyRadiusList;                             // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FProjectileSummonImagineConfig
{
    TSoftClassPtr<AASCharacterBase> SummonImagineCharacter;                           // 0x0000 (size: 0x28)
    FVector ImagineCharacterOffsetPos;                                                // 0x0028 (size: 0xC)
    char padding_0[0x4];                                                              // 0x0034 (size: 0x4)
    class USBCharaCreateData* SummonImagineCCD;                                       // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FProjectileTargetInfoSet
{
    TArray<TWeakObjectPtr<USceneComponent>> TargetCompList;                           // 0x0000 (size: 0x10)
    FVector_NetQuantize TargetPoint;                                                  // 0x0010 (size: 0xC)
    uint8 bValidTargetPoint;                                                          // 0x001C (size: 0x1)

}; // Size: 0x20

struct FProjectileWideShotConfig
{
    char padding_0[0x4];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x4

struct FProjectileWideShotRapidConfig
{
    FProjectileRapidConfig RapidConfig;                                               // 0x0000 (size: 0x48)
    float WideRange;                                                                  // 0x0048 (size: 0x4)

}; // Size: 0x50

struct FQuestBoardQuestData
{
    bool bSeparator;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 QuestIndex;                                                                 // 0x0004 (size: 0x4)
    int32 SortId;                                                                     // 0x0008 (size: 0x4)
    EQuestCategory2 Category2;                                                        // 0x000C (size: 0x1)
    EQuestCategory3 Category3;                                                        // 0x000D (size: 0x1)
    EQuestStatus QuestStatus;                                                         // 0x000E (size: 0x1)
    char padding_1[0x1];                                                              // 0x000F (size: 0x1)
    int32 ClassLevelPrecondition;                                                     // 0x0010 (size: 0x4)
    bool bCanReceive;                                                                 // 0x0014 (size: 0x1)
    bool bNew;                                                                        // 0x0015 (size: 0x1)

}; // Size: 0x18

struct FQuestConditionData
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FQuestConditionStepData
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

struct FQuestConsumeItemData
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FQuestListQuestData
{
    int32 QuestIndex;                                                                 // 0x0000 (size: 0x4)
    int32 SortId;                                                                     // 0x0004 (size: 0x4)
    char padding_0[0x1];                                                              // 0x0008 (size: 0x1)
    EQuestStatus QuestStatus;                                                         // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FQuestMasterData
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    FName LongId;                                                                     // 0x0004 (size: 0x8)
    int32 SortId;                                                                     // 0x000C (size: 0x4)
    EQuestCategory1 Category1;                                                        // 0x0010 (size: 0x1)
    EQuestCategory2 Category2;                                                        // 0x0011 (size: 0x1)
    EQuestCategory3 Category3;                                                        // 0x0012 (size: 0x1)
    bool bActive;                                                                     // 0x0013 (size: 0x1)
    FSBTextTableHash Name;                                                            // 0x0014 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x0018 (size: 0x4)
    FName ThumbnailId;                                                                // 0x001C (size: 0x8)
    char padding_0[0x14];                                                             // 0x0024 (size: 0x14)
    FSBTextTableHash ConditionDetail;                                                 // 0x0038 (size: 0x4)
    FName ClientId;                                                                   // 0x003C (size: 0x8)
    FName ReporterId;                                                                 // 0x0044 (size: 0x8)
    bool bAutoReport;                                                                 // 0x004C (size: 0x1)
    char padding_1[0x3];                                                              // 0x004D (size: 0x3)
    FQuestConditionData ConditionInfo;                                                // 0x0050 (size: 0x10)
    TArray<FRewardInfo> RewardInfoList;                                               // 0x0060 (size: 0x10)
    FQuestUnlockData UnlockData;                                                      // 0x0070 (size: 0x10)
    TArray<FQuestConsumeItemData> ConsumeItems;                                       // 0x0080 (size: 0x10)
    FSBTextTableHash DoneTextId;                                                      // 0x0090 (size: 0x4)
    FSBTextTableHash CloseTextId;                                                     // 0x0094 (size: 0x4)
    FSBTextTableHash DoneSynopsisId;                                                  // 0x0098 (size: 0x4)
    FSBTextTableHash CloseSynopsisId;                                                 // 0x009C (size: 0x4)
    FName CloseLocationId;                                                            // 0x00A0 (size: 0x8)
    bool bIgnoreCompleteJingle;                                                       // 0x00A8 (size: 0x1)
    char padding_2[0x3];                                                              // 0x00A9 (size: 0x3)
    FName TextTableName;                                                              // 0x00AC (size: 0x8)
    int32 RepeatCount;                                                                // 0x00B4 (size: 0x4)
    bool bDebug;                                                                      // 0x00B8 (size: 0x1)
    char padding_3[0x3];                                                              // 0x00B9 (size: 0x3)
    FName AcceptTerm;                                                                 // 0x00BC (size: 0x8)
    FName CompleteTerm;                                                               // 0x00C4 (size: 0x8)
    int32 CompletableCount;                                                           // 0x00CC (size: 0x4)
    FQuestRevivalCondition RevivalCondition;                                          // 0x00D0 (size: 0x30)
    TArray<FRewardInfo> AdditionalRewards;                                            // 0x0100 (size: 0x10)
    bool bCompletableCountNotifyEnable;                                               // 0x0110 (size: 0x1)
    bool bRevivalConditionNotifyEnable;                                               // 0x0111 (size: 0x1)

}; // Size: 0x118

struct FQuestProgressInfo
{
    TArray<FQuestProgressItem> Items;                                                 // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FQuestProgressItem
{
    int32 ConditionDataId;                                                            // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    int32 StepNo;                                                                     // 0x0008 (size: 0x4)
    bool bTalkNpc;                                                                    // 0x000C (size: 0x1)
    char padding_1[0x3];                                                              // 0x000D (size: 0x3)
    int32 KillEnemyNum;                                                               // 0x0010 (size: 0x4)
    int32 CollectItemNum;                                                             // 0x0014 (size: 0x4)
    int32 ClearIDNum;                                                                 // 0x0018 (size: 0x4)
    bool bArrived;                                                                    // 0x001C (size: 0x1)
    bool bPayedMoney;                                                                 // 0x001D (size: 0x1)
    bool bPlayedEmote;                                                                // 0x001E (size: 0x1)
    bool bActivatedWarpPortal;                                                        // 0x001F (size: 0x1)
    int32 InteractedNum;                                                              // 0x0020 (size: 0x4)
    int32 CraftItemNum;                                                               // 0x0024 (size: 0x4)
    bool bAdventurerRankUp;                                                           // 0x0028 (size: 0x1)
    bool bChallengeQuestStart;                                                        // 0x0029 (size: 0x1)
    char padding_2[0x2];                                                              // 0x002A (size: 0x2)
    int32 FangExpeditionNum;                                                          // 0x002C (size: 0x4)
    int32 StackBNum;                                                                  // 0x0030 (size: 0x4)
    char padding_3[0x4];                                                              // 0x0034 (size: 0x4)
    TArray<FString> AchieveConditions;                                                // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FQuestRevivalCondition
{
    EQuestRevivalConditionType Type;                                                  // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 Hours;                                                                      // 0x0004 (size: 0x4)
    FString OnTime;                                                                   // 0x0008 (size: 0x10)
    int32 OnDays;                                                                     // 0x0018 (size: 0x4)
    uint8 OnWeekdays;                                                                 // 0x001C (size: 0x1)
    char padding_1[0x3];                                                              // 0x001D (size: 0x3)
    FName QuestID;                                                                    // 0x0020 (size: 0x8)
    int32 QuestStep;                                                                  // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FQuestUnlockConditionItem
{
    char padding_0[0x34];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x34

struct FQuestUnlockData
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FRandVal
{
    float FMin;                                                                       // 0x0000 (size: 0x4)
    float FMax;                                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FRandomTreasureBoxChest
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FSBMasterTreasure MasterTreasureByRandom;                                         // 0x0008 (size: 0x68)
    FString GameContentId;                                                            // 0x0070 (size: 0x10)
    FString Tag;                                                                      // 0x0080 (size: 0x10)
    TArray<FRandomTreasureBoxChestGroupContentId> GroupContentId;                     // 0x0090 (size: 0x10)

}; // Size: 0xA0

struct FRandomTreasureBoxChestContentItems
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    ESBTreasureBoxRewardType ItemType;                                                // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 Amount;                                                                     // 0x0014 (size: 0x4)
    float ItemRarity;                                                                 // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FRandomTreasureBoxChestContents
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    TArray<FRandomTreasureBoxChestContentItems> ItemLists;                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FRandomTreasureBoxChestGroupContentId
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 PopNum;                                                                     // 0x0004 (size: 0x4)
    int32 ContentId;                                                                  // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FRandomTreasureBoxChestMapInfo
{
    FString Tag;                                                                      // 0x0000 (size: 0x10)
    FString GameContentId;                                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FRankingCharacterData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString Name;                                                                     // 0x0010 (size: 0x10)
    int32 TotalPower;                                                                 // 0x0020 (size: 0x4)
    int32 ClassRank;                                                                  // 0x0024 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FRankingData
{
    int32 Rank;                                                                       // 0x0000 (size: 0x4)
    int32 Value;                                                                      // 0x0004 (size: 0x4)
    FString CharacterId;                                                              // 0x0008 (size: 0x10)
    FString shortId;                                                                  // 0x0018 (size: 0x10)
    FString Name;                                                                     // 0x0028 (size: 0x10)
    int32 TotalPower;                                                                 // 0x0038 (size: 0x4)
    int32 ClassLevel;                                                                 // 0x003C (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0040 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0041 (size: 0x3)
    int32 Achievement;                                                                // 0x0044 (size: 0x4)

}; // Size: 0x48

struct FRankingHistoryData
{
    FString RankingId;                                                                // 0x0000 (size: 0x10)
    FString RankingGroup;                                                             // 0x0010 (size: 0x10)
    FString RankingName;                                                              // 0x0020 (size: 0x10)
    ESBRankingType RankingType;                                                       // 0x0030 (size: 0x1)
    ESBRankingTargetType RankingTargetType;                                           // 0x0031 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0032 (size: 0x6)
    FString EnableGameMode;                                                           // 0x0038 (size: 0x10)
    FString EnableContentId;                                                          // 0x0048 (size: 0x10)
    ESBClassType EnableClassType;                                                     // 0x0058 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0059 (size: 0x7)
    FString ContentId;                                                                // 0x0060 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0070 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0071 (size: 0x3)
    int32 Season;                                                                     // 0x0074 (size: 0x4)
    int32 RequiredValue;                                                              // 0x0078 (size: 0x4)
    int32 LimitedNumber;                                                              // 0x007C (size: 0x4)
    int32 LastUpdated;                                                                // 0x0080 (size: 0x4)
    char padding_3[0x4];                                                              // 0x0084 (size: 0x4)
    FString TermId;                                                                   // 0x0088 (size: 0x10)
    FString PublicTermId;                                                             // 0x0098 (size: 0x10)

}; // Size: 0xA8

struct FRankingRewardData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FName Ranking_Id;                                                                 // 0x0004 (size: 0x8)
    FName Content_Id;                                                                 // 0x000C (size: 0x8)
    ESBClassType Class_Type;                                                          // 0x0014 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0015 (size: 0x3)
    int32 From_rank;                                                                  // 0x0018 (size: 0x4)
    int32 To_Rank;                                                                    // 0x001C (size: 0x4)
    TArray<FRankingTablereRewardData> Rewards;                                        // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FRankingTablereRewardData
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    FName Master_Rewards_ID;                                                          // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FRawOverlapActorInfo
{
    char padding_0[0x18];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x18

struct FRawOverlapCompCombination
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FReadedMarkData
{
    TArray<FString> ReadedIDArray;                                                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FRecipeSetMasterData
{
    int32 RecipeSetId;                                                                // 0x0000 (size: 0x4)
    FSBTextTableHash RecipeSetNameTextId;                                             // 0x0004 (size: 0x4)
    TArray<int32> RecipeIdList;                                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FReportData
{
    FString ReportedPlayerId;                                                         // 0x0000 (size: 0x10)
    FString ReportedCharacterId;                                                      // 0x0010 (size: 0x10)
    FString Message;                                                                  // 0x0020 (size: 0x10)
    int32 Category;                                                                   // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FRewardInfo
{
    int32 RewardId;                                                                   // 0x0000 (size: 0x4)
    EQuestRewardCategory Category;                                                    // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 ClearCountForAdditional;                                                    // 0x0008 (size: 0x4)
    FName MasterRewardsId;                                                            // 0x000C (size: 0x8)
    bool bHidden_flag;                                                                // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FSBAIAttackableArea
{
    FVector Offset;                                                                   // 0x0000 (size: 0xC)
    float MinRange;                                                                   // 0x000C (size: 0x4)
    float MaxRange;                                                                   // 0x0010 (size: 0x4)
    float LeftAngle;                                                                  // 0x0014 (size: 0x4)
    float RightAngle;                                                                 // 0x0018 (size: 0x4)
    float UpperAngle;                                                                 // 0x001C (size: 0x4)
    float LowerAngle;                                                                 // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FSBAIComboOnlySkill
{
    FName StanceName;                                                                 // 0x0000 (size: 0x8)
    TArray<FName> ComboOnlyCommand;                                                   // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBAIComboSequenceTreeNode
{
    TArray<FSBAIComboSequenceTreeNodeNextLink> NextList;                              // 0x0000 (size: 0x10)

}; // Size: 0x18

struct FSBAIComboSequenceTreeNodeNextLink
{
    char padding_0[0x14];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x14

struct FSBAIEnemyActionLotteryRuleHolder
{
    bool bInvertResult;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    class USBAIEnemyActionLotteryRule* Rule;                                          // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBAIEnemyActionLotteryRules
{
    ESBAIEnemyActionLotteryLogicalOperationType LogicalOperationType;                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBAIEnemyActionLotteryRuleHolder> RuleHolders;                            // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBAIEnemyActionLotteryTable : public FTableRowBase
{
    FName ActionName;                                                                 // 0x0008 (size: 0x8)
    ESBAIEnemyActionLotteryPhase Phase;                                               // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    FName Stance;                                                                     // 0x0014 (size: 0x8)
    ESBAIEnemyActionLotteryPartyBattle PartyBattle;                                   // 0x001C (size: 0x1)
    bool bShareRecast;                                                                // 0x001D (size: 0x1)
    char padding_1[0x2];                                                              // 0x001E (size: 0x2)
    FName RequiredActionName;                                                         // 0x0020 (size: 0x8)
    int32 RequiredNumber;                                                             // 0x0028 (size: 0x4)
    float RangeMin;                                                                   // 0x002C (size: 0x4)
    float RangeMax;                                                                   // 0x0030 (size: 0x4)
    float DurationMin;                                                                // 0x0034 (size: 0x4)
    float DurationMax;                                                                // 0x0038 (size: 0x4)
    ESBAIEnemyActionLotteryPriority Priority;                                         // 0x003C (size: 0x1)
    char padding_2[0x3];                                                              // 0x003D (size: 0x3)
    FName WeightGroup;                                                                // 0x0040 (size: 0x8)
    int32 Weight;                                                                     // 0x0048 (size: 0x4)
    int32 WeightInc;                                                                  // 0x004C (size: 0x4)
    FSBAIEnemyActionLotteryRules AdditionalRules;                                     // 0x0050 (size: 0x18)
    ESBAIEnemyActionLotteryModifierTrigger ModifierTrigger;                           // 0x0068 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0069 (size: 0x7)
    TArray<ESBAIEnemyActionLotteryModifierInstant> ModifierInstants;                  // 0x0070 (size: 0x10)
    ESBAIEnemyActionLotteryPriority ModifierPriority;                                 // 0x0080 (size: 0x1)

}; // Size: 0x88

struct FSBAITacticalSkillRootTask
{
    FString TaskName;                                                                 // 0x0000 (size: 0x10)
    FString MethodName;                                                               // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBAITacticalSkill_AdditionalEffect
{
    FString StateName;                                                                // 0x0000 (size: 0x10)
    ESBAITacticalSkill_StateType ValueType;                                           // 0x0010 (size: 0x1)
    bool bBoolValue;                                                                  // 0x0011 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0012 (size: 0x2)
    int32 IntValue;                                                                   // 0x0014 (size: 0x4)
    float FloatValue;                                                                 // 0x0018 (size: 0x4)
    ESBAITacticalSkill_StateOperation Operation;                                      // 0x001C (size: 0x1)

}; // Size: 0x20

struct FSBAITacticalSkill_AdditionalPrecondition
{
    FString StateName;                                                                // 0x0000 (size: 0x10)
    ESBAITacticalSkill_StateType ValueType;                                           // 0x0010 (size: 0x1)
    bool bBoolValue;                                                                  // 0x0011 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0012 (size: 0x2)
    int32 IntValue;                                                                   // 0x0014 (size: 0x4)
    float FloatValue;                                                                 // 0x0018 (size: 0x4)
    ESBAITacticalSkill_StateComparison Comparison;                                    // 0x001C (size: 0x1)

}; // Size: 0x20

struct FSBAITacticalSkill_DomainOverride
{
    FAIFwParameterizedHTNDomain Domain;                                               // 0x0000 (size: 0x18)
    bool bOverrideCompound;                                                           // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBAITask_FleeFromParams
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

struct FSBAbilityConditionConfig : public FTableRowBase
{
    TSubclassOf<class USBAbilityCondition> Condition;                                 // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBAbilityConditionID
{
    FName ID;                                                                         // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBAbilityConditionInfo
{
    FSBAbilityConditionID ConditionId;                                                // 0x0000 (size: 0x8)
    int32 Value;                                                                      // 0x0008 (size: 0x4)
    uint8 bIsForceCondition;                                                          // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBAbilityConfig : public FTableRowBase
{
    TSubclassOf<class USBAbility> Object;                                             // 0x0008 (size: 0x8)
    ESBAbilityExecuteEnv ExecuteEnv;                                                  // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 MaxTriggers;                                                                // 0x0014 (size: 0x4)
    ESBAbilitySimultaneousActivationControl SimultaneousControl;                      // 0x0018 (size: 0x1)
    ESBAbilityFlags Flag;                                                             // 0x0019 (size: 0x1)
    ESBAbilityEffectiveCategory EffectiveCategory;                                    // 0x001A (size: 0x1)
    ESBBattleEffectiveFeel FeelType;                                                  // 0x001B (size: 0x1)
    FSBBattleStatusEffectID EffectId;                                                 // 0x001C (size: 0x8)
    ESBAbilityCalcSuccessRate CalcSuccessRate;                                        // 0x0024 (size: 0x1)
    ESBBattleStatusResistType ReferenceResistType;                                    // 0x0025 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0026 (size: 0x2)
    uint8 bExclusionLevelDifference;                                                  // 0x0028 (size: 0x1)
    uint8 bApplyAccumulation;                                                         // 0x0028 (size: 0x1)
    uint8 bIsImpossibleSummonMount;                                                   // 0x0028 (size: 0x1)
    uint8 bIsFinishMount;                                                             // 0x0028 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0029 (size: 0x3)
    ESBStatusAilmentIconType IconType;                                                // 0x002C (size: 0x1)
    char padding_3[0x3];                                                              // 0x002D (size: 0x3)
    int32 UIAttribute;                                                                // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBAbilityDataInterface
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBAbilityEffectData
{
    FSBAbilityMasterID ID;                                                            // 0x0000 (size: 0x4)
    int32 Parts1Value1;                                                               // 0x0004 (size: 0x4)
    int32 Parts1Value2;                                                               // 0x0008 (size: 0x4)
    int32 Parts2Value1;                                                               // 0x000C (size: 0x4)
    int32 Parts2Value2;                                                               // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBAbilityEffectMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 AbilityID;                                                                  // 0x0004 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0008 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x000C (size: 0x4)
    int32 Ability_parts1_Value1;                                                      // 0x0010 (size: 0x4)
    int32 Ability_parts1_Value2;                                                      // 0x0014 (size: 0x4)
    int32 Ability_parts2_Value1;                                                      // 0x0018 (size: 0x4)
    int32 Ability_parts2_Value2;                                                      // 0x001C (size: 0x4)
    int32 LotteryGroupId;                                                             // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FSBAbilityElementStatusReinforceLevelModifySetting
{
    int32 StatusAilmentLevel;                                                         // 0x0000 (size: 0x4)
    float ModifyValue;                                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBAbilityGroupConfig
{
    FSBBattleStatusEffectID EffectId;                                                 // 0x0000 (size: 0x8)
    ESBStatusAilmentIconType IconType;                                                // 0x0008 (size: 0x1)
    ESBAbilityFlags Flag;                                                             // 0x0009 (size: 0x1)
    char padding_0[0x2];                                                              // 0x000A (size: 0x2)
    int32 MaxTriggers;                                                                // 0x000C (size: 0x4)
    ESBAbilitySimultaneousActivationControl SimultaneousControl;                      // 0x0010 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0011 (size: 0x7)
    TArray<ESBBattleEffectiveGroup> ExcludeGroupList;                                 // 0x0018 (size: 0x10)
    uint8 bIsImpossibleSummonMount;                                                   // 0x0028 (size: 0x1)
    uint8 bApplyGroupCalcToAbility;                                                   // 0x0028 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0029 (size: 0x3)
    ESBAbilityCalcSuccessRate CalcSuccessRate;                                        // 0x002C (size: 0x1)
    ESBBattleStatusResistType ReferenceResistType;                                    // 0x002D (size: 0x1)
    char padding_3[0x2];                                                              // 0x002E (size: 0x2)
    uint8 bExclusionLevelDifference;                                                  // 0x0030 (size: 0x1)
    uint8 bApplyAccumulation;                                                         // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBAbilityID
{
    FName ID;                                                                         // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBAbilityLimitParam
{
    uint8 bEnable;                                                                    // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 Max;                                                                        // 0x0004 (size: 0x4)
    int32 Min;                                                                        // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBAbilityMasterData : public FSBAbilityDataInterface
{
    int32 ID;                                                                         // 0x0008 (size: 0x4)
    EAbilityCategoryType Category;                                                    // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    FName Ability_parts1_Name;                                                        // 0x0010 (size: 0x8)
    FSBTextTableHash Ability_Name1;                                                   // 0x0018 (size: 0x4)
    FName Ability_parts2_Name;                                                        // 0x001C (size: 0x8)
    FSBTextTableHash Ability_Name2;                                                   // 0x0024 (size: 0x4)
    FName Dynamic_Condition1_type;                                                    // 0x0028 (size: 0x8)
    int32 Dynamic_Condition1_value;                                                   // 0x0030 (size: 0x4)
    bool Dynamic_Condition1_forcecondition;                                           // 0x0034 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0035 (size: 0x3)
    float Dynamic_condition1_effectivetime;                                           // 0x0038 (size: 0x4)
    float Dynamic_Condition1_interval;                                                // 0x003C (size: 0x4)

}; // Size: 0x40

struct FSBAbilityMasterID
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBAbilityModifyData : public FTableRowBase
{
    FDataTableRowHandle RowHandle;                                                    // 0x0008 (size: 0x10)
    TArray<FSBAbilityModifyParam> ModiryParamList;                                    // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBAbilityModifyParam
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TArray<FSBAbilityPartsModifyParam> PartsList;                                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBAbilityParts
{
    FSBAbilityID AbilityID;                                                           // 0x0000 (size: 0x8)
    int32 Value1;                                                                     // 0x0008 (size: 0x4)
    int32 Value2;                                                                     // 0x000C (size: 0x4)
    uint8 bIndividualRate;                                                            // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    float Rate;                                                                       // 0x0014 (size: 0x4)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBAbilityPartsModifyParam
{
    FSBAbilityID AbilityID;                                                           // 0x0000 (size: 0x8)
    bool bOverride;                                                                   // 0x0008 (size: 0x1)
    bool bModifyValue1;                                                               // 0x0009 (size: 0x1)
    char padding_0[0x2];                                                              // 0x000A (size: 0x2)
    int32 Value1;                                                                     // 0x000C (size: 0x4)
    class UCurveFloat* Value1Curve;                                                   // 0x0010 (size: 0x8)
    bool bModifyValue2;                                                               // 0x0018 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0019 (size: 0x3)
    int32 Value2;                                                                     // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBAbilityTextData
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    FString Desc;                                                                     // 0x0010 (size: 0x10)
    bool bValidAbility1;                                                              // 0x0020 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0021 (size: 0x7)
    FString AbilityEffectName1;                                                       // 0x0028 (size: 0x10)
    bool bValidAbility2;                                                              // 0x0038 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0039 (size: 0x7)
    FString AbilityEffectName2;                                                       // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBAbilityValueLimit
{
    ESBAbilityValueLimitType LimitType;                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBAccumulationResistSetting
{
    float SuccessRate;                                                                // 0x0000 (size: 0x4)
    float EffectiveTimeRate;                                                          // 0x0004 (size: 0x4)
    float Time;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBAchievementInfo
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBAchievementLargeCategoryInfo
{
    int32 LargeCategoryId;                                                            // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<int32> MediumCategoryList;                                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBAchievementRewardData
{
    TArray<FOwnItemInfo> DirtyItems;                                                  // 0x0000 (size: 0x10)
    TArray<FOwnItemInfo> SoldItems;                                                   // 0x0010 (size: 0x10)
    TArray<FSBCharacterToken> Tokens;                                                 // 0x0020 (size: 0x10)
    int32 AddLuno;                                                                    // 0x0030 (size: 0x4)
    int32 AddGC;                                                                      // 0x0034 (size: 0x4)
    int32 AddExp;                                                                     // 0x0038 (size: 0x4)
    int32 FreeCurrencies;                                                             // 0x003C (size: 0x4)
    int32 VanishedMoney;                                                              // 0x0040 (size: 0x4)
    int32 VanishedGc;                                                                 // 0x0044 (size: 0x4)
    int32 VanishedExp;                                                                // 0x0048 (size: 0x4)
    int32 VanishedCurrencies;                                                         // 0x004C (size: 0x4)
    TArray<FSBAchievementRewardedStampData> VanishStampDataList;                      // 0x0050 (size: 0x10)
    TArray<int32> AwardIdList;                                                        // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FSBAchievementRewardedStampData
{
    int32 StampId;                                                                    // 0x0000 (size: 0x4)
    bool IsNew;                                                                       // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBAchievementSelectCategory
{
    int32 LargeCategory;                                                              // 0x0000 (size: 0x4)
    int32 MidiumCategory;                                                             // 0x0004 (size: 0x4)
    bool IsSelect;                                                                    // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBActionGamepadKeyPair
{
    TEnumAsByte<ESBKeyConfigAction::Type> Action;                                     // 0x0000 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Key;                                    // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FSBActionKeyboardKeyPair
{
    TEnumAsByte<ESBKeyConfigAction::Type> Action;                                     // 0x0000 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Key;                                   // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FSBActionMouseKeyPair
{
    TEnumAsByte<ESBKeyConfigAction::Type> Action;                                     // 0x0000 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Key;                                      // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FSBActiveArtsID
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBActiveItemData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    int32 ItemIndex;                                                                  // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FDateTime LimitTime;                                                              // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBActiveItemList
{
    TArray<FSBActiveItemData> ActiveItems;                                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBActiveOutGameBuffDataList
{
    EOutGameBuffType BuffType;                                                        // 0x0000 (size: 0x1)
    char padding_0[0x17];                                                             // 0x0001 (size: 0x17)
    TArray<class USBActiveOutGameBuffData*> BuffDataList;                             // 0x0018 (size: 0x10)

}; // Size: 0x30

struct FSBActivityData
{
    ESBActivityType Type;                                                             // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FDateTime AchieveTime;                                                            // 0x0008 (size: 0x8)
    TArray<FSBActivityDataParam> Params;                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBActivityDataParam
{
    FString Key;                                                                      // 0x0000 (size: 0x10)
    FString Value;                                                                    // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBAddItemData
{
    int32 storage_no;                                                                 // 0x0000 (size: 0x4)
    EItemType item_type;                                                              // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 item_id;                                                                    // 0x0008 (size: 0x4)
    int32 Amount;                                                                     // 0x000C (size: 0x4)
    bool identified;                                                                  // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FSBAdjustRootMotionSettings
{
    FSBCharacterAdjustRootMotionSettings_AdjustVelocity AdjustVelocitySettings;       // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FSBCharacterAdjustRootMotionSettings_TargetLocation TargetLocationSettings;       // 0x0004 (size: 0x28)
    FSBCharacterAdjustRootMotionSettings_Facing FacingSettings;                       // 0x002C (size: 0x8)
    FSBCharacterAdjustRootMotionSettings_Following FollowingSettings;                 // 0x0034 (size: 0x8)
    FVector ScaleRatio;                                                               // 0x003C (size: 0xC)
    FName TargetLocationOffsetSocketName;                                             // 0x0048 (size: 0x8)
    FVector TargetLocationOffset;                                                     // 0x0050 (size: 0xC)
    bool bEnablePredictTarget;                                                        // 0x005C (size: 0x1)
    char padding_1[0x3];                                                              // 0x005D (size: 0x3)
    int32 TargetIndex;                                                                // 0x0060 (size: 0x4)
    ESBAdjustRootMotionAdjustType AdjustType;                                         // 0x0064 (size: 0x1)
    ESBAdjustRootMotionTargetInterpolationType TargetInterpolationType;               // 0x0065 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0066 (size: 0x2)
    float TargetDistanceRatio;                                                        // 0x0068 (size: 0x4)
    float TargetLocationOffsetZ;                                                      // 0x006C (size: 0x4)
    float RequiredStartLocationOffsetZ;                                               // 0x0070 (size: 0x4)
    float TraceTargetBelowHeight;                                                     // 0x0074 (size: 0x4)
    float AdjustRangeMin;                                                             // 0x0078 (size: 0x4)
    float AdjustRangeMax;                                                             // 0x007C (size: 0x4)
    float YawAngleMax;                                                                // 0x0080 (size: 0x4)
    float PitchAngleMax;                                                              // 0x0084 (size: 0x4)
    bool bUseManualOffset;                                                            // 0x0088 (size: 0x1)
    bool bAdjustWithZAxis;                                                            // 0x0089 (size: 0x1)
    bool bAdjustNavMeshArea;                                                          // 0x008A (size: 0x1)
    bool bCheckNavigationRaycast;                                                     // 0x008B (size: 0x1)
    ESBAdjustRootMotionZAxisMode ZAxisMode;                                           // 0x008C (size: 0x1)
    char padding_3[0x3];                                                              // 0x008D (size: 0x3)
    float FacingRotationRate;                                                         // 0x0090 (size: 0x4)
    float FollowTime;                                                                 // 0x0094 (size: 0x4)
    float FollowRotationRate;                                                         // 0x0098 (size: 0x4)
    float FollowVelocity;                                                             // 0x009C (size: 0x4)
    float PredictTime;                                                                // 0x00A0 (size: 0x4)
    float MinAdjustLength;                                                            // 0x00A4 (size: 0x4)
    float MaxAdjustLength;                                                            // 0x00A8 (size: 0x4)
    float YawMaxAngle;                                                                // 0x00AC (size: 0x4)
    float PitchMaxAngle;                                                              // 0x00B0 (size: 0x4)
    float FrontTargetOffset;                                                          // 0x00B4 (size: 0x4)
    float TopTargetOffset;                                                            // 0x00B8 (size: 0x4)
    float YawRotationRate;                                                            // 0x00BC (size: 0x4)

}; // Size: 0xC0

struct FSBAdventureBoardCondition
{
    FString Condition;                                                                // 0x0000 (size: 0x10)
    FString Progress;                                                                 // 0x0010 (size: 0x10)
    FString MissonId;                                                                 // 0x0020 (size: 0x10)
    bool Complated;                                                                   // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    int32 OrderPriority;                                                              // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FSBAdventureBoardInfo
{
    FSBTextTableHash NameId;                                                          // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBAdventureBoardCondition> ConditionList;                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBAdventureBoardListManager
{
    TArray<FSBAdventureBoardParam> BoardParamList;                                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBAdventureBoardMissionParamMasterData
{
    FString MissionId;                                                                // 0x0000 (size: 0x10)
    ESBMissionQuestType Type;                                                         // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    FString QuestID;                                                                  // 0x0018 (size: 0x10)
    FString QuestGroupId;                                                             // 0x0028 (size: 0x10)
    FSBTextTableHash NameId;                                                          // 0x0038 (size: 0x4)
    char padding_1[0x4];                                                              // 0x003C (size: 0x4)
    FString MapId;                                                                    // 0x0040 (size: 0x10)
    FString EnemyId;                                                                  // 0x0050 (size: 0x10)
    ESBMissionQuestItemType ItemType;                                                 // 0x0060 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0061 (size: 0x7)
    FString ItemIdString;                                                             // 0x0068 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0078 (size: 0x1)
    ESBMissionQuestPlaceType PlaceType;                                               // 0x0079 (size: 0x1)
    char padding_3[0x6];                                                              // 0x007A (size: 0x6)
    FString BuffId;                                                                   // 0x0080 (size: 0x10)
    int32 CountBonus;                                                                 // 0x0090 (size: 0x4)
    char padding_4[0x4];                                                              // 0x0094 (size: 0x4)
    FString CountBonusTermId;                                                         // 0x0098 (size: 0x10)

}; // Size: 0xA8

struct FSBAdventureBoardMissionTypeData : public FTableRowBase
{
    ESBAdventureBoardPanelMissionType Type;                                           // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 TypeNameId;                                                                 // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBAdventureBoardNotifyClearStatus
{
    ESBAdventureBoardClearStatus Status;                                              // 0x0000 (size: 0x1)
    bool IsComplete;                                                                  // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FSBAdventureBoardPanelParam
{
    int32 PanelId;                                                                    // 0x0000 (size: 0x4)
    int32 ProgressCnt;                                                                // 0x0004 (size: 0x4)
    ESBAdventureBoardPanelStatus Status;                                              // 0x0008 (size: 0x1)
    bool IsHudDraw;                                                                   // 0x0009 (size: 0x1)
    bool IsNewOpen;                                                                   // 0x000A (size: 0x1)

}; // Size: 0xC

struct FSBAdventureBoardPanelParamMasterData
{
    int32 PanelId;                                                                    // 0x0000 (size: 0x4)
    int32 BoardId;                                                                    // 0x0004 (size: 0x4)
    FVector2D UIPos;                                                                  // 0x0008 (size: 0x8)
    ESBAdventureBoardPanelType Type;                                                  // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    FString MissionId;                                                                // 0x0018 (size: 0x10)
    int32 RequiredCnt;                                                                // 0x0028 (size: 0x4)
    char padding_1[0x4];                                                              // 0x002C (size: 0x4)
    TArray<FName> RewardIdList;                                                       // 0x0030 (size: 0x10)
    TArray<int32> NextPanelList;                                                      // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBAdventureBoardPanelUpdateData
{
    int32 BoardId;                                                                    // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString PanelId;                                                                  // 0x0008 (size: 0x10)
    ESBAdventureBoardPanelStatus Status;                                              // 0x0018 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0019 (size: 0x3)
    int32 ProgressCnt;                                                                // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBAdventureBoardParam
{
    int32 BoardId;                                                                    // 0x0000 (size: 0x4)
    ESBAdventureBoardStatus Status;                                                   // 0x0004 (size: 0x1)
    bool IsActive;                                                                    // 0x0005 (size: 0x1)
    bool IsFavorite;                                                                  // 0x0006 (size: 0x1)
    bool IsHudDraw;                                                                   // 0x0007 (size: 0x1)
    TArray<FSBAdventureBoardPanelParam> PanelParamList;                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBAdventureBoardParamMasterData
{
    int32 BoardId;                                                                    // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString VersionId;                                                                // 0x0008 (size: 0x10)
    FSBTextTableHash NameId;                                                          // 0x0018 (size: 0x4)
    int32 IconID;                                                                     // 0x001C (size: 0x4)
    ESBAdventureBoardType Type;                                                       // 0x0020 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0021 (size: 0x7)
    TArray<FName> CompleteRewardIdList;                                               // 0x0028 (size: 0x10)
    FString ChallengeTermId;                                                          // 0x0038 (size: 0x10)
    FString AcceptanceTermId;                                                         // 0x0048 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0058 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0059 (size: 0x7)
    TArray<FSBAdventureBoardPanelParamMasterData> PanelParamList;                     // 0x0060 (size: 0x10)
    int32 SortId;                                                                     // 0x0070 (size: 0x4)
    FSBTextTableHash DescID;                                                          // 0x0074 (size: 0x4)

}; // Size: 0x78

struct FSBAdventureBoardRouteParam
{
    int32 StartPanelId;                                                               // 0x0000 (size: 0x4)
    int32 TermPanelId;                                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBAdventureBoardUpdateData
{
    int32 BoardId;                                                                    // 0x0000 (size: 0x4)
    ESBAdventureBoardStatus Status;                                                   // 0x0004 (size: 0x1)
    bool IsActive;                                                                    // 0x0005 (size: 0x1)
    bool IsHudDraw;                                                                   // 0x0006 (size: 0x1)
    bool IsFavorite;                                                                  // 0x0007 (size: 0x1)

}; // Size: 0x8

struct FSBAdventurerRankMasterData
{
    int32 Rank;                                                                       // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<int32> AdventureBoardIdList;                                               // 0x0008 (size: 0x10)
    int32 DistributeAdventureBoardId;                                                 // 0x0018 (size: 0x4)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    TArray<FString> GameContentIds;                                                   // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBAestheShopAppearanceInfo
{
    int32 InfoId;                                                                     // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FSBCharaCreateParameter CharaCreateParameter;                                     // 0x0008 (size: 0x3C0)
    FDateTime DataSaveDateTime;                                                       // 0x03C8 (size: 0x8)

}; // Size: 0x3D0

struct FSBAestheShopCharaParamRestrictionMasterData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    ESBCharacterGender Gender;                                                        // 0x0010 (size: 0x1)
    ESBAestheShopCharaPartsAndParamEditType EditType;                                 // 0x0011 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0012 (size: 0x6)
    TArray<int32> ParamValueList;                                                     // 0x0018 (size: 0x10)
    int32 ParamMin;                                                                   // 0x0028 (size: 0x4)
    int32 ParamMax;                                                                   // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBAestheShopCharaPartsIconInfoForSort
{
    int32 SortId;                                                                     // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TSoftObjectPtr<UTexture2D> IconTexture;                                           // 0x0008 (size: 0x28)
    FName AssetId;                                                                    // 0x0030 (size: 0x8)
    FString IconID;                                                                   // 0x0038 (size: 0x10)
    bool bIsNew;                                                                      // 0x0048 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0049 (size: 0x7)
    FString TermId;                                                                   // 0x0050 (size: 0x10)
    int64 TermTicks;                                                                  // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FSBAestheShopCourseMasterData
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0004 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString CourseIconName;                                                           // 0x0010 (size: 0x10)
    bool CanBeCompleted;                                                              // 0x0020 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0021 (size: 0x3)
    int32 TicketId;                                                                   // 0x0024 (size: 0x4)
    int32 TicketConsumeAmount;                                                        // 0x0028 (size: 0x4)
    EAestheShopCourseUsableCategory CategoryGender;                                   // 0x002C (size: 0x1)
    EAestheShopCourseUsableCategory CategoryPreset;                                   // 0x002D (size: 0x1)
    EAestheShopCourseUsableCategory CategoryAppearance;                               // 0x002E (size: 0x1)
    EAestheShopCourseUsableCategory CategoryDefaultVoice;                             // 0x002F (size: 0x1)
    EAestheShopCourseUsableCategory CategoryExtraVoice;                               // 0x0030 (size: 0x1)
    EAestheShopCourseUsableCategory CategoryFaceTypeAndBody;                          // 0x0031 (size: 0x1)
    EAestheShopCourseUsableCategory CategoryHair;                                     // 0x0032 (size: 0x1)
    EAestheShopCourseUsableCategory CategorySkinAndFace;                              // 0x0033 (size: 0x1)
    EAestheShopCourseUsableCategory CategoryEyeParts;                                 // 0x0034 (size: 0x1)
    EAestheShopCourseUsableCategory CategoryFaceParts;                                // 0x0035 (size: 0x1)
    EAestheShopCourseUsableCategory CategoryMakeup;                                   // 0x0036 (size: 0x1)
    char padding_2[0x1];                                                              // 0x0037 (size: 0x1)
    FString EventTermId;                                                              // 0x0038 (size: 0x10)
    bool IsListVisible;                                                               // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FSBAestheShopPartsMasterData
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString IconID;                                                                   // 0x0008 (size: 0x10)
    FString AssetId;                                                                  // 0x0018 (size: 0x10)
    int32 SortId;                                                                     // 0x0028 (size: 0x4)
    bool IsActive;                                                                    // 0x002C (size: 0x1)
    char padding_1[0x3];                                                              // 0x002D (size: 0x3)
    FString EventTermId;                                                              // 0x0030 (size: 0x10)
    ESBCharacterGender Gender;                                                        // 0x0040 (size: 0x1)
    ESBAestheShopCharaPartsIconType PartsIconType;                                    // 0x0041 (size: 0x1)
    ESBAestheShopCharaFaceType FaceType;                                              // 0x0042 (size: 0x1)
    ESBAestheShopCharaBodyType BodyType;                                              // 0x0043 (size: 0x1)
    ESBAestheShopCharaHairType HairType;                                              // 0x0044 (size: 0x1)
    ESBAestheShopCharaPartsAndParamEditType EditType;                                 // 0x0045 (size: 0x1)

}; // Size: 0x48

struct FSBAimBodyBlendRateSetting
{
    FName Tag;                                                                        // 0x0000 (size: 0x8)
    float BlendRate;                                                                  // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBAkEventLODTableRow : public FTableRowBase
{
    ESBAkEventLOD LOD;                                                                // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    float Distance;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBAkEventTriggerAreaData
{
    int32 Priority;                                                                   // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FString CategoryName;                                                             // 0x0018 (size: 0x10)
    class UAkAudioEvent* BeginOverlapAkEvent;                                         // 0x0028 (size: 0x8)
    class UAkAudioEvent* EndOverlapAkEvent;                                           // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FSBAkRTPC
{
    FName RTPCName;                                                                   // 0x0000 (size: 0x8)
    float Value;                                                                      // 0x0008 (size: 0x4)
    float ValueMin;                                                                   // 0x000C (size: 0x4)
    float ValueMax;                                                                   // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBAmbientAkEventAssetData
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

struct FSBAnimSingleNodeInstanceProxy : public FAnimSingleNodeInstanceProxy
{
    char padding_0[0x8C0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x8C0

struct FSBAnimTagEffectSetting
{
    FName AnimTag;                                                                    // 0x0008 (size: 0x8)
    FSBEffectAsset Effect;                                                            // 0x0010 (size: 0x1A8)

}; // Size: 0x1B8

struct FSBArenaMissionData : public FTableRowBase
{
    EArenaMissionAchieveType Type;                                                    // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    FString Value1;                                                                   // 0x0010 (size: 0x10)
    FString Value2;                                                                   // 0x0020 (size: 0x10)
    float LimitTime;                                                                  // 0x0030 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0034 (size: 0x4)
    FDataTableRowHandle MissionRewardHandle;                                          // 0x0038 (size: 0x10)
    FText RewardText;                                                                 // 0x0048 (size: 0x18)

}; // Size: 0x60

struct FSBAttackCollisionAddition
{
    bool bOverrideAttackHitType;                                                      // 0x0000 (size: 0x1)
    EAttackHitType AttackHitType;                                                     // 0x0001 (size: 0x1)
    int16 AttackDirectionOffset;                                                      // 0x0002 (size: 0x2)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> ModifyScaleList;                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBAttackDeactiveStatusGroupData
{
    ESBBattleEffectiveGroup Group;                                                    // 0x0000 (size: 0x1)
    bool bDeactiveStatusGivenByOther;                                                 // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FSBAttackDeactiveStatusHandleData
{
    FDataTableRowHandle Handle;                                                       // 0x0000 (size: 0x10)
    bool bDeactiveStatusGivenByOther;                                                 // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBAttackDirectionSetting
{
    ESBAttackDirectionOrigin AttackDirectionOrigin;                                   // 0x0000 (size: 0x1)
    ESBAttackDirectionType AttackDirection;                                           // 0x0001 (size: 0x1)
    int16 DirectionYaw;                                                               // 0x0002 (size: 0x2)
    uint8 bEnableBackAttackTrigger;                                                   // 0x0004 (size: 0x1)
    uint8 bSpecifyGuardDirection;                                                     // 0x0004 (size: 0x1)
    ESBAttackDirectionOrigin AttackDirectionOriginForGuard;                           // 0x0005 (size: 0x1)
    ESBAttackDirectionType AttackDirectionForGuard;                                   // 0x0006 (size: 0x1)

}; // Size: 0x8

struct FSBAttackHitLaunchProjectile
{
    FSBAttackID AttackID;                                                             // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle RowHandle;                                                    // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBAttackHitSelfApplyStatus
{
    FSBAttackID AttackID;                                                             // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle RowHandle;                                                    // 0x0008 (size: 0x10)
    float DelayTime;                                                                  // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBAttackHitStatusAilmentCondition
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    FDataTableRowHandle StatusAilmentHandle;                                          // 0x0010 (size: 0x10)
    bool bApplyDuplicateStatusAilment;                                                // 0x0020 (size: 0x1)
    bool bCheckSelfApplyOnlyDuplicateStatusAilment;                                   // 0x0021 (size: 0x1)

}; // Size: 0x28

struct FSBAttackHitStopSetting
{
    float AttackHitStopTime;                                                          // 0x0000 (size: 0x4)
    float DamageHitStopTime;                                                          // 0x0004 (size: 0x4)
    ESBHitSlomoPower HitSlomoPower;                                                   // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    uint8 bSlomoAttackActor;                                                          // 0x000C (size: 0x1)
    uint8 bSlomoDamageActor;                                                          // 0x000C (size: 0x1)
    char padding_1[0x3];                                                              // 0x000D (size: 0x3)
    ESBHitSlomoType DamageHitStopType;                                                // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FSBAttackID
{
    int32 AttackID;                                                                   // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBAttackMasterData
{
    int32 AttackID;                                                                   // 0x0000 (size: 0x4)
    int32 Name;                                                                       // 0x0004 (size: 0x4)
    int32 HitCount;                                                                   // 0x0008 (size: 0x4)
    float HitInterval;                                                                // 0x000C (size: 0x4)
    EAttackHitType attack_hit_type;                                                   // 0x0010 (size: 0x1)
    EAttackAttributeType attack_attribute_type;                                       // 0x0011 (size: 0x1)
    EDamageType damage_type;                                                          // 0x0012 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0013 (size: 0x1)
    float AttackScale;                                                                // 0x0014 (size: 0x4)
    int32 damage_value1;                                                              // 0x0018 (size: 0x4)
    int32 damage_value2;                                                              // 0x001C (size: 0x4)
    float back_attack_scale;                                                          // 0x0020 (size: 0x4)
    float down_attack_scale;                                                          // 0x0024 (size: 0x4)
    float BadConditionAttackScale;                                                    // 0x0028 (size: 0x4)
    float ShieldDamageModifyRate;                                                     // 0x002C (size: 0x4)
    FSBAttackDirectionSetting attack_direction_setting;                               // 0x0030 (size: 0x8)
    ESBDamageAttackType attack_type;                                                  // 0x0038 (size: 0x1)
    ESBAttackThroughType through_type;                                                // 0x0039 (size: 0x1)
    char padding_1[0x2];                                                              // 0x003A (size: 0x2)
    uint8 bAttribute_Explode;                                                         // 0x003C (size: 0x1)
    char padding_2[0x3];                                                              // 0x003D (size: 0x3)
    FSBAttackStunSetting StunSetting;                                                 // 0x0040 (size: 0x18)
    FSBAttackHitStopSetting HitStop;                                                  // 0x0058 (size: 0x14)
    char padding_3[0x4];                                                              // 0x006C (size: 0x4)
    FString HitSlomoCurveName;                                                        // 0x0070 (size: 0x10)
    FSBHitKnockBackSetting HitKnockBack;                                              // 0x0080 (size: 0x18)
    float Hate;                                                                       // 0x0098 (size: 0x4)
    char padding_4[0x4];                                                              // 0x009C (size: 0x4)
    FString special_hit_effect_name;                                                  // 0x00A0 (size: 0x10)
    char padding_5[0x8];                                                              // 0x00B0 (size: 0x8)
    TArray<FSBAttackParam> AttackParam;                                               // 0x00B8 (size: 0x10)

}; // Size: 0xE8

struct FSBAttackMasterDataModifyData : public FTableRowBase
{
    FSBAttackID AttackID;                                                             // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBAttackMasterDataModifyParam> ModiryParamList;                           // 0x0010 (size: 0x10)
    TArray<FDataTableRowHandle> ModiryParamRowHandleList;                             // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBAttackMasterDataModifyParam
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    bool bOverride;                                                                   // 0x0010 (size: 0x1)
    bool bModifyHitInterval;                                                          // 0x0011 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0012 (size: 0x2)
    float HitInterval;                                                                // 0x0014 (size: 0x4)
    float DamageModifyRate;                                                           // 0x0018 (size: 0x4)
    int32 AttackScaleModifyRate;                                                      // 0x001C (size: 0x4)
    bool bModifyDamageValue1;                                                         // 0x0020 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0021 (size: 0x3)
    float DamageValue1;                                                               // 0x0024 (size: 0x4)
    bool bModifyDownAttackScale;                                                      // 0x0028 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0029 (size: 0x3)
    float DownAttackScale;                                                            // 0x002C (size: 0x4)
    bool bModifyBadConditionAttackScale;                                              // 0x0030 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0031 (size: 0x3)
    float BadConditionAttackScale;                                                    // 0x0034 (size: 0x4)
    float ShieldDamageModifyRate;                                                     // 0x0038 (size: 0x4)
    bool bModifyAttackDirection;                                                      // 0x003C (size: 0x1)
    char padding_4[0x1];                                                              // 0x003D (size: 0x1)
    FSBAttackDirectionSetting AttackDirectionSetting;                                 // 0x003E (size: 0x8)
    bool bModifyAttackThroughConfig;                                                  // 0x0046 (size: 0x1)
    char padding_5[0x1];                                                              // 0x0047 (size: 0x1)
    FSBAttackThroughConfig AttackThroughConfig;                                       // 0x0048 (size: 0x8)
    bool bModifyStunDirection;                                                        // 0x0050 (size: 0x1)
    ESBStunDirection StunDirection;                                                   // 0x0051 (size: 0x1)
    char padding_6[0x6];                                                              // 0x0052 (size: 0x6)
    TArray<FSBElementDamageModifySetting> ElementDamageModifySettingList;             // 0x0058 (size: 0x10)
    bool bModifyHitStop;                                                              // 0x0068 (size: 0x1)
    char padding_7[0x3];                                                              // 0x0069 (size: 0x3)
    FSBAttackHitStopSetting HitStop;                                                  // 0x006C (size: 0x14)
    bool bModifyHitKnockBack;                                                         // 0x0080 (size: 0x1)
    char padding_8[0x3];                                                              // 0x0081 (size: 0x3)
    FSBHitKnockBackSetting HitKnockBack;                                              // 0x0084 (size: 0x18)
    bool bModifyHateScale;                                                            // 0x009C (size: 0x1)
    char padding_9[0x3];                                                              // 0x009D (size: 0x3)
    float HateScale;                                                                  // 0x00A0 (size: 0x4)
    bool bModifySpecialHitEffectName;                                                 // 0x00A4 (size: 0x1)
    char padding_10[0x3];                                                             // 0x00A5 (size: 0x3)
    FName SpecialHitEffectName;                                                       // 0x00A8 (size: 0x8)
    char padding_11[0x8];                                                             // 0x00B0 (size: 0x8)
    TArray<FSBStatusAilmentHandle> GiveStatusAilmentList;                             // 0x00B8 (size: 0x10)
    TArray<FSBAttackStatusData> GaveDamageSelfStatusAilmentList;                      // 0x00C8 (size: 0x10)
    TArray<FSBAttackStatusData> GaveHitSelfStatusAilmentList;                         // 0x00D8 (size: 0x10)
    TArray<FSBAttackStatusData> GaveWeakPointHitSelfStatusAilmentList;                // 0x00E8 (size: 0x10)
    TArray<FSBAttackDeactiveStatusHandleData> DeactiveStatusHandleList;               // 0x00F8 (size: 0x10)
    TArray<FSBAttackDeactiveStatusGroupData> DeactiveStatusGroupList;                 // 0x0108 (size: 0x10)

}; // Size: 0x118

struct FSBAttackModifyMasterData
{
    int32 SettingID;                                                                  // 0x0000 (size: 0x4)
    int32 AttackID;                                                                   // 0x0004 (size: 0x4)
    TArray<FSBAttackMasterDataModifyParam> ModifyParamList;                           // 0x0008 (size: 0x10)
    TArray<int32> UseSettingIDList;                                                   // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBAttackOverrideMasterData : public FSBAttackMasterData
{
    FName ChracterID;                                                                 // 0x00E8 (size: 0x8)

}; // Size: 0x100

struct FSBAttackParam
{
    ESBAttackParam Type;                                                              // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBAttackProjectile
{
    FDataTableRowHandle RowHandle;                                                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBAttackSettings
{
    float HomingDashTime;                                                             // 0x0000 (size: 0x4)
    float HomingDashRange;                                                            // 0x0004 (size: 0x4)
    float AttackRange;                                                                // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBAttackStatusData
{
    FSBStatusAilmentHandle StatusAilment;                                             // 0x0000 (size: 0x20)
    float DelayTime;                                                                  // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBAttackStunSetting
{
    TArray<FSBElementDamageSetting> ElementDamageList;                                // 0x0000 (size: 0x10)
    ESBStunDirection Direction;                                                       // 0x0010 (size: 0x1)
    bool bLevelDiff;                                                                  // 0x0011 (size: 0x1)

}; // Size: 0x18

struct FSBAttackThroughConfig
{
    ESBDamageAttackType AttackType;                                                   // 0x0000 (size: 0x1)
    ESBAttackThroughType ThroughType;                                                 // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    int32 AttributeBitMask;                                                           // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBAttributeEffectInfo
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    TSubclassOf<class ASBProjectileEffect> EffectActor;                               // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBAttributeSlashDisk
{
    ESBAttribute ElementType;                                                         // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FSBEffectSetting SlashDiskEffect;                                                 // 0x0008 (size: 0x150)

}; // Size: 0x158

struct FSBAutoQuestComponentData
{
    int32 ClassExp;                                                                   // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBCharacterToken> TokenList;                                              // 0x0008 (size: 0x10)
    FSBExtraExpParse ClassExtraExp;                                                   // 0x0018 (size: 0x18)

}; // Size: 0x30

struct FSBAutoStampSaveData
{
    TMap<class FString, class FAutoWordUserSetting> AutoStampData;                    // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSBAutoWordData
{
    bool bEnable;                                                                     // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 Priority;                                                                   // 0x0004 (size: 0x4)
    float CooolTime;                                                                  // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBBDFObjectCommonTypeInfo
{
    FSBBDFObjectEffectInfo PartsEffect;                                               // 0x0000 (size: 0x10)
    FSBBDFObjectPartsBreakEffectInfo PartsBreakEffect;                                // 0x0010 (size: 0x30)

}; // Size: 0x40

struct FSBBDFObjectEffectInfo
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    float Scale;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSBBDFObjectMaterialInfo
{
    int32 MaterialIndex;                                                              // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    class UMaterialInterface* Material;                                               // 0x0008 (size: 0x8)

}; // Size: 0x18

struct FSBBDFObjectParts
{
    FName CollisionGroupName;                                                         // 0x0000 (size: 0x8)
    ESBBDFObjectType DefaultType;                                                     // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TMap<class ESBBDFObjectType, class FSBBDFObjectTypeInfo> TypeInfo;                // 0x0010 (size: 0x50)
    FName SocketName;                                                                 // 0x0060 (size: 0x8)
    TArray<int32> OffMaterialIndexesOnDeploy;                                         // 0x0068 (size: 0x10)
    TArray<FName> OffTargetableNamesOnDeploy;                                         // 0x0078 (size: 0x10)
    TArray<FName> OffDamageCollisionNamesOnDeploy;                                    // 0x0088 (size: 0x10)
    int32 AnchorID;                                                                   // 0x0098 (size: 0x4)
    bool bExtraParts;                                                                 // 0x009C (size: 0x1)
    char padding_1[0x3];                                                              // 0x009D (size: 0x3)
    TArray<int32> ExtraMaterialIndexes;                                               // 0x00A0 (size: 0x10)
    TArray<FName> ExtraDamageCollisionNames;                                          // 0x00B0 (size: 0x10)
    TArray<FName> ExtraTargetableNames;                                               // 0x00C0 (size: 0x10)
    ESBBDFObjectType Type;                                                            // 0x00D0 (size: 0x1)
    bool bEnabled;                                                                    // 0x00D1 (size: 0x1)
    char padding_2[0x6];                                                              // 0x00D2 (size: 0x6)
    class UParticleSystem* ParticleByType;                                            // 0x00D8 (size: 0x8)
    class USBEnemyBDFObjectComponent* BDFObjectComponent;                             // 0x00E0 (size: 0x8)
    class AActor* BDFObjectProjectile;                                                // 0x00E8 (size: 0x8)

}; // Size: 0x100

struct FSBBDFObjectPartsBreakEffectInfo
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    TSoftObjectPtr<UAkAudioEvent> EffectSE;                                           // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBBDFObjectPartsHealEffectInfo
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0008 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x0014 (size: 0xC)
    float Scale;                                                                      // 0x0020 (size: 0x4)
    bool bAttached;                                                                   // 0x0024 (size: 0x1)
    bool bCastShadow;                                                                 // 0x0025 (size: 0x1)
    EEffectId EffectId;                                                               // 0x0026 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0027 (size: 0x1)
    TSoftObjectPtr<UAkAudioEvent> EffectSE;                                           // 0x0028 (size: 0x28)

}; // Size: 0x50

struct FSBBDFObjectTypeInfo
{
    TArray<FSBBDFObjectMaterialInfo> MaterialInfo;                                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBBGMBattleAreaContentIdData
{
    FString ContentId;                                                                // 0x0000 (size: 0x10)
    ESBBattleBGMType BattleBGMType;                                                   // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    class UAkAudioEvent* BattleBGMEvent;                                              // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBBGMEventRow : public FTableRowBase
{
    TSoftObjectPtr<UAkAudioEvent> Event;                                              // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBBGMInitializeValueArena
{
    float RequestTimeOfPreBattleEnd;                                                  // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBBGMInitializeValueData
{
    class USBBGMAkComponent* BGMAkComponent;                                          // 0x0000 (size: 0x8)
    TMap<class FString, class ESBBGMMapGameMode> BGMGameModeMap;                      // 0x0008 (size: 0x50)
    TArray<FString> ContentIdListOfForceUpdateMapID;                                  // 0x0058 (size: 0x10)
    FSBBGMInitializeValueDataInterruptQuest InterruptQuest;                           // 0x0068 (size: 0xC)
    char padding_0[0x4];                                                              // 0x0074 (size: 0x4)
    FSBBGMInitializeValueDataBattle Battle;                                           // 0x0078 (size: 0x78)
    FSBBGMInitializeValueInstanceArea InstanceArea;                                   // 0x00F0 (size: 0x30)
    FSBBGMInitializeValueArena Arena;                                                 // 0x0120 (size: 0x4)

}; // Size: 0x128

struct FSBBGMInitializeValueDataBattle
{
    int32 WeakEnemyLevelDiff;                                                         // 0x0000 (size: 0x4)
    int32 StrongEnemyLevelDiff;                                                       // 0x0004 (size: 0x4)
    float WaitTimeOfFieldBattleEnd;                                                   // 0x0008 (size: 0x4)
    float WaitTimeOfDungeonZakoBattleEnd;                                             // 0x000C (size: 0x4)
    float WaitTimeOfDungeonMiddleBossBattleEnd;                                       // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    TMap<class FString, class ESBBattleBGMType> LevelBattleBGMMap;                    // 0x0018 (size: 0x50)
    TArray<FString> NoRequestDefaultBattleBGMList;                                    // 0x0068 (size: 0x10)

}; // Size: 0x78

struct FSBBGMInitializeValueDataInterruptQuest
{
    float WaitTimeOfStart;                                                            // 0x0000 (size: 0x4)
    float WaitTimeOfSuccess;                                                          // 0x0004 (size: 0x4)
    float WaitTimeOfFail;                                                             // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBBGMInitializeValueInstanceArea
{
    TArray<FString> MapIDArrayOfStopTickBGM;                                          // 0x0000 (size: 0x10)
    TArray<FString> MapIDArrayOfNotRequestNoBattle;                                   // 0x0010 (size: 0x10)
    TArray<FString> MapIDArrayOfStopMusciAfterInstanceArea;                           // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBBGMMuteInTheaterRow : public FTableRowBase
{
    FString DemoName;                                                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBBGMTimeAttackAreaIDRow : public FTableRowBase
{
    FString BGMMapId;                                                                 // 0x0008 (size: 0x10)
    TMap<int32, FString> AreaIDEachLapMap;                                            // 0x0018 (size: 0x50)

}; // Size: 0x68

struct FSBBGMTriggerData
{
    bool IsActive;                                                                    // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString AreaId;                                                                   // 0x0008 (size: 0x10)
    int32 Priority;                                                                   // 0x0018 (size: 0x4)
    bool bCheckValidGameMode;                                                         // 0x001C (size: 0x1)
    char padding_1[0x3];                                                              // 0x001D (size: 0x3)
    TArray<ESBBGMMapGameMode> ValidGameModeList;                                      // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBBPPtExchangeMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FName TermId;                                                                     // 0x0004 (size: 0x8)
    ESBRewardItemType ItemType;                                                       // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    int32 ItemId;                                                                     // 0x0010 (size: 0x4)
    int32 ExchangeCount;                                                              // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBBPPtShopItemMasterData : public FSBFlatShopItemMasterData
{
    FSBTextTableHash ItemCaution;                                                     // 0x0078 (size: 0x4)
    FSBTextTableHash CoinCaution;                                                     // 0x007C (size: 0x4)
    FString SpFlags;                                                                  // 0x0080 (size: 0x10)

}; // Size: 0x90

struct FSBBPPtShopPurchaseLimitMasterData : public FSBFlatShopPurchaseLimitMasterData
{
    char padding_0[0x18];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x18

struct FSBBTNodePropertyWalkingMode : public FAIFwBTNodePropertyEnumBase
{
    ESBEnemyWalkingMode DefaultValue;                                                 // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBBTNodePropertyWarpDirectionType : public FAIFwBTNodePropertyEnumBase
{
    ESBEnemyWarpDirectionType DefaultValue;                                           // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBBadZoneAvoidanceAngle
{
    float CenterAngle;                                                                // 0x0000 (size: 0x4)
    float WidthAngle;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBBalloonWindowRequest
{
    FText Text;                                                                       // 0x0000 (size: 0x18)
    int32 CameraNumber;                                                               // 0x0018 (size: 0x4)
    int32 StampNumber;                                                                // 0x001C (size: 0x4)
    class ACharacter* Speaker;                                                        // 0x0020 (size: 0x8)
    FName AttachTransformName;                                                        // 0x0028 (size: 0x8)
    bool bAutoClose;                                                                  // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    float AutoCloseTime;                                                              // 0x0034 (size: 0x4)
    class UTextureRenderTarget2D* RenderTarget;                                       // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FSBBattleDebugParam
{
    ESBBattleDebugParamVariableType VariableType;                                     // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBBattleItemEffect
{
    uint8 bIsEnable;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> Particle;                                         // 0x0008 (size: 0x28)
    uint8 bIsAttach;                                                                  // 0x0030 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0031 (size: 0x3)
    FName SocketName;                                                                 // 0x0034 (size: 0x8)
    FName ActorParameterName;                                                         // 0x003C (size: 0x8)
    char padding_2[0x4];                                                              // 0x0044 (size: 0x4)
    FAkEventVariables AkEvent;                                                        // 0x0048 (size: 0x40)

}; // Size: 0x88

struct FSBBattleNpcInfo : public FTableRowBase
{
    FName npc_id;                                                                     // 0x0008 (size: 0x8)
    int32 Level;                                                                      // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBBattleScoreMasterData
{
    int32 SettingType;                                                                // 0x0000 (size: 0x4)
    float Coefficient;                                                                // 0x0004 (size: 0x4)
    float Min;                                                                        // 0x0008 (size: 0x4)
    float Max;                                                                        // 0x000C (size: 0x4)
    int32 RoundingType;                                                               // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBBattleStatusEffect
{
    TArray<FSBBattleStatusParticleEffect> ParticleEffectList;                         // 0x0000 (size: 0x10)
    TArray<FSBBattleStatusEffectActor> EffectActorList;                               // 0x0010 (size: 0x10)
    TArray<FSBBattleStatusMaterialEffect> MaterialEffectList;                         // 0x0020 (size: 0x10)
    FAkEventVariables AkEvent;                                                        // 0x0030 (size: 0x40)

}; // Size: 0x70

struct FSBBattleStatusEffectActor
{
    TSoftClassPtr<AActor> EffectActor;                                                // 0x0000 (size: 0x28)
    uint8 bIsAttach;                                                                  // 0x0028 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0029 (size: 0x3)
    TEnumAsByte<EEffectTarget> AttachTargetType;                                      // 0x002C (size: 0x1)
    char padding_1[0x3];                                                              // 0x002D (size: 0x3)
    FName AttachSocketName;                                                           // 0x0030 (size: 0x8)
    uint8 bIsOutDestroy;                                                              // 0x0038 (size: 0x1)
    uint8 bApplyElementEffectScale;                                                   // 0x0038 (size: 0x1)
    uint8 bIsSpawnOnlyInvoker;                                                        // 0x0038 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0039 (size: 0x7)
    FAkEventVariables AkEvent;                                                        // 0x0040 (size: 0x40)

}; // Size: 0x80

struct FSBBattleStatusEffectConfig : public FTableRowBase
{
    uint8 bRestrictOnSpecificCharacter;                                               // 0x0008 (size: 0x1)
    uint8 bEnableInEffect;                                                            // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    FSBBattleStatusEffect InEffect;                                                   // 0x0010 (size: 0x70)
    uint8 bEnableOverrideEffect;                                                      // 0x0080 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0081 (size: 0x7)
    FSBBattleStatusEffect OverrideEffect;                                             // 0x0088 (size: 0x70)
    uint8 bEnableInOrOverrideEffect;                                                  // 0x00F8 (size: 0x1)
    char padding_2[0x7];                                                              // 0x00F9 (size: 0x7)
    FSBBattleStatusEffect InOrOverrideEffect;                                         // 0x0100 (size: 0x70)
    uint8 bEnableOutEffect;                                                           // 0x0170 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0171 (size: 0x7)
    FSBBattleStatusEffect OutEffect;                                                  // 0x0178 (size: 0x70)

}; // Size: 0x1E8

struct FSBBattleStatusEffectID
{
    FName ID;                                                                         // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBBattleStatusMasterDataMediator
{
    FSBAbilityMasterID AbilityID;                                                     // 0x0000 (size: 0x4)
    int16 Parts1Value1;                                                               // 0x0004 (size: 0x2)
    int16 Parts1Value2;                                                               // 0x0006 (size: 0x2)
    int16 Parts2Value1;                                                               // 0x0008 (size: 0x2)
    int16 Parts2Value2;                                                               // 0x000A (size: 0x2)
    char padding_0[0x2C];                                                             // 0x000C (size: 0x2C)
    FSBStatusAilmentID BattleStatusID;                                                // 0x0038 (size: 0x8)
    FSBStatusAilmentHandle DataHandle;                                                // 0x0040 (size: 0x20)
    char padding_1[0x8];                                                              // 0x0060 (size: 0x8)
    class AActor* Causer;                                                             // 0x0068 (size: 0x8)

}; // Size: 0x70

struct FSBBattleStatusMaterialEffect
{
    FName MaterialParamName;                                                          // 0x0000 (size: 0x8)
    float SetValue;                                                                   // 0x0008 (size: 0x4)
    uint8 bIsSpawnOnlyInvoker;                                                        // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBBattleStatusParticleEffect
{
    TSoftObjectPtr<UParticleSystem> Particle;                                         // 0x0000 (size: 0x28)
    uint8 bIsAttach;                                                                  // 0x0028 (size: 0x1)
    uint8 bAbsoluteRotation;                                                          // 0x0028 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0029 (size: 0x3)
    TEnumAsByte<EEffectTarget> AttachTargetType;                                      // 0x002C (size: 0x1)
    char padding_1[0x3];                                                              // 0x002D (size: 0x3)
    FName AttachSocketName;                                                           // 0x0030 (size: 0x8)
    FName ActorParameterName;                                                         // 0x0038 (size: 0x8)
    uint8 bIsOutDestroy;                                                              // 0x0040 (size: 0x1)
    uint8 bIsAutoDestroy;                                                             // 0x0040 (size: 0x1)
    uint8 bIsSpawnOnlyInvoker;                                                        // 0x0040 (size: 0x1)
    uint8 bIsActorScalable;                                                           // 0x0040 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0041 (size: 0x3)
    ESBEffectVisibleType VisibleType;                                                 // 0x0044 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0045 (size: 0x3)
    uint8 bIsSourceActorInvoker;                                                      // 0x0048 (size: 0x1)
    char padding_4[0x7];                                                              // 0x0049 (size: 0x7)
    FAkEventVariables AkEvent;                                                        // 0x0050 (size: 0x40)

}; // Size: 0x90

struct FSBBattleStatusProjectile
{
    ESBStatusProjectileRequestCondition RequestCondition;                             // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FSBProjectileSelectHandle ProjectileSelectHandle;                                 // 0x0008 (size: 0x18)
    ESBStatusProjectileInvoker InvokerType;                                           // 0x0020 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0021 (size: 0x3)
    uint8 bIsAutoDestroy;                                                             // 0x0024 (size: 0x1)
    uint8 bIsBurstFinishProjectile;                                                   // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FSBBattleStatusProjectileConfig : public FTableRowBase
{
    uint8 bEnableIn;                                                                  // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TArray<FSBBattleStatusProjectile> Ins;                                            // 0x0010 (size: 0x10)
    uint8 bEnableOverride;                                                            // 0x0020 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0021 (size: 0x7)
    TArray<FSBBattleStatusProjectile> Overrides;                                      // 0x0028 (size: 0x10)
    uint8 bEnableInOrOverride;                                                        // 0x0038 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0039 (size: 0x7)
    TArray<FSBBattleStatusProjectile> InOrOverrides;                                  // 0x0040 (size: 0x10)
    uint8 bEnableOut;                                                                 // 0x0050 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0051 (size: 0x7)
    TArray<FSBBattleStatusProjectile> Outs;                                           // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FSBBattleStatusProjectileID
{
    FName ID;                                                                         // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBBattleStatusResistanceSetting
{
    ESBBattleStatusResistType BattleStatusType;                                       // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float ResistanceValue;                                                            // 0x0004 (size: 0x4)

}; // Size: 0xC

struct FSBBerserkerBerserkModeComboGaugeModifyDamageUpSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    bool ConsumeComboGaugeAllAndModeEnd;                                              // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    class UCurveFloat* DamageUpScaleCurve;                                            // 0x0018 (size: 0x8)
    float ConsumeComboGaugeRate;                                                      // 0x0020 (size: 0x4)
    float DamageUpRate;                                                               // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBBerserkerComboGaugeCastSetting
{
    TArray<FSBConditionCheckParam> ConditinoList;                                     // 0x0000 (size: 0x10)
    int32 ChangeRate;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBBerserkerComboGaugeHitSettings
{
    FSBAttackID AttackID;                                                             // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0008 (size: 0x10)
    float GaugeAmount;                                                                // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBBerserkerComboSettings
{
    float GaugeAmountMax;                                                             // 0x0000 (size: 0x4)
    float GaugeAmountByHit;                                                           // 0x0004 (size: 0x4)
    float GaugeAmountResetTime;                                                       // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBConditionCheckFloatParam> ComboGaugeModifySettingList;                  // 0x0010 (size: 0x10)
    TArray<FSBBerserkerComboGaugeHitSettings> ComboGaugeHitSettingsList;              // 0x0020 (size: 0x10)
    class UCurveFloat* DamageUpScaleCurve;                                            // 0x0030 (size: 0x8)
    TArray<FSBConditionCheckFloatParam> ComboGaugeMaxBonusModifySettingList;          // 0x0038 (size: 0x10)
    class UCurveFloat* SkillComboAddGauge;                                            // 0x0048 (size: 0x8)
    TArray<FSBBerserkerSkillComboEffectSettings> SkillComboEffectSettingList;         // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FSBBerserkerConsumeComboAttackSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float UseComboGaugeAmount;                                                        // 0x0010 (size: 0x4)
    float DamageModifyRate;                                                           // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBBerserkerPartyChainDrainSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    int32 PartyChainNum;                                                              // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FDataTableRowHandle StatusAlimentHandle;                                          // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBBerserkerSkillComboEffectSettings
{
    int32 ComboCount;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBEffectAsset> ComboCountUpEffectList;                                    // 0x0008 (size: 0x10)
    TArray<FSBEffectAsset> ComboKeepEffectList;                                       // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBBlasterBattleStatusSpreadSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    ESBBattleEffective Effective;                                                     // 0x0010 (size: 0x1)
    ESBBattleEffectiveGroup EffectiveGroup;                                           // 0x0011 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0012 (size: 0x6)
    FDataTableRowHandle RowHandle;                                                    // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBBlasterElementSpreadAccumulationSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float AccumulationRate;                                                           // 0x0010 (size: 0x4)
    float AccumulationMax;                                                            // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBBlasterElementSpreadProjectileSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    FDataTableRowHandle ElementSpreadProjectileHandle;                                // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBBlasterGaugeAmountAddSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float AddValue;                                                                   // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBBlasterGaugeAmountWeakPointHitMultiplierSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float MultiplierValue;                                                            // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBBlasterHatTrickSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    FDataTableRowHandle ComboShotProjectileHandle;                                    // 0x0010 (size: 0x10)
    FDataTableRowHandle LaunchMultiHitProjectileHandle;                               // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBBlasterHatTrickWeakPointHitDamageModifySetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float DamageModifyRate;                                                           // 0x0010 (size: 0x4)
    bool bNotWeakPointHit;                                                            // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FSBBlasterHitDistanceDamageModifySetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float DamageModifyRate;                                                           // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    TArray<FSBAttackID> AttackIDList;                                                 // 0x0018 (size: 0x10)
    float MinDistance;                                                                // 0x0028 (size: 0x4)
    float MaxDistance;                                                                // 0x002C (size: 0x4)
    bool bIncreaseDamageAtClose;                                                      // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBBlasterHoldingArrowEffectSetting : public FSBAnimTagEffectSetting
{
    char padding_0[0x1B8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x1B8

struct FSBBlasterSkillChargeLevelSetting : public FSBPlayerSkillChargeLevelSetting
{
    FSBBlasterHoldingArrowEffectSetting HoldArrowSetting;                             // 0x0050 (size: 0x1B8)

}; // Size: 0x208

struct FSBBlasterSkillChargeSetting : public FSBPlayerSkillChargeSettingBase
{
    TArray<FSBBlasterSkillChargeLevelSetting> LevelSettingList;                       // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBBlasterSpreadShotAreaModifySetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    int32 ModifyRate;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBBlasterWeakPointHitDamageUpSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float DamageUpRate;                                                               // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBBookMarkData
{
    bool bIsCustom;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString BookMark1;                                                                // 0x0008 (size: 0x10)
    FString BookMark2;                                                                // 0x0018 (size: 0x10)
    FString BookMark3;                                                                // 0x0028 (size: 0x10)
    FString BookMark4;                                                                // 0x0038 (size: 0x10)
    FString BookMark5;                                                                // 0x0048 (size: 0x10)
    FString BookMark6;                                                                // 0x0058 (size: 0x10)
    FString BookMark7;                                                                // 0x0068 (size: 0x10)
    FString BookMark8;                                                                // 0x0078 (size: 0x10)
    FString BookMark9;                                                                // 0x0088 (size: 0x10)
    FString BookMark10;                                                               // 0x0098 (size: 0x10)
    FString BookMark11;                                                               // 0x00A8 (size: 0x10)
    FString BookMark12;                                                               // 0x00B8 (size: 0x10)
    FString BookMark13;                                                               // 0x00C8 (size: 0x10)
    FString BookMark14;                                                               // 0x00D8 (size: 0x10)
    FString BookMark15;                                                               // 0x00E8 (size: 0x10)
    FString BookMark16;                                                               // 0x00F8 (size: 0x10)
    FString BookMark17;                                                               // 0x0108 (size: 0x10)
    FString BookMark18;                                                               // 0x0118 (size: 0x10)
    FString BookMark19;                                                               // 0x0128 (size: 0x10)
    FString BookMark20;                                                               // 0x0138 (size: 0x10)
    FString BookMark21;                                                               // 0x0148 (size: 0x10)
    FString BookMark22;                                                               // 0x0158 (size: 0x10)
    FString BookMark23;                                                               // 0x0168 (size: 0x10)
    FString BookMark24;                                                               // 0x0178 (size: 0x10)

}; // Size: 0x188

struct FSBBookMarkSaveData
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    TMap<class ESBClassType, class FSBBookMarkData> Data;                             // 0x0010 (size: 0x50)

}; // Size: 0x60

struct FSBBossBGMTableRow : public FTableRowBase
{
    FString Memo;                                                                     // 0x0008 (size: 0x10)
    TArray<FString> EnemyIDList;                                                      // 0x0018 (size: 0x10)
    bool IsMiddleBoss;                                                                // 0x0028 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0029 (size: 0x7)
    TArray<ESBBGMMapGameMode> BGMGameModeList;                                        // 0x0030 (size: 0x10)
    bool bIsUniqueBGM;                                                                // 0x0040 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0041 (size: 0x7)
    TArray<FSBDefaultBossBGMSettingData> DefaultSettingDataArray;                     // 0x0048 (size: 0x10)
    ESBResultBGMType DefaultResultBGMType;                                            // 0x0058 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0059 (size: 0x7)
    TArray<FSBUniqueBossBGMSettingData> UniqueSettingDataArray;                       // 0x0060 (size: 0x10)
    class UAkAudioEvent* UniqueResultBGMType;                                         // 0x0070 (size: 0x8)

}; // Size: 0x78

struct FSBBossWeakConditionCheck
{
    FName ConditionId;                                                                // 0x0000 (size: 0x8)
    float BossWeakRatio;                                                              // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBBuddyConditionalVoiceSettings : public FTableRowBase
{
    FName ConditionId;                                                                // 0x0008 (size: 0x8)
    FString SublevelId;                                                               // 0x0010 (size: 0x10)
    ESBConditionalVoicePriority Priority;                                             // 0x0020 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0021 (size: 0x3)
    float CancelTime;                                                                 // 0x0024 (size: 0x4)
    float Interval;                                                                   // 0x0028 (size: 0x4)
    ESBConditionalVoiceRequestType RequestType;                                       // 0x002C (size: 0x1)
    char padding_1[0x3];                                                              // 0x002D (size: 0x3)
    TArray<ESBBuddyType> Speakers;                                                    // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FSBBuddyEnemyIdData : public FTableRowBase
{
    FString EnemyId;                                                                  // 0x0008 (size: 0x10)
    ESBBuddyType BuddyType;                                                           // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBBuddyVoiceEventData
{
    bool IsCommon;                                                                    // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString MapId;                                                                    // 0x0008 (size: 0x10)
    bool IsDungeonNormal;                                                             // 0x0018 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0019 (size: 0x7)
    TSoftObjectPtr<UAkAudioEvent> Event;                                              // 0x0020 (size: 0x28)

}; // Size: 0x48

struct FSBBuddyVoiceEventTableRow : public FTableRowBase
{
    FName ConditionId;                                                                // 0x0008 (size: 0x8)
    TArray<FSBBuddyVoiceEventData> EventData;                                         // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBBulkGetItemProductItemInfo
{
    EItemType ItemType;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    int32 AddCount;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBBulkGetItemProductItemSetInfo : public FTableRowBase
{
    FText Name;                                                                       // 0x0008 (size: 0x18)
    FText Description;                                                                // 0x0020 (size: 0x18)
    FText Category;                                                                   // 0x0038 (size: 0x18)
    TArray<FSBBulkGetItemProductItemInfo> ProductItems;                               // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FSBBurderingDummyData
{
    uint8 DummyData;                                                                  // 0x0000 (size: 0x3E8)

}; // Size: 0x3E8

struct FSBCacheBonePosition
{
    FName SocketName;                                                                 // 0x0000 (size: 0x8)
    char padding_0[0x8];                                                              // 0x0008 (size: 0x8)
    FTransform Transform;                                                             // 0x0010 (size: 0x30)

}; // Size: 0x40

struct FSBCameraDistanceTransparentParam
{
    float Distance;                                                                   // 0x0000 (size: 0x4)
    float DistanceBuffer;                                                             // 0x0004 (size: 0x4)
    bool bIsCheckSokcet;                                                              // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBCameraShieldingTransparentParam
{
    float Distance;                                                                   // 0x0000 (size: 0x4)
    float DistanceBuffer;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBCameraZoomLevelCharacterData
{
    TMap<class FString, class FSBCameraZoomLevelDatas> CharacterZoomLevels;           // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSBCameraZoomLevelDatas
{
    TArray<FCameraZoomLevelParam> CameraZoomLevelParam;                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBCaptureStudioCharacterWeaponData
{
    TSoftObjectPtr<USkeletalMesh> WeaponMesh;                                         // 0x0000 (size: 0x28)
    FVector WeaponLocation;                                                           // 0x0028 (size: 0xC)
    FRotator Rotation;                                                                // 0x0034 (size: 0xC)
    FName SocketName;                                                                 // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBCaptureStudioImagineData : public FTableRowBase
{
    int32 ImagineId;                                                                  // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TSoftObjectPtr<USkeletalMesh> Mesh;                                               // 0x0010 (size: 0x28)
    TSoftObjectPtr<USBCharaCreateData> CharaCreate;                                   // 0x0038 (size: 0x28)
    TSoftObjectPtr<UAnimationAsset> Animation;                                        // 0x0060 (size: 0x28)
    FVector Location;                                                                 // 0x0088 (size: 0xC)
    FRotator Rotation;                                                                // 0x0094 (size: 0xC)
    float Scale;                                                                      // 0x00A0 (size: 0x4)
    char padding_1[0x4];                                                              // 0x00A4 (size: 0x4)
    TArray<FSBCaptureStudioCharacterWeaponData> Weapons;                              // 0x00A8 (size: 0x10)
    TArray<TSoftObjectPtr<UMaterialInterface>> OverrideMaterials;                     // 0x00B8 (size: 0x10)

}; // Size: 0xC8

struct FSBCashExchangeShopProductList
{
    FString ProductId;                                                                // 0x0000 (size: 0x10)
    int32 SellingPriceCash;                                                           // 0x0010 (size: 0x4)
    int32 SellingPricePaid;                                                           // 0x0014 (size: 0x4)
    int32 SellingPriceFree;                                                           // 0x0018 (size: 0x4)
    int32 SoldNumberLimit;                                                            // 0x001C (size: 0x4)
    FString SaleStartDate;                                                            // 0x0020 (size: 0x10)
    FString SaleEndDate;                                                              // 0x0030 (size: 0x10)
    int32 SortId;                                                                     // 0x0040 (size: 0x4)
    int32 Flags;                                                                      // 0x0044 (size: 0x4)
    FString ProductThumbnail;                                                         // 0x0048 (size: 0x10)
    FString ProductName;                                                              // 0x0058 (size: 0x10)
    FString ProductText;                                                              // 0x0068 (size: 0x10)
    FString ProductDetail;                                                            // 0x0078 (size: 0x10)
    FString OfficialComment;                                                          // 0x0088 (size: 0x10)

}; // Size: 0x98

struct FSBCashHistory
{
    FString UpdateType;                                                               // 0x0000 (size: 0x10)
    int32 PaidAmount;                                                                 // 0x0010 (size: 0x4)
    int32 FreeAmount;                                                                 // 0x0014 (size: 0x4)
    FString ActionType;                                                               // 0x0018 (size: 0x10)
    int32 ActionTypeTextId;                                                           // 0x0028 (size: 0x4)
    char padding_0[0x4];                                                              // 0x002C (size: 0x4)
    FString ReasonText;                                                               // 0x0030 (size: 0x10)
    FDateTime HistoryDate;                                                            // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBChangeCostumeData
{
    int32 storage_no;                                                                 // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)
    FString unique_id;                                                                // 0x0008 (size: 0x10)
    FCostumeData CostumeData;                                                         // 0x0018 (size: 0x20)

}; // Size: 0x38

struct FSBChangeItemAmountParam
{
    FString UniqueId;                                                                 // 0x0000 (size: 0x10)
    int32 StorageNumber;                                                              // 0x0010 (size: 0x4)
    int32 ItemIndex;                                                                  // 0x0014 (size: 0x4)
    EItemType ItemType;                                                               // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    int32 Amount;                                                                     // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBChangeLandingSecond
{
    float Distance;                                                                   // 0x0000 (size: 0x4)
    float Second;                                                                     // 0x0004 (size: 0x4)
    float MinSecond;                                                                  // 0x0008 (size: 0x4)
    float MaxSecond;                                                                  // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBChangeMaterialColorParam
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBCharaCreateBoneScaleGroupData
{
    FName GroupName;                                                                  // 0x0000 (size: 0x8)
    float DefaultSliderValue;                                                         // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBCharaCreateBoneScalePartsData> PartsList;                               // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBCharaCreateBoneScalePartsData
{
    ECharaCreateBoneScaleType ScaleType;                                              // 0x0000 (size: 0x1)
    ECharaCreateBoneScaleID BoneID;                                                   // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    float DefaultValue;                                                               // 0x0004 (size: 0x4)
    float MinValue;                                                                   // 0x0008 (size: 0x4)
    float MaxValue;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBCharaCreateColor
{
    bool IsValid;                                                                     // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName ColorName;                                                                  // 0x0004 (size: 0x8)
    FLinearColor BaseColor;                                                           // 0x000C (size: 0x10)
    int32 SaturationMin;                                                              // 0x001C (size: 0x4)
    int32 SaturationMax;                                                              // 0x0020 (size: 0x4)
    int32 ValueMin;                                                                   // 0x0024 (size: 0x4)
    int32 ValueMax;                                                                   // 0x0028 (size: 0x4)
    float SaturationPuls;                                                             // 0x002C (size: 0x4)
    float SaturationMinus;                                                            // 0x0030 (size: 0x4)
    float ValuePuls;                                                                  // 0x0034 (size: 0x4)
    float ValueMinus;                                                                 // 0x0038 (size: 0x4)

}; // Size: 0x3C

struct FSBCharaCreateColorHSV
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Saturation;                                                                 // 0x0004 (size: 0x4)
    int32 Value;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBCharaCreateColorSet
{
    FSBCharaCreateColor Color1;                                                       // 0x0008 (size: 0x3C)
    FSBCharaCreateColor Color2;                                                       // 0x0044 (size: 0x3C)
    FSBCharaCreateColor Color3;                                                       // 0x0080 (size: 0x3C)
    FSBCharaCreateColor Color4;                                                       // 0x00BC (size: 0x3C)

}; // Size: 0xF8

struct FSBCharaCreateColorSetV6 : public FSBCharaCreateColorSet
{
    FSBCharaCreateColor Color5;                                                       // 0x00F8 (size: 0x3C)
    FSBCharaCreateColor Color6;                                                       // 0x0134 (size: 0x3C)

}; // Size: 0x170

struct FSBCharaCreateComponentPostPhysicsTickFunction : public FTickFunction
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

struct FSBCharaCreateCrtBoneData
{
    ECharaPartsCrtLocation CrtLocation;                                               // 0x0000 (size: 0x1)
    ECharaPartsCrtBone CrtBoneID;                                                     // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    float Scale;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBCharaCreateDataInfo : public FTableRowBase
{
    TSoftObjectPtr<USBCharaCreateData> CharaCreateData;                               // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBCharaCreateDebugInfoPartsNameAndPartsData
{
    ECharaPartsLocation CharaPartsLocation;                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName PartsName;                                                                  // 0x0004 (size: 0x8)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    class UCharaPartsData* CharaPartsData;                                            // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBCharaCreateMakeup
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    bool Mirror;                                                                      // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FSBCharaCreateColorHSV Color;                                                     // 0x0008 (size: 0xC)

}; // Size: 0x14

struct FSBCharaCreateMole
{
    bool IsOn;                                                                        // 0x0000 (size: 0x1)
    bool IsMirror;                                                                    // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FSBCharaCreateMoleDataTable
{
    TArray<FSBCharaCreateMole> MoleDatas;                                             // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBCharaCreateParameter
{
    ECharaPartsCharacterType CharacterType;                                           // 0x0000 (size: 0x1)
    ESBCharacterGender Gender;                                                        // 0x0001 (size: 0x1)
    ECharaPartsBody BodyType;                                                         // 0x0002 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0003 (size: 0x1)
    int32 FaceType;                                                                   // 0x0004 (size: 0x4)
    int32 VoiceId;                                                                    // 0x0008 (size: 0x4)
    ENpcJob JobType;                                                                  // 0x000C (size: 0x1)
    ECharaPartsRegion Region;                                                         // 0x000D (size: 0x1)
    char padding_1[0x2];                                                              // 0x000E (size: 0x2)
    FName BodyName;                                                                   // 0x0010 (size: 0x8)
    FSBCharaCreateColorHSV BodyColor;                                                 // 0x0018 (size: 0xC)
    int32 BodyMaterial;                                                               // 0x0024 (size: 0x4)
    FName FaceName;                                                                   // 0x0028 (size: 0x8)
    FSBCharaCreateColorHSV FaceColor;                                                 // 0x0030 (size: 0xC)
    int32 FaceMaterial;                                                               // 0x003C (size: 0x4)
    int32 SkinColorID;                                                                // 0x0040 (size: 0x4)
    FSBCharaCreateColorHSV SkinColor;                                                 // 0x0044 (size: 0xC)
    bool bHairHatOption;                                                              // 0x0050 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0051 (size: 0x3)
    FName HairName;                                                                   // 0x0054 (size: 0x8)
    FSBCharaCreateColorHSV HairCostumeColor;                                          // 0x005C (size: 0xC)
    FSBCharaCreateColorHSV HairColor1;                                                // 0x0068 (size: 0xC)
    FSBCharaCreateColorHSV HairColor2;                                                // 0x0074 (size: 0xC)
    FSBCharaCreateColorHSV HairColor3;                                                // 0x0080 (size: 0xC)
    FLinearColor HairMeshSwitch;                                                      // 0x008C (size: 0x10)
    int32 HairGradationType;                                                          // 0x009C (size: 0x4)
    int32 EyelashColorValue;                                                          // 0x00A0 (size: 0x4)
    int32 EyelashColorIndex;                                                          // 0x00A4 (size: 0x4)
    int32 BrowColorValue;                                                             // 0x00A8 (size: 0x4)
    int32 BrowColorIndex;                                                             // 0x00AC (size: 0x4)
    int32 BeardColorIndex;                                                            // 0x00B0 (size: 0x4)
    bool bHairMirror;                                                                 // 0x00B4 (size: 0x1)
    char padding_3[0x3];                                                              // 0x00B5 (size: 0x3)
    FName UpperName;                                                                  // 0x00B8 (size: 0x8)
    FSBCharaCreateColorHSV UpperColor;                                                // 0x00C0 (size: 0xC)
    int32 UpperMaterial;                                                              // 0x00CC (size: 0x4)
    FName LowerName;                                                                  // 0x00D0 (size: 0x8)
    FSBCharaCreateColorHSV LowerColor;                                                // 0x00D8 (size: 0xC)
    int32 LowerMaterial;                                                              // 0x00E4 (size: 0x4)
    FName GlovesName;                                                                 // 0x00E8 (size: 0x8)
    FSBCharaCreateColorHSV GlovesColor;                                               // 0x00F0 (size: 0xC)
    int32 GlovesMaterial;                                                             // 0x00FC (size: 0x4)
    FName ShoesName;                                                                  // 0x0100 (size: 0x8)
    FSBCharaCreateColorHSV ShoesColor;                                                // 0x0108 (size: 0xC)
    int32 ShoesMaterial;                                                              // 0x0114 (size: 0x4)
    FName HatName;                                                                    // 0x0118 (size: 0x8)
    FSBCharaCreateColorHSV HatColor;                                                  // 0x0120 (size: 0xC)
    int32 HatMaterial;                                                                // 0x012C (size: 0x4)
    FName Accessory1Name;                                                             // 0x0130 (size: 0x8)
    FSBCharaCreateColorHSV Accessory1Color;                                           // 0x0138 (size: 0xC)
    FName Accessory2Name;                                                             // 0x0144 (size: 0x8)
    FSBCharaCreateColorHSV Accessory2Color;                                           // 0x014C (size: 0xC)
    FName Accessory3Name;                                                             // 0x0158 (size: 0x8)
    FSBCharaCreateColorHSV Accessory3Color;                                           // 0x0160 (size: 0xC)
    FName UnderwearName;                                                              // 0x016C (size: 0x8)
    FSBCharaCreateColorHSV UnderwearColor;                                            // 0x0174 (size: 0xC)
    int32 UnderwearMaterial;                                                          // 0x0180 (size: 0x4)
    FName UnderwearUpperName;                                                         // 0x0184 (size: 0x8)
    FSBCharaCreateColorHSV UnderwearUpperColor;                                       // 0x018C (size: 0xC)
    int32 UnderwearUpperMaterial;                                                     // 0x0198 (size: 0x4)
    ECharaPartsAccessoryLocation Accessory1CustomLocation;                            // 0x019C (size: 0x1)
    ECharaPartsAccessoryLocation Accessory2CustomLocation;                            // 0x019D (size: 0x1)
    ECharaPartsAccessoryLocation Accessory3CustomLocation;                            // 0x019E (size: 0x1)
    char padding_4[0x1];                                                              // 0x019F (size: 0x1)
    FName EyeName;                                                                    // 0x01A0 (size: 0x8)
    FName BrowName;                                                                   // 0x01A8 (size: 0x8)
    FName MouthName;                                                                  // 0x01B0 (size: 0x8)
    FName NoseName;                                                                   // 0x01B8 (size: 0x8)
    FName LineName;                                                                   // 0x01C0 (size: 0x8)
    FName BeardName;                                                                  // 0x01C8 (size: 0x8)
    FName BackOfHeadName;                                                             // 0x01D0 (size: 0x8)
    FName AccessoryHeadTopName;                                                       // 0x01D8 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryHeadTopColor;                                     // 0x01E0 (size: 0xC)
    int32 AccessoryHeadTopMaterial;                                                   // 0x01EC (size: 0x4)
    FName AccessoryHeadMidName;                                                       // 0x01F0 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryHeadMidColor;                                     // 0x01F8 (size: 0xC)
    int32 AccessoryHeadMidMaterial;                                                   // 0x0204 (size: 0x4)
    FName AccessoryHeadLowName;                                                       // 0x0208 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryHeadLowColor;                                     // 0x0210 (size: 0xC)
    int32 AccessoryHeadLowMaterial;                                                   // 0x021C (size: 0x4)
    FName AccessoryHeadEarName;                                                       // 0x0220 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryHeadEarColor;                                     // 0x0228 (size: 0xC)
    int32 AccessoryHeadEarMaterial;                                                   // 0x0234 (size: 0x4)
    FName AccessoryFingerName;                                                        // 0x0238 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryFingerColor;                                      // 0x0240 (size: 0xC)
    int32 AccessoryFingerMaterial;                                                    // 0x024C (size: 0x4)
    FName AccessoryLeftFingerName;                                                    // 0x0250 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryLeftFingerColor;                                  // 0x0258 (size: 0xC)
    int32 AccessoryLeftFingerMaterial;                                                // 0x0264 (size: 0x4)
    FName AccessoryEngagementName;                                                    // 0x0268 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryEngagementColor;                                  // 0x0270 (size: 0xC)
    int32 AccessoryEngagementMaterial;                                                // 0x027C (size: 0x4)
    FName AccessoryBodyBackName;                                                      // 0x0280 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryBodyBackColor;                                    // 0x0288 (size: 0xC)
    int32 AccessoryBodyBackMaterial;                                                  // 0x0294 (size: 0x4)
    FName AccessoryHipBackName;                                                       // 0x0298 (size: 0x8)
    FSBCharaCreateColorHSV AccessoryHipBackColor;                                     // 0x02A0 (size: 0xC)
    int32 AccessoryHipBackMaterial;                                                   // 0x02AC (size: 0x4)
    bool bIsMouthSpecular;                                                            // 0x02B0 (size: 0x1)
    bool bIsOddEye;                                                                   // 0x02B1 (size: 0x1)
    char padding_5[0x2];                                                              // 0x02B2 (size: 0x2)
    int32 EyeLeftIrisID;                                                              // 0x02B4 (size: 0x4)
    int32 EyeRightIrisID;                                                             // 0x02B8 (size: 0x4)
    FSBCharaCreateColorHSV EyeLeftColor1;                                             // 0x02BC (size: 0xC)
    FSBCharaCreateColorHSV EyeLeftColor2;                                             // 0x02C8 (size: 0xC)
    FSBCharaCreateColorHSV EyeLeftColor3;                                             // 0x02D4 (size: 0xC)
    FSBCharaCreateColorHSV EyeLeftColor4;                                             // 0x02E0 (size: 0xC)
    FSBCharaCreateColorHSV EyeRightColor1;                                            // 0x02EC (size: 0xC)
    FSBCharaCreateColorHSV EyeRightColor2;                                            // 0x02F8 (size: 0xC)
    FSBCharaCreateColorHSV EyeRightColor3;                                            // 0x0304 (size: 0xC)
    FSBCharaCreateColorHSV EyeRightColor4;                                            // 0x0310 (size: 0xC)
    FSBCharaCreateMakeup MakeupCondition;                                             // 0x031C (size: 0x14)
    FSBCharaCreateMakeup MakeupLip;                                                   // 0x0330 (size: 0x14)
    FSBCharaCreateMakeup MakeupPaint1;                                                // 0x0344 (size: 0x14)
    FSBCharaCreateMakeup MakeupPaint2;                                                // 0x0358 (size: 0x14)
    char padding_6[0x4];                                                              // 0x036C (size: 0x4)
    FSBCharaCreateMoleDataTable MakeupMole;                                           // 0x0370 (size: 0x10)
    float EyebrowAngle;                                                               // 0x0380 (size: 0x4)
    float EyeAngle;                                                                   // 0x0384 (size: 0x4)
    int32 EyelashTextureIndex;                                                        // 0x0388 (size: 0x4)
    float HairGradationHeight;                                                        // 0x038C (size: 0x4)
    float HairGradationRange;                                                         // 0x0390 (size: 0x4)
    char padding_7[0x4];                                                              // 0x0394 (size: 0x4)
    TArray<float> SliderValue;                                                        // 0x0398 (size: 0x10)
    int32 HatItemID;                                                                  // 0x03A8 (size: 0x4)
    int32 UpperItemID;                                                                // 0x03AC (size: 0x4)
    int32 LowerItemID;                                                                // 0x03B0 (size: 0x4)
    int32 GlovesItemID;                                                               // 0x03B4 (size: 0x4)
    int32 ShoesItemID;                                                                // 0x03B8 (size: 0x4)
    int32 UnderwearItemID;                                                            // 0x03BC (size: 0x4)

}; // Size: 0x3C0

struct FSBCharaCreatePartsIconIdData
{
    FString FaceIconId;                                                               // 0x0000 (size: 0x10)
    FString HairIconId;                                                               // 0x0010 (size: 0x10)
    FString EyeIconId;                                                                // 0x0020 (size: 0x10)
    FString EyeBrowIconId;                                                            // 0x0030 (size: 0x10)
    FString EyeLashIconId;                                                            // 0x0040 (size: 0x10)
    FString LeftEyeIrisIconId;                                                        // 0x0050 (size: 0x10)
    FString RightEyeIrisIconId;                                                       // 0x0060 (size: 0x10)
    FString NoseIconId;                                                               // 0x0070 (size: 0x10)
    FString MouthIconId;                                                              // 0x0080 (size: 0x10)
    FString FaceLineIconId;                                                           // 0x0090 (size: 0x10)
    FString MakeupConditionIconId;                                                    // 0x00A0 (size: 0x10)
    FString MakeupLipIconId;                                                          // 0x00B0 (size: 0x10)
    FString MakeupPaint1IconId;                                                       // 0x00C0 (size: 0x10)
    FString MakeupPaint2IconId;                                                       // 0x00D0 (size: 0x10)
    FString BeardIconId;                                                              // 0x00E0 (size: 0x10)
    FString HairGradationTypeIconId;                                                  // 0x00F0 (size: 0x10)

}; // Size: 0x100

struct FSBCharaCreatePartsSettings
{
    TArray<class UObject*> HoldAssetArray;                                            // 0x0050 (size: 0x10)
    char padding_0[0x48];                                                             // 0x0060 (size: 0x48)
    class UCharaPartsData* PartsData;                                                 // 0x00A8 (size: 0x8)

}; // Size: 0xC0

struct FSBCharaCreateSlider
{
    float Height;                                                                     // 0x0000 (size: 0x4)
    float Physique;                                                                   // 0x0004 (size: 0x4)
    float Bust;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBCharaCreateTweakColorOffset
{
    float SaturationScale;                                                            // 0x0000 (size: 0x4)
    float ValueScale;                                                                 // 0x0004 (size: 0x4)
    float SaturationOffset;                                                           // 0x0008 (size: 0x4)
    float ValueOffset;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBCharaPartsData : public FTableRowBase
{
    bool bForceAddCharaCreateViewerList;                                              // 0x0008 (size: 0x1)
    bool bRandomCreation;                                                             // 0x0009 (size: 0x1)
    ECharaPartsLocation PartsLocation;                                                // 0x000A (size: 0x1)
    char padding_0[0x5];                                                              // 0x000B (size: 0x5)
    class UCharaPartsData* M000;                                                      // 0x0010 (size: 0x8)
    class UCharaPartsData* M100;                                                      // 0x0018 (size: 0x8)
    class UCharaPartsData* M200;                                                      // 0x0020 (size: 0x8)
    class UCharaPartsData* M300;                                                      // 0x0028 (size: 0x8)
    class UCharaPartsData* M400;                                                      // 0x0030 (size: 0x8)
    class UCharaPartsData* M500;                                                      // 0x0038 (size: 0x8)
    class UCharaPartsData* F000;                                                      // 0x0040 (size: 0x8)
    class UCharaPartsData* F100;                                                      // 0x0048 (size: 0x8)
    class UCharaPartsData* F200;                                                      // 0x0050 (size: 0x8)
    class UCharaPartsData* F300;                                                      // 0x0058 (size: 0x8)
    class UCharaPartsData* F400;                                                      // 0x0060 (size: 0x8)
    class UCharaPartsData* F500;                                                      // 0x0068 (size: 0x8)

}; // Size: 0x70

struct FSBCharaPartsMobData : public FSBCharaPartsData
{
    ENpcJob PartsJob;                                                                 // 0x0070 (size: 0x1)
    ECharaPartsAgeGroup AgeGroup;                                                     // 0x0071 (size: 0x1)
    ECharaPartsRegion Region;                                                         // 0x0072 (size: 0x1)

}; // Size: 0x78

struct FSBCharacterAchievementDataInfo
{
    int32 AchievementId;                                                              // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDateTime Date;                                                                   // 0x0008 (size: 0x8)
    int32 Progress;                                                                   // 0x0010 (size: 0x4)
    bool IsRecievedReward;                                                            // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FSBCharacterAdjustRootMotionSettings_AdjustVelocity
{
    ESBAdjustRootMotionAdjustType AdjustType;                                         // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FSBCharacterAdjustRootMotionSettings_Facing
{
    float FacingRotationRate;                                                         // 0x0000 (size: 0x4)
    ESBCharacterAdjustRootMotion_Facing_RotationType RotationType;                    // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBCharacterAdjustRootMotionSettings_Following
{
    float FollowTime;                                                                 // 0x0000 (size: 0x4)
    float FollowVelocity;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBCharacterAdjustRootMotionSettings_TargetLocation
{
    ESBAdjustRootMotionTargetType TargetType;                                         // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float TargetDistanceRatio;                                                        // 0x0004 (size: 0x4)
    float TargetLocationOffsetZ;                                                      // 0x0008 (size: 0x4)
    float RequiredStartLocationOffsetZ;                                               // 0x000C (size: 0x4)
    float TraceTargetBelowHeight;                                                     // 0x0010 (size: 0x4)
    float AdjustRangeMin;                                                             // 0x0014 (size: 0x4)
    float AdjustRangeMax;                                                             // 0x0018 (size: 0x4)
    float YawAngleMax;                                                                // 0x001C (size: 0x4)
    float PitchAngleMax;                                                              // 0x0020 (size: 0x4)
    ESBAdjustRootMotionZAxisMode ZAxisMode;                                           // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FSBCharacterAdjustRootMotionSetupPicker
{
    TScriptInterface<class ISBCharacterAdjustRootMotionSetupInterface> TargetSetupInterface; // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBCharacterAnimInstanceProxy : public FASAnimInstanceProxy
{
    char padding_0[0x830];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x830

struct FSBCharacterAnimationSamplingActor_AttackRangeSettings
{
    char padding_0[0xC];                                                              // 0x0000 (size: 0x0)
}; // Size: 0xC

struct FSBCharacterAnimationSamplingOverrideActionData
{
    FSBAIAttackableArea OverrideAttackableArea;                                       // 0x0000 (size: 0x24)

}; // Size: 0x24

struct FSBCharacterAnimationSamplingResult
{
    TMap<class FName, class FSBCharacterAnimationSamplingResultActionData> ActionGroupMap; // 0x0000 (size: 0x50)
    TMap<class FName, class FSBCharacterAnimationSamplingOverrideActionData> OverrideActionDataMap; // 0x0050 (size: 0x50)
    TMap<class FName, class FSBCharacterAnimationSamplingResultActionGroup> ActionDataGroupMap; // 0x00A0 (size: 0x50)
    TMap<class FName, class FSBCharacterAnimationSamplingResultAnimationSequenceGroup> AnimationSequenceGroupMap; // 0x00F0 (size: 0x50)
    TMap<class FName, class FSBCharacterAnimationSamplingResultAnimationSocketOrBoneGroup> SocketOrBoneInfoMap; // 0x0140 (size: 0x50)

}; // Size: 0x190

struct FSBCharacterAnimationSamplingResultActionData
{
    TArray<FSBCharacterAnimationSamplingResultAttackInfo> AttackInfos;                // 0x0000 (size: 0x10)
    TArray<FName> UseAnimationAssetPath;                                              // 0x0010 (size: 0x10)
    float AnimTime;                                                                   // 0x0020 (size: 0x4)
    FSBCharacterLocationAndRotation LocationAndRotation;                              // 0x0024 (size: 0x18)
    char padding_0[0x4];                                                              // 0x003C (size: 0x4)
    TArray<FSBCharacterAnimationSamplingResultAdjustRootMotion> AdjustRootMotionInfoArray; // 0x0040 (size: 0x10)
    TArray<FSBCharacterAnimationSamplingResultFaceTarget> FaceTargetInfoArray;        // 0x0050 (size: 0x10)
    float ProjectileRange;                                                            // 0x0060 (size: 0x4)

}; // Size: 0x68

struct FSBCharacterAnimationSamplingResultActionDerivationInfo
{
    FSBCharacterAnimationSamplingResultActionDerivationKey Key;                       // 0x0000 (size: 0x18)
    FSBCharacterAnimationSamplingResultActionData ActionData;                         // 0x0018 (size: 0x68)

}; // Size: 0x80

struct FSBCharacterAnimationSamplingResultActionDerivationKey
{
    ESBCharacterAnimationSamplingResultActionDerivedType Type;                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float ThresholdVelocity;                                                          // 0x0004 (size: 0x4)
    TArray<FName> CommandArray;                                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBCharacterAnimationSamplingResultActionGroup
{
    TArray<FSBCharacterAnimationSamplingResultActionDerivationInfo> ActionDerivationArray; // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBCharacterAnimationSamplingResultAdjustRootMotion
{
    FName AnimSequenceName;                                                           // 0x0000 (size: 0x8)
    FName NotifyName;                                                                 // 0x0008 (size: 0x8)
    float BeginNotifyTime;                                                            // 0x0010 (size: 0x4)
    char padding_0[0xC];                                                              // 0x0014 (size: 0xC)
    FTransform BeginNotifyTransform;                                                  // 0x0020 (size: 0x30)
    float EndNotifyTime;                                                              // 0x0050 (size: 0x4)
    char padding_1[0xC];                                                              // 0x0054 (size: 0xC)
    FTransform EndNotifyTransform;                                                    // 0x0060 (size: 0x30)
    FSBAdjustRootMotionSettings Settings;                                             // 0x0090 (size: 0xC0)

}; // Size: 0x150

struct FSBCharacterAnimationSamplingResultAnimNotifyStateGroup
{
    float BeginNotifyTime;                                                            // 0x0000 (size: 0x4)
    float EndNotifyTime;                                                              // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBCharacterAnimationSamplingResultAnimationSequenceGroup
{
    TMap<class FName, class FSBCharacterAnimationSamplingResultAnimNotifyStateGroup> NotifyStateGroupMap; // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSBCharacterAnimationSamplingResultAnimationSocketOrBoneGroup
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    uint8 bBone;                                                                      // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBCharacterAnimationSamplingResultAttackInfo
{
    FName AnimSequenceName;                                                           // 0x0000 (size: 0x8)
    FName NotifyName;                                                                 // 0x0008 (size: 0x8)
    FSBCharacterAnimationSamplingResultAttackRange AttackRange;                       // 0x0010 (size: 0x1C)
    float HomingRange;                                                                // 0x002C (size: 0x4)
    bool bUseManualSettingAttackRangeWithAdjustRootMotion;                            // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    FSBCharacterAnimationSamplingResultAttackRange AttackRangeWithAdjustRootMotion;   // 0x0034 (size: 0x1C)
    FSBCharacterAnimationSamplingResultAttackRangePitchAngle AttackRangePitchAngle;   // 0x0050 (size: 0x8)
    bool bUseManualSettingAttackRangePitchAngle;                                      // 0x0058 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0059 (size: 0x3)
    FSBCharacterAnimationSamplingResultAttackRangePitchAngle ManualSettingAttackRangePitchAngle; // 0x005C (size: 0x8)
    float BeginAttackTime;                                                            // 0x0064 (size: 0x4)
    FVector BeginAttackLocation;                                                      // 0x0068 (size: 0xC)
    float EndAttackTime;                                                              // 0x0074 (size: 0x4)
    FVector EndAttackLocation;                                                        // 0x0078 (size: 0xC)

}; // Size: 0x84

struct FSBCharacterAnimationSamplingResultAttackRange
{
    float LeftAngle;                                                                  // 0x0000 (size: 0x4)
    float RightAngle;                                                                 // 0x0004 (size: 0x4)
    float MinRange;                                                                   // 0x0008 (size: 0x4)
    float MaxRange;                                                                   // 0x000C (size: 0x4)
    FVector Offset;                                                                   // 0x0010 (size: 0xC)

}; // Size: 0x1C

struct FSBCharacterAnimationSamplingResultAttackRangePitchAngle
{
    float UpperAngle;                                                                 // 0x0000 (size: 0x4)
    float LowerAngle;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBCharacterAnimationSamplingResultFaceTarget
{
    FName AnimSequenceName;                                                           // 0x0000 (size: 0x8)
    FName NotifyName;                                                                 // 0x0008 (size: 0x8)
    float BeginNotifyTime;                                                            // 0x0010 (size: 0x4)
    float EndNotifyTime;                                                              // 0x0014 (size: 0x4)
    float YawOffset;                                                                  // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBCharacterAnimationSamplingSimulateActionInfo
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBCharacterBanFinishedTimeInfos
{
    int32 Day;                                                                        // 0x0000 (size: 0x4)
    int32 Hour;                                                                       // 0x0004 (size: 0x4)
    int32 Minute;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBCharacterChanceTimeTableElementalBurst
{
    TMap<ESBAttribute, float> ChanceTimeMap;                                          // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSBCharacterChanceTimeTablePartsBreak
{
    TMap<FName, float> ChanceTimeMap;                                                 // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSBCharacterHisotroyForKPI
{
    char padding_0[0x14];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x14

struct FSBCharacterImagineData
{
    int32 PerkId;                                                                     // 0x0000 (size: 0x4)
    bool IsTermLimited;                                                               // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FDateTime ExpiryDateTime;                                                         // 0x0008 (size: 0x8)
    int32 StackBNum;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBCharacterLocationAndRotation
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    FRotator Rotation;                                                                // 0x000C (size: 0xC)

}; // Size: 0x18

struct FSBCharacterMisc
{
    int32 Money;                                                                      // 0x0000 (size: 0x4)
    int32 AdventurerRank;                                                             // 0x0004 (size: 0x4)
    FSBKeyPairList KeyValues;                                                         // 0x0008 (size: 0x10)
    FCharaEquipInfo EquipInfo;                                                        // 0x0018 (size: 0x10)
    FEquipedArtsListInfo EquipedArtsListInfo;                                         // 0x0028 (size: 0x10)
    FShortcutInfo ShortcutInfo;                                                       // 0x0038 (size: 0x10)
    FString Name;                                                                     // 0x0048 (size: 0x10)
    ESBClassType Role;                                                                // 0x0058 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0059 (size: 0x3)
    int32 TensionTag;                                                                 // 0x005C (size: 0x4)
    FString Comment;                                                                  // 0x0060 (size: 0x10)
    FSBCharacterQuestSetting QuestSetting;                                            // 0x0070 (size: 0x38)
    FMapPinListInfo MapPinInfoList;                                                   // 0x00A8 (size: 0x18)
    int32 AchievementSelected;                                                        // 0x00C0 (size: 0x4)
    int32 MissionQuestRank;                                                           // 0x00C4 (size: 0x4)
    bool OpenCommandMenuFlag;                                                         // 0x00C8 (size: 0x1)
    char padding_1[0x7];                                                              // 0x00C9 (size: 0x7)
    TArray<FCharaSkillMasteryInfo> CharaSkillMasteryInfoList;                         // 0x00D0 (size: 0x10)
    TArray<FCharaSkillMasteryInfo> CharaSkillMasteryOthersInfoList;                   // 0x00E0 (size: 0x10)
    TArray<ESBClassType> CharaSkillMasteryOthersInfoLoadClassList;                    // 0x00F0 (size: 0x10)
    TArray<FCharaClassInfo> CharaClassInfoList;                                       // 0x0100 (size: 0x10)
    char padding_2[0x20];                                                             // 0x0110 (size: 0x20)
    TArray<FSBCharacterToken> CharacterTokenList;                                     // 0x0130 (size: 0x10)
    TArray<FString> TraversedList;                                                    // 0x0140 (size: 0x10)
    TArray<FString> MyBlackList;                                                      // 0x0150 (size: 0x10)
    TArray<FString> MyPlatformBlackList;                                              // 0x0160 (size: 0x10)
    FName LastTravelCityId;                                                           // 0x0170 (size: 0x8)
    FString MountingImagineId;                                                        // 0x0178 (size: 0x10)
    int32 CommandMenuPlayerAvatarPoseId;                                              // 0x0188 (size: 0x4)
    ESBBanType BanType;                                                               // 0x018C (size: 0x1)
    char padding_3[0x3];                                                              // 0x018D (size: 0x3)
    float MountEnergy;                                                                // 0x0190 (size: 0x4)
    int32 RoseOrbPaid;                                                                // 0x0194 (size: 0x4)
    int32 RoseOrbFree;                                                                // 0x0198 (size: 0x4)
    int32 BPPoint;                                                                    // 0x019C (size: 0x4)
    int32 SeasonPoint;                                                                // 0x01A0 (size: 0x4)
    char padding_4[0x4];                                                              // 0x01A4 (size: 0x4)
    FString BestScore;                                                                // 0x01A8 (size: 0x10)
    FString SendRestrictionTime;                                                      // 0x01B8 (size: 0x10)
    FDateTime ExpiredTimeRoseOrbPaid;                                                 // 0x01C8 (size: 0x8)
    FDateTime ExpiredTimeRoseOrbFree;                                                 // 0x01D0 (size: 0x8)
    FDateTime ExpiredTimeBPPoint;                                                     // 0x01D8 (size: 0x8)

}; // Size: 0x1E0

struct FSBCharacterMountImagineData
{
    FString UniqueId;                                                                 // 0x0000 (size: 0x10)
    int32 ImagineId;                                                                  // 0x0010 (size: 0x4)
    bool IsTermLimited;                                                               // 0x0014 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0015 (size: 0x3)
    FDateTime ExpiryDateTime;                                                         // 0x0018 (size: 0x8)
    int32 StackBNum;                                                                  // 0x0020 (size: 0x4)
    bool UseFang_expedition;                                                          // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FSBCharacterNotification
{
    int32 Type;                                                                       // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString Body;                                                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBCharacterProfileData : public FTableRowBase
{
    FName ProfileId;                                                                  // 0x0008 (size: 0x8)
    ESBFacilityType FacilityType;                                                     // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    TArray<FSBCharacterProfileLocationData> Locations;                                // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBCharacterProfileLocationData
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    FName GameContentId;                                                              // 0x0008 (size: 0x8)
    FName RouteGuideGameContentId;                                                    // 0x0010 (size: 0x8)
    FVector WorldLocation;                                                            // 0x0018 (size: 0xC)
    FVector MapLocation;                                                              // 0x0024 (size: 0xC)
    ESBRouteGuideArea RouteGuideArea;                                                 // 0x0030 (size: 0x1)
    bool bDisableShowIconOnMap;                                                       // 0x0031 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0032 (size: 0x6)
    FString EventTermId;                                                              // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBCharacterQuestSetting
{
    TArray<int32> CheckList;                                                          // 0x0000 (size: 0x10)
    TArray<FSBCharacterStepListInfo> StepList;                                        // 0x0010 (size: 0x10)
    bool IsUpdateStepList;                                                            // 0x0020 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0021 (size: 0x7)
    TArray<FSBStepListTargetEnemyData> TargetEnemyIdList;                             // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBCharacterReadedData
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    TMap<TEnumAsByte<ENewMarkContentType::Type>, FReadedMarkData> Data;               // 0x0010 (size: 0x50)

}; // Size: 0x60

struct FSBCharacterShortcutInfos
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    TArray<FShortcutInfo> ShortcutInfo;                                               // 0x0010 (size: 0x10)
    int32 SlotNo;                                                                     // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBCharacterSlotPurchase
{
    int32 CharacterSlot;                                                              // 0x0000 (size: 0x4)
    int32 PurchaseAmount;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBCharacterStatus
{
    int32 STR;                                                                        // 0x0000 (size: 0x4)
    int32 VIT;                                                                        // 0x0004 (size: 0x4)
    int32 DEX;                                                                        // 0x0008 (size: 0x4)
    int32 INT;                                                                        // 0x000C (size: 0x4)
    int32 MND;                                                                        // 0x0010 (size: 0x4)
    int32 AttackPower;                                                                // 0x0014 (size: 0x4)
    int32 DefensePower;                                                               // 0x0018 (size: 0x4)
    int32 RecoveryPower;                                                              // 0x001C (size: 0x4)
    int32 CriticalRate;                                                               // 0x0020 (size: 0x4)
    int32 CriticalPower;                                                              // 0x0024 (size: 0x4)
    int32 Level;                                                                      // 0x0028 (size: 0x4)
    int32 HitPoint;                                                                   // 0x002C (size: 0x4)
    int32 MaxHitPoint;                                                                // 0x0030 (size: 0x4)
    int32 MaxStamina;                                                                 // 0x0034 (size: 0x4)
    int32 PassiveSkillCost;                                                           // 0x0038 (size: 0x4)
    int32 ImagineSkillCost;                                                           // 0x003C (size: 0x4)

}; // Size: 0x40

struct FSBCharacterStepListInfo
{
    ESBCharacterStepListType Type;                                                    // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ID;                                                                         // 0x0004 (size: 0x4)
    FString StringId;                                                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBCharacterSystemParam : public FTableRowBase
{
    float ATTACK_POWER_COEFFICIENT_A;                                                 // 0x0008 (size: 0x4)
    float ATTACK_POWER_COEFFICIENT_B;                                                 // 0x000C (size: 0x4)
    float DEFENSE_POWER_COEFFICIENT;                                                  // 0x0010 (size: 0x4)
    float HEAL_ACTION_COEFFICIENT;                                                    // 0x0014 (size: 0x4)
    float FLUCTUATION_MIN;                                                            // 0x0018 (size: 0x4)
    float FLUCTUATION_MAX;                                                            // 0x001C (size: 0x4)
    float WEAK_POINT_SCALE;                                                           // 0x0020 (size: 0x4)
    float ELEMENT_DAMAGE_SCALE_WEAPON_COEFFICIENT;                                    // 0x0024 (size: 0x4)
    float ELEMENT_DAMAGE_SCALE_ATTACKACTION_COEFFICIENT;                              // 0x0028 (size: 0x4)
    float ELEMENT_ACCUM_SCALE_WEAPON_COEFFICIENT;                                     // 0x002C (size: 0x4)
    float ELEMENT_ACCUM_SCALE_ATTACKACTION_COEFFICIENT;                               // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBCharacterToken
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    bool IsUser;                                                                      // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 Amount;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBCharacterWeaponPerkData
{
    int32 PerkId;                                                                     // 0x0000 (size: 0x4)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    FSBCharacterWeaponPerkValues Values;                                              // 0x0008 (size: 0x10)
    int32 Rarity;                                                                     // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBCharacterWeaponPerkValues
{
    int32 AbilityParts1Value1;                                                        // 0x0000 (size: 0x4)
    int32 AbilityParts1Value2;                                                        // 0x0004 (size: 0x4)
    int32 AbilityParts2Value1;                                                        // 0x0008 (size: 0x4)
    int32 AbilityParts2Value2;                                                        // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBChargeProjectileChangeCondition
{
    uint32 ChangeProjectileIndex;                                                     // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBConditionCheckParam> ChangeConditionList;                               // 0x0010 (size: 0x10)
    FDataTableRowHandle ChangeProjectileHandle;                                       // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBChatLogWindowStatusSave
{
    bool bIsVisible;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 FilterType;                                                                 // 0x0004 (size: 0x4)
    int32 DetailFilterType;                                                           // 0x0008 (size: 0x4)
    bool bIsTabVisible;                                                               // 0x000C (size: 0x1)
    bool bIsChatUnreadNotify;                                                         // 0x000D (size: 0x1)

}; // Size: 0x10

struct FSBChatOnlineStatus
{
    int32 OnlineStatusId;                                                             // 0x0000 (size: 0x4)
    bool IsBlackListed;                                                               // 0x0004 (size: 0x1)
    bool IsBlackListedBy;                                                             // 0x0005 (size: 0x1)
    bool IsPSOnly;                                                                    // 0x0006 (size: 0x1)

}; // Size: 0x8

struct FSBChatRoomMessage
{
    FString RoomId;                                                                   // 0x0000 (size: 0x10)
    FDateTime Timestamp;                                                              // 0x0010 (size: 0x8)
    class ASBPlayerCharacter* SenderPlayer;                                           // 0x0018 (size: 0x8)
    FString Nickname;                                                                 // 0x0020 (size: 0x10)
    FString MessageBody;                                                              // 0x0030 (size: 0x10)
    bool bIsChat;                                                                     // 0x0040 (size: 0x1)

}; // Size: 0x48

struct FSBChatSaveDatas
{
    TArray<FSBChatLogWindowStatusSave> ChatLogWindow;                                 // 0x0000 (size: 0x10)
    int32 LogTextSize;                                                                // 0x0010 (size: 0x4)
    int32 LogTextSizeIndex;                                                           // 0x0014 (size: 0x4)
    bool bIsDirectMode;                                                               // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    int32 MainSelectTab;                                                              // 0x001C (size: 0x4)
    int32 LogDispTimeType;                                                            // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBChatSenderData
{
    ESBChatLogType ChatLogType;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString DirectChatName;                                                           // 0x0008 (size: 0x10)
    FString DirectChatPlayerID;                                                       // 0x0018 (size: 0x10)
    FString DirectChatCharacterID;                                                    // 0x0028 (size: 0x10)
    FString DirectChatShortID;                                                        // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBChatSpecialCommandInfo
{
    EChatSpecialCommandType CommandType;                                              // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 Val;                                                                        // 0x0004 (size: 0x4)
    ESBChatLogType ChatLogType;                                                       // 0x0008 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0009 (size: 0x7)
    FString Message;                                                                  // 0x0010 (size: 0x10)
    bool IsTypingError;                                                               // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FSBChatUIMessage
{
    FDateTime Timestamp;                                                              // 0x0000 (size: 0x8)
    FString SenderPlayerId;                                                           // 0x0008 (size: 0x10)
    FString SenderCharacterId;                                                        // 0x0018 (size: 0x10)
    FText SenderName;                                                                 // 0x0028 (size: 0x18)
    FString ReceiverPlayerId;                                                         // 0x0040 (size: 0x10)
    FText MessageBody;                                                                // 0x0050 (size: 0x18)
    ESBChatLogType Type;                                                              // 0x0068 (size: 0x1)
    ESBChatLogOption Option;                                                          // 0x0069 (size: 0x1)
    ESBSystemLogDetailType DetailType;                                                // 0x006A (size: 0x1)
    bool IsCloseArea;                                                                 // 0x006B (size: 0x1)
    bool IsDead;                                                                      // 0x006C (size: 0x1)
    bool IsUnread;                                                                    // 0x006D (size: 0x1)

}; // Size: 0x70

struct FSBCheatCheckContainerSet_PlayerSatisfiedConditionCheck
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBCheatCheckContainer_PlayerSatisfiedConditionCheck
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBCheatCheckFatalRecord
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBCheatCheckHistoryBase
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBCheatCheckHistoryData_MoveOnServer : public FSBCheatCheckHistoryBase
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBCheatCheckHistory_CastSkill : public FSBCheatCheckHistoryBase
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBCheatCheckHistory_CheckPoint_TA : public FSBCheatCheckHistoryBase
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBCheatCheckHistory_Damage : public FSBCheatCheckHistoryBase
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBCheatCheckHistory_MoveOnServer
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBCheatCheckSendDataBase
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBCheatCheckSendData_OnCastSkill : public FSBCheatCheckSendDataBase
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

struct FSBCheatReceiveLogInfo
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

struct FSBCheerfulItemAttachmentTypeSpawnSetting
{
    TSubclassOf<class ASBCheerfulItemBase> ItemActor;                                 // 0x0000 (size: 0x8)
    FName ItemAttachSocketName;                                                       // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBCheerfulItemOneMotionTypeSpawnSetting
{
    TSubclassOf<class ASBCheerfulItemBase> ItemActor;                                 // 0x0000 (size: 0x8)
    FName ItemAttachSocketName;                                                       // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBCheerfulItemTableRow : public FTableRowBase
{
    ESBCheerfulItemType ItemType;                                                     // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 ItemIndex;                                                                  // 0x000C (size: 0x4)
    bool bEnableTimeToConsumeCheerfulItem;                                            // 0x0010 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0011 (size: 0x3)
    float TimeToConsumeCheerfulItem;                                                  // 0x0014 (size: 0x4)
    ESBCheerfulProcessMode ProcessMode;                                               // 0x0018 (size: 0x1)
    ESBCheerfulMoveRestrictMode MovementRestrictMode;                                 // 0x0019 (size: 0x1)
    bool bAllowJumpMovement;                                                          // 0x001A (size: 0x1)
    bool bAllowAutoRunMovement;                                                       // 0x001B (size: 0x1)
    char padding_2[0x4];                                                              // 0x001C (size: 0x4)
    class UASStateMachine* StateMachine;                                              // 0x0020 (size: 0x8)
    class UASAnimationSet* AnimationSet;                                              // 0x0028 (size: 0x8)
    TArray<FSBCheerfulItemAttachmentTypeSpawnSetting> AttachmentTypeItemSpawnSettingList; // 0x0030 (size: 0x10)
    TArray<FSBCheerfulItemOneMotionTypeSpawnSetting> OneMotionTypeItemSpawnSettingList; // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBChoiceDialogParameter
{
    FName TextId;                                                                     // 0x0000 (size: 0x8)
    class ULevelSequence* LevelSequence;                                              // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBChoiceDialogPayload
{
    FName QuestionTextId;                                                             // 0x0000 (size: 0x8)
    TArray<FSBChoiceDialogParameter> SelectItems;                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBClassChangeBattleCode
{
    FString CodeName;                                                                 // 0x0000 (size: 0x10)
    int32 Index;                                                                      // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBClassChangeSyncData
{
    ESBClassType Role;                                                                // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FCharaEquipInfo Equip;                                                            // 0x0008 (size: 0x10)
    FEquipedArtsListInfo EquipedArts;                                                 // 0x0018 (size: 0x10)
    TArray<FCharaSkillMasteryInfo> SkillMastery;                                      // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBClassOrderedBuffInfo
{
    TArray<FSBPlayerBuffInfo> ClassOrderedBuffs;                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBClientManagedProperty
{
    float Stamina;                                                                    // 0x0000 (size: 0x4)
    float SubArtsRecastTime;                                                          // 0x0004 (size: 0x4)
    float Arts1RecastTime;                                                            // 0x0008 (size: 0x4)
    float Arts2RecastTime;                                                            // 0x000C (size: 0x4)
    float Arts3RecastTime;                                                            // 0x0010 (size: 0x4)
    float Arts4RecastTime;                                                            // 0x0014 (size: 0x4)
    float Arts5RecastTime;                                                            // 0x0018 (size: 0x4)
    float Arts6RecastTime;                                                            // 0x001C (size: 0x4)
    float Arts7RecastTime;                                                            // 0x0020 (size: 0x4)
    float Arts8RecastTime;                                                            // 0x0024 (size: 0x4)
    float ImagineArtsRecastTime;                                                      // 0x0028 (size: 0x4)
    float ImagineArts2RecastTime;                                                     // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBCollisionGroupHitPointInfo
{
    FName GroupName;                                                                  // 0x0000 (size: 0x8)
    float MaxHitPoint;                                                                // 0x0008 (size: 0x4)
    float CurrentHitPoint;                                                            // 0x000C (size: 0x4)
    int32 BreakStep;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBCollisionGroupInfo
{
    FName GroupName;                                                                  // 0x0000 (size: 0x8)
    float DamageScale;                                                                // 0x0008 (size: 0x4)
    float HitPointRate;                                                               // 0x000C (size: 0x4)
    TArray<float> NextHitPointRate;                                                   // 0x0010 (size: 0x10)
    TArray<FSBPartsDamageEffectParams> PartsDamageEffects;                            // 0x0020 (size: 0x10)
    bool Weakness;                                                                    // 0x0030 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0031 (size: 0x7)
    TArray<FSBElementResistanceSetting> PartsResistElementList;                       // 0x0038 (size: 0x10)
    bool ResistElementDamage;                                                         // 0x0048 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0049 (size: 0x7)
    TArray<FName> GroupNameToShareDamage;                                             // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FSBCollisionGroupResistanceCorrection : public FSBElementResistanceCorrectionSetting
{
    int32 CollisionGroupId;                                                           // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBCombatCoordinatorGroup
{
    TArray<class ASBCombatCoordinator*> CombatCoordinators;                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBCommandMenuChildData
{
    TSoftClassPtr<UUserWidget> WidgetPtr;                                             // 0x0000 (size: 0x28)
    bool RemoveAfterSwitching;                                                        // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FSBCommandMenuChildInstanceData
{
    class UUserWidget* Widget;                                                        // 0x0000 (size: 0x8)
    bool RemoveAfterSwitching;                                                        // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FSBCommonLevelData
{
    FString Type;                                                                     // 0x0000 (size: 0x10)
    TArray<FSBCommonLevelItem> levels;                                                // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBCommonLevelItem
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    int32 next_exp;                                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBCommonSaveData
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    TMap<class FString, class FCommonCharacterSave> CharacterSave;                    // 0x0010 (size: 0x50)
    bool MailAutoDeleteCheck;                                                         // 0x0060 (size: 0x1)

}; // Size: 0x68

struct FSBCondition
{
    int32 ConditionId;                                                                // 0x0000 (size: 0x4)
    int32 TargetType1;                                                                // 0x0004 (size: 0x4)
    int32 TargetType2;                                                                // 0x0008 (size: 0x4)
    int32 Min;                                                                        // 0x000C (size: 0x4)
    int32 Max;                                                                        // 0x0010 (size: 0x4)
    FName CompId;                                                                     // 0x0014 (size: 0x8)

}; // Size: 0x1C

struct FSBConditionCheckEffectTableHandle
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    FDataTableRowHandle EffectTableHandle;                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBConditionCheckFloatCurveParam
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    class UCurveFloat* FloatCurve;                                                    // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBConditionCheckFloatParam
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float FloatValue;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBConditionCheckIntParam
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    int32 IntValue;                                                                   // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBConditionCheckLinearColorParam
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    FLinearColor ParamColor;                                                          // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBConditionCheckParam
{
    ESBConditionCheckType ConditionCheckType;                                         // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FSBActiveArtsID ActiveArtsID;                                                     // 0x0004 (size: 0x4)
    FSBPassiveArtsID PassiveArtsID;                                                   // 0x0008 (size: 0x4)
    int32 IntValue;                                                                   // 0x000C (size: 0x4)
    float FloatValue;                                                                 // 0x0010 (size: 0x4)
    FName NameValue;                                                                  // 0x0014 (size: 0x8)
    ESBMagnitudeRelation Relation;                                                    // 0x001C (size: 0x1)
    char padding_1[0x3];                                                              // 0x001D (size: 0x3)
    FDataTableRowHandle BattleStatusRowHandle;                                        // 0x0020 (size: 0x10)
    ESBBattleEffectiveGroup BattleEffectiveGroup;                                     // 0x0030 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0031 (size: 0x7)
    TArray<ESBAbilityFlags> AbilityFlagList;                                          // 0x0038 (size: 0x10)
    TArray<ESBAbilityOnlyPlayerStatus> OnlyPlayerStatusList;                          // 0x0048 (size: 0x10)
    ESBAttribute ElementType;                                                         // 0x0058 (size: 0x1)
    ESBArrayLogicalOperator ArrayLogic;                                               // 0x0059 (size: 0x1)
    bool bNot;                                                                        // 0x005A (size: 0x1)

}; // Size: 0x60

struct FSBConditionCheckParticleSystemParam
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    class UParticleSystem* ParticleSystem;                                            // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBConditionCheckRowHandleParam
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    FDataTableRowHandle RowHandle;                                                    // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBConditionPointProjectileParams
{
    FDataTableRowHandle ConditionPointHandle;                                         // 0x0000 (size: 0x10)
    FSBProjectileSelectHandle ConditionPointSelectHandle;                             // 0x0010 (size: 0x18)

}; // Size: 0x28

struct FSBConditionalVoiceBuddy
{
    char padding_0[0xC];                                                              // 0x0000 (size: 0x0)
}; // Size: 0xC

struct FSBConditionalVoiceRequest
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBConfigureSaveData_ChatSound
{
    bool bPlayNear;                                                                   // 0x0000 (size: 0x1)
    bool bPlayZone;                                                                   // 0x0001 (size: 0x1)
    bool bPlayParty;                                                                  // 0x0002 (size: 0x1)
    bool bPlayGuild;                                                                  // 0x0003 (size: 0x1)
    bool bPlayPrivate;                                                                // 0x0004 (size: 0x1)

}; // Size: 0x5

struct FSBConfigureSaveData_General
{
    ESBOperateMode OperateMode;                                                       // 0x0000 (size: 0x1)
    ESBKeyGuideDisplayType IsOperateModeGuideVisibility;                              // 0x0001 (size: 0x1)
    ESBPadKeySkinType PadSkinType;                                                    // 0x0002 (size: 0x1)
    bool IsHUDBeltVisible;                                                            // 0x0003 (size: 0x1)
    bool IsSilentBalloon;                                                             // 0x0004 (size: 0x1)
    ESBWeaponVisibleType WeaponVisibleType;                                           // 0x0005 (size: 0x1)
    bool IsSilentInterruptDialog;                                                     // 0x0006 (size: 0x1)
    ESBSSLogoPosition LogoPosition;                                                   // 0x0007 (size: 0x1)
    FString ScreenshotSaveDirectory;                                                  // 0x0008 (size: 0x10)
    bool IsHideHudAtScreenshot;                                                       // 0x0018 (size: 0x1)
    bool IsShowScreenshotNotifications;                                               // 0x0019 (size: 0x1)
    bool IsShowDemoCaption;                                                           // 0x001A (size: 0x1)
    ESBShortcutRingMode eShortcutRingMode;                                            // 0x001B (size: 0x1)
    bool bShortcutClosingExecute;                                                     // 0x001C (size: 0x1)
    bool bShortcutAuotClose;                                                          // 0x001D (size: 0x1)
    bool bFocusNearSight;                                                             // 0x001E (size: 0x1)
    bool bAutoNextTarget;                                                             // 0x001F (size: 0x1)
    bool bUseCheckDialogActive;                                                       // 0x0020 (size: 0x1)
    bool bDontDisplayThePhotoModeQuitConfirmDialog;                                   // 0x0021 (size: 0x1)
    bool bHideOthersPlayerAtFishing;                                                  // 0x0022 (size: 0x1)
    char padding_0[0x5];                                                              // 0x0023 (size: 0x5)
    FSBUseCheckDialogFlags UseCheckDialogFlags;                                       // 0x0028 (size: 0x50)
    bool bSwapPadDecideButton;                                                        // 0x0078 (size: 0x1)

}; // Size: 0x80

struct FSBConfigureSaveData_Graphics
{
    bool bIsCustom;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ScreenPercentage;                                                           // 0x0004 (size: 0x4)
    int32 ViewDistanceQuality;                                                        // 0x0008 (size: 0x4)
    int32 AntiAliasQuality;                                                           // 0x000C (size: 0x4)
    int32 PostProcessQuality;                                                         // 0x0010 (size: 0x4)
    int32 ShadowQuality;                                                              // 0x0014 (size: 0x4)
    int32 TextureQuality;                                                             // 0x0018 (size: 0x4)
    int32 EffectsQuality;                                                             // 0x001C (size: 0x4)
    int32 FoliageQuality;                                                             // 0x0020 (size: 0x4)
    int32 PresetTextId;                                                               // 0x0024 (size: 0x4)
    int32 EnemyVisibledDistance;                                                      // 0x0028 (size: 0x4)

}; // Size: 0x2C

struct FSBConfigureSaveData_Sound
{
    int32 VolumeMaster;                                                               // 0x0000 (size: 0x4)
    int32 VolumeBackGroundMusic;                                                      // 0x0004 (size: 0x4)
    int32 VolumeAmbient;                                                              // 0x0008 (size: 0x4)
    int32 VolumeSoundEffect;                                                          // 0x000C (size: 0x4)
    int32 VolumeVoice;                                                                // 0x0010 (size: 0x4)
    int32 VolumeSystem;                                                               // 0x0014 (size: 0x4)
    bool bMuteMaster;                                                                 // 0x0018 (size: 0x1)
    bool bMuteBackGroundMusic;                                                        // 0x0019 (size: 0x1)
    bool bMuteAmbient;                                                                // 0x001A (size: 0x1)
    bool bMuteSoundEffect;                                                            // 0x001B (size: 0x1)
    bool bMuteVoice;                                                                  // 0x001C (size: 0x1)
    bool bMuteSystem;                                                                 // 0x001D (size: 0x1)

}; // Size: 0x20

struct FSBConfigureSaveData_SoundUser
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    bool bMuteGestureSound;                                                           // 0x0010 (size: 0x1)
    bool bMuteCostumeSound;                                                           // 0x0011 (size: 0x1)
    FSBConfigureSaveData_ChatSound ChatSound;                                         // 0x0012 (size: 0x5)
    bool bMuteNonActiveWindowSound;                                                   // 0x0017 (size: 0x1)

}; // Size: 0x18

struct FSBConsumeStaminaAmountSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float ConsumeStaminaAmount;                                                       // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBCorrectTargetDirectionInfo
{
    bool bIsUpdatingCorrectDirection;                                                 // 0x0024 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0025 (size: 0x3)
    float MaxRotationDegreePerSecond;                                                 // 0x0028 (size: 0x4)
    float MaxCorrectDegree;                                                           // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBCostumeColorValiation
{
    float SaturationMin;                                                              // 0x0000 (size: 0x4)
    float SaturationMax;                                                              // 0x0004 (size: 0x4)
    float ValueMin;                                                                   // 0x0008 (size: 0x4)
    float ValueMax;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBCostumeExtraColorMasterData
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    int32 CostumeId;                                                                  // 0x0004 (size: 0x4)
    int32 SortId;                                                                     // 0x0008 (size: 0x4)
    int32 CostumeColorId;                                                             // 0x000C (size: 0x4)
    int32 MaterialId;                                                                 // 0x0010 (size: 0x4)
    int32 CostumeColorSaturation;                                                     // 0x0014 (size: 0x4)
    int32 CostumeColorValue;                                                          // 0x0018 (size: 0x4)
    bool IsInActive;                                                                  // 0x001C (size: 0x1)
    char padding_0[0x3];                                                              // 0x001D (size: 0x3)
    FString EventTermId;                                                              // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBCostumeMaterialActorTableRow : public FTableRowBase
{
    ESBCostumeMaterial Upper;                                                         // 0x0010 (size: 0x1)
    ESBCostumeMaterial Lower;                                                         // 0x0011 (size: 0x1)
    ESBCostumeMaterial Shoes;                                                         // 0x0012 (size: 0x1)

}; // Size: 0x18

struct FSBCostumeMaterialTableRow : public FTableRowBase
{
    FString CharaPartsName;                                                           // 0x0010 (size: 0x10)
    FString SkeletalMeshName;                                                         // 0x0020 (size: 0x10)
    ESBCostumeMaterial Upper;                                                         // 0x0030 (size: 0x1)
    ESBCostumeMaterial Lower;                                                         // 0x0031 (size: 0x1)
    ESBCostumeMaterial Shoes;                                                         // 0x0032 (size: 0x1)

}; // Size: 0x38

struct FSBCounterDamageRate
{
    float Attack;                                                                     // 0x0000 (size: 0x4)
    float Stun;                                                                       // 0x0004 (size: 0x4)
    float KneelDown;                                                                  // 0x0008 (size: 0x4)
    float Down;                                                                       // 0x000C (size: 0x4)
    float UpperDown;                                                                  // 0x0010 (size: 0x4)
    float HiUpperDown;                                                                // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBCountryConfigMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 separate_paid_free;                                                         // 0x0004 (size: 0x4)
    int32 currency_history;                                                           // 0x0008 (size: 0x4)
    int32 registration_age_verification;                                              // 0x000C (size: 0x4)
    int32 expired_amount_amortization;                                                // 0x0010 (size: 0x4)
    int32 paid_only_product;                                                          // 0x0014 (size: 0x4)
    int32 gasha_rate;                                                                 // 0x0018 (size: 0x4)
    int32 specified_commercial_transactions_act;                                      // 0x001C (size: 0x4)
    FString time_zone;                                                                // 0x0020 (size: 0x10)
    FTimespan time_difference;                                                        // 0x0030 (size: 0x8)
    FDateTime date_change_time;                                                       // 0x0038 (size: 0x8)
    ESBWeekChangeDayOfWeek week_change_day_of_week;                                   // 0x0040 (size: 0x1)

}; // Size: 0x48

struct FSBCountryTimeZoneSetting : public FTableRowBase
{
    FSBCountryTimeZoneType TimeZoneType;                                              // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 ShiftHour;                                                                  // 0x000C (size: 0x4)
    int32 ShiftMinits;                                                                // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBCouponCreatedData
{
    int32 CampaignId;                                                                 // 0x0000 (size: 0x4)
    bool Enabled;                                                                     // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FDateTime ExtendedDeadline;                                                       // 0x0008 (size: 0x8)
    FString AuthCode;                                                                 // 0x0010 (size: 0x10)
    FString IssuerID;                                                                 // 0x0020 (size: 0x10)
    FDateTime Created;                                                                // 0x0030 (size: 0x8)
    FDateTime Updated;                                                                // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FSBCouponMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 AdventurerRank;                                                             // 0x0004 (size: 0x4)
    ESBCouponQuestType QuestType;                                                     // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 QuestCompleteCount;                                                         // 0x000C (size: 0x4)
    TArray<FSBCouponRewardID> RewardId;                                               // 0x0010 (size: 0x10)
    int32 ReductionRate;                                                              // 0x0020 (size: 0x4)
    int32 DurationDays;                                                               // 0x0024 (size: 0x4)
    FDateTime StartAt;                                                                // 0x0028 (size: 0x8)
    FDateTime EndAt;                                                                  // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FSBCouponRewardID
{
    int32 RewardLevel;                                                                // 0x0000 (size: 0x4)
    int32 UseCount;                                                                   // 0x0004 (size: 0x4)
    FString RewardId;                                                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBCreatedElementAmpOption
{
    FSBPlayingEffect PlayingEffect;                                                   // 0x0008 (size: 0xC8)

}; // Size: 0x118

struct FSBCreatedThunderCloudOption
{
    FSBPlayingEffect PlayingEffect;                                                   // 0x0008 (size: 0xC8)

}; // Size: 0x160

struct FSBCryptoCurrency
{
    int32 FreeRoseOrb;                                                                // 0x0000 (size: 0x4)
    int32 PaidRoseOrb;                                                                // 0x0004 (size: 0x4)
    int32 SkyCoin;                                                                    // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FDateTime ExpiredFreeRoseOrb;                                                     // 0x0010 (size: 0x8)
    FDateTime ExpiredPaidRoseOrb;                                                     // 0x0018 (size: 0x8)
    FDateTime ExpiredSkyCoin;                                                         // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSBCubeBuilderParameter
{
    float X;                                                                          // 0x0000 (size: 0x4)
    float Y;                                                                          // 0x0004 (size: 0x4)
    float Z;                                                                          // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBCurrencyShopItemMasterData : public FSBFlatShopItemMasterData
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x78

struct FSBCurrencyShopPurchaseLimitMasterData : public FSBFlatShopPurchaseLimitMasterData
{
    char padding_0[0x18];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x18

struct FSBCursorStateHandle
{
    int32 Handle;                                                                     // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBCurveMoveSetting
{
    FName CurveMoveName;                                                              // 0x0000 (size: 0x8)
    TSoftObjectPtr<UCurveVector> CurveData;                                           // 0x0008 (size: 0x28)
    TArray<FName> NeedTags;                                                           // 0x0030 (size: 0x10)
    TArray<FName> ForbidTags;                                                         // 0x0040 (size: 0x10)
    uint8 bMoveBackward;                                                              // 0x0050 (size: 0x1)
    uint8 bGoAroundLockonTarget;                                                      // 0x0050 (size: 0x1)
    uint8 bApplyXY;                                                                   // 0x0050 (size: 0x1)
    uint8 bApplyZ;                                                                    // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FSBCustomParam_SpawnEmitterByProjectileID
{
    FProjectileEffectParam EffectParam;                                               // 0x0000 (size: 0x38)
    FRotator Rot;                                                                     // 0x0038 (size: 0xC)
    float ScaleValue;                                                                 // 0x0044 (size: 0x4)
    TEnumAsByte<EPhysicalSurface> Surface;                                            // 0x0048 (size: 0x1)
    ESBAttribute OverrideElementType;                                                 // 0x0049 (size: 0x1)

}; // Size: 0x50

struct FSBCustomTextureData : public FTableRowBase
{
    ESBCustomTextureType Type;                                                        // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 Index;                                                                      // 0x000C (size: 0x4)
    ESBCharacterGender Gender;                                                        // 0x0010 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0011 (size: 0x7)
    TSoftObjectPtr<UTexture2D> BaseColorTexture;                                      // 0x0018 (size: 0x28)
    TSoftObjectPtr<UTexture2D> SpecularTexture;                                       // 0x0040 (size: 0x28)
    TSoftObjectPtr<UTexture2D> IdMaskTexture;                                         // 0x0068 (size: 0x28)
    TSoftObjectPtr<UTexture2D> HairPatternMaskTexture;                                // 0x0090 (size: 0x28)

}; // Size: 0xB8

struct FSBCylinderBuilderParameter
{
    float Radius;                                                                     // 0x0000 (size: 0x4)
    int32 Sides;                                                                      // 0x0004 (size: 0x4)
    float Z;                                                                          // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBDamageEvent : public FPointDamageEvent
{
    int8 bIsEncryptionKeyValid;                                                       // 0x00A8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00A9 (size: 0x7)
    TArray<FSBDamageEventElementData> ElementDataList;                                // 0x00B0 (size: 0x10)
    TArray<FSBStatusAilmentHandle> StatusAliments;                                    // 0x00C0 (size: 0x10)
    char padding_1[0x8];                                                              // 0x00D0 (size: 0x8)
    int8 EncryptionKey3;                                                              // 0x00D8 (size: 0x1)
    uint8 Parity4;                                                                    // 0x00D9 (size: 0x1)
    char padding_2[0x6];                                                              // 0x00DA (size: 0x6)
    TArray<FSBStatusAilmentHandle> SelfStatusAliments;                                // 0x00E0 (size: 0x10)
    FVector_NetQuantizeNormal ShotDirectionForSideBackAttack;                         // 0x00F0 (size: 0xC)
    TEnumAsByte<ESBInvincibleAnimation::Type> InvincibleAnimationType;                // 0x00FC (size: 0x1)
    int8 GroupId;                                                                     // 0x00FD (size: 0x1)
    char padding_3[0x2];                                                              // 0x00FE (size: 0x2)
    float AttackPowerScale;                                                           // 0x0100 (size: 0x4)
    char padding_4[0x4];                                                              // 0x0104 (size: 0x4)
    class AActor* EffectiveDamageCauser;                                              // 0x0108 (size: 0x8)
    uint8 Parity3;                                                                    // 0x0110 (size: 0x1)
    int8 HitEffectAngle;                                                              // 0x0111 (size: 0x1)
    uint8 SkillPosition;                                                              // 0x0112 (size: 0x1)
    int8 EncryptionKey1;                                                              // 0x0113 (size: 0x1)
    uint16 SkillId;                                                                   // 0x0114 (size: 0x2)
    char padding_5[0x2];                                                              // 0x0116 (size: 0x2)
    FSBProjectileIdentifyHandle ProjectileIdentifyHandle;                             // 0x0118 (size: 0x10)
    uint8 BitFlagSerialized4;                                                         // 0x0128 (size: 0x1)
    uint8 BitFlagSerialized3;                                                         // 0x0129 (size: 0x1)
    char padding_6[0x2];                                                              // 0x012A (size: 0x2)
    float ProjectileLimitDamageValue;                                                 // 0x012C (size: 0x4)
    uint8 bIsProjectileForceLimitDamage;                                              // 0x0130 (size: 0x1)
    char padding_7[0x7];                                                              // 0x0131 (size: 0x7)
    TArray<FSBDamageEventGeneralParam> GeneralParamList;                              // 0x0138 (size: 0x10)
    uint16 DamageKnockBackDistance;                                                   // 0x0148 (size: 0x2)
    uint8 DamageKnockBackTime;                                                        // 0x014A (size: 0x1)
    char padding_8[0x1];                                                              // 0x014B (size: 0x1)
    int32 AttackID;                                                                   // 0x014C (size: 0x4)
    uint8 BitFlagSerialized6;                                                         // 0x0150 (size: 0x1)
    uint8 Parity1;                                                                    // 0x0151 (size: 0x1)
    uint8 BitFlagSerialized2;                                                         // 0x0152 (size: 0x1)
    char padding_9[0x1];                                                              // 0x0153 (size: 0x1)
    uint32 Flags;                                                                     // 0x0154 (size: 0x4)
    int8 EncryptionKey2;                                                              // 0x0158 (size: 0x1)
    char padding_10[0x3F];                                                            // 0x0159 (size: 0x3F)
    uint8 Parity2;                                                                    // 0x0198 (size: 0x1)
    uint8 BitFlagSerialized1;                                                         // 0x0199 (size: 0x1)
    uint8 bInventoryIndex1;                                                           // 0x019A (size: 0x1)
    int8 EncryptionKey4;                                                              // 0x019B (size: 0x1)
    uint8 bInvalidDamageFromAbility;                                                  // 0x019C (size: 0x1)
    uint8 BitFlagSerialized5;                                                         // 0x019D (size: 0x1)
    uint8 bMissDamageFromAbility;                                                     // 0x019E (size: 0x1)
    ESBFieldDamageType FieldDamageType;                                               // 0x019F (size: 0x1)

}; // Size: 0x1A0

struct FSBDamageEventCommonFlag
{
    bool bDownHit;                                                                    // 0x0008 (size: 0x1)
    bool bBadConditionHit;                                                            // 0x0009 (size: 0x1)
    bool bHPDamageType;                                                               // 0x000A (size: 0x1)
    bool bAttackActionAndWeaponHaveElement;                                           // 0x000B (size: 0x1)
    bool bDamageKnockBack;                                                            // 0x000C (size: 0x1)
    bool bSuperArmorSucceeded;                                                        // 0x000D (size: 0x1)
    bool bOverrideHitEffectAngle;                                                     // 0x000E (size: 0x1)
    bool bPlayedHitEffectInLocal;                                                     // 0x000F (size: 0x1)
    bool bBackHit;                                                                    // 0x0010 (size: 0x1)
    bool bWeakPointHit;                                                               // 0x0011 (size: 0x1)
    bool bCriticalHit;                                                                // 0x0012 (size: 0x1)
    bool bDotDamage;                                                                  // 0x0013 (size: 0x1)
    bool bSubstituteDamageBySelf;                                                     // 0x0014 (size: 0x1)
    bool bGutsActivated;                                                              // 0x0015 (size: 0x1)
    bool bInvincibleSucceeded;                                                        // 0x0016 (size: 0x1)
    bool bPlayInvincibleSucceededEffect;                                              // 0x0017 (size: 0x1)
    bool bGuardHit;                                                                   // 0x0018 (size: 0x1)
    bool bGuardSucceeded;                                                             // 0x0019 (size: 0x1)
    bool bGuardKnockBack;                                                             // 0x001A (size: 0x1)
    bool bOverrideStunDirectionDown;                                                  // 0x001B (size: 0x1)
    bool bOverrideStunDirectionKnockBack;                                             // 0x001C (size: 0x1)
    bool bOverrideStunDirectionUp;                                                    // 0x001D (size: 0x1)
    bool bPlayEarthMeltEffect;                                                        // 0x001E (size: 0x1)
    bool bPlayFireMeltEffect;                                                         // 0x001F (size: 0x1)
    bool bPlayIceMeltEffect;                                                          // 0x0020 (size: 0x1)
    bool bPlayThunderMeltEffect;                                                      // 0x0021 (size: 0x1)
    bool bPlayLightMeltEffect;                                                        // 0x0022 (size: 0x1)
    bool bPlayDarknessMeltEffect;                                                     // 0x0023 (size: 0x1)
    bool bPlayIceBreakEffect;                                                         // 0x0024 (size: 0x1)
    bool bPlayStoneBreakEffect;                                                       // 0x0025 (size: 0x1)
    bool bPlayElementSpreadEffect;                                                    // 0x0026 (size: 0x1)
    bool bHideDamageUI;                                                               // 0x0027 (size: 0x1)
    bool bNoDamageByLevelCoefficient;                                                 // 0x0028 (size: 0x1)
    bool bNoDamageByGuard;                                                            // 0x0029 (size: 0x1)

}; // Size: 0x30

struct FSBDamageEventElementData : public FSBDamageEventElementDataForMulticast
{
    uint8 ElementValue;                                                               // 0x0002 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0003 (size: 0x1)
    float AccumValue;                                                                 // 0x0004 (size: 0x4)
    float ResultAccumValue;                                                           // 0x0008 (size: 0x4)
    ESBStunValueCalculation CalculationType;                                          // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBDamageEventElementDataForMulticast
{
    ESBAttribute ElementType;                                                         // 0x0000 (size: 0x1)
    uint8 bTakeReaction;                                                              // 0x0001 (size: 0x1)
    uint8 bPlayHitEffect;                                                             // 0x0001 (size: 0x1)
    uint8 bAttackAction;                                                              // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FSBDamageEventGeneralParam
{
    ESBDamageEventGeneralParam Type;                                                  // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBDamageEventStunDataForMulticast
{
    uint16 StunValue;                                                                 // 0x0000 (size: 0x2)
    ESBStunValueCalculation CalculationType;                                          // 0x0002 (size: 0x1)

}; // Size: 0x4

struct FSBDamageEventUploadFlag : public FSBDamageEventCommonFlag
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

struct FSBDamageHitEffectSetting
{
    FSBEffectSetting Normal;                                                          // 0x0000 (size: 0x150)
    FSBEffectSetting Low;                                                             // 0x0150 (size: 0x150)
    FSBEffectSetting High;                                                            // 0x02A0 (size: 0x150)
    FSBEffectSetting StepJump;                                                        // 0x03F0 (size: 0x150)

}; // Size: 0x540

struct FSBDamageInfo
{
    float Damage;                                                                     // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    class UASDamageType* Type;                                                        // 0x0008 (size: 0x8)
    TEnumAsByte<ESBDamageDirection> Direction;                                        // 0x0010 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0011 (size: 0x3)
    FVector ImpulseDir;                                                               // 0x0014 (size: 0xC)
    TWeakObjectPtr<class APawn> PawnInstigator;                                       // 0x0020 (size: 0x8)
    FSBStunInfo StunInfo;                                                             // 0x0028 (size: 0x14)
    ESBAttribute DeathElementType;                                                    // 0x003C (size: 0x1)
    char padding_2[0x3];                                                              // 0x003D (size: 0x3)
    uint8 bHitWeakPoint;                                                              // 0x0040 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0041 (size: 0x3)
    ESBFieldDamageType FieldDamageType;                                               // 0x0044 (size: 0x1)
    ESBDeathReactionType DeathReactionType;                                           // 0x0045 (size: 0x1)

}; // Size: 0x58

struct FSBDamageUIRequestInfo
{
    class AActor* Actor;                                                              // 0x0000 (size: 0x8)
    FVector Location;                                                                 // 0x0008 (size: 0xC)
    int32 DamageValue;                                                                // 0x0014 (size: 0x4)
    float AttributeScale;                                                             // 0x0018 (size: 0x4)
    bool bIsWeakPointHit;                                                             // 0x001C (size: 0x1)
    bool bIsGuard;                                                                    // 0x001D (size: 0x1)
    bool bIsCriticalHit;                                                              // 0x001E (size: 0x1)
    bool bIsMiss;                                                                     // 0x001F (size: 0x1)

}; // Size: 0x20

struct FSBDeathEffectParams
{
    FName EffectAttachPointName;                                                      // 0x0000 (size: 0x8)
    FVector EffectActorScale;                                                         // 0x0008 (size: 0xC)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    TArray<class UParticleSystem*> ParticleEffects;                                   // 0x0018 (size: 0x10)
    TArray<TSoftClassPtr<AActor>> EffectActors;                                       // 0x0028 (size: 0x10)
    TArray<FAkEventVariables> DeathAkEvents;                                          // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBDebugGatherAroundPlayerParam : public FSBDebugGatherPlayerParam
{
    FString PlayerName;                                                               // 0x0090 (size: 0x10)
    TArray<FString> CurrentStateInfo;                                                 // 0x00A0 (size: 0x10)

}; // Size: 0xB0

struct FSBDebugGatherPlayerParam
{
    int32 CharacterLevel;                                                             // 0x0000 (size: 0x4)
    int32 CharacterExp;                                                               // 0x0004 (size: 0x4)
    float CurrentHitPoint;                                                            // 0x0008 (size: 0x4)
    float MaxHitPoint;                                                                // 0x000C (size: 0x4)
    FSBCharacterStatus CharacterStatus;                                               // 0x0010 (size: 0x40)
    bool bInvincibleMotion;                                                           // 0x0050 (size: 0x1)
    int8 InvincibleAnimationType;                                                     // 0x0051 (size: 0x1)
    ESBInvincibleLevel InvincibleLevel;                                               // 0x0052 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0053 (size: 0x1)
    uint8 bWaitTimeDone;                                                              // 0x0054 (size: 0x1)
    uint8 bLocalWarpFlag;                                                             // 0x0054 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0055 (size: 0x3)
    int32 WarpState;                                                                  // 0x0058 (size: 0x4)
    uint8 bPlayingWarpAroundEffect;                                                   // 0x005C (size: 0x1)
    char padding_2[0x3];                                                              // 0x005D (size: 0x3)
    TArray<int32> ActiveArtsList;                                                     // 0x0060 (size: 0x10)
    TArray<FName> ImagineArtsList;                                                    // 0x0070 (size: 0x10)
    TArray<int32> PassiveArtsList;                                                    // 0x0080 (size: 0x10)

}; // Size: 0x90

struct FSBDebugGatherStateMachine
{
    FString StateMachineNodeName;                                                     // 0x0000 (size: 0x10)
    FString StateMachineName;                                                         // 0x0010 (size: 0x10)
    int32 CurrentState;                                                               // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    TArray<FString> StateNames;                                                       // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBDebugGatherStateMachineParam
{
    TArray<FSBDebugGatherStateMachine> StateMachines;                                 // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBDebugMemoSetting
{
    FText ViewText;                                                                   // 0x0000 (size: 0x18)
    FVector PutLocation;                                                              // 0x0018 (size: 0xC)

}; // Size: 0x28

struct FSBDebugMenu : public FTableRowBase
{
    FName TitleName;                                                                  // 0x0008 (size: 0x8)
    class UDataTable* DataTable;                                                      // 0x0010 (size: 0x8)
    TEnumAsByte<ESBDebugMenuType> Type;                                               // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBDebugParameter : public FTableRowBase
{
    FName ParameterName;                                                              // 0x0008 (size: 0x8)
    class USBTextTableAsset* TextTableAsset;                                          // 0x0010 (size: 0x8)
    FName TitleTextId;                                                                // 0x0018 (size: 0x8)
    FName ToolTipTextId;                                                              // 0x0020 (size: 0x8)
    TEnumAsByte<ESBDebugMenuType> Type;                                               // 0x0028 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0029 (size: 0x7)
    TArray<FString> InitialValue;                                                     // 0x0030 (size: 0x10)
    TSoftClassPtr<UUserWidget> WidgetClass;                                           // 0x0040 (size: 0x28)
    FString ToolTip;                                                                  // 0x0068 (size: 0x10)
    bool enable;                                                                      // 0x0078 (size: 0x1)
    bool bEditorOnly;                                                                 // 0x0079 (size: 0x1)
    bool bReadOnly;                                                                   // 0x007A (size: 0x1)

}; // Size: 0xA0

struct FSBDebugParameterForSaveGame
{
    FName ParameterName;                                                              // 0x0000 (size: 0x8)
    TEnumAsByte<ESBDebugMenuType> Type;                                               // 0x0008 (size: 0x1)
    uint8 Value;                                                                      // 0x0009 (size: 0x4)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    FString SelectedOption;                                                           // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBDebugPostDataType
{
    ESBDebugPostDataType Type;                                                        // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Key;                                                                      // 0x0008 (size: 0x10)
    FString StringValue;                                                              // 0x0018 (size: 0x10)
    int32 IntegerValue;                                                               // 0x0028 (size: 0x4)
    float NumberValue;                                                                // 0x002C (size: 0x4)
    bool BooleanValue;                                                                // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBDebugRespawnPointData
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    FVector Location;                                                                 // 0x0010 (size: 0xC)

}; // Size: 0x20

struct FSBDebugSettingByMenu
{
    FName TitleName;                                                                  // 0x0000 (size: 0x8)
    TArray<FSBDebugParameterForSaveGame> Params;                                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBDebugWaveEnemyParamSettingBase
{
    FText SettingLabel;                                                               // 0x0000 (size: 0x18)
    FText EnemyId;                                                                    // 0x0018 (size: 0x18)
    int32 EnemyLv;                                                                    // 0x0030 (size: 0x4)
    float TimeLimit;                                                                  // 0x0034 (size: 0x4)
    float IntervalEnemySpawn;                                                         // 0x0038 (size: 0x4)
    int32 MaxEnemyNum;                                                                // 0x003C (size: 0x4)
    int32 MinEnemyNum;                                                                // 0x0040 (size: 0x4)

}; // Size: 0x48

struct FSBDecayedWeaponData
{
    EItemType ItemType;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString UniqueId;                                                                 // 0x0008 (size: 0x10)
    int32 ItemId;                                                                     // 0x0018 (size: 0x4)
    int32 OldItemId;                                                                  // 0x001C (size: 0x4)
    int32 StorageNumber;                                                              // 0x0020 (size: 0x4)
    int32 Amount;                                                                     // 0x0024 (size: 0x4)
    FDateTime ExpiryDateTime;                                                         // 0x0028 (size: 0x8)
    bool bIsEquipped;                                                                 // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBDefaultBossBGMSettingData
{
    ESBBossBGMSettingType SettingType;                                                // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 SettingValue;                                                               // 0x0004 (size: 0x4)
    ESBBattleBGMType BattleBGMType;                                                   // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBDefaultWeaponParam : public FTableRowBase
{
    int32 Status_AP;                                                                  // 0x0008 (size: 0x4)
    int32 Status_CP;                                                                  // 0x000C (size: 0x4)
    int32 Status_STR;                                                                 // 0x0010 (size: 0x4)
    int32 Status_VIT;                                                                 // 0x0014 (size: 0x4)
    int32 Status_DEX;                                                                 // 0x0018 (size: 0x4)
    int32 Status_INT;                                                                 // 0x001C (size: 0x4)
    int32 Status_MND;                                                                 // 0x0020 (size: 0x4)
    int32 Status_ATTR;                                                                // 0x0024 (size: 0x4)
    int32 Status_SPC;                                                                 // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FSBDefenceGuardConfig
{
    int32 GuardBitMask;                                                               // 0x0000 (size: 0x4)
    int32 NotThroughMask;                                                             // 0x0004 (size: 0x4)
    float GuardableAngle;                                                             // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBDeletedCostumeData
{
    EItemType ItemType;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString UniqueId;                                                                 // 0x0008 (size: 0x10)
    int32 ItemId;                                                                     // 0x0018 (size: 0x4)
    int32 ColorId;                                                                    // 0x001C (size: 0x4)
    int32 ColorSaturation;                                                            // 0x0020 (size: 0x4)
    int32 ColorValue;                                                                 // 0x0024 (size: 0x4)
    int32 MaterialId;                                                                 // 0x0028 (size: 0x4)
    int32 StorageNumber;                                                              // 0x002C (size: 0x4)
    int32 Amount;                                                                     // 0x0030 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0034 (size: 0x4)
    FDateTime ExpiryDateTime;                                                         // 0x0038 (size: 0x8)
    bool bIsEquipped;                                                                 // 0x0040 (size: 0x1)
    ESBCharaEquipType EquipType;                                                      // 0x0041 (size: 0x1)

}; // Size: 0x48

struct FSBDeletedImagineData
{
    EItemType ItemType;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString UniqueId;                                                                 // 0x0008 (size: 0x10)
    int32 ItemId;                                                                     // 0x0018 (size: 0x4)
    int32 StorageNumber;                                                              // 0x001C (size: 0x4)
    int32 Amount;                                                                     // 0x0020 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0024 (size: 0x4)
    FDateTime ExpiryDateTime;                                                         // 0x0028 (size: 0x8)
    bool bIsEquipped;                                                                 // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBDeletedMountData
{
    EItemType ItemType;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString UniqueId;                                                                 // 0x0008 (size: 0x10)
    int32 ItemId;                                                                     // 0x0018 (size: 0x4)
    int32 StorageNumber;                                                              // 0x001C (size: 0x4)
    int32 Amount;                                                                     // 0x0020 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0024 (size: 0x4)
    FDateTime ExpiryDateTime;                                                         // 0x0028 (size: 0x8)
    bool bIsEquipped;                                                                 // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBDemoData : public FTableRowBase
{
    TSoftObjectPtr<ULevelSequence> LevelSequenceAsset;                                // 0x0008 (size: 0x28)
    TSoftClassPtr<ASBLevelSequenceActor> LevelSequenceClass;                          // 0x0030 (size: 0x28)
    ESBDemoVisibleCharacterType DemoVisibleCharacterType;                             // 0x0058 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0059 (size: 0x3)
    FName LevelName;                                                                  // 0x005C (size: 0x8)
    bool IsTheater;                                                                   // 0x0064 (size: 0x1)
    ESBDemoMediaType MediaType;                                                       // 0x0065 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0066 (size: 0x2)
    TSoftObjectPtr<UTexture2D> Thumbnail;                                             // 0x0068 (size: 0x28)

}; // Size: 0x90

struct FSBDemoEndSoundSetting
{
    TSoftObjectPtr<UAkAudioEvent> DemoEndEvent;                                       // 0x0000 (size: 0x28)
    bool IsMuteBGMAfterDemoEndToChangeMap;                                            // 0x0028 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0029 (size: 0x7)
    TSoftObjectPtr<UAkAudioEvent> UnMuteEventOfChangeMap;                             // 0x0030 (size: 0x28)

}; // Size: 0x58

struct FSBDemoSoundDataTableRow : public FTableRowBase
{
    FString SequenceAssetName;                                                        // 0x0008 (size: 0x10)
    TSoftObjectPtr<UAkAudioEvent> DemoStartEvent;                                     // 0x0018 (size: 0x28)
    FSBDemoEndSoundSetting DemoEndSetting;                                            // 0x0040 (size: 0x58)
    TSoftObjectPtr<UAkAudioEvent> DemoSkipEvent;                                      // 0x0098 (size: 0x28)
    TArray<TSoftObjectPtr<UAkAudioEvent>> EventsOfNotMediaLoaded;                     // 0x00C0 (size: 0x10)

}; // Size: 0xD0

struct FSBDhcBattleAttributeResistanceInfo
{
    ESBAttribute Attribute;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ResistanceValue;                                                            // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBDhcBattleHighScoreInfo
{
    ESBClassType ClassType;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ClassLevel;                                                                 // 0x0004 (size: 0x4)
    int32 BattleScore;                                                                // 0x0008 (size: 0x4)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    FString GameMode;                                                                 // 0x0010 (size: 0x10)
    int32 HighScore;                                                                  // 0x0020 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0024 (size: 0x4)
    FSBDhcBattlePlayerStatusInfo PlayerStatusInfo;                                    // 0x0028 (size: 0x40)
    FSBDhcBattlePlayerEquipsInfo PlayerEquipsInfo;                                    // 0x0068 (size: 0x40)
    TArray<FSBDhcBattlePlayerEquipArtsInfo> PlayerEquipArtsInfos;                     // 0x00A8 (size: 0x10)

}; // Size: 0xB8

struct FSBDhcBattleInfo
{
    TArray<FSBDhcBattleHighScoreInfo> AttackCheckerHighScoreInfos;                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBDhcBattlePlayerEquipArtsInfo
{
    int32 ArtsType;                                                                   // 0x0000 (size: 0x4)
    int32 ArtsId;                                                                     // 0x0004 (size: 0x4)
    int32 ArtsSlotId;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBDhcBattlePlayerEquipImagineInfo
{
    int32 ImagineId;                                                                  // 0x0000 (size: 0x4)
    int32 ImagineLevel;                                                               // 0x0004 (size: 0x4)
    int32 ImagineSlotId;                                                              // 0x0008 (size: 0x4)
    FName UniqueId;                                                                   // 0x000C (size: 0x8)

}; // Size: 0x14

struct FSBDhcBattlePlayerEquipWeaponInfo
{
    int32 WeaponID;                                                                   // 0x0000 (size: 0x4)
    int32 WeaponLevel;                                                                // 0x0004 (size: 0x4)
    int32 AttackPower;                                                                // 0x0008 (size: 0x4)
    int32 AttributePower;                                                             // 0x000C (size: 0x4)
    int32 SpecialEffectId;                                                            // 0x0010 (size: 0x4)
    FName UniqueId;                                                                   // 0x0014 (size: 0x8)

}; // Size: 0x1C

struct FSBDhcBattlePlayerEquipsInfo
{
    FSBDhcBattlePlayerEquipWeaponInfo EquipWeaponInfo;                                // 0x0000 (size: 0x1C)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    TArray<FSBDhcBattlePlayerEquipImagineInfo> EquipBattleImagineInfos;               // 0x0020 (size: 0x10)
    TArray<FSBDhcBattlePlayerEquipImagineInfo> EquipEnhanceImagineInfos;              // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FSBDhcBattlePlayerStatusInfo
{
    int32 STR;                                                                        // 0x0000 (size: 0x4)
    int32 VIT;                                                                        // 0x0004 (size: 0x4)
    int32 DEX;                                                                        // 0x0008 (size: 0x4)
    int32 INT;                                                                        // 0x000C (size: 0x4)
    int32 MND;                                                                        // 0x0010 (size: 0x4)
    int32 AttackPower;                                                                // 0x0014 (size: 0x4)
    int32 CriticalRate;                                                               // 0x0018 (size: 0x4)
    int32 CriticalPower;                                                              // 0x001C (size: 0x4)
    int32 DefensePower;                                                               // 0x0020 (size: 0x4)
    int32 RecoveryPower;                                                              // 0x0024 (size: 0x4)
    TArray<FSBDhcBattleAttributeResistanceInfo> AttributeResistanceInfos;             // 0x0028 (size: 0x10)
    int32 HitPoint;                                                                   // 0x0038 (size: 0x4)
    int32 Stamina;                                                                    // 0x003C (size: 0x4)

}; // Size: 0x40

struct FSBDiffItemInfo
{
    int32 ItemIndex;                                                                  // 0x0000 (size: 0x4)
    EItemType ItemType;                                                               // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 DiffAmount;                                                                 // 0x0008 (size: 0x4)
    bool bIsIdentified;                                                               // 0x000C (size: 0x1)
    bool IsMissionBagItem;                                                            // 0x000D (size: 0x1)

}; // Size: 0x10

struct FSBDirectChatSenderLogData
{
    FString DirectChatName;                                                           // 0x0000 (size: 0x10)
    FString DirectChatPlayerID;                                                       // 0x0010 (size: 0x10)
    FString DirectChatCharacterID;                                                    // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBDirectChatUIMessage
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)
    FText CharacterName;                                                              // 0x0020 (size: 0x18)
    int32 WindowIndex;                                                                // 0x0038 (size: 0x4)
    char padding_0[0x4];                                                              // 0x003C (size: 0x4)
    TArray<FSBChatUIMessage> ChatLogMessList;                                         // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBDownloadImageCache
{
    class UTexture2DDynamic* Texture;                                                 // 0x0010 (size: 0x8)

}; // Size: 0x20

struct FSBDropData
{
    ESBRewardItemType ItemType;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    int32 MinNumOfAcq;                                                                // 0x0008 (size: 0x4)
    int32 MaxNumOfAcq;                                                                // 0x000C (size: 0x4)
    int32 StepSize;                                                                   // 0x0010 (size: 0x4)
    float DropRate;                                                                   // 0x0014 (size: 0x4)

}; // Size: 0x28

struct FSBDungeonClearAddRewardInfo
{
    int32 AddMoney;                                                                   // 0x0000 (size: 0x4)
    int32 AddExp;                                                                     // 0x0004 (size: 0x4)
    int32 AddGC;                                                                      // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FOwnItemInfo> DirtyItems;                                                  // 0x0010 (size: 0x10)
    TArray<FName> RewardedIds;                                                        // 0x0020 (size: 0x10)
    FSBOverLimit OverLimit;                                                           // 0x0030 (size: 0x20)
    FSBExtraExpParse ClassExtraExp;                                                   // 0x0050 (size: 0x18)
    TArray<FSBRewardToken> Token;                                                     // 0x0068 (size: 0x10)
    TArray<int32> MedalIDs;                                                           // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FSBDungeonClearPartyMemberData
{
    FString UserId;                                                                   // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)
    bool PartyFlag;                                                                   // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FSBDungeonClearRewardInfo
{
    int32 Rank;                                                                       // 0x0000 (size: 0x4)
    int32 RankingValue;                                                               // 0x0004 (size: 0x4)
    int32 BestScore;                                                                  // 0x0008 (size: 0x4)
    int32 CompleteNum;                                                                // 0x000C (size: 0x4)
    int32 DailyBoostsNum;                                                             // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FSBDungeonClearAddRewardInfo RewardsClear;                                        // 0x0018 (size: 0x88)
    FSBDungeonClearAddRewardInfo RewardsRank;                                         // 0x00A0 (size: 0x88)
    FSBDungeonClearAddRewardInfo RewardsPlus;                                         // 0x0128 (size: 0x88)
    FSBRaidReward RewardsRaid;                                                        // 0x01B0 (size: 0x120)
    FSBDxReward RewardsDx;                                                            // 0x02D0 (size: 0x220)
    TArray<FOwnItemInfo> DropItems;                                                   // 0x04F0 (size: 0x10)
    TArray<FSBSkillParam> TacticalAbilityB;                                           // 0x0500 (size: 0x10)
    TArray<int32> AchievementIdList;                                                  // 0x0510 (size: 0x10)
    FSBLetter Letter;                                                                 // 0x0520 (size: 0x28)
    FSBMasterRewardControl RewardControl;                                             // 0x0548 (size: 0x14)
    char padding_1[0x4];                                                              // 0x055C (size: 0x4)
    TArray<FSBMasterGuildBonus> TeamBonus;                                            // 0x0560 (size: 0x10)
    bool isWareHouseAbilities;                                                        // 0x0570 (size: 0x1)
    bool IsBuffItemBonusLuno;                                                         // 0x0571 (size: 0x1)
    bool IsBuffItemBonusEXP;                                                          // 0x0572 (size: 0x1)
    bool IsBuffItemBonusGC;                                                           // 0x0573 (size: 0x1)

}; // Size: 0x578

struct FSBDungeonCompleteState
{
    FName DungeonId;                                                                  // 0x0000 (size: 0x8)
    ESBDungeonCompleteType Type;                                                      // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 PassageStep;                                                                // 0x000C (size: 0x4)
    int32 CompleteNum;                                                                // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBDungeonDifficultyInfo : public FTableRowBase
{
    int32 RespawnableNumPerPlayer;                                                    // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSBDungeonEntryConditionEquipCondition
{
    ESBDungeonEntryConditionItemType ItemType;                                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    ESBDungeonEntryConditionAppearanceType AppearanceType;                            // 0x0008 (size: 0x1)
    ESBClassType ClassType;                                                           // 0x0009 (size: 0x1)
    char padding_1[0x2];                                                              // 0x000A (size: 0x2)
    int32 KillerPerkId;                                                               // 0x000C (size: 0x4)
    int32 AbilityPerkId;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBDungeonEntryConditionMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBDungeonEntryConditionEquipCondition> EquipConditionOr;                  // 0x0008 (size: 0x10)
    TArray<FSBDungeonEntryConditionEquipCondition> EquipConditionAnd;                 // 0x0018 (size: 0x10)
    ESBDungeonEntryConditionElementType ElementType;                                  // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FSBDungeonProcess : public FTableRowBase
{
    FName process_id;                                                                 // 0x0008 (size: 0x8)
    ESBDungeonProcessStatus process_status;                                           // 0x0010 (size: 0x1)
    ESBDungeonClearCondition clear_type;                                              // 0x0011 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0012 (size: 0x6)
    FString clear_parameter;                                                          // 0x0018 (size: 0x10)
    FString scripts;                                                                  // 0x0028 (size: 0x10)
    FString exec_script_code;                                                         // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBDungeonProcessCondition
{
    ESBDungeonProcessStatus ProcessStatus;                                            // 0x0000 (size: 0x1)
    ESBDungeonClearCondition ClearType;                                               // 0x0001 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0002 (size: 0x6)
    FString ClearParameter;                                                           // 0x0008 (size: 0x10)
    FString Script;                                                                   // 0x0018 (size: 0x10)
    FString ExecScriptCode;                                                           // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBDungeonProcessTable : public FTableRowBase
{
    FName MapId;                                                                      // 0x0008 (size: 0x8)
    TArray<FSBDungeonProcess> DungeonProcess;                                         // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBDungeonProgressItemUIInfo
{
    EDungeonClearConditionType ConditionType;                                         // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString ConditionString;                                                          // 0x0008 (size: 0x10)
    FString ProgressString;                                                           // 0x0018 (size: 0x10)
    bool bCompleted;                                                                  // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FSBDungeonRecord
{
    FSBDungeonCompleteState CompleteState;                                            // 0x0000 (size: 0x14)
    ESBClassType ClassType;                                                           // 0x0014 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0015 (size: 0x3)
    int32 BestScore;                                                                  // 0x0018 (size: 0x4)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    TArray<int32> RapTime;                                                            // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBDungeonRect
{
    FVector BoxCenterPos;                                                             // 0x0010 (size: 0xC)

}; // Size: 0x1C

struct FSBDungeonRewardInfo
{
    TArray<FSBDungeonRewardItem> RewardItems;                                         // 0x0000 (size: 0x10)
    int32 RewardMoney;                                                                // 0x0010 (size: 0x4)
    int32 BravePoint;                                                                 // 0x0014 (size: 0x4)
    int32 ClassExp;                                                                   // 0x0018 (size: 0x4)
    ESBDungeonEvaluation Evaluation;                                                  // 0x001C (size: 0x1)

}; // Size: 0x20

struct FSBDungeonRewardItem
{
    int32 ItemIndex;                                                                  // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBDungeonScriptQueue
{
    FName ScriptId;                                                                   // 0x0000 (size: 0x8)
    int32 RequestCount;                                                               // 0x0008 (size: 0x4)
    int32 EndCount;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBDungeonSupply
{
    int32 ItemIndex;                                                                  // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBDxBattleGameScore
{
    float TotalScore;                                                                 // 0x0004 (size: 0x4)
    int32 TotalScoreInteger;                                                          // 0x0008 (size: 0x4)
    int32 RankingRank;                                                                // 0x000C (size: 0x4)
    int32 AwardValue;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBDxBattleGateData
{
    FString GateId;                                                                   // 0x0000 (size: 0x10)
    FString MapId;                                                                    // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBDxBattleMasterData
{
    FString RaidId;                                                                   // 0x0000 (size: 0x10)
    int32 NameId;                                                                     // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FString MapId;                                                                    // 0x0018 (size: 0x10)
    FString RewardId;                                                                 // 0x0028 (size: 0x10)
    float TotalRankingGCMultiplier;                                                   // 0x0038 (size: 0x4)
    float ClassRankingGCMultiplier;                                                   // 0x003C (size: 0x4)
    float AwardGCMultiplier;                                                          // 0x0040 (size: 0x4)
    float AwardMostDamageMultiplier;                                                  // 0x0044 (size: 0x4)
    float AwardInstaneousDumageMultiplier;                                            // 0x0048 (size: 0x4)
    float AwardBuffMultiplier;                                                        // 0x004C (size: 0x4)
    float AwardResurrectionMultiplier;                                                // 0x0050 (size: 0x4)
    float AwardDebuffMultiplier;                                                      // 0x0054 (size: 0x4)
    float AwardGimmickAttackMultiplier;                                               // 0x0058 (size: 0x4)
    float AwardLastAttakMultiplier;                                                   // 0x005C (size: 0x4)
    float AwardMostTakeHitsMultiplier;                                                // 0x0060 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0064 (size: 0x4)
    FString TermId;                                                                   // 0x0068 (size: 0x10)
    TArray<FSBDxBattleGateData> GateData;                                             // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FSBDxBattleOccurringCheckData
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBDxBattleResult
{
    FSBDxBattleResultPersonal PersonalData;                                           // 0x0000 (size: 0x28)
    FSBDxBattleResultRanking RankingData;                                             // 0x0028 (size: 0x30)
    FSBDxBattleResultAward AwardPlayerData;                                           // 0x0058 (size: 0x10)
    bool GameClear;                                                                   // 0x0068 (size: 0x1)
    bool IsCompleteClear;                                                             // 0x0069 (size: 0x1)

}; // Size: 0x70

struct FSBDxBattleResultAward
{
    TArray<FSBDxBattleResultAwardParam> AwardPlayerList;                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBDxBattleResultAwardParam
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 Level;                                                                      // 0x0014 (size: 0x4)
    int32 AwardedFlag;                                                                // 0x0018 (size: 0x4)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    FString CharacterId;                                                              // 0x0020 (size: 0x10)
    float AwardValue;                                                                 // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBDxBattleResultPersonal
{
    int32 AddBravePoint;                                                              // 0x0000 (size: 0x4)
    int32 AwardedFlagBit;                                                             // 0x0004 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 TotalRanking;                                                               // 0x000C (size: 0x4)
    int32 ClassRanking;                                                               // 0x0010 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0014 (size: 0x4)
    TArray<FSBDxBattleGameScore> ScoreList;                                           // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBDxBattleResultRanking
{
    TArray<FSBDxBattleResultRankingParam> TotalTopList;                               // 0x0000 (size: 0x10)
    TArray<FSBDxBattleResultRankingParam> MyClassTopList;                             // 0x0010 (size: 0x10)
    TArray<FSBDxBattleResultRankingParam> OtherClassTopList;                          // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBDxBattleResultRankingParam
{
    int32 RankingRank;                                                                // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString Name;                                                                     // 0x0008 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0018 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0019 (size: 0x3)
    int32 Level;                                                                      // 0x001C (size: 0x4)
    FString CharacterId;                                                              // 0x0020 (size: 0x10)
    float Contribution;                                                               // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBDxBattleSettingData
{
    FSBDxBattleMasterData MasterData;                                                 // 0x0000 (size: 0x88)
    FString TermId;                                                                   // 0x0088 (size: 0x10)
    TArray<FSBMasterReward> RewardList;                                               // 0x0098 (size: 0x10)
    bool IsRaidMasterSet;                                                             // 0x00A8 (size: 0x1)
    bool IsMapMasterSet;                                                              // 0x00A9 (size: 0x1)

}; // Size: 0xB0

struct FSBDxReward
{
    FSBDungeonClearAddRewardInfo RewardsBreakObject;                                  // 0x0000 (size: 0x88)
    FSBDungeonClearAddRewardInfo RewardsContribution;                                 // 0x0088 (size: 0x88)
    FSBDungeonClearAddRewardInfo RewardsRanking;                                      // 0x0110 (size: 0x88)
    FSBDungeonClearAddRewardInfo RewardsClassRanking;                                 // 0x0198 (size: 0x88)

}; // Size: 0x220

struct FSBDynamicTriggerData
{
    ESBAbilityDynamicTriggerType DynamicTriggerType;                                  // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    int64 BeginTimeTicks;                                                             // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBEdgeInfo : public FSBEdgeLocation
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

struct FSBEdgeLocation
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBEffectAsset : public FSBEffectSettingBase
{
    TSoftObjectPtr<UParticleSystem> Particle;                                         // 0x0050 (size: 0x28)
    TSoftObjectPtr<UNiagaraSystem> NiagaraSystem;                                     // 0x0078 (size: 0x28)
    TSoftClassPtr<ASBProjectileEffect> EffectActor;                                   // 0x00A0 (size: 0x28)
    TArray<TSoftClassPtr<AActor>> EffectActorList;                                    // 0x00C8 (size: 0x10)
    TSoftObjectPtr<UAkAudioEvent> Sound;                                              // 0x00D8 (size: 0x28)
    FAkEventVariables SoundParam;                                                     // 0x0100 (size: 0x40)
    TSoftObjectPtr<UAkAudioEvent> EndSound;                                           // 0x0140 (size: 0x28)
    FAkEventVariables EndSoundParam;                                                  // 0x0168 (size: 0x40)

}; // Size: 0x1A8

struct FSBEffectSetting : public FSBEffectSettingBase
{
    class UParticleSystem* Particle;                                                  // 0x0050 (size: 0x8)
    class UNiagaraSystem* NiagaraSystem;                                              // 0x0058 (size: 0x8)
    TSubclassOf<class ASBProjectileEffect> EffectActor;                               // 0x0060 (size: 0x8)
    TArray<class TSubclassOf<AActor>> EffectActorList;                                // 0x0068 (size: 0x10)
    class UAkAudioEvent* Sound;                                                       // 0x0078 (size: 0x8)
    FAkEventVariables SoundParam;                                                     // 0x0080 (size: 0x40)
    class UAkAudioEvent* EndSound;                                                    // 0x00C0 (size: 0x8)
    FAkEventVariables EndSoundParam;                                                  // 0x00C8 (size: 0x40)
    class UAkAudioEvent* CauserPlayerVoice;                                           // 0x0108 (size: 0x8)
    FAkEventVariables CauserPlayerVoiceParam;                                         // 0x0110 (size: 0x40)

}; // Size: 0x150

struct FSBEffectSettingBase
{
    TEnumAsByte<EEffectTarget> EffectTarget;                                          // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    float ParticleScale;                                                              // 0x000C (size: 0x4)
    FVector LocationOffset;                                                           // 0x0010 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x001C (size: 0xC)
    char padding_1[0x4];                                                              // 0x0028 (size: 0x4)
    uint8 bAttach;                                                                    // 0x002C (size: 0x1)
    uint8 bAbsoluteRotation;                                                          // 0x002C (size: 0x1)
    uint8 bDetachWhenDeactivate;                                                      // 0x002C (size: 0x1)
    uint8 bVisibleByHiddenSourceActor;                                                // 0x002C (size: 0x1)
    char padding_2[0x3];                                                              // 0x002D (size: 0x3)
    FName AttachPointName;                                                            // 0x0030 (size: 0x8)
    FName ActorParameterName;                                                         // 0x0038 (size: 0x8)
    uint8 bOverrideLightingChannels;                                                  // 0x0040 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0041 (size: 0x3)
    FLightingChannels OverrideLightingChannels;                                       // 0x0044 (size: 0x1)
    char padding_4[0x3];                                                              // 0x0045 (size: 0x3)
    uint8 bOverrideElementType;                                                       // 0x0048 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0049 (size: 0x3)
    ESBAttribute ElementType;                                                         // 0x004C (size: 0x1)
    ESBEffectVisibleType VisibleType;                                                 // 0x004D (size: 0x1)
    ESBEffectCullingType CullingType;                                                 // 0x004E (size: 0x1)

}; // Size: 0x50

struct FSBEffectShaderParameter
{
    ESBEffectShaderParamTarget Target;                                                // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    FName ScalarParameterName;                                                        // 0x000C (size: 0x8)
    float ScalarValue;                                                                // 0x0014 (size: 0x4)
    FName VectorParameterName;                                                        // 0x0018 (size: 0x8)
    FLinearColor VectorValue;                                                         // 0x0020 (size: 0x10)
    bool ApplyImmediately;                                                            // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBEffectiveImpotantStatusParam
{
    int16 AddHp;                                                                      // 0x0000 (size: 0x2)
    int16 AddPercentHp;                                                               // 0x0002 (size: 0x2)
    int16 AddStamina;                                                                 // 0x0004 (size: 0x2)
    int16 AddPercentStamina;                                                          // 0x0006 (size: 0x2)
    int16 AddSTR;                                                                     // 0x0008 (size: 0x2)
    int16 AddVIT;                                                                     // 0x000A (size: 0x2)
    int16 AddDEX;                                                                     // 0x000C (size: 0x2)
    int16 AddINT;                                                                     // 0x000E (size: 0x2)
    int16 AddMND;                                                                     // 0x0010 (size: 0x2)
    int16 AddAttackPower;                                                             // 0x0012 (size: 0x2)
    int8 AddPercentAttackPower;                                                       // 0x0014 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0015 (size: 0x1)
    int16 AddDefencePower;                                                            // 0x0016 (size: 0x2)
    int8 AddPercentDefencePower;                                                      // 0x0018 (size: 0x1)
    char padding_1[0x1];                                                              // 0x0019 (size: 0x1)
    int16 AddRecuperativePower;                                                       // 0x001A (size: 0x2)
    int16 AddCriticalHitRate;                                                         // 0x001C (size: 0x2)
    int16 AddCriticalHitPower;                                                        // 0x001E (size: 0x2)
    ESBInvincibleLevel InvincibleLevel;                                               // 0x0020 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0021 (size: 0x3)
    uint8 bSuperArmor;                                                                // 0x0024 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0025 (size: 0x3)
    int16 AddFireResist;                                                              // 0x0028 (size: 0x2)
    int16 AddIceResist;                                                               // 0x002A (size: 0x2)
    int16 AddThunderResist;                                                           // 0x002C (size: 0x2)
    int16 AddEarthResist;                                                             // 0x002E (size: 0x2)
    int16 AddLightResist;                                                             // 0x0030 (size: 0x2)
    int16 AddDarknessResist;                                                          // 0x0032 (size: 0x2)

}; // Size: 0x34

struct FSBEffectiveStatusAilment
{
    FSBBattleStatusMasterDataMediator MasterDataMediator;                             // 0x0000 (size: 0x70)
    TArray<uint8> AbilityUniqueHandles;                                               // 0x0070 (size: 0x10)
    uint8 bIsActive;                                                                  // 0x0080 (size: 0x1)
    uint8 bIsReserveDelete;                                                           // 0x0080 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0081 (size: 0x3)
    TWeakObjectPtr<class AActor> Invoker;                                             // 0x0084 (size: 0x8)
    uint8 EffectiveUniqueHandle;                                                      // 0x008C (size: 0x1)
    ESBAbilityRequestSource RequestSourceType;                                        // 0x008D (size: 0x1)
    char padding_1[0x2];                                                              // 0x008E (size: 0x2)
    int64 LimitTimeTicks;                                                             // 0x0090 (size: 0x8)
    char padding_2[0xC];                                                              // 0x0098 (size: 0xC)
    float InitRemainTime;                                                             // 0x00A4 (size: 0x4)
    TArray<class USBAbility*> Abilitys;                                               // 0x00A8 (size: 0x10)
    char padding_3[0x28];                                                             // 0x00B8 (size: 0x28)
    TArray<class USBAbilityCondition*> AbilityFinishConditions;                       // 0x00E0 (size: 0x10)
    char padding_4[0x38];                                                             // 0x00F0 (size: 0x38)
    ESkillActionPosition SkillPosition;                                               // 0x0128 (size: 0x1)

}; // Size: 0x130

struct FSBEffectiveStatusAilmentPriorityInfo
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBEffectiveStatusEffect
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

struct FSBEffectiveStatusParam
{
    int8 AddFireAttack;                                                               // 0x0034 (size: 0x1)
    int8 AddIceAttack;                                                                // 0x0035 (size: 0x1)
    int8 AddThunderAttack;                                                            // 0x0036 (size: 0x1)
    int8 AddEarthAttack;                                                              // 0x0037 (size: 0x1)
    int8 AddLightAttack;                                                              // 0x0038 (size: 0x1)
    int8 AddDarknessAttack;                                                           // 0x0039 (size: 0x1)
    char padding_0[0x6];                                                              // 0x003A (size: 0x6)
    TArray<FSBValueDataByID> AddElementAccumulationPowerList;                         // 0x0040 (size: 0x10)
    TArray<FSBValueDataByID> AddRacePowerList;                                        // 0x0050 (size: 0x10)
    TArray<FSBValueDataByID> AddAttributePowerList;                                   // 0x0060 (size: 0x10)
    TMap<FString, int16> AddEnemyIDPowerList;                                         // 0x0070 (size: 0x50)
    TMap<FString, int16> AddDungeonIDPowerList;                                       // 0x00C0 (size: 0x50)
    TMap<int32, int16> AddTacticalSkillIDPowerList;                                   // 0x0110 (size: 0x50)
    TArray<FSBValueDataByID> AddSkillPowerList;                                       // 0x0160 (size: 0x10)
    TArray<FSBValueDataByID> AddDamageAttackTypePowerList;                            // 0x0170 (size: 0x10)
    int16 IncAndDecGiveDamage;                                                        // 0x0180 (size: 0x2)
    int16 IncAndDecDamageRecieve;                                                     // 0x0182 (size: 0x2)
    char padding_1[0x4];                                                              // 0x0184 (size: 0x4)
    TArray<FSBValueDataByID> IncAndDecAttackTypeRecieveDamageList;                    // 0x0188 (size: 0x10)
    TArray<FSBValueDataByID> IncAndDecElementRecieveDamageList;                       // 0x0198 (size: 0x10)
    TArray<FSBValueDataByID> IncAndDecBattleImagineElementRecieveDamageList;          // 0x01A8 (size: 0x10)
    int16 IncAndDecDotDamage_Fire;                                                    // 0x01B8 (size: 0x2)
    int16 IncAndDecDotDamage_Thunder;                                                 // 0x01BA (size: 0x2)
    int16 IncAndDecDotTime_Light;                                                     // 0x01BC (size: 0x2)
    int16 IncAndDecDotDamage_Darkness;                                                // 0x01BE (size: 0x2)
    float IncAndDecDotRateToHP_Fire;                                                  // 0x01C0 (size: 0x4)
    float IncAndDecParalyzeInterval;                                                  // 0x01C4 (size: 0x4)
    int16 IncAndDecDarkIncidenceRate;                                                 // 0x01C8 (size: 0x2)
    char padding_2[0x6];                                                              // 0x01CA (size: 0x6)
    TArray<FSBValueDataByID> IncAndDecControlBadConditionList;                        // 0x01D0 (size: 0x10)
    TArray<FSBValueDataByID> IncAndDecStatusResistValueList;                          // 0x01E0 (size: 0x10)
    TArray<FName> InvalidAbilitys;                                                    // 0x01F0 (size: 0x10)
    TArray<ESBBattleEffectiveGroup> InvalidGroups;                                    // 0x0200 (size: 0x10)
    int16 IncAndDecMoveSpeed;                                                         // 0x0210 (size: 0x2)
    int16 IncAndDecJumpVelocity;                                                      // 0x0212 (size: 0x2)
    int16 IncAndDecResurrectionSpeed;                                                 // 0x0214 (size: 0x2)
    int16 IncAndDecStaminaRecovery;                                                   // 0x0216 (size: 0x2)
    int16 IncAndDecStaminaReduceCorrect;                                              // 0x0218 (size: 0x2)
    int16 IncAndDecStaminaByDodge;                                                    // 0x021A (size: 0x2)
    int16 IncAndDecStaminaByJump;                                                     // 0x021C (size: 0x2)
    int16 IncAndDecStaminaByDash;                                                     // 0x021E (size: 0x2)
    char padding_3[0x58];                                                             // 0x0220 (size: 0x58)
    int16 IncAndDecHateCalcMagnification;                                             // 0x0278 (size: 0x2)
    char padding_4[0x6];                                                              // 0x027A (size: 0x6)
    TArray<FSBValueDataByID> IncAndDecSkillRecastTimeList;                            // 0x0280 (size: 0x10)
    TArray<FSBValueDataByID> IncAndDecTacticalSkillIDRecastTimeList;                  // 0x0290 (size: 0x10)
    int16 IncAndDecSkillButtonChargeTime;                                             // 0x02A0 (size: 0x2)
    char padding_5[0x6];                                                              // 0x02A2 (size: 0x6)
    TArray<FSBStatusAlimentPointGravityConfig> GravityConfigList;                     // 0x02A8 (size: 0x10)
    char padding_6[0x4];                                                              // 0x02B8 (size: 0x4)
    float AddMagicPointWhenResurrectionPlayer;                                        // 0x02BC (size: 0x4)
    int16 GuardShieldDamage;                                                          // 0x02C0 (size: 0x2)
    int16 GuardSpecialGauge;                                                          // 0x02C2 (size: 0x2)
    int16 GuardReduceSkillRecastTime;                                                 // 0x02C4 (size: 0x2)
    int16 GuardReduceSpecialSkillRecastTime;                                          // 0x02C6 (size: 0x2)
    char padding_7[0x8];                                                              // 0x02C8 (size: 0x8)
    TArray<FSBValueDataByIDListData> AddElementAccumulationTacticalSkillIDPowerList;  // 0x02D0 (size: 0x10)
    class AActor* Owner;                                                              // 0x02E0 (size: 0x8)

}; // Size: 0x2E8

struct FSBEffectiveStatusProjectile
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBElementAmpOptionElementSetting
{
    ESBAttribute ElementType;                                                         // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FSBEffectAsset InActionEffect;                                                    // 0x0008 (size: 0x1A8)
    FDataTableRowHandle ProjectileHandle;                                             // 0x01B0 (size: 0x10)

}; // Size: 0x1C0

struct FSBElementAmpOptionLocationSetting
{
    FVector LocationOffset;                                                           // 0x0000 (size: 0xC)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FSBEffectAsset IdlingEffect;                                                      // 0x0010 (size: 0x1A8)

}; // Size: 0x1B8

struct FSBElementBurstBonusLevelSetting
{
    int32 BonusLevel;                                                                 // 0x0000 (size: 0x4)
    float NeedAccumAmount;                                                            // 0x0004 (size: 0x4)
    TMap<ESBAttribute, float> BurstEndDamageModifyRateList;                           // 0x0008 (size: 0x50)

}; // Size: 0x58

struct FSBElementDamageCondition
{
    float AccumDamage;                                                                // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    float StatusAilmentTimer;                                                         // 0x0008 (size: 0x4)
    char padding_1[0x1C];                                                             // 0x000C (size: 0x1C)
    float StatusAilmentHitPoint;                                                      // 0x0028 (size: 0x4)
    char padding_2[0x2];                                                              // 0x002C (size: 0x2)
    uint8 BurstBonusLevel;                                                            // 0x002E (size: 0x1)
    char padding_3[0x1];                                                              // 0x002F (size: 0x1)
    float BurstBonusTimer;                                                            // 0x0030 (size: 0x4)

}; // Size: 0x50

struct FSBElementDamageModifySetting
{
    ESBAttribute ElementType;                                                         // 0x0000 (size: 0x1)
    bool bModifyElementDamage;                                                        // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    float ElementDamage;                                                              // 0x0004 (size: 0x4)
    bool bModifyCalculationType;                                                      // 0x0008 (size: 0x1)
    ESBStunValueCalculation CalculationType;                                          // 0x0009 (size: 0x1)
    bool bModifyElementDamageModifyRate;                                              // 0x000A (size: 0x1)
    char padding_1[0x1];                                                              // 0x000B (size: 0x1)
    float ElementDamageModifyRate;                                                    // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBElementDamageSetting
{
    ESBAttribute ElementType;                                                         // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ElementValue;                                                               // 0x0004 (size: 0x4)
    float Damage;                                                                     // 0x0008 (size: 0x4)
    ESBStunValueCalculation CalculationType;                                          // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBElementHitEffectSetting
{
    FSBEffectSetting Hit;                                                             // 0x0000 (size: 0x150)
    FSBEffectSetting Melt;                                                            // 0x0150 (size: 0x150)
    FSBEffectSetting Break;                                                           // 0x02A0 (size: 0x150)
    FSBEffectSetting Muzzle;                                                          // 0x03F0 (size: 0x150)

}; // Size: 0x540

struct FSBElementResistanceCorrectionSetting
{
    ESBAttribute ElementType;                                                         // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float ResistanceCorrection;                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBElementResistanceSetting
{
    ESBAttribute ElementType;                                                         // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float ResistanceValue;                                                            // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBEmoteMasterData
{
    int32 EmoteId;                                                                    // 0x0000 (size: 0x4)
    FSBTextTableHash NameTextId;                                                      // 0x0004 (size: 0x4)
    int32 SortId;                                                                     // 0x0008 (size: 0x4)
    FSBTextTableHash LogTextMyselfTextId;                                             // 0x000C (size: 0x4)
    FSBTextTableHash LogTextOthersTextId;                                             // 0x0010 (size: 0x4)
    int32 InitialGrant;                                                               // 0x0014 (size: 0x4)
    FString TermId;                                                                   // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBEmotionInfo : public FTableRowBase
{
    int32 ID;                                                                         // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString Name;                                                                     // 0x0010 (size: 0x10)
    int32 SortNo;                                                                     // 0x0020 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0024 (size: 0x4)
    class UTexture2D* IconTexture;                                                    // 0x0028 (size: 0x8)
    int32 ReleasedFlag;                                                               // 0x0030 (size: 0x4)
    uint8 AadditionalInfoBitmask;                                                     // 0x0034 (size: 0x1)

}; // Size: 0x38

struct FSBEncryptNetSerializeID
{
    int32 ID;                                                                         // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBEnemyActionConsumeStamina
{
    float EndValue;                                                                   // 0x0000 (size: 0x4)
    float ComboValue;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBEnemyActionParamRecastTimeCheck
{
    FName EnemyActionName;                                                            // 0x0000 (size: 0x8)
    float NowRecastTime;                                                              // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBEnemyActionTable : public FSBEnemyActionTableRowBase
{
    float RecastTime;                                                                 // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    FDataTableRowHandle RecastStaminaSyncAction;                                      // 0x0028 (size: 0x10)
    int32 AvailableCount;                                                             // 0x0038 (size: 0x4)
    float Stamina;                                                                    // 0x003C (size: 0x4)
    float ChantTime;                                                                  // 0x0040 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0044 (size: 0x4)
    TSoftObjectPtr<UBlendSpaceBase> TurnMotion;                                       // 0x0048 (size: 0x28)

}; // Size: 0x70

struct FSBEnemyActionTableNormalMode : public FSBEnemyActionTableRowBase
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBEnemyActionTableRowBase : public FSCTActionTable
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBEnemyAppearanceData
{
    FName CharaBPId;                                                                  // 0x0000 (size: 0x8)
    FName MainInventoryId;                                                            // 0x0008 (size: 0x8)
    FName SubInventoryId;                                                             // 0x0010 (size: 0x8)
    float Scale;                                                                      // 0x0018 (size: 0x4)
    float Weight;                                                                     // 0x001C (size: 0x4)
    ESBEnemyReactionType DamageReactionType;                                          // 0x0020 (size: 0x1)
    bool bIsDamageReactionLefelDiff;                                                  // 0x0021 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0022 (size: 0x2)
    float ResistSlash;                                                                // 0x0024 (size: 0x4)
    float ResistThrust;                                                               // 0x0028 (size: 0x4)
    float ResistBlow;                                                                 // 0x002C (size: 0x4)
    float ResistRock;                                                                 // 0x0030 (size: 0x4)
    float ResistThunder;                                                              // 0x0034 (size: 0x4)
    float ResistFire;                                                                 // 0x0038 (size: 0x4)
    float ResistIce;                                                                  // 0x003C (size: 0x4)
    float ResistLight;                                                                // 0x0040 (size: 0x4)
    float ResistDarkness;                                                             // 0x0044 (size: 0x4)
    float ResistStun;                                                                 // 0x0048 (size: 0x4)
    float ResistPoison;                                                               // 0x004C (size: 0x4)
    float ResistSleep;                                                                // 0x0050 (size: 0x4)
    float ResistBerserk;                                                              // 0x0054 (size: 0x4)
    float ResistDark;                                                                 // 0x0058 (size: 0x4)
    float ResistBind;                                                                 // 0x005C (size: 0x4)
    float ResistPalsy;                                                                // 0x0060 (size: 0x4)
    float ResistDrain;                                                                // 0x0064 (size: 0x4)
    float ResistFlashStun;                                                            // 0x0068 (size: 0x4)
    FSBTextTableHash RaceId;                                                          // 0x006C (size: 0x4)
    int32 Attribute;                                                                  // 0x0070 (size: 0x4)

}; // Size: 0x74

struct FSBEnemyBattlePart
{
    TSubclassOf<class USBEnemyBattlePartTransition> TransitionClass;                  // 0x0000 (size: 0x8)
    FName ActivateModifierName;                                                       // 0x0008 (size: 0x8)
    int32 NextPartIndex;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBEnemyBattleStatusConditionalBias : public FTableRowBase
{
    float HitPoint;                                                                   // 0x0008 (size: 0x4)
    float AttackPower;                                                                // 0x000C (size: 0x4)
    float DefencePower;                                                               // 0x0010 (size: 0x4)
    float StaminaMax;                                                                 // 0x0014 (size: 0x4)
    float ElemDmgBias;                                                                // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBEnemyBattleStatusConditionalBiasList : public FTableRowBase
{
    TArray<FSBEnemyBattleStatusConditionalBias> BiasData;                             // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBEnemyChangeableMaterialInfo
{
    class UMaterialInterface* Material;                                               // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBEnemyChangedMaterialInfo
{
    int32 MaterialIndex;                                                              // 0x0000 (size: 0x4)
    int32 ChangeableMaterialInfoIndex;                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBEnemyChantEffectEmitInfo
{
    char padding_0[0x18];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x18

struct FSBEnemyChantEffectInfo
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

struct FSBEnemyChantEffectMotionStoredAddress
{
    TSoftObjectPtr<UASAnimationSet> MagicActionAnimationSet;                          // 0x0000 (size: 0x28)
    FName MotionKeyName;                                                              // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FSBEnemyChantMarkerInfo
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

struct FSBEnemyChantMarkerMinimumParams
{
    FSBEnemySkillMarkerSetting EnemySkillMarkerSetting;                               // 0x0000 (size: 0x30)
    FVector LocationOffset;                                                           // 0x0030 (size: 0xC)
    EMarkerTargetingType TargetingType;                                               // 0x003C (size: 0x1)
    char padding_0[0x3];                                                              // 0x003D (size: 0x3)
    FSBCharacterAdjustRootMotionSetupPicker AdjustRootMotionSetupPicker;              // 0x0040 (size: 0x10)
    int32 TargetIndex;                                                                // 0x0050 (size: 0x4)
    bool bIsFixedLocation;                                                            // 0x0054 (size: 0x1)
    EMarkerSizeType SizeType;                                                         // 0x0055 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0056 (size: 0x2)
    float SizeMargin;                                                                 // 0x0058 (size: 0x4)

}; // Size: 0x78

struct FSBEnemyChantMarkerParams : public FSBEnemyChantMarkerMinimumParams
{
    float WaitStartTime;                                                              // 0x0078 (size: 0x4)
    float LifeTime;                                                                   // 0x007C (size: 0x4)
    float WaitEndTime;                                                                // 0x0080 (size: 0x4)
    FRotator RotationOffset;                                                          // 0x0084 (size: 0xC)

}; // Size: 0x90

struct FSBEnemyChantMarkerParamsTable
{
    TArray<FSBEnemyChantMarkerParams> MarkerParamsList;                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBEnemyChantMarkerStruct
{
    FSBEnemyChantMarkerParams m_MarkerParams;                                         // 0x0008 (size: 0x90)
    char padding_0[0x18];                                                             // 0x0098 (size: 0x18)
    FVector m_AimLocation;                                                            // 0x00B0 (size: 0xC)
    char padding_1[0x1];                                                              // 0x00BC (size: 0x1)
    bool m_bMarkerOverlapped;                                                         // 0x00BD (size: 0x1)
    bool m_bTargetExist;                                                              // 0x00BE (size: 0x1)
    bool m_bShowMarker;                                                               // 0x00BF (size: 0x1)
    float m_MarkerRange;                                                              // 0x00C0 (size: 0x4)
    float m_MarkerLifeTime;                                                           // 0x00C4 (size: 0x4)
    float StartTime;                                                                  // 0x00C8 (size: 0x4)
    char padding_2[0x4];                                                              // 0x00CC (size: 0x4)
    uint64 RelatedProjectileUniqueID;                                                 // 0x00D0 (size: 0x8)
    char padding_3[0x2];                                                              // 0x00D8 (size: 0x2)
    MarkerState m_CurrentState;                                                       // 0x00DA (size: 0x1)
    bool bIsSettedClientMarkerStruct;                                                 // 0x00DB (size: 0x1)

}; // Size: 0xE0

struct FSBEnemyCharacterAnimInstanceProxy : public FSBCharacterAnimInstanceProxy
{
    char padding_0[0x840];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x840

struct FSBEnemyCommandSelector
{
    class UDataTable* ActionTable;                                                    // 0x0000 (size: 0x8)
    FString Command;                                                                  // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBEnemyCompoundPartsBreakInfo
{
    ESBPartsConditonLogic PartsConditionLogic;                                        // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBPartsBreakState> PartsConditions;                                       // 0x0008 (size: 0x10)
    TArray<FName> ModifierNames;                                                      // 0x0018 (size: 0x10)

}; // Size: 0x30

struct FSBEnemyDamageEventInfo
{
    ESBDamageAttackType AttackType;                                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 GroupId;                                                                    // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBEnemyData
{
    FName ContentId;                                                                  // 0x0000 (size: 0x8)
    FName EnemyId;                                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBEnemyDifficultyData : public FTableRowBase
{
    int32 StaminaMax;                                                                 // 0x0008 (size: 0x4)
    int32 StaminaRecoverySpeed;                                                       // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBEnemyDropItemData
{
    FName ContentId;                                                                  // 0x0000 (size: 0x8)
    ESBEnemyDropItemType Type;                                                        // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 LevelMin;                                                                   // 0x000C (size: 0x4)
    int32 LevelMax;                                                                   // 0x0010 (size: 0x4)
    ESBEnemyDropItemConditionType ConditionType;                                      // 0x0014 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0015 (size: 0x3)
    float DropRate;                                                                   // 0x0018 (size: 0x4)
    int32 ItemIndex;                                                                  // 0x001C (size: 0x4)
    int32 DropNumLv1;                                                                 // 0x0020 (size: 0x4)
    int32 DropNumLv100;                                                               // 0x0024 (size: 0x4)
    float DropNumCrv;                                                                 // 0x0028 (size: 0x4)
    int32 DropNumRnd;                                                                 // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBEnemyDungeonAttributeData : public FTableRowBase
{
    float ResistRock;                                                                 // 0x0008 (size: 0x4)
    float ResistThunder;                                                              // 0x000C (size: 0x4)
    float ResistFire;                                                                 // 0x0010 (size: 0x4)
    float ResistIce;                                                                  // 0x0014 (size: 0x4)
    float ResistLight;                                                                // 0x0018 (size: 0x4)
    float ResistDarkness;                                                             // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBEnemyDxBattleTableRow : public FTableRowBase
{
    FString Note;                                                                     // 0x0008 (size: 0x10)
    ESBEnemyWalkingMode GateWalkingMode;                                              // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    float InitialHitPointRate;                                                        // 0x001C (size: 0x4)
    float DeltaHitPointRate;                                                          // 0x0020 (size: 0x4)
    float Interval;                                                                   // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBEnemyExChantEffectEmitInfo
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBEnemyExpBonusScale
{
    float BaseScale;                                                                  // 0x0000 (size: 0x4)
    float PrivateScale;                                                               // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBEnemyExtraActionTable : public FTableRowBase
{
    float InitialRecastTime;                                                          // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBEnemyOverrideActionParam> OverrideActionParams;                         // 0x0010 (size: 0x10)
    FSBSpawnActionSetting SpawnActionSetting;                                         // 0x0020 (size: 0x30)
    FSBEnemyExtraSpawnActionSetting ExtraSpawnActionSetting;                          // 0x0050 (size: 0x8)

}; // Size: 0x58

struct FSBEnemyExtraSpawnActionSetting
{
    FName SpawnActionStanceName;                                                      // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBEnemyHabitatSettings
{
    FString EnemySetId;                                                               // 0x0000 (size: 0x10)
    FString EnemyId;                                                                  // 0x0010 (size: 0x10)
    int32 LevelMin;                                                                   // 0x0020 (size: 0x4)
    int32 LevelMax;                                                                   // 0x0024 (size: 0x4)
    float Weight;                                                                     // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FSBEnemyLevelParamData
{
    float HitPoint;                                                                   // 0x0000 (size: 0x4)
    float HitPointFactor;                                                             // 0x0004 (size: 0x4)
    float AttackPower;                                                                // 0x0008 (size: 0x4)
    float AttackPowerFactor;                                                          // 0x000C (size: 0x4)
    float DefencePower;                                                               // 0x0010 (size: 0x4)
    float DefencePowerFactor;                                                         // 0x0014 (size: 0x4)
    int32 ExpLv1;                                                                     // 0x0018 (size: 0x4)
    int32 ExpLv100;                                                                   // 0x001C (size: 0x4)
    float ExpCrv;                                                                     // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FSBEnemyLog
{
    FName EnemyId;                                                                    // 0x0000 (size: 0x8)
    int32 Num;                                                                        // 0x0008 (size: 0x4)

}; // Size: 0x20

struct FSBEnemyLogLocationCount
{
    FName AreaId;                                                                     // 0x0000 (size: 0x8)
    int32 Count;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBEnemyLookAtOutParam
{
    FSBLookAtCustomParam LookAtCustomParam;                                           // 0x0004 (size: 0x1C)

}; // Size: 0x20

struct FSBEnemyLvGapBiasCoefficients : public FTableRowBase
{
    int32 QualifyingLvGapMin;                                                         // 0x0008 (size: 0x4)
    int32 QualifyingLvGapMax;                                                         // 0x000C (size: 0x4)
    int32 DisqualifyingLvGapMax;                                                      // 0x0010 (size: 0x4)
    int32 DisqualifyingLvGapMin;                                                      // 0x0014 (size: 0x4)
    float DisqualifyingLvGapBiasWithSuperiorEnemy;                                    // 0x0018 (size: 0x4)
    float DisqualifyingLvGapBiasWithInferiorEnemy;                                    // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBEnemyLvGapBiasData : public FTableRowBase
{
    float Exp;                                                                        // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSBEnemyMaterialVisibilityFlag
{
    uint32 Flags;                                                                     // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBEnemyMaxSpawnNumData : public FTableRowBase
{
    int32 MaxSpawnNum;                                                                // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSBEnemyMeshData : public FTableRowBase
{
    TSoftObjectPtr<USkeletalMesh> Mesh;                                               // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBEnemyMinimumDamageData : public FTableRowBase
{
    FName AppearanceId;                                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBEnemyModifierRegisteredConfigInfo
{
    FName OverrideParentConfigName;                                                   // 0x000C (size: 0x8)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    class USBEnemyModifierTemplate_BlueprintBase* Modifier;                           // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBEnemyMtrlData : public FTableRowBase
{
    TSoftObjectPtr<UCharaPartsMaterialSet> Mtrl;                                      // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBEnemyMultiTargetInfo
{
    TArray<FSBEnemyTargetInfo> Elements;                                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBEnemyNotifyCastMagicEffectParams
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    FName SocketName;                                                                 // 0x0008 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0010 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x001C (size: 0xC)
    float Scale;                                                                      // 0x0028 (size: 0x4)
    bool bAttached;                                                                   // 0x002C (size: 0x1)
    bool bSetStartTimeWithProjectileStartTime;                                        // 0x002D (size: 0x1)
    char padding_0[0x2];                                                              // 0x002E (size: 0x2)
    float WaitStartTime;                                                              // 0x0030 (size: 0x4)
    bool bAdjustLifeTimeToProjectileSpawnNotify;                                      // 0x0034 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0035 (size: 0x3)
    float LifeTime;                                                                   // 0x0038 (size: 0x4)
    char padding_2[0x4];                                                              // 0x003C (size: 0x4)
    FAkEventVariables AkEventOnBegin;                                                 // 0x0040 (size: 0x40)
    bool bIsAkEventStopWhenDestroyed;                                                 // 0x0080 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0081 (size: 0x7)
    FAkEventVariables AkEventOnEnd;                                                   // 0x0088 (size: 0x40)
    FAkEventVariables AkEventOnCancel;                                                // 0x00C8 (size: 0x40)

}; // Size: 0x108

struct FSBEnemyNotifyCastMagicEffectParamsTable
{
    TArray<FSBEnemyNotifyCastMagicEffectParams> MagicParams;                          // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBEnemyOverrideActionParam
{
    FName ActionName;                                                                 // 0x0000 (size: 0x8)
    float RecastTime;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBEnemyPartsBreakInfo
{
    FName CollisionGroupName;                                                         // 0x0000 (size: 0x8)
    TArray<FSBEnemyPartsBreakInfoStep> Steps;                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBEnemyPartsBreakInfoStep
{
    float HpPer;                                                                      // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBEnemySpawnBrokenPartsInfo> SpawnParts;                                  // 0x0008 (size: 0x10)
    TArray<int32> OnMaterialIndexes;                                                  // 0x0018 (size: 0x10)
    TArray<int32> OffMaterialIndexes;                                                 // 0x0028 (size: 0x10)
    TArray<FSBPartsBreakEffectParams> Effects;                                        // 0x0038 (size: 0x10)
    TArray<FName> OffTargetableComponents;                                            // 0x0048 (size: 0x10)
    TArray<FName> OffCollisionComponents;                                             // 0x0058 (size: 0x10)
    TArray<class TSubclassOf<USBAICustom_Base>> AICustoms;                            // 0x0068 (size: 0x10)
    TArray<FName> ModifierNames;                                                      // 0x0078 (size: 0x10)
    float Delay;                                                                      // 0x0088 (size: 0x4)
    char padding_1[0x4];                                                              // 0x008C (size: 0x4)
    TArray<FName> IgnoreBoneNames;                                                    // 0x0090 (size: 0x10)

}; // Size: 0xA0

struct FSBEnemyPartsCollisionStates
{
    bool bIsActive;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    bool bIsActivatedWithPartsBreak;                                                  // 0x0008 (size: 0x1)
    bool bIsActivatedWithAction;                                                      // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FSBEnemyPartsTargetableState
{
    char padding_0[0x4];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x4

struct FSBEnemyPhaseChangeRuleExpression
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBEnemyPredictTargetProjectileInfo
{
    FDataTableRowHandle ProjectileHandle;                                             // 0x0000 (size: 0x10)
    FName SpawnSocketName;                                                            // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBEnemyProjectileChantEffectInfo
{
    TSubclassOf<class AActor> ChantEffect;                                            // 0x0000 (size: 0x8)
    FName SocketName;                                                                 // 0x0008 (size: 0x8)
    FVector PositionOffset;                                                           // 0x0010 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x001C (size: 0xC)
    float ScaleOffset;                                                                // 0x0028 (size: 0x4)
    bool bAttachToActor;                                                              // 0x002C (size: 0x1)

}; // Size: 0x30

struct FSBEnemyProjectileNotifyParam
{
    bool bUseLookAtVirtualSocket;                                                     // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FVector LookAtVirtualSocketSpownLocation;                                         // 0x0004 (size: 0xC)
    FVector LookAtVirtualSocketRotateLocation;                                        // 0x0010 (size: 0xC)

}; // Size: 0x1C

struct FSBEnemyReserveSlotNumData : public FTableRowBase
{
    int32 ChallangeQuestNum;                                                          // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSBEnemySetAssetData : public FTableRowBase
{
    TSoftObjectPtr<USBEnemySetAsset> EnemySet;                                        // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBEnemySetData
{
    FName EnemySetId;                                                                 // 0x0000 (size: 0x8)
    FName ActorTag;                                                                   // 0x0008 (size: 0x8)
    TArray<FSBEnemySetMemberData> Members;                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBEnemySetMemberData
{
    FName EnemyId;                                                                    // 0x0000 (size: 0x8)
    int32 MinLv;                                                                      // 0x0008 (size: 0x4)
    int32 MaxLv;                                                                      // 0x000C (size: 0x4)
    int32 ContentRatio;                                                               // 0x0010 (size: 0x4)
    int32 EnemyNum;                                                                   // 0x0014 (size: 0x4)
    FName ActorTag;                                                                   // 0x0018 (size: 0x8)
    int32 ReserveSlot;                                                                // 0x0020 (size: 0x4)
    FName SpawnAction;                                                                // 0x0024 (size: 0x8)
    FName TermId;                                                                     // 0x002C (size: 0x8)
    FName TermReplaceEnemy;                                                           // 0x0034 (size: 0x8)
    int32 InGameTime;                                                                 // 0x003C (size: 0x4)
    int32 ContentDifficulty;                                                          // 0x0040 (size: 0x4)

}; // Size: 0x44

struct FSBEnemySkillAsset_Base : public FTableRowBase
{
    FString AppearanceId;                                                             // 0x0008 (size: 0x10)
    FString UseId;                                                                    // 0x0018 (size: 0x10)
    float RecastTime;                                                                 // 0x0028 (size: 0x4)
    float Stamina;                                                                    // 0x002C (size: 0x4)
    int32 MinLevel;                                                                   // 0x0030 (size: 0x4)
    int32 MaxLevel;                                                                   // 0x0034 (size: 0x4)
    ESBEnemySkillActivationTrigger Trigger;                                           // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FSBEnemySkillAsset_Combo : public FSBEnemySkillAsset_Base
{
    FName ActivationTag;                                                              // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBEnemySkillAsset_ReactiveSkill : public FSBEnemySkillAsset_Base
{
    TSubclassOf<class UAIFwReactiveSkill> ReactiveSkill;                              // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBEnemySkillAsset_TacticalSkill : public FSBEnemySkillAsset_Base
{
    TSubclassOf<class USBAITacticalSkill> TacticalSkill;                              // 0x0040 (size: 0x8)
    int32 SABProbability;                                                             // 0x0048 (size: 0x4)

}; // Size: 0x50

struct FSBEnemySkillMarkerSetting
{
    TSubclassOf<class ASBSkillMarker> MarkerActor;                                    // 0x0000 (size: 0x8)
    uint8 bSetMarkerRadius;                                                           // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    float MarkerRadius;                                                               // 0x000C (size: 0x4)
    TEnumAsByte<ESBSkillMarkerPlace::Type> MarkerPlaceType;                           // 0x0010 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0011 (size: 0x3)
    float RangeMin;                                                                   // 0x0014 (size: 0x4)
    float RangeMax;                                                                   // 0x0018 (size: 0x4)
    float HeightRange;                                                                // 0x001C (size: 0x4)
    float MarkerColRadius;                                                            // 0x0020 (size: 0x4)
    float RotationSpeed;                                                              // 0x0024 (size: 0x4)
    bool bShowMarkerAnytime;                                                          // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FSBEnemySkillParamData
{
    FName ActionName;                                                                 // 0x0000 (size: 0x8)
    int32 RecastTime;                                                                 // 0x0008 (size: 0x4)
    int32 Stamina;                                                                    // 0x000C (size: 0x4)
    ESBEnemySkillType SkillType;                                                      // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 MinLv;                                                                      // 0x0014 (size: 0x4)
    int32 MaxLv;                                                                      // 0x0018 (size: 0x4)
    ESBEnemySkillActivationTrigger SkillActivationTrigger;                            // 0x001C (size: 0x1)
    char padding_1[0x3];                                                              // 0x001D (size: 0x3)
    TArray<FString> LimitedModifiers;                                                 // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBEnemySpawnBrokenPartsInfo
{
    TSoftClassPtr<AActor> SpawnActor;                                                 // 0x0000 (size: 0x28)
    FName SocketName;                                                                 // 0x0028 (size: 0x8)
    FVector SpawnLocationOffset;                                                      // 0x0030 (size: 0xC)
    FRotator SpawnRotationOffset;                                                     // 0x003C (size: 0xC)
    FRandVal Distance;                                                                // 0x0048 (size: 0x8)
    FRandVal Time;                                                                    // 0x0050 (size: 0x8)
    FRandVal Yaw;                                                                     // 0x0058 (size: 0x8)

}; // Size: 0x60

struct FSBEnemySpawnHabitat
{
    char padding_0[0x18];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x18

struct FSBEnemySpawnInfo
{
    int32 SpawnableEnemyNum;                                                          // 0x0000 (size: 0x4)
    int32 EmptySlotNum;                                                               // 0x0004 (size: 0x4)
    int32 ReservedSlotNum;                                                            // 0x0008 (size: 0x4)
    int32 UsingSlotNum;                                                               // 0x000C (size: 0x4)
    int32 SpawnedEnemyNum;                                                            // 0x0010 (size: 0x4)
    int32 EnemyCharacterNum;                                                          // 0x0014 (size: 0x4)
    int32 BuddyNum;                                                                   // 0x0018 (size: 0x4)
    int32 MokujinNum;                                                                 // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBEnemySpawnPoint
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBEnemyStanceSetting
{
    FName StanceName;                                                                 // 0x0000 (size: 0x8)
    TArray<FName> ActivateModifierNames;                                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBEnemyStateChangeKeyPair
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBEnemySummonInfo
{
    FString EnemyId;                                                                  // 0x0000 (size: 0x10)
    int32 Level;                                                                      // 0x0010 (size: 0x4)
    FVector Location;                                                                 // 0x0014 (size: 0xC)
    FRotator Rotation;                                                                // 0x0020 (size: 0xC)
    bool bAdjustLocation;                                                             // 0x002C (size: 0x1)
    char padding_0[0x3];                                                              // 0x002D (size: 0x3)
    FName SpawnActionName;                                                            // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FSBEnemyTargetInfo
{
    bool bIsValidLocation;                                                            // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FVector TargetLocation;                                                           // 0x0004 (size: 0xC)
    TWeakObjectPtr<class AActor> TargetActor;                                         // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBEnemyTypeData : public FTableRowBase
{
    TSoftClassPtr<ASBEnemyCharacter> EnemyClass;                                      // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBEnemyTypeSwitchTableRow : public FTableRowBase
{
    TArray<FString> EnemyTypeList;                                                    // 0x0008 (size: 0x10)
    FString SwitchGroup;                                                              // 0x0018 (size: 0x10)
    FString VoiceTypeList;                                                            // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBEnemyVoiceEventTableRow : public FTableRowBase
{
    class UAkAudioEvent* Event;                                                       // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBEnemyWarpEffectInfo
{
    class UParticleSystem* Particle;                                                  // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBEnemyWaveData
{
    FName EnemyWaveId;                                                                // 0x0000 (size: 0x8)
    TArray<FSBEnemyWaveStepData> Steps;                                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBEnemyWaveLocation
{
    ESBEnemyWaveLocationType Type;                                                    // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName AreaName;                                                                   // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FSBEnemyWaveRule
{
    ESBEnemyWaveRuleType Type;                                                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 RemainingCount;                                                             // 0x0004 (size: 0x4)
    float HPRate;                                                                     // 0x0008 (size: 0x4)
    FName EnemyTag;                                                                   // 0x000C (size: 0x8)

}; // Size: 0x14

struct FSBEnemyWaveSettings : public FTableRowBase
{
    TArray<FSBEnemyWaveSpawnSettings> Enemies;                                        // 0x0008 (size: 0x10)
    FSBEnemyWaveLocation Location;                                                    // 0x0018 (size: 0xC)
    FSBEnemyWaveRule Rule;                                                            // 0x0024 (size: 0x14)
    float Delay;                                                                      // 0x0038 (size: 0x4)
    FName Tag;                                                                        // 0x003C (size: 0x8)

}; // Size: 0x48

struct FSBEnemyWaveSettingsAssetData : public FTableRowBase
{
    TSoftObjectPtr<USBEnemyWaveSettingsAsset> EnemyWaveSettings;                      // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBEnemyWaveSpawnSettings
{
    FString EnemyId;                                                                  // 0x0000 (size: 0x10)
    int32 Level;                                                                      // 0x0010 (size: 0x4)
    int32 Num;                                                                        // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBEnemyWaveStepConditionData
{
    ESBEnemyWaveStepConditionType Type;                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName Tag;                                                                        // 0x0004 (size: 0x8)
    int32 ParamInt1;                                                                  // 0x000C (size: 0x4)
    int32 NextStep;                                                                   // 0x0010 (size: 0x4)
    float DelaySec;                                                                   // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBEnemyWaveStepData
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    FName EnemySetId;                                                                 // 0x0004 (size: 0x8)
    ESBEnemyWaveSpawnLocation SpawnLocation;                                          // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    FName IdentificationTag;                                                          // 0x0010 (size: 0x8)
    TArray<FSBEnemyWaveStepConditionData> Conditions;                                 // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBEngramInfo
{
    TSubclassOf<class AActor> Engram;                                                 // 0x0000 (size: 0x8)
    int32 ChargeValue;                                                                // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSBEntryAbilityData
{
    ESBAbrityType AbrityType;                                                         // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 AbrityId;                                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBEnvironmentWeaponEffect : public FSBPlayWeaponEffect
{
    TEnumAsByte<EEnvironmentType::Type> Type;                                         // 0x0278 (size: 0x1)

}; // Size: 0x280

struct FSBEquipWeapon : public FASEquipWeapon
{
    TEnumAsByte<ESBWeaponAttach> WeaponAttach;                                        // 0x0028 (size: 0x1)

}; // Size: 0x2C

struct FSBEquipmentSeries
{
    ESBEquipmentSeriesItemType ItemType;                                              // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 EquipmentId;                                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBEventEnemyDropMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString TermId;                                                                   // 0x0008 (size: 0x10)
    TArray<FSBEnemyData> EnemyList;                                                   // 0x0018 (size: 0x10)
    int32 EntryConditionId;                                                           // 0x0028 (size: 0x4)
    char padding_1[0x4];                                                              // 0x002C (size: 0x4)
    TArray<FSBEntryAbilityData> EntryAbilitySet;                                      // 0x0030 (size: 0x10)
    TArray<FSBDropData> DropList;                                                     // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBEventExecutorItem
{
    TWeakObjectPtr<class UObject> Receiver;                                           // 0x0000 (size: 0x8)
    FSBEventExecutorItemDelegate Delegate;                                            // 0x0008 (size: 0x10)
    void SBEventReceiverDelegate(class UObject* Sender, class UObject* Param);

}; // Size: 0x18

struct FSBEventExecutorItems
{
    TArray<FSBEventExecutorItem> List;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBEventExecutorSuspendedEventItem
{
    class UObject* Sender;                                                            // 0x0008 (size: 0x8)
    class UObject* Param;                                                             // 0x0010 (size: 0x8)

}; // Size: 0x20

struct FSBEventExecutorTypesDummy
{
    FSBEventExecutorTypesDummyDelegate Delegate;                                      // 0x0000 (size: 0x10)
    void SBEventReceiverDelegate(class UObject* Sender, class UObject* Param);

}; // Size: 0x10

struct FSBEventShopExchangeHistory
{
    int32 ShopId;                                                                     // 0x0000 (size: 0x4)
    int32 ProductId;                                                                  // 0x0004 (size: 0x4)
    int32 ExchangeNum;                                                                // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBEventShopItemMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 EventId;                                                                    // 0x0004 (size: 0x4)
    bool enable;                                                                      // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 ItemSetId;                                                                  // 0x000C (size: 0x4)
    FSBTextTableHash ItemName;                                                        // 0x0010 (size: 0x4)
    int32 SellType;                                                                   // 0x0014 (size: 0x4)
    int32 SortId;                                                                     // 0x0018 (size: 0x4)
    int32 NeedRank;                                                                   // 0x001C (size: 0x4)
    int32 CurrencyType;                                                               // 0x0020 (size: 0x4)
    int32 TokenID;                                                                    // 0x0024 (size: 0x4)
    int32 TokenAmount;                                                                // 0x0028 (size: 0x4)
    FSBTextTableHash ItemDescription;                                                 // 0x002C (size: 0x4)
    int32 TextureId;                                                                  // 0x0030 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0034 (size: 0x4)
    FDateTime StartDate;                                                              // 0x0038 (size: 0x8)
    FDateTime EndDate;                                                                // 0x0040 (size: 0x8)
    int32 ResetType;                                                                  // 0x0048 (size: 0x4)
    int32 ExchangeLimit;                                                              // 0x004C (size: 0x4)

}; // Size: 0x50

struct FSBEventShopItemSetMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 ProductId;                                                                  // 0x0004 (size: 0x4)
    int32 ItemType;                                                                   // 0x0008 (size: 0x4)
    int32 ItemId;                                                                     // 0x000C (size: 0x4)
    int32 UnitNum;                                                                    // 0x0010 (size: 0x4)
    int32 SortId;                                                                     // 0x0014 (size: 0x4)
    int32 Exp;                                                                        // 0x0018 (size: 0x4)
    int32 SubPerk1;                                                                   // 0x001C (size: 0x4)
    int32 SubPerk2;                                                                   // 0x0020 (size: 0x4)
    int32 SubPerk3;                                                                   // 0x0024 (size: 0x4)
    int32 SubPerk4;                                                                   // 0x0028 (size: 0x4)
    int32 SubPerk5;                                                                   // 0x002C (size: 0x4)
    int32 ColorId;                                                                    // 0x0030 (size: 0x4)

}; // Size: 0x34

struct FSBEventShopMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Type;                                                                       // 0x0004 (size: 0x4)
    int32 SortId;                                                                     // 0x0008 (size: 0x4)
    bool Order;                                                                       // 0x000C (size: 0x1)
    bool enable;                                                                      // 0x000D (size: 0x1)
    char padding_0[0x2];                                                              // 0x000E (size: 0x2)
    TSoftObjectPtr<UTexture2D> Banner;                                                // 0x0010 (size: 0x28)
    FDateTime StartDate;                                                              // 0x0038 (size: 0x8)
    FDateTime EndDate;                                                                // 0x0040 (size: 0x8)
    TArray<int32> TokenList;                                                          // 0x0048 (size: 0x10)

}; // Size: 0x58

struct FSBEventShopProduct
{
    int32 MasterId;                                                                   // 0x0000 (size: 0x4)
    int32 EventId;                                                                    // 0x0004 (size: 0x4)
    int32 ItemSetId;                                                                  // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString ItemName;                                                                 // 0x0010 (size: 0x10)
    int32 SellType;                                                                   // 0x0020 (size: 0x4)
    int32 SortId;                                                                     // 0x0024 (size: 0x4)
    int32 NeedRank;                                                                   // 0x0028 (size: 0x4)
    int32 CurrencyType;                                                               // 0x002C (size: 0x4)
    int32 TokenID;                                                                    // 0x0030 (size: 0x4)
    int32 TokenAmount;                                                                // 0x0034 (size: 0x4)
    FString ItemDescription;                                                          // 0x0038 (size: 0x10)
    int32 TextureId;                                                                  // 0x0048 (size: 0x4)
    char padding_1[0x4];                                                              // 0x004C (size: 0x4)
    FDateTime StartDate;                                                              // 0x0050 (size: 0x8)
    FDateTime EndDate;                                                                // 0x0058 (size: 0x8)
    int32 ResetType;                                                                  // 0x0060 (size: 0x4)
    int32 ExchangeLimit;                                                              // 0x0064 (size: 0x4)
    int32 StockNum;                                                                   // 0x0068 (size: 0x4)
    bool IsAchieve;                                                                   // 0x006C (size: 0x1)
    bool CanBeLearned;                                                                // 0x006D (size: 0x1)

}; // Size: 0x70

struct FSBEventShopPurchaseItemInfo
{
    int32 MasterIndex;                                                                // 0x0000 (size: 0x4)
    int32 ItemIndex;                                                                  // 0x0004 (size: 0x4)
    int32 ItemAmount;                                                                 // 0x0008 (size: 0x4)
    int32 TokenIndex;                                                                 // 0x000C (size: 0x4)
    int32 TokenPrice;                                                                 // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FString ItemName;                                                                 // 0x0018 (size: 0x10)
    int32 NumOfProducts;                                                              // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FSBEventShopRealGoodsMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 CampaignId;                                                                 // 0x0004 (size: 0x4)
    FSBTextTableHash ProductNameTextId;                                               // 0x0008 (size: 0x4)
    FSBTextTableHash ProductDescTextId;                                               // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBEventTermVirtualDateTimeParam
{
    char padding_0[0x18];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x18

struct FSBEventTermsChecker
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

struct FSBEventTermsData
{
    FDateTime StartTime;                                                              // 0x0000 (size: 0x8)
    FDateTime EndTime;                                                                // 0x0008 (size: 0x8)
    int32 onDaysStart;                                                                // 0x0010 (size: 0x4)
    int32 onDaysEnd;                                                                  // 0x0014 (size: 0x4)
    FTimespan onHoursStart;                                                           // 0x0018 (size: 0x8)
    FTimespan onHoursEnd;                                                             // 0x0020 (size: 0x8)
    int32 onWeekDayBit;                                                               // 0x0028 (size: 0x4)
    ESBEventTermsCheckType CheckType;                                                 // 0x002C (size: 0x1)
    ESBEventTermsDateType DateCheckType;                                              // 0x002D (size: 0x1)
    bool HourCheck;                                                                   // 0x002E (size: 0x1)

}; // Size: 0x30

struct FSBEventTermsMasterData
{
    FString TermId;                                                                   // 0x0000 (size: 0x10)
    TArray<FSBEventTermsData> Terms;                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBEventTrigger : public FTableRowBase
{
    class USBScriptAsset* ScriptAsset;                                                // 0x0008 (size: 0x8)
    TArray<FSBEventTriggerCondition> Conditions;                                      // 0x0010 (size: 0x10)
    TArray<FSBEventTriggerCloseCondition> CloseConditions;                            // 0x0020 (size: 0x10)

}; // Size: 0x38

struct FSBEventTriggerCloseCondition
{
    ESBEventTriggerCloseConditionType Type;                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName QuestID;                                                                    // 0x0004 (size: 0x8)
    int32 Step;                                                                       // 0x000C (size: 0x4)
    EQuestStatus Status;                                                              // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FSBEventTriggerCondition
{
    ESBEventTriggerConditionType Type;                                                // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Value1;                                                                   // 0x0008 (size: 0x10)
    FString Value2;                                                                   // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBExchangeItemLogInfo
{
    FString ShopId;                                                                   // 0x0000 (size: 0x10)
    int32 ProductId;                                                                  // 0x0010 (size: 0x4)
    int32 ItemId;                                                                     // 0x0014 (size: 0x4)
    int32 ExchangeCount;                                                              // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBExitEffectParams
{
    FName EffectAttachPointName;                                                      // 0x0000 (size: 0x8)
    FVector EffectActorScale;                                                         // 0x0008 (size: 0xC)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    TArray<class UParticleSystem*> ParticleEffects;                                   // 0x0018 (size: 0x10)
    TArray<TSoftClassPtr<AActor>> EffectActors;                                       // 0x0028 (size: 0x10)
    TArray<FAkEventVariables> ExitAkEvents;                                           // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBExpiredEquipmentCharacterCreationData
{
    FString HatName;                                                                  // 0x0000 (size: 0x10)
    FString UpperName;                                                                // 0x0010 (size: 0x10)
    FString LowerName;                                                                // 0x0020 (size: 0x10)
    FString GlovesName;                                                               // 0x0030 (size: 0x10)
    FString ShoesName;                                                                // 0x0040 (size: 0x10)
    FString UnderwearName;                                                            // 0x0050 (size: 0x10)
    FString AccessoryHeadTopName;                                                     // 0x0060 (size: 0x10)
    FString AccessoryHeadMidName;                                                     // 0x0070 (size: 0x10)
    FString AccessoryHeadLowName;                                                     // 0x0080 (size: 0x10)
    FString AccessoryHeadEarName;                                                     // 0x0090 (size: 0x10)
    FString AccessoryRightFingerName;                                                 // 0x00A0 (size: 0x10)
    FString AccessoryLeftFingerName;                                                  // 0x00B0 (size: 0x10)
    FString AccessoryEngagementName;                                                  // 0x00C0 (size: 0x10)
    FString AccessoryBodyBackName;                                                    // 0x00D0 (size: 0x10)
    FString AccessoryHipBackName;                                                     // 0x00E0 (size: 0x10)

}; // Size: 0xF0

struct FSBExpiredEquipmentData
{
    TArray<FSBDecayedWeaponData> DecayedWeapons;                                      // 0x0000 (size: 0x10)
    TArray<FSBDeletedCostumeData> DeletedCostumes;                                    // 0x0010 (size: 0x10)
    TArray<FSBDeletedImagineData> DeletedImagines;                                    // 0x0020 (size: 0x10)
    TArray<FSBDeletedMountData> DeletedMounts;                                        // 0x0030 (size: 0x10)
    FSBExpiredEquipmentCharacterCreationData CharacterCreationData;                   // 0x0040 (size: 0xF0)

}; // Size: 0x130

struct FSBExpiredToken
{
    FString UserId;                                                                   // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)
    int32 TokenID;                                                                    // 0x0020 (size: 0x4)
    int32 ExpiredAmount;                                                              // 0x0024 (size: 0x4)
    FDateTime RegisteDate;                                                            // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FSBExpiredTokenStates
{
    TArray<FSBExpiredToken> ExpiredStates;                                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBExplosionParams
{
    float ExplosionDelay;                                                             // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle ExplosionHandle;                                              // 0x0008 (size: 0x10)
    FSBProjectileSelectHandle ExplosionSelectHandle;                                  // 0x0018 (size: 0x18)
    ESBExplosionBarrelDamage ExplosionBarrelDamage;                                   // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBExtraCurveForce
{
    FVector PhysicsForce;                                                             // 0x0000 (size: 0xC)
    FVector PhysicsExternalForceDir;                                                  // 0x000C (size: 0xC)
    FRuntimeFloatCurve PhysicsExternalVelocityCurve;                                  // 0x0018 (size: 0x88)
    FVector PhysicsAngularForce;                                                      // 0x00A0 (size: 0xC)
    FVector PhysicsExternalAngularForceDir;                                           // 0x00AC (size: 0xC)
    FRuntimeFloatCurve PhysicsExternalAngularVelocityCurve;                           // 0x00B8 (size: 0x88)

}; // Size: 0x150

struct FSBExtraExpParse
{
    int32 Before;                                                                     // 0x0000 (size: 0x4)
    int32 Added;                                                                      // 0x0004 (size: 0x4)
    int32 After;                                                                      // 0x0008 (size: 0x4)
    FSBCharacterToken Token;                                                          // 0x000C (size: 0xC)

}; // Size: 0x18

struct FSBFAGatherPointLotResult
{
    int32 ItemUniqueId;                                                               // 0x0000 (size: 0x4)
    int32 Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBFaceBlendParameter
{
    float Smile;                                                                      // 0x0000 (size: 0x4)
    float Sad;                                                                        // 0x0004 (size: 0x4)
    float Anger;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBFacilityIconStatusConditionSetting
{
    EFacilityIconStatus Status;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBFieldStatusConditionItem> ConditionItems;                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBFacilityIconStatusSetting
{
    EFacilityIconStatus DefaultStatus;                                                // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBFacilityIconStatusConditionSetting> ConditionSettings;                  // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBFangTokenMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBTokenEffectType EffectType;                                                    // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 EffectValue;                                                                // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBFang_expeditionAreaData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString AreaName;                                                                 // 0x0010 (size: 0x10)
    int32 Category;                                                                   // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    FString Category2;                                                                // 0x0028 (size: 0x10)
    int32 MaxMountNum;                                                                // 0x0038 (size: 0x4)
    int32 SortId;                                                                     // 0x003C (size: 0x4)
    bool Rare;                                                                        // 0x0040 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0041 (size: 0x3)
    int32 TermId;                                                                     // 0x0044 (size: 0x4)
    int32 Level;                                                                      // 0x0048 (size: 0x4)
    int32 NowExp;                                                                     // 0x004C (size: 0x4)
    int32 NextExp;                                                                    // 0x0050 (size: 0x4)
    float ShorteningEffect;                                                           // 0x0054 (size: 0x4)
    int32 ExpeditionCount;                                                            // 0x0058 (size: 0x4)
    FVector2D IconPosition;                                                           // 0x005C (size: 0x8)
    char padding_2[0x4];                                                              // 0x0064 (size: 0x4)
    FString RequesterName;                                                            // 0x0068 (size: 0x10)
    FString RequestDetailText;                                                        // 0x0078 (size: 0x10)
    TArray<FSBFang_expeditionTimeData> TimeData;                                      // 0x0088 (size: 0x10)
    TArray<FSBFang_expeditionLimitData> LimitData;                                    // 0x0098 (size: 0x10)

}; // Size: 0xA8

struct FSBFang_expeditionData
{
    TArray<FSBFang_expeditionAreaData> AreaData;                                      // 0x0000 (size: 0x10)
    TArray<FSBFang_expeditionPlayData> PlayData;                                      // 0x0010 (size: 0x10)
    int32 ExpeditionSlotMax;                                                          // 0x0020 (size: 0x4)
    bool IsRareOpen;                                                                  // 0x0024 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0025 (size: 0x3)
    int32 RareTimeStack;                                                              // 0x0028 (size: 0x4)
    int32 RemainingCancel;                                                            // 0x002C (size: 0x4)
    int32 ExpeditionSlotOpenCount;                                                    // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBFang_expeditionIconData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString Field;                                                                    // 0x0008 (size: 0x10)
    FVector2D Pos;                                                                    // 0x0018 (size: 0x8)
    TArray<FString> AreaIdList;                                                       // 0x0020 (size: 0x10)
    TArray<int32> StatusList;                                                         // 0x0030 (size: 0x10)
    TArray<FString> PlayIdList;                                                       // 0x0040 (size: 0x10)
    bool NewIconFlag;                                                                 // 0x0050 (size: 0x1)
    bool TimeIconFlag;                                                                // 0x0051 (size: 0x1)

}; // Size: 0x58

struct FSBFang_expeditionLimitData
{
    ESBFang_expeditionLimitType Type;                                                 // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Condition;                                                                // 0x0008 (size: 0x10)
    bool ClearFlag;                                                                   // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBFang_expeditionPlayData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString MasterId;                                                                 // 0x0010 (size: 0x10)
    ESBFang_expeditionStatus Status;                                                  // 0x0020 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0021 (size: 0x7)
    FDateTime EndTime;                                                                // 0x0028 (size: 0x8)
    TArray<int32> Exp;                                                                // 0x0030 (size: 0x10)
    TArray<int32> UseTokenIds;                                                        // 0x0040 (size: 0x10)
    TArray<FString> MountUniqueIds;                                                   // 0x0050 (size: 0x10)
    TArray<FString> RewardIds;                                                        // 0x0060 (size: 0x10)
    bool CanImmediate;                                                                // 0x0070 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0071 (size: 0x7)
    FSBFang_expeditionAreaData AreaData;                                              // 0x0078 (size: 0xA8)

}; // Size: 0x120

struct FSBFang_expeditionRandomRewardData
{
    FSBMasterReward Reward;                                                           // 0x0000 (size: 0x14)
    float Weight;                                                                     // 0x0014 (size: 0x4)
    int32 TypeCount;                                                                  // 0x0018 (size: 0x4)
    float Lottery;                                                                    // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBFang_expeditionRandomRewardListData
{
    int32 TypeCount;                                                                  // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBFang_expeditionRandomRewardData> List;                                  // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBFang_expeditionRewardData
{
    TArray<FSBMasterReward> CertaintyReward;                                          // 0x0000 (size: 0x10)
    TArray<FSBFang_expeditionRandomRewardListData> RandomReward;                      // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBFang_expeditionSplitData
{
    TArray<FSBFang_expeditionAreaData> AreaData;                                      // 0x0000 (size: 0x10)
    int32 Number;                                                                     // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBFang_expeditionTimeData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    int32 BaseTime;                                                                   // 0x0010 (size: 0x4)
    int32 Exp;                                                                        // 0x0014 (size: 0x4)
    int32 MaxAddNum;                                                                  // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    FSBFang_expeditionRewardData Reward;                                              // 0x0020 (size: 0x20)

}; // Size: 0x40

struct FSBFang_expeditionTokenData
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

struct FSBFeatureSetting
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FName Feature_Id;                                                                 // 0x0004 (size: 0x8)
    bool Enabled;                                                                     // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    FName Version;                                                                    // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBFieldStatusConditionChallengeQuest
{
    FName QuestID;                                                                    // 0x0000 (size: 0x8)
    ESBFieldStatusChallengeQuestSettingType Setting;                                  // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBFieldStatusConditionDungeonActivateFlag
{
    FName DungeonId;                                                                  // 0x0000 (size: 0x8)
    bool bFlagValue;                                                                  // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBFieldStatusConditionDungeonCompleteFlag
{
    FName DungeonId;                                                                  // 0x0000 (size: 0x8)
    bool bFlagValue;                                                                  // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBFieldStatusConditionEventTerm
{
    FName ID;                                                                         // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBFieldStatusConditionEventTermStatus
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    ESBEventTermCheckNormalStatus Status;                                             // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBFieldStatusConditionItem
{
    ESBFieldStatusConditionType ConditionType;                                        // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FSBFieldStatusConditionQuestStatus QuestStatus;                                   // 0x0008 (size: 0x20)
    FSBFieldStatusConditionScenarioFlag ScenarioFlag;                                 // 0x0028 (size: 0x18)
    FSBFieldStatusConditionResearchTeam ResearchTeam;                                 // 0x0040 (size: 0x10)
    FSBFieldStatusConditionEventTerm EventTerm;                                       // 0x0050 (size: 0x8)
    FSBFieldStatusConditionEventTermStatus EventTermStatus;                           // 0x0058 (size: 0xC)
    FSBFieldStatusConditionChallengeQuest ChallengeQuest;                             // 0x0064 (size: 0xC)
    FSBFieldStatusConditionQuestConditionItem QuestConditionItem;                     // 0x0070 (size: 0x10)
    FSBFieldStatusConditionDungeonActivateFlag DungeonActivateFlag;                   // 0x0080 (size: 0xC)
    FSBFieldStatusConditionDungeonCompleteFlag DungeonCompleteFlag;                   // 0x008C (size: 0xC)

}; // Size: 0x98

struct FSBFieldStatusConditionQuestConditionItem
{
    FName QuestID;                                                                    // 0x0000 (size: 0x8)
    int32 ConditionItemId;                                                            // 0x0008 (size: 0x4)
    bool bIsCompleted;                                                                // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBFieldStatusConditionQuestStatus
{
    FName QuestID;                                                                    // 0x0000 (size: 0x8)
    EQuestStatus QuestStatus;                                                         // 0x0008 (size: 0x1)
    bool bSetProgress;                                                                // 0x0009 (size: 0x1)
    char padding_0[0x6];                                                              // 0x000A (size: 0x6)
    FString QuestStep;                                                                // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBFieldStatusConditionResearchTeam
{
    FString ID;                                                                       // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBFieldStatusConditionScenarioFlag
{
    FDataTableRowHandle FlagHandle;                                                   // 0x0000 (size: 0x10)
    bool bFlagValue;                                                                  // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBFieldStatusConditionSetting
{
    EFieldStatus Status;                                                              // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBFieldStatusConditionItem> ConditionItems;                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBFieldStatusSetting : public FTableRowBase
{
    EFieldStatus DefaultStatus;                                                       // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TArray<FSBFieldStatusConditionSetting> ConditionSettings;                         // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBFireBurnerFireShot
{
    FSBPlayingEffect PlayingEffect;                                                   // 0x0030 (size: 0xC8)
    FSBPlayingEffect PlayingFireStringEffect;                                         // 0x00F8 (size: 0xC8)

}; // Size: 0x240

struct FSBFishData : public FTableRowBase
{
    FString FishName;                                                                 // 0x0008 (size: 0x10)
    FString FishDescription;                                                          // 0x0018 (size: 0x10)
    class USkeletalMesh* Mesh;                                                        // 0x0028 (size: 0x8)
    class UMaterial* Material;                                                        // 0x0030 (size: 0x8)
    class UAnimationAsset* Animation;                                                 // 0x0038 (size: 0x8)
    class USBTextTableAsset* TextTableAsset;                                          // 0x0040 (size: 0x8)
    int32 FishNameTextId;                                                             // 0x0048 (size: 0x4)
    int32 FishDescriptionTextId;                                                      // 0x004C (size: 0x4)
    float ScaleMin;                                                                   // 0x0050 (size: 0x4)
    float ScaleMax;                                                                   // 0x0054 (size: 0x4)
    float Length;                                                                     // 0x0058 (size: 0x4)
    float Stamina;                                                                    // 0x005C (size: 0x4)
    float Speed;                                                                      // 0x0060 (size: 0x4)
    float BreakTimeMin;                                                               // 0x0064 (size: 0x4)
    float BreakTimeMax;                                                               // 0x0068 (size: 0x4)
    float TiredTimeMin;                                                               // 0x006C (size: 0x4)
    float TiredTimeMax;                                                               // 0x0070 (size: 0x4)
    float TiredRate;                                                                  // 0x0074 (size: 0x4)
    float WiggleStrength;                                                             // 0x0078 (size: 0x4)
    float WiggleSpeed;                                                                // 0x007C (size: 0x4)
    ESBFishRarityClassId RarityClassId;                                               // 0x0080 (size: 0x1)
    ESBFishScaleClassId ScaleClassId;                                                 // 0x0081 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0082 (size: 0x6)
    TArray<FSBFishRarityItem> RarityItemArray;                                        // 0x0088 (size: 0x10)

}; // Size: 0x98

struct FSBFishDebugParam
{
    bool bCheatCheck;                                                                 // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString FishId;                                                                   // 0x0008 (size: 0x10)
    float FishRarity;                                                                 // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBFishDisplayInfo
{
    bool UploadSuccess;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 RetCode;                                                                    // 0x0004 (size: 0x4)
    FString FishId;                                                                   // 0x0008 (size: 0x10)
    FString ItemName;                                                                 // 0x0018 (size: 0x10)
    float Length;                                                                     // 0x0028 (size: 0x4)
    int32 Amount;                                                                     // 0x002C (size: 0x4)
    bool NewFish;                                                                     // 0x0030 (size: 0x1)
    bool NewRecord;                                                                   // 0x0031 (size: 0x1)

}; // Size: 0x38

struct FSBFishGameInfoPerPlayer
{
    int32 PositionId;                                                                 // 0x0000 (size: 0x4)
    FName FishId;                                                                     // 0x0004 (size: 0x8)
    float Rarity;                                                                     // 0x000C (size: 0x4)
    FDateTime FishFightStartTime;                                                     // 0x0010 (size: 0x8)
    class AActor* FishingFishActor;                                                   // 0x0018 (size: 0x8)
    FSBFishDebugParam FishDebugParam;                                                 // 0x0020 (size: 0x20)

}; // Size: 0x40

struct FSBFishLotInfoTable : public FTableRowBase
{
    float BlueDevil;                                                                  // 0x0008 (size: 0x4)
    float ScorpionFish;                                                               // 0x000C (size: 0x4)
    float PufferFish;                                                                 // 0x0010 (size: 0x4)
    float JackMackerel;                                                               // 0x0014 (size: 0x4)
    float Skipjack;                                                                   // 0x0018 (size: 0x4)
    float AnglerFish;                                                                 // 0x001C (size: 0x4)
    float Marlin;                                                                     // 0x0020 (size: 0x4)
    float ItemBox;                                                                    // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBFishLotWeightInfo
{
    char padding_0[0xC];                                                              // 0x0000 (size: 0x0)
}; // Size: 0xC

struct FSBFishRarityItem
{
    float RarityLimit;                                                                // 0x0000 (size: 0x4)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBFishingItemLotInfo
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    int32 ItemAmount;                                                                 // 0x0004 (size: 0x4)
    float ItemLotRate;                                                                // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString Descript;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBFishingItemLotTable : public FTableRowBase
{
    TArray<FSBFishingItemLotInfo> InfoArray;                                          // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBFlatShopItemMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 ShopId;                                                                     // 0x0004 (size: 0x4)
    int32 IsEnabled;                                                                  // 0x0008 (size: 0x4)
    int32 ShopItemId;                                                                 // 0x000C (size: 0x4)
    FSBTextTableHash ItemName;                                                        // 0x0010 (size: 0x4)
    int32 ItemPosition;                                                               // 0x0014 (size: 0x4)
    int32 SortId;                                                                     // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    TArray<int32> CategoryId;                                                         // 0x0020 (size: 0x10)
    bool UseCoupon;                                                                   // 0x0030 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0031 (size: 0x3)
    int32 PurchaseLimitId;                                                            // 0x0034 (size: 0x4)
    int32 FluctuationCount;                                                           // 0x0038 (size: 0x4)
    int32 NextId;                                                                     // 0x003C (size: 0x4)
    int32 ViewType;                                                                   // 0x0040 (size: 0x4)
    FSBTextTableHash ItemDescription;                                                 // 0x0044 (size: 0x4)
    int32 TextureId;                                                                  // 0x0048 (size: 0x4)
    int32 BonusId;                                                                    // 0x004C (size: 0x4)
    FName MailFormatId;                                                               // 0x0050 (size: 0x8)
    int32 Ribbon;                                                                     // 0x0058 (size: 0x4)
    int32 PeriodRibbon;                                                               // 0x005C (size: 0x4)
    FDateTime StartDate;                                                              // 0x0060 (size: 0x8)
    FDateTime EndDate;                                                                // 0x0068 (size: 0x8)
    int32 CautionGender;                                                              // 0x0070 (size: 0x4)

}; // Size: 0x78

struct FSBFlatShopItemSetMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 ShopItemId;                                                                 // 0x0004 (size: 0x4)
    int32 ItemType;                                                                   // 0x0008 (size: 0x4)
    int32 ItemId;                                                                     // 0x000C (size: 0x4)
    int32 ItemCount;                                                                  // 0x0010 (size: 0x4)
    int32 SortId;                                                                     // 0x0014 (size: 0x4)
    int32 MaxRerity;                                                                  // 0x0018 (size: 0x4)
    int32 Rerity;                                                                     // 0x001C (size: 0x4)
    int32 Exp;                                                                        // 0x0020 (size: 0x4)
    int32 SubPerk1;                                                                   // 0x0024 (size: 0x4)
    int32 SubPerk2;                                                                   // 0x0028 (size: 0x4)
    int32 SubPerk3;                                                                   // 0x002C (size: 0x4)
    int32 SubPerk4;                                                                   // 0x0030 (size: 0x4)
    int32 SubPerk5;                                                                   // 0x0034 (size: 0x4)
    int32 ColorId;                                                                    // 0x0038 (size: 0x4)

}; // Size: 0x3C

struct FSBFlatShopPurchaseLimitMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 LimitId;                                                                    // 0x0004 (size: 0x4)
    int32 FluctuationCount;                                                           // 0x0008 (size: 0x4)
    int32 ConditionId;                                                                // 0x000C (size: 0x4)
    int32 Price;                                                                      // 0x0010 (size: 0x4)
    int32 LimitCount;                                                                 // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBFoliageCollisionReaction : public FTableRowBase
{
    TSoftObjectPtr<UStaticMesh> MeshPtr;                                              // 0x0008 (size: 0x28)
    TSoftObjectPtr<UMaterialInterface> MaterialOverride;                              // 0x0030 (size: 0x28)
    class UAkAudioEvent* AudioEvent;                                                  // 0x0058 (size: 0x8)
    class UParticleSystem* Particle;                                                  // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FSBFoliageCollisionResult
{
    class UAkAudioEvent* AudioEvent;                                                  // 0x0000 (size: 0x8)
    class UParticleSystem* Particle;                                                  // 0x0008 (size: 0x8)
    FTransform Transform;                                                             // 0x0010 (size: 0x30)

}; // Size: 0x40

struct FSBFoliageParticleInstance
{
    class UParticleSystem* ParticleSystem;                                            // 0x0000 (size: 0x8)
    int32 ParticleTypeId;                                                             // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FTransform Transform;                                                             // 0x0010 (size: 0x30)
    float SpawnDistanceSq;                                                            // 0x0040 (size: 0x4)
    float DestroyDistanceSq;                                                          // 0x0044 (size: 0x4)
    class UParticleSystemComponent* ParticleObject;                                   // 0x0048 (size: 0x8)

}; // Size: 0x50

struct FSBFoliageParticleType
{
    class UStaticMesh* Mesh;                                                          // 0x0000 (size: 0x8)
    class UMaterialInterface* MaterialOverride;                                       // 0x0008 (size: 0x8)
    class UParticleSystem* Particle;                                                  // 0x0010 (size: 0x8)
    FVector Offset;                                                                   // 0x0018 (size: 0xC)
    bool bRotation;                                                                   // 0x0024 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0025 (size: 0x3)
    float Distance;                                                                   // 0x0028 (size: 0x4)
    int32 Count;                                                                      // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBFoliageReactionData
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    FVector Velocity;                                                                 // 0x000C (size: 0xC)
    float HalfHeight;                                                                 // 0x0018 (size: 0x4)
    float Radius;                                                                     // 0x001C (size: 0x4)
    float Strength;                                                                   // 0x0020 (size: 0x4)
    float Center;                                                                     // 0x0024 (size: 0x4)
    float Peak;                                                                       // 0x0028 (size: 0x4)
    float BrushScale;                                                                 // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBFoliageReactionNotify
{
    FName SocketName;                                                                 // 0x0000 (size: 0x8)
    FSBFoliageReactionSpawn SpawnParams;                                              // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBFoliageReactionPreset : public FTableRowBase
{
    float StartRadius;                                                                // 0x0008 (size: 0x4)
    float EndRadius;                                                                  // 0x000C (size: 0x4)
    float StartStrength;                                                              // 0x0010 (size: 0x4)
    float EndStrength;                                                                // 0x0014 (size: 0x4)
    float HalfHeight;                                                                 // 0x0018 (size: 0x4)
    float Center;                                                                     // 0x001C (size: 0x4)
    float Peak;                                                                       // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBFoliageReactionSpawn
{
    FVector LocationOffset;                                                           // 0x0000 (size: 0xC)
    float StartDelay;                                                                 // 0x000C (size: 0x4)
    float LifeTime;                                                                   // 0x0010 (size: 0x4)
    float Scale;                                                                      // 0x0014 (size: 0x4)
    FDataTableRowHandle DataPreset;                                                   // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBFoliageSoundInstance
{
    int32 SoundTypeId;                                                                // 0x0008 (size: 0x4)
    FVector Location;                                                                 // 0x000C (size: 0xC)
    float Scale;                                                                      // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    class UAkComponent* AkComponent;                                                  // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSBFoliageSoundType
{
    class UStaticMesh* Mesh;                                                          // 0x0000 (size: 0x8)
    class UAkAudioEvent* AudioStart;                                                  // 0x0008 (size: 0x8)
    FVector Offset;                                                                   // 0x0010 (size: 0xC)
    int32 Count;                                                                      // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBFootPrintDecal
{
    TWeakObjectPtr<class UDecalComponent> m_DecalComponent;                           // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FSBFootprintSideSocket
{
    EFootPrintSide FootprintSide;                                                     // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName SocketName;                                                                 // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FSBFootprintSoundAdditionalSwitchSetting
{
    FString SwitchGroup;                                                              // 0x0000 (size: 0x10)
    FString SwitchState;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBFootprintSoundSetting
{
    TSoftObjectPtr<UAkAudioEvent> Sound;                                              // 0x0000 (size: 0x28)
    float DelayTime;                                                                  // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FSBFreeBuffNpcSpawnParameter
{
    FName ProfileDataId;                                                              // 0x0000 (size: 0x8)
    FSBNpcSpawnPointSettings SpawnSettings;                                           // 0x0008 (size: 0x110)
    FSBNpcScriptInfo ScriptInfo;                                                      // 0x0118 (size: 0x28)

}; // Size: 0x140

struct FSBFreeBuffPlayerBuffTimeInfo
{
    ESBFreeBuffPointType BuffType;                                                    // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FDateTime EndBuffTime;                                                            // 0x0008 (size: 0x8)
    bool IsActivate;                                                                  // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBFreeBuffPointEntryInfo
{
    TSubclassOf<class ASBFieldActorFreeBuffPoint> TargetClass;                        // 0x0000 (size: 0x8)
    FString ObjectId;                                                                 // 0x0008 (size: 0x10)
    FString Tag;                                                                      // 0x0018 (size: 0x10)
    char padding_0[0x8];                                                              // 0x0028 (size: 0x8)
    FTransform Transform;                                                             // 0x0030 (size: 0x30)
    ESBFreeBuffPointType Type;                                                        // 0x0060 (size: 0x1)
    ESBFreeBuffPointView PointView;                                                   // 0x0061 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0062 (size: 0x2)
    int32 FreeBuffPointId;                                                            // 0x0064 (size: 0x4)
    bool IsReturnCity;                                                                // 0x0068 (size: 0x1)
    bool IsInteracted;                                                                // 0x0069 (size: 0x1)
    char padding_2[0x2];                                                              // 0x006A (size: 0x2)
    FName NpcSpawnerTag;                                                              // 0x006C (size: 0x8)
    bool bDebugSpawn;                                                                 // 0x0074 (size: 0x1)

}; // Size: 0x80

struct FSBFreeBuffPointRespawnInfo
{
    FString WorldName;                                                                // 0x0000 (size: 0x10)
    int32 FreeBuffPointId;                                                            // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FDateTime EndBuffTime;                                                            // 0x0018 (size: 0x8)
    bool PickupAtOnce;                                                                // 0x0020 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0021 (size: 0x7)
    FString EntriedObjectId;                                                          // 0x0028 (size: 0x10)
    FString EntriedTag;                                                               // 0x0038 (size: 0x10)
    bool IsReturnCity;                                                                // 0x0048 (size: 0x1)
    bool IsInteracted;                                                                // 0x0049 (size: 0x1)
    char padding_2[0x6];                                                              // 0x004A (size: 0x6)
    bool RespawnInterval;                                                             // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FSBFreeBuffPointServerInfo : public FTableRowBase
{
    int32 object_id;                                                                  // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString Tag;                                                                      // 0x0010 (size: 0x10)
    FString map_id;                                                                   // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBFusionCostMasterData
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    int32 Cost;                                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBFusionPerkPickMasterData
{
    int32 LotteryGroupId;                                                             // 0x0000 (size: 0x4)
    int32 MinValue;                                                                   // 0x0004 (size: 0x4)
    int32 MaxValue;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBFusionTicketMasterData
{
    int32 TokenID;                                                                    // 0x0000 (size: 0x4)
    int32 NeedCount;                                                                  // 0x0004 (size: 0x4)
    int32 Level;                                                                      // 0x0008 (size: 0x4)
    ESBFusionTicketType TicketType;                                                   // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBFusionTicketMasterStorage
{
    ESBFusionTicketType Type;                                                         // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBFusionTicketMasterData> Data;                                           // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBGameModeInfo : public FTableRowBase
{
    FName UiType;                                                                     // 0x0008 (size: 0x8)
    ESBPlayGameMode PlayGameMode;                                                     // 0x0010 (size: 0x1)
    bool bDungeon;                                                                    // 0x0011 (size: 0x1)
    bool bPvpMode;                                                                    // 0x0012 (size: 0x1)
    bool bInstanceArea;                                                               // 0x0013 (size: 0x1)
    bool bTimeProgression;                                                            // 0x0014 (size: 0x1)
    bool bFieldBagAccessible;                                                         // 0x0015 (size: 0x1)
    ESBInventoryAccessType InventoryAccessType;                                       // 0x0016 (size: 0x1)
    bool bTalkModeFull;                                                               // 0x0017 (size: 0x1)
    bool bMovableAfterResult;                                                         // 0x0018 (size: 0x1)
    ESBDungeonMatchMenuRegisterType MatchMenuRegisterType;                            // 0x0019 (size: 0x1)
    ESBContentExitTravelTarget DefaultExitTravel;                                     // 0x001A (size: 0x1)
    char padding_0[0x1];                                                              // 0x001B (size: 0x1)
    FName DeathPenaltyStatusAilmentName;                                              // 0x001C (size: 0x8)
    float DeathPenaltyStatusAilmentTime;                                              // 0x0024 (size: 0x4)
    bool IsBackfillAllowed;                                                           // 0x0028 (size: 0x1)
    bool IsJoinMiddle;                                                                // 0x0029 (size: 0x1)
    ESBGameModeStartMode StartMode;                                                   // 0x002A (size: 0x1)

}; // Size: 0x30

struct FSBGamePadSettings
{
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Dash;                                   // 0x0000 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> AutoRun;                                // 0x0001 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Jump;                                   // 0x0002 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> MainAction;                             // 0x0003 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> SubAction;                              // 0x0004 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> LeftSkill;                              // 0x0005 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> RightSkill;                             // 0x0006 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Skill1;                                 // 0x0007 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Skill2;                                 // 0x0008 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Skill3;                                 // 0x0009 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Skill4;                                 // 0x000A (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> SpecialSkill;                           // 0x000B (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Dodge;                                  // 0x000C (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Interaction;                            // 0x000D (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Reload;                                 // 0x000E (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ImagineArts;                            // 0x000F (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ImagineArts2;                           // 0x0010 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ImagineMount;                           // 0x0011 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> CameraZoomIn;                           // 0x0012 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> CameraZoomOut;                          // 0x0013 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> CameraReset;                            // 0x0014 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> LockOn;                                 // 0x0015 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutExec;                           // 0x0016 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutMoveLeft;                       // 0x0017 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutMoveRight;                      // 0x0018 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Function;                               // 0x0019 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Function2;                              // 0x001A (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> MainMenu;                               // 0x001B (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ChatWindow;                             // 0x001C (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRing;                           // 0x001D (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRingExeF5;                      // 0x001E (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRingExeF6;                      // 0x001F (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRingExeF7;                      // 0x0020 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRingExeF8;                      // 0x0021 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRingExeF9;                      // 0x0022 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRingExeF10;                     // 0x0023 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRingExeF11;                     // 0x0024 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> ShortcutRingExeF12;                     // 0x0025 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> WholeMap;                               // 0x0026 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Pushpin;                                // 0x0027 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> PhotoMode;                              // 0x0028 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> Screenshot;                             // 0x0029 (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> QAHUD;                                  // 0x002A (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> QuestHudChange;                         // 0x002B (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> KeyGuide;                               // 0x002C (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> SkillPaletteChange;                     // 0x002D (size: 0x1)
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> NowParty;                               // 0x002E (size: 0x1)
    char padding_0[0x1];                                                              // 0x002F (size: 0x1)
    float LeftStickInputThresholdX;                                                   // 0x0030 (size: 0x4)
    float LeftStickInputStrengthX;                                                    // 0x0034 (size: 0x4)
    float LeftStickInputThresholdY;                                                   // 0x0038 (size: 0x4)
    float LeftStickInputStrengthY;                                                    // 0x003C (size: 0x4)
    float RightStickInputThresholdX;                                                  // 0x0040 (size: 0x4)
    float RightStickInputStrengthX;                                                   // 0x0044 (size: 0x4)
    float RightStickInputThresholdY;                                                  // 0x0048 (size: 0x4)
    float RightStickInputStrengthY;                                                   // 0x004C (size: 0x4)
    float CameraSpeedRateYaw;                                                         // 0x0050 (size: 0x4)
    float CameraSpeedRatePitch;                                                       // 0x0054 (size: 0x4)
    float AimAssist_FitTargetStrength;                                                // 0x0058 (size: 0x4)
    float AimAssist_FollowTargetStrength;                                             // 0x005C (size: 0x4)
    float AimAssist_CameraBrakeStrength;                                              // 0x0060 (size: 0x4)
    uint8 bSwitchAnalogStick;                                                         // 0x0064 (size: 0x1)
    uint8 bReverseCameraPitch;                                                        // 0x0064 (size: 0x1)
    uint8 bReverseCameraYaw;                                                          // 0x0064 (size: 0x1)

}; // Size: 0x88

struct FSBGameServerPartyInfo
{
    ESBPartyType PartyType;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString PartyId;                                                                  // 0x0008 (size: 0x10)
    FString LeaderId;                                                                 // 0x0018 (size: 0x10)
    TArray<FSBGameServerPartyMemberInfo> Members;                                     // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBGameServerPartyMemberInfo
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)
    FString CharacterName;                                                            // 0x0020 (size: 0x10)
    bool bIsInvited;                                                                  // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBGameSettingsMasterData
{
    ESBGameSettingsType ID;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 Setting_Value;                                                              // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBGameTime
{
    int32 Hour;                                                                       // 0x0004 (size: 0x4)
    int32 Minute;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBGashaBonus
{
    int32 ItemSetId;                                                                  // 0x0000 (size: 0x4)
    FSBGashaItem ItemInfo;                                                            // 0x0004 (size: 0xC)
    int32 UniqueId;                                                                   // 0x0010 (size: 0x4)
    int32 Num;                                                                        // 0x0014 (size: 0x4)
    int32 Limit;                                                                      // 0x0018 (size: 0x4)
    int32 Step;                                                                       // 0x001C (size: 0x4)
    int32 Lap;                                                                        // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FSBGashaBonusListInfo
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString TermStart;                                                                // 0x0010 (size: 0x10)
    FString TermEnd;                                                                  // 0x0020 (size: 0x10)
    int32 RepeatNum;                                                                  // 0x0030 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0034 (size: 0x4)
    TArray<FSBGashaBonus> ItemList;                                                   // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBGashaCategory
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString Name;                                                                     // 0x0008 (size: 0x10)
    int32 RibbonFlag;                                                                 // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBGashaExpectDemoLotteryData : public FTableRowBase
{
    ESBGashaExpectDemoType DemoType;                                                  // 0x0008 (size: 0x1)
    ESBGashaDemoRank DemoRank;                                                        // 0x0009 (size: 0x1)
    char padding_0[0x2];                                                              // 0x000A (size: 0x2)
    float Probability;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBGashaInfo
{
    FString GashaId;                                                                  // 0x0000 (size: 0x10)
    int32 ID;                                                                         // 0x0010 (size: 0x4)
    int32 SortId;                                                                     // 0x0014 (size: 0x4)
    FString Title;                                                                    // 0x0018 (size: 0x10)
    FString Desc;                                                                     // 0x0028 (size: 0x10)
    FString DetailDesc;                                                               // 0x0038 (size: 0x10)
    FString WarningComment;                                                           // 0x0048 (size: 0x10)
    int32 CategoryId;                                                                 // 0x0058 (size: 0x4)
    char padding_0[0x4];                                                              // 0x005C (size: 0x4)
    FString Category;                                                                 // 0x0060 (size: 0x10)
    FString Tags;                                                                     // 0x0070 (size: 0x10)
    int32 Type;                                                                       // 0x0080 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0084 (size: 0x4)
    FString Banner;                                                                   // 0x0088 (size: 0x10)
    FString SimpleBanner;                                                             // 0x0098 (size: 0x10)
    FString GashaStart;                                                               // 0x00A8 (size: 0x10)
    FString GashaEnd;                                                                 // 0x00B8 (size: 0x10)
    FDateTime GashaEndDate;                                                           // 0x00C8 (size: 0x8)
    TArray<FSBGashaPrices> Prices;                                                    // 0x00D0 (size: 0x10)
    TArray<FSBGashaTickets> Tickets;                                                  // 0x00E0 (size: 0x10)
    int32 Gender;                                                                     // 0x00F0 (size: 0x4)
    char padding_2[0x4];                                                              // 0x00F4 (size: 0x4)
    FSBGashaBonusListInfo BonusListInfo;                                              // 0x00F8 (size: 0x48)
    int32 RibbonFlag;                                                                 // 0x0140 (size: 0x4)
    bool PaidOnly;                                                                    // 0x0144 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0145 (size: 0x3)
    FString GroupId;                                                                  // 0x0148 (size: 0x10)
    int32 GroupStep;                                                                  // 0x0158 (size: 0x4)
    int32 StepNow;                                                                    // 0x015C (size: 0x4)
    int32 StepMax;                                                                    // 0x0160 (size: 0x4)
    int32 LapCount;                                                                   // 0x0164 (size: 0x4)
    int32 PlayCount;                                                                  // 0x0168 (size: 0x4)
    int32 TotalPlayCount;                                                             // 0x016C (size: 0x4)
    bool IsNextGasha;                                                                 // 0x0170 (size: 0x1)
    char padding_4[0x7];                                                              // 0x0171 (size: 0x7)
    FSBGashaBonusListInfo CurrencyBonusListInfo;                                      // 0x0178 (size: 0x48)
    int32 CurrencyTotalPlayCount;                                                     // 0x01C0 (size: 0x4)

}; // Size: 0x1C8

struct FSBGashaItem
{
    int32 ItemType;                                                                   // 0x0000 (size: 0x4)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    int32 Amount;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBGashaPlayCount
{
    FString GashaId;                                                                  // 0x0000 (size: 0x10)
    int32 ID;                                                                         // 0x0010 (size: 0x4)
    int32 Count;                                                                      // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBGashaPrices
{
    int32 CurrencyType;                                                               // 0x0000 (size: 0x4)
    int32 PriceOfOne;                                                                 // 0x0004 (size: 0x4)
    int32 BulkPrice;                                                                  // 0x0008 (size: 0x4)
    int32 Amount;                                                                     // 0x000C (size: 0x4)
    FString Comment;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBGashaPullInfo
{
    FString GashaId;                                                                  // 0x0000 (size: 0x10)
    int32 ID;                                                                         // 0x0010 (size: 0x4)
    int32 BeforeCount;                                                                // 0x0014 (size: 0x4)
    int32 AfterCount;                                                                 // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    FSBGashaReceipt Receipts;                                                         // 0x0020 (size: 0x20)
    TArray<FSBGashaReward> Rewards;                                                   // 0x0040 (size: 0x10)
    TArray<FSBGashaBonus> Bonus;                                                      // 0x0050 (size: 0x10)
    int32 StepNext;                                                                   // 0x0060 (size: 0x4)
    int32 CurrencyAfterCount;                                                         // 0x0064 (size: 0x4)

}; // Size: 0x68

struct FSBGashaRankUpDemoLotteryData : public FTableRowBase
{
    ESBRarity BeforeRarity;                                                           // 0x0008 (size: 0x1)
    ESBRarity AfterRarity;                                                            // 0x0009 (size: 0x1)
    char padding_0[0x2];                                                              // 0x000A (size: 0x2)
    float Probability;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBGashaReceipt
{
    TArray<FSBGashaReceiptDiff> Currency;                                             // 0x0000 (size: 0x10)
    TArray<FSBGashaReceiptDiff> Tickets;                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBGashaReceiptDiff
{
    int32 Type;                                                                       // 0x0000 (size: 0x4)
    int32 Before;                                                                     // 0x0004 (size: 0x4)
    int32 After;                                                                      // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FDateTime ExpiredAt;                                                              // 0x0010 (size: 0x8)
    bool IsExpired;                                                                   // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBGashaResultData
{
    TArray<FSBGashaResultItemData> Items;                                             // 0x0000 (size: 0x10)
    ESBGashaDemoRank DemoRank_GashaStart;                                             // 0x0010 (size: 0x1)
    ESBGashaDemoRank DemoRank_Character;                                              // 0x0011 (size: 0x1)
    ESBGashaDemoRank DemoRank_GashaMachine;                                           // 0x0012 (size: 0x1)

}; // Size: 0x18

struct FSBGashaResultItemData
{
    EItemType ItemType;                                                               // 0x0000 (size: 0x1)
    ESBRewardItemType RewardItemType;                                                 // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    ESBRarity Rarity;                                                                 // 0x0008 (size: 0x1)
    ESBRarity DemoRarity;                                                             // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FSBGashaReward
{
    int32 SortId;                                                                     // 0x0000 (size: 0x4)
    int32 Rarity;                                                                     // 0x0004 (size: 0x4)
    float Wight;                                                                      // 0x0008 (size: 0x4)
    int32 ItemSetId;                                                                  // 0x000C (size: 0x4)
    FSBGashaItem ItemInfo;                                                            // 0x0010 (size: 0xC)
    int32 Step;                                                                       // 0x001C (size: 0x4)
    bool IsConfirm;                                                                   // 0x0020 (size: 0x1)
    bool IsTicketGasha;                                                               // 0x0021 (size: 0x1)

}; // Size: 0x24

struct FSBGashaTickets
{
    int32 TokenID;                                                                    // 0x0000 (size: 0x4)
    int32 PriceOfOne;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBGashaVoiceData : public FTableRowBase
{
    FDataTableRowHandle GroupHandle;                                                  // 0x0008 (size: 0x10)
    float LotteryRate;                                                                // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    FSoftObjectPath VoiceEvent;                                                       // 0x0020 (size: 0x18)

}; // Size: 0x38

struct FSBGashaVoiceGroupData : public FTableRowBase
{
    FName GroupId;                                                                    // 0x0008 (size: 0x8)
    FString TermId;                                                                   // 0x0010 (size: 0x10)
    float LotteryRate;                                                                // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBGatherLotConfig
{
    int32 ItemUniqueId;                                                               // 0x0000 (size: 0x4)
    int32 ItemNum;                                                                    // 0x0004 (size: 0x4)
    int32 LotRate;                                                                    // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBGatherPointConfig : public FTableRowBase
{
    int32 AreaId;                                                                     // 0x0008 (size: 0x4)
    FName AreaName;                                                                   // 0x000C (size: 0x8)
    int32 MaxSpawnNum;                                                                // 0x0014 (size: 0x4)
    TArray<FSBGatherLotConfig> LotArray;                                              // 0x0018 (size: 0x10)
    int32 MinSecondSpawnTime;                                                         // 0x0028 (size: 0x4)
    int32 MaxSecondSpawnTime;                                                         // 0x002C (size: 0x4)
    bool EnableLimitedSpawn;                                                          // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    int32 StartSpawnTime;                                                             // 0x0034 (size: 0x4)
    int32 EndSpawnTime;                                                               // 0x0038 (size: 0x4)
    int32 MaxInteractionNum;                                                          // 0x003C (size: 0x4)

}; // Size: 0x40

struct FSBGatherPointEntryInfo
{
    TSubclassOf<class ASBFieldActorGatherPoint> TargetClass;                          // 0x0000 (size: 0x8)
    FString ObjectId;                                                                 // 0x0008 (size: 0x10)
    FString Tag;                                                                      // 0x0018 (size: 0x10)
    EGatherHeight Position;                                                           // 0x0028 (size: 0x1)
    TEnumAsByte<EPhysicalSurface> GatherSoundSurface;                                 // 0x0029 (size: 0x1)
    char padding_0[0x6];                                                              // 0x002A (size: 0x6)
    FTransform Transform;                                                             // 0x0030 (size: 0x30)
    ESBTreasureBoxRarity GatherRarity;                                                // 0x0060 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0061 (size: 0x3)
    int32 GatherPointId;                                                              // 0x0064 (size: 0x4)
    bool bDebugSpawn;                                                                 // 0x0068 (size: 0x1)
    bool IsFiexedRespawn;                                                             // 0x0069 (size: 0x1)
    bool IsReturnCity;                                                                // 0x006A (size: 0x1)
    bool IsGathered;                                                                  // 0x006B (size: 0x1)

}; // Size: 0x70

struct FSBGatherPointLotSimulateResult
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)
    int32 Count;                                                                      // 0x0008 (size: 0x4)
    ESBTreasureBoxRewardType Type;                                                    // 0x000C (size: 0x1)
    ESBTreasureBoxRarity GatherRarity;                                                // 0x000D (size: 0x1)

}; // Size: 0x10

struct FSBGatherPointRespawnInfo
{
    FString WorldName;                                                                // 0x0000 (size: 0x10)
    int32 GatherPointId;                                                              // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FDateTime RespawnTime;                                                            // 0x0018 (size: 0x8)
    bool PickupAtOnce;                                                                // 0x0020 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0021 (size: 0x7)
    FString EntriedObjectId;                                                          // 0x0028 (size: 0x10)
    FString EntriedTag;                                                               // 0x0038 (size: 0x10)
    bool IsFiexedRespawn;                                                             // 0x0048 (size: 0x1)
    bool IsReturnCity;                                                                // 0x0049 (size: 0x1)
    bool IsGathered;                                                                  // 0x004A (size: 0x1)
    char padding_2[0x5];                                                              // 0x004B (size: 0x5)
    bool RespawnInterval;                                                             // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FSBGlobalRepTargetInfo
{
    class AActor* Actor;                                                              // 0x0000 (size: 0x8)

}; // Size: 0x28

struct FSBGrassSoundCountInfo
{
    char padding_0[0xC];                                                              // 0x0000 (size: 0x0)
}; // Size: 0xC

struct FSBGrassSoundEventList : public FTableRowBase
{
    FName ID;                                                                         // 0x0008 (size: 0x8)
    class UAkAudioEvent* AudioEvent;                                                  // 0x0010 (size: 0x8)
    int32 Threshold;                                                                  // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBGrassSoundMeshList : public FTableRowBase
{
    FName ID;                                                                         // 0x0008 (size: 0x8)
    TSoftObjectPtr<UStaticMesh> MeshPtr;                                              // 0x0010 (size: 0x28)
    float Priority;                                                                   // 0x0038 (size: 0x4)

}; // Size: 0x40

struct FSBGuardEffectSetting
{
    float NeedDurabilityRate;                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FSBEffectAsset GuardActiveEffect;                                                 // 0x0008 (size: 0x1A8)
    FSBEffectAsset GuardSuccessEffect;                                                // 0x01B0 (size: 0x1A8)
    FSBEffectAsset GuardBreakEffect;                                                  // 0x0358 (size: 0x1A8)
    FSBEffectAsset GuardEndEffect;                                                    // 0x0500 (size: 0x1A8)

}; // Size: 0x6A8

struct FSBGuardKnockBackSetting : public FSBHitKnockBackSetting
{
    float ShieldDamageRate;                                                           // 0x0018 (size: 0x4)
    ESBGuardKnockBackPower GuardKnockBackPower;                                       // 0x001C (size: 0x1)

}; // Size: 0x20

struct FSBHUDLayoutDatas
{
    TMap<class FString, class FVector2D> LayoutData;                                  // 0x0000 (size: 0x50)
    TMap<class FString, class FAnchors> LayoutAnchors;                                // 0x0050 (size: 0x50)
    TMap<FString, int32> LayoutZOrder;                                                // 0x00A0 (size: 0x50)

}; // Size: 0xF0

struct FSBHUDLayoutWindowSizeDatas
{
    TMap<class FString, class FVector2D> SizeData;                                    // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSBHappyNappo
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString Tag;                                                                      // 0x0010 (size: 0x10)
    FString game_content_id;                                                          // 0x0020 (size: 0x10)
    int32 nappo_num;                                                                  // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBHintShowStatusData
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    TArray<bool> bIsShowedArray;                                                      // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBHintShowStatusTable
{
    TMap<class FString, class FSBHintShowStatusData> StatusTable;                     // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSBHistoryExpired
{
    int32 ExpiredFreeAmount;                                                          // 0x0000 (size: 0x4)
    int32 ExpiredPaidAmount;                                                          // 0x0004 (size: 0x4)
    int32 ExpiredCoinAmount;                                                          // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FDateTime ExpiredFreeAt;                                                          // 0x0010 (size: 0x8)
    FDateTime ExpiredPaidAt;                                                          // 0x0018 (size: 0x8)
    FDateTime ExpiredCoinAt;                                                          // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSBHitCameraShakeSetting
{
    ESBHitCameraShake ShakeType;                                                      // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSubclassOf<class UCameraShakeBase> CameraShake;                                  // 0x0008 (size: 0x8)
    float ShakeScale;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBHitDirectionResistanceCorrection : public FSBElementResistanceCorrectionSetting
{
    ESBHitDirection HitDirection;                                                     // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBHitKnockBackSetting
{
    ESBHitKnockBackPower KnockBackPowerType;                                          // 0x0000 (size: 0x1)
    bool bOverrideKnockBackPower;                                                     // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    float OverrideKnockBackPower;                                                     // 0x0004 (size: 0x4)
    ESBHitKnockBackTime KnockBackTimeType;                                            // 0x0008 (size: 0x1)
    bool bOverrideKnockBackTime;                                                      // 0x0009 (size: 0x1)
    char padding_1[0x2];                                                              // 0x000A (size: 0x2)
    float OverrideKnockBackTime;                                                      // 0x000C (size: 0x4)
    uint8 bNoAttackerKnockBack;                                                       // 0x0010 (size: 0x1)
    uint8 bReverseKnockBackDirection;                                                 // 0x0010 (size: 0x1)
    uint8 bNeedGiveStunToKnockBack;                                                   // 0x0010 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0011 (size: 0x3)
    float CapsuleSpace;                                                               // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBHitResult : public FHitResult
{
    char padding_0[0x8C];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x8C

struct FSBHitSlomoCurveConfig : public FTableRowBase
{
    class UCurveFloat* CurveData;                                                     // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBHitSlomoCurveSetting
{
    ESBHitSlomoPower HitSlomoPower;                                                   // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    class UCurveFloat* CurveData;                                                     // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBHoldHandParam
{
    float Range;                                                                      // 0x0000 (size: 0x4)
    float YawLimit;                                                                   // 0x0004 (size: 0x4)
    float PitchLimit;                                                                 // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FDataTableRowHandle Camera;                                                       // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBHttpQueryPool
{
    TArray<class USBHttpQuery*> InUseList;                                            // 0x0000 (size: 0x10)
    TArray<class USBHttpQuery*> FreeList;                                             // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBImagineInfo : public FTableRowBase
{
    FName ImagineArtsName;                                                            // 0x0008 (size: 0x8)
    FName ImagineArtsTypeNameID;                                                      // 0x0010 (size: 0x8)
    FName ImagineHyouiTypeNameID;                                                     // 0x0018 (size: 0x8)
    TSoftClassPtr<USBImagineSkillInfo> ImagineSkill;                                  // 0x0020 (size: 0x28)

}; // Size: 0x48

struct FSBImagineSoundDataTableRow : public FTableRowBase
{
    FString EnemyType;                                                                // 0x0010 (size: 0x10)
    FString ActionName;                                                               // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBInitialiCheatCommandData
{
    bool bIsActive;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Command;                                                                  // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBInitializeWeaponMasterData
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBInstanceBattleProviderSpawnInfo
{
    class ATargetPoint* SpawnPoint;                                                   // 0x0000 (size: 0x8)
    TSubclassOf<class AActor> SpawnClass;                                             // 0x0008 (size: 0x8)

}; // Size: 0x18

struct FSBInteractionInfo
{
    ESBInteractionType InteractionType;                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FVector Location;                                                                 // 0x0004 (size: 0xC)
    TWeakObjectPtr<class USBInteractionTargetComponent> TargetComponent;              // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBInteractionSearchPriority : public FTableRowBase
{
    ESBInteractionType InteractionType;                                               // 0x0008 (size: 0x1)
    EInteractionTargetType InteractionTargetType;                                     // 0x0009 (size: 0x1)
    char padding_0[0x6];                                                              // 0x000A (size: 0x6)
    TArray<ESBInteractionSearchPriorityAdditional> Additionals;                       // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBInterruptQuestDestructibleObject
{
    FName DataId;                                                                     // 0x0000 (size: 0x8)
    TWeakObjectPtr<class ASBDestructible> Destructible;                               // 0x0008 (size: 0x8)
    bool IsActive;                                                                    // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FSBInterruptQuestDestructibleObjectData
{
    FName ObjectId;                                                                   // 0x0000 (size: 0x8)
    FName QuestID;                                                                    // 0x0008 (size: 0x8)
    FVector Location;                                                                 // 0x0010 (size: 0xC)
    bool IsActive;                                                                    // 0x001C (size: 0x1)

}; // Size: 0x20

struct FSBInterruptQuestDestructibleObjectMasterData
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    FName DataId;                                                                     // 0x0008 (size: 0x8)
    EInterruptQuestDestructibleType Type;                                             // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    FVector Location;                                                                 // 0x0014 (size: 0xC)
    float Roll;                                                                       // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FSBInterruptQuestEnemySpawnData : public FTableRowBase
{
    FString DataBaseId;                                                               // 0x0008 (size: 0x10)
    FString GroupId;                                                                  // 0x0018 (size: 0x10)
    FString EnemyId;                                                                  // 0x0028 (size: 0x10)
    int32 EnemyLv;                                                                    // 0x0038 (size: 0x4)
    FVector Location;                                                                 // 0x003C (size: 0xC)
    float Roll;                                                                       // 0x0048 (size: 0x4)
    bool ClearTargetEnemy;                                                            // 0x004C (size: 0x1)

}; // Size: 0x50

struct FSBInterruptQuestEnemySpawnRequest
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

struct FSBInterruptQuestFieldObjectVisible
{
    char padding_0[0x14];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x14

struct FSBInterruptQuestGimmickObjectData
{
    FName ObjectId;                                                                   // 0x0000 (size: 0x8)
    FName QuestID;                                                                    // 0x0008 (size: 0x8)
    FVector Location;                                                                 // 0x0010 (size: 0xC)

}; // Size: 0x1C

struct FSBInterruptQuestMasterData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FSBTextTableHash NameTextId;                                                      // 0x0010 (size: 0x4)
    int32 QuestAreaRadius;                                                            // 0x0014 (size: 0x4)
    int32 GimmickAreaRadius;                                                          // 0x0018 (size: 0x4)
    int32 TimeLimit;                                                                  // 0x001C (size: 0x4)
    int32 CoolTime;                                                                   // 0x0020 (size: 0x4)
    bool AnyOneCheckFlag;                                                             // 0x0024 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0025 (size: 0x3)
    FSBInterruptQuestMasterData_StartCondData QuestCound;                             // 0x0028 (size: 0x28)
    TArray<FSBInterruptQuestMasterData_StartMainAction> StartMainActionList;          // 0x0050 (size: 0x10)
    TArray<FSBInterruptQuestMasterData_AchievementCond> AchievementCondList;          // 0x0060 (size: 0x10)
    FSBInterruptQuestMasterData_StepupCond StepupCond;                                // 0x0070 (size: 0x28)
    EInterruptQuestRewardType RewardType;                                             // 0x0098 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0099 (size: 0x7)
    TArray<FString> RewardIdList;                                                     // 0x00A0 (size: 0x10)
    EInterruptQuestFailureStepType FailureStepBack;                                   // 0x00B0 (size: 0x1)

}; // Size: 0xB8

struct FSBInterruptQuestMasterData_AchievementCond
{
    EInterruptQuestAchievementType Cond;                                              // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Value_1;                                                                  // 0x0008 (size: 0x10)
    FString Value_2;                                                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBInterruptQuestMasterData_StartCondData
{
    EInterruptQuestMainConditionType Cond;                                            // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Value;                                                                    // 0x0008 (size: 0x10)
    TArray<FSBInterruptQuestMasterData_SubCondData> SubCondList;                      // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBInterruptQuestMasterData_StartMainAction
{
    EInterruptQuestStartMainActionType Cond;                                          // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Value_1;                                                                  // 0x0008 (size: 0x10)
    FString Value_2;                                                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBInterruptQuestMasterData_StepupCond
{
    EInterruptQuestStepupType Cond;                                                   // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Value_1;                                                                  // 0x0008 (size: 0x10)
    FString Value_2;                                                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBInterruptQuestMasterData_SubCondData
{
    EInterruptQuestSubConditionType Cond;                                             // 0x0000 (size: 0x1)
    EInterruptQuestSubConditionAreaType AreaType;                                     // 0x0001 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0002 (size: 0x6)
    FString Value_1;                                                                  // 0x0008 (size: 0x10)
    FString Value_2;                                                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBInterruptQuestNamedEnemyParam
{
    FString EnemyId;                                                                  // 0x0000 (size: 0x10)
    int32 EnemyLv;                                                                    // 0x0010 (size: 0x4)
    FVector Location;                                                                 // 0x0014 (size: 0xC)
    float Roll;                                                                       // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBInterruptQuestNpcData
{
    FName NpcId;                                                                      // 0x0000 (size: 0x8)
    FName QuestID;                                                                    // 0x0008 (size: 0x8)
    FVector Location;                                                                 // 0x0010 (size: 0xC)

}; // Size: 0x1C

struct FSBInterruptQuestPlayInfo
{
    FName QuestID;                                                                    // 0x0000 (size: 0x8)
    uint32 InstanceId;                                                                // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    uint64 EndTimeTick;                                                               // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBInterruptQuestPlayerRanking
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    ESBClassType Class;                                                               // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 RankingRank;                                                                // 0x0014 (size: 0x4)
    int32 ContributionPoint;                                                          // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBInterruptQuestPointCounter
{
    TArray<TWeakObjectPtr<AActor>> Actors;                                            // 0x0000 (size: 0x10)
    float Counter;                                                                    // 0x0010 (size: 0x4)
    bool IsAchieved;                                                                  // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FSBInterruptQuestProgressInfo
{
    TArray<FSBInterruptQuestProgressItem> Items;                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBInterruptQuestProgressItem
{
    FString Condition;                                                                // 0x0000 (size: 0x10)
    FString ProgressNumer;                                                            // 0x0010 (size: 0x10)
    bool Completed;                                                                   // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FSBInterruptQuestResultInfo
{
    FName QuestID;                                                                    // 0x0000 (size: 0x8)
    TArray<FSBInterruptQuestPlayerRanking> Ranking;                                   // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBInterruptQuestTreasureEnemyPopParam
{
    bool Active;                                                                      // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 TreasureId;                                                                 // 0x0004 (size: 0x4)
    int32 Count;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBInterruptQuestTreasureObjectParam : public FTableRowBase
{
    FName DataId;                                                                     // 0x0008 (size: 0x8)
    int32 TreasureId;                                                                 // 0x0010 (size: 0x4)
    int32 Count;                                                                      // 0x0014 (size: 0x4)
    FSBInterruptQuestTreasureEnemyPopParam EnemyPop;                                  // 0x0018 (size: 0xC)
    FSBInterruptQuestTreasureTickPopParam TickPop;                                    // 0x0024 (size: 0x14)

}; // Size: 0x38

struct FSBInterruptQuestTreasureTickPopData
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

struct FSBInterruptQuestTreasureTickPopParam
{
    bool Active;                                                                      // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 TreasureId;                                                                 // 0x0004 (size: 0x4)
    int32 PopMax;                                                                     // 0x0008 (size: 0x4)
    int32 PopNum;                                                                     // 0x000C (size: 0x4)
    float TimeCount;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBInterruptQuestUtilityConditionData
{
    EInterruptQuestConditionType Condition;                                           // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FString> Target;                                                           // 0x0008 (size: 0x10)
    int32 Value;                                                                      // 0x0018 (size: 0x4)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    FString Name;                                                                     // 0x0020 (size: 0x10)
    int32 Count;                                                                      // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBInvalidFlyingEnemyReductionData : public FTableRowBase
{
    FName ContentId;                                                                  // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBInventoryWeapon
{
    TEnumAsByte<ESBWeaponEquipType> EquipType;                                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName DefaultAssetName;                                                           // 0x0004 (size: 0x8)
    FSBWeaponAttach SheatheAttach;                                                    // 0x000C (size: 0x28)
    FSBWeaponAttach UnsheatheAttach;                                                  // 0x0034 (size: 0x28)
    char padding_1[0x4];                                                              // 0x005C (size: 0x4)
    class ASBWeapon* CurrentWeapon;                                                   // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FSBInviteInfo
{
    FString LeaderId;                                                                 // 0x0000 (size: 0x10)
    FString LeaderName;                                                               // 0x0010 (size: 0x10)
    FString CharacterId;                                                              // 0x0020 (size: 0x10)
    float LimitTime;                                                                  // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBItemBoxContentParam
{
    int32 ItemBoxContentsId;                                                          // 0x0000 (size: 0x4)
    ESBRewardItemType ItemType;                                                       // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 ItemTypeId;                                                                 // 0x0008 (size: 0x4)
    int32 ItemRarity;                                                                 // 0x000C (size: 0x4)
    int32 MaxNumOfAcq;                                                                // 0x0010 (size: 0x4)
    int32 MinNumOfAcq;                                                                // 0x0014 (size: 0x4)
    int32 StepSize;                                                                   // 0x0018 (size: 0x4)
    float Percentage;                                                                 // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBItemBoxResultItemData
{
    ESBRewardItemType RewardItemType;                                                 // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ID;                                                                         // 0x0004 (size: 0x4)
    int32 Amount;                                                                     // 0x0008 (size: 0x4)
    bool bDuplicate;                                                                  // 0x000C (size: 0x1)
    char padding_1[0x3];                                                              // 0x000D (size: 0x3)
    int32 SellerItemID;                                                               // 0x0010 (size: 0x4)
    int32 SaleAmount;                                                                 // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBItemInUseCanGestureData : public FTableRowBase
{
    TArray<EItemEfficacyType> EfficacyList;                                           // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBItemSelectorInfo
{
    int32 ItemIndex;                                                                  // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)
    EItemType Type;                                                                   // 0x0008 (size: 0x1)
    bool IsSupplyItem;                                                                // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FSBIvyPlacementInstanceSetting
{
    float TrackBank;                                                                  // 0x0000 (size: 0x4)
    float TrackWidth;                                                                 // 0x0004 (size: 0x4)
    float TrackThickness;                                                             // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    class UStaticMesh* ChangeTrackMesh;                                               // 0x0010 (size: 0x8)
    bool IsIndividuallyTrackForwardAxis;                                              // 0x0018 (size: 0x1)
    TEnumAsByte<ESplineMeshAxis::Type> TrackForwardAxis;                              // 0x0019 (size: 0x1)

}; // Size: 0x20

struct FSBKeyConfigDatas
{
    TArray<FSBPlayerClassKeyConfigDataDiff> DiffKeyConfig;                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBKeyPair
{
    FName Key;                                                                        // 0x0000 (size: 0x8)
    FString Value;                                                                    // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBKeyPairList
{
    TArray<FSBKeyPair> Pairs;                                                         // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBKeyboardSettings
{
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> MoveFront;                             // 0x0000 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> MoveBack;                              // 0x0001 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> MoveLeft;                              // 0x0002 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> MoveRight;                             // 0x0003 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Walk;                                  // 0x0004 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Dash;                                  // 0x0005 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> AutoRun;                               // 0x0006 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Jump;                                  // 0x0007 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> OrientToCamera;                        // 0x0008 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> MainAction;                            // 0x0009 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> SubAction;                             // 0x000A (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> LeftSkill;                             // 0x000B (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> RightSkill;                            // 0x000C (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Skill1;                                // 0x000D (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Skill2;                                // 0x000E (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Skill3;                                // 0x000F (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Skill4;                                // 0x0010 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> SpecialSkill;                          // 0x0011 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Dodge;                                 // 0x0012 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Interaction;                           // 0x0013 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Reload;                                // 0x0014 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ImagineArts;                           // 0x0015 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ImagineArts2;                          // 0x0016 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ImagineMount;                          // 0x0017 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> CameraPitchUp;                         // 0x0018 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> CameraPitchDown;                       // 0x0019 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> CameraYawLeft;                         // 0x001A (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> CameraYawRight;                        // 0x001B (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> CameraZoomIn;                          // 0x001C (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> CameraZoomOut;                         // 0x001D (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> CameraReset;                           // 0x001E (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> LockOn;                                // 0x001F (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> LockOnTargetRight;                     // 0x0020 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> LockOnTargetLeft;                      // 0x0021 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutExec;                          // 0x0022 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutMoveLeft;                      // 0x0023 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutMoveRight;                     // 0x0024 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Function;                              // 0x0025 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> MainMenu;                              // 0x0026 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ChatWindow;                            // 0x0027 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAMyCharacter;                         // 0x0028 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAInventory;                           // 0x0029 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAQuest;                               // 0x002A (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAMap;                                 // 0x002B (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QALibrary;                             // 0x002C (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAContents;                            // 0x002D (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAParty;                               // 0x002E (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAGuild;                               // 0x002F (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAMyGacha;                             // 0x0030 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAOption;                              // 0x0031 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAPhotoMode;                           // 0x0032 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QAHUD;                                 // 0x0033 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QACommunicate;                         // 0x0034 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRing;                          // 0x0035 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRingExeF5;                     // 0x0036 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRingExeF6;                     // 0x0037 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRingExeF7;                     // 0x0038 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRingExeF8;                     // 0x0039 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRingExeF9;                     // 0x003A (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRingExeF10;                    // 0x003B (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRingExeF11;                    // 0x003C (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> ShortcutRingExeF12;                    // 0x003D (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> WholeMap;                              // 0x003E (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Screenshot;                            // 0x003F (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMarkRegist;                        // 0x0040 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark1;                             // 0x0041 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark2;                             // 0x0042 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark3;                             // 0x0043 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark4;                             // 0x0044 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark5;                             // 0x0045 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark6;                             // 0x0046 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark7;                             // 0x0047 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark8;                             // 0x0048 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark9;                             // 0x0049 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark10;                            // 0x004A (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark11;                            // 0x004B (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark12;                            // 0x004C (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark13;                            // 0x004D (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark14;                            // 0x004E (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark15;                            // 0x004F (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark16;                            // 0x0050 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark17;                            // 0x0051 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark18;                            // 0x0052 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark19;                            // 0x0053 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark20;                            // 0x0054 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark21;                            // 0x0055 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark22;                            // 0x0056 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark23;                            // 0x0057 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> BookMark24;                            // 0x0058 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> Pushpin;                               // 0x0059 (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> PhotoMode;                             // 0x005A (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> QuestHudChange;                        // 0x005B (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> KeyGuide;                              // 0x005C (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> SkillPaletteChange;                    // 0x005D (size: 0x1)
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> NowParty;                              // 0x005E (size: 0x1)
    char padding_0[0x1];                                                              // 0x005F (size: 0x1)
    float CameraSpeedRateYaw;                                                         // 0x0060 (size: 0x4)
    float CameraSpeedRatePitch;                                                       // 0x0064 (size: 0x4)
    float AimAssist_FitTargetStrength;                                                // 0x0068 (size: 0x4)
    float AimAssist_FollowTargetStrength;                                             // 0x006C (size: 0x4)
    float AimAssist_CameraBrakeStrength;                                              // 0x0070 (size: 0x4)

}; // Size: 0x98

struct FSBKeyconfigFloatParamValuePair
{
    ESBKeyConfigFloatParam ParamType;                                                 // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBKnockBackWeightClass
{
    ESBKnockBackWeightClass WeightClass;                                              // 0x0000 (size: 0x1)
    ESBEnemyReactionType DamageReactionType;                                          // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    float KnockBackDistanceRatio;                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBLancerPrepareStyleMarkCountSetting
{
    FSBStatusAilmentHandle MarkCountStatusAilment;                                    // 0x0000 (size: 0x20)
    float AttackUpRate;                                                               // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> ConditionAddList;                             // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBLancerResonanceSpearLancerMarkSpreadSetting
{
    FDataTableRowHandle LancerMarkRowHandle;                                          // 0x0000 (size: 0x10)
    FSBEffectAsset SpreadEffect;                                                      // 0x0010 (size: 0x1A8)

}; // Size: 0x1B8

struct FSBLancerResonanceSpearMaxNumSpreadCharacterSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    int32 MaxNumSpreadCharacter;                                                      // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBLastJoinedContentInfoState
{
    FString ContentId;                                                                // 0x0000 (size: 0x10)
    FDateTime ExpireTime;                                                             // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBLastJoinedPartyInfoState
{
    FString PartyId;                                                                  // 0x0000 (size: 0x10)
    ESBPartyType PartyType;                                                           // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    FDateTime ExpireTime;                                                             // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBLaunchAndDestroyProjectileSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TArray<FDataTableRowHandle> ProjectileHandleList;                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBLaunchSkillPreInputTimeConditionOverrideInfo
{
    ELaunchSkillPreInputType LaunchSkillPreInputType;                                 // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0008 (size: 0x10)
    float OverrideLaunchSkillPreInputTime;                                            // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBLetter
{
    TArray<FOwnItemInfo> SendItems;                                                   // 0x0000 (size: 0x10)
    TArray<FOwnItemInfo> LostItems;                                                   // 0x0010 (size: 0x10)
    int32 SkyCoin;                                                                    // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBLevelTerm
{
    FName LevelName;                                                                  // 0x0000 (size: 0x8)
    FString TermId;                                                                   // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBLevelingMaterials
{
    FString UniqueId;                                                                 // 0x0000 (size: 0x10)
    int32 StorageNo;                                                                  // 0x0010 (size: 0x4)
    int32 UseNum;                                                                     // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBLibraryEnemyAppearanceData
{
    FName AppearanceId;                                                               // 0x0000 (size: 0x8)
    FSBTextTableHash RaceId;                                                          // 0x0008 (size: 0x4)
    FSBTextTableHash NameId;                                                          // 0x000C (size: 0x4)
    TArray<FName> EnemyIDList;                                                        // 0x0010 (size: 0x10)
    bool AllReadFlag;                                                                 // 0x0020 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0021 (size: 0x7)
    TMap<class FString, class FName> AreaData;                                        // 0x0028 (size: 0x50)
    FName ModelId;                                                                    // 0x0078 (size: 0x8)
    TArray<FSBLibraryEnemyPartsBreakData> PartsData;                                  // 0x0080 (size: 0x10)

}; // Size: 0x90

struct FSBLibraryEnemyData
{
    FName BaseEnemyId;                                                                // 0x0000 (size: 0x8)
    FSBTextTableHash RaceId;                                                          // 0x0008 (size: 0x4)
    FSBTextTableHash NameId;                                                          // 0x000C (size: 0x4)
    TArray<FSBLibraryEnemyIndividualData> List;                                       // 0x0010 (size: 0x10)
    ESBLibraryEnemyViewSetting ViewSetting;                                           // 0x0020 (size: 0x1)
    ESBLibraryEnemyWeaponSetting WeaponSetting;                                       // 0x0021 (size: 0x1)

}; // Size: 0x28

struct FSBLibraryEnemyDetailOpenSetting : public FTableRowBase
{
    int32 Element;                                                                    // 0x0008 (size: 0x4)
    int32 Race;                                                                       // 0x000C (size: 0x4)
    int32 Attribute;                                                                  // 0x0010 (size: 0x4)
    int32 Status;                                                                     // 0x0014 (size: 0x4)
    int32 Comment;                                                                    // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBLibraryEnemyIndividualData
{
    FName AppearanceId;                                                               // 0x0000 (size: 0x8)
    FName NameId;                                                                     // 0x0008 (size: 0x8)
    TArray<FName> EnemyIDList;                                                        // 0x0010 (size: 0x10)
    bool AllReadFlag;                                                                 // 0x0020 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0021 (size: 0x7)
    TMap<class FString, class FName> AreaData;                                        // 0x0028 (size: 0x50)
    FName ModelId;                                                                    // 0x0078 (size: 0x8)
    TArray<FSBLibraryEnemyPartsBreakData> PartsData;                                  // 0x0080 (size: 0x10)
    int32 KillCount;                                                                  // 0x0090 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0094 (size: 0x4)
    TMap<FName, int32> ActiveTime;                                                    // 0x0098 (size: 0x50)

}; // Size: 0xE8

struct FSBLibraryEnemyPartsBreakData
{
    FName Group;                                                                      // 0x0000 (size: 0x8)
    int32 MaxStep;                                                                    // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBLibraryEnemyReadData
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    int32 DetailTabCount;                                                             // 0x0008 (size: 0x4)
    int32 ExplainTabCount;                                                            // 0x000C (size: 0x4)
    TArray<FName> AreaIdList;                                                         // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBLibraryEnemySetting : public FTableRowBase
{
    bool Lineup;                                                                      // 0x0008 (size: 0x1)
    bool Scenario;                                                                    // 0x0009 (size: 0x1)
    bool Boss;                                                                        // 0x000A (size: 0x1)
    char padding_0[0x1];                                                              // 0x000B (size: 0x1)
    FName LibraryName;                                                                // 0x000C (size: 0x8)
    char padding_1[0x4];                                                              // 0x0014 (size: 0x4)
    TArray<ESBLibraryEnemyElementType> AttackElement;                                 // 0x0018 (size: 0x10)
    ESBLibraryEnemyAppearanceTime AppearanceTime;                                     // 0x0028 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0029 (size: 0x7)
    TArray<FName> SameEnemyId;                                                        // 0x0030 (size: 0x10)
    FName DetailOpenType;                                                             // 0x0040 (size: 0x8)
    float ModelRotate;                                                                // 0x0048 (size: 0x4)
    float ModelScale;                                                                 // 0x004C (size: 0x4)
    float CameraHeight;                                                               // 0x0050 (size: 0x4)
    float CameraSideOffset;                                                           // 0x0054 (size: 0x4)
    ESBLibraryEnemyViewSetting StandType;                                             // 0x0058 (size: 0x1)
    ESBLibraryEnemyWeaponSetting WeaponType;                                          // 0x0059 (size: 0x1)

}; // Size: 0x60

struct FSBLibraryImagineSaveData
{
    TArray<FSBReadLibraryImagineData> ReadList;                                       // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBLibraryItemMakeListData
{
    EItemType Type;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    int32 RecepiId;                                                                   // 0x0008 (size: 0x4)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    FString Name;                                                                     // 0x0010 (size: 0x10)
    bool IsFindRecepi;                                                                // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FSBLibraryItemSaveData
{
    TArray<FSBReadLibraryItemData> ReadList;                                          // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBLibrarySaveData
{
    TMap<class FString, class FSBReadBookmarkSaveData> ReadBookmarkSaveData;          // 0x0000 (size: 0x50)
    TMap<class FString, class FSBLibraryItemSaveData> ReadItemSaveData;               // 0x0050 (size: 0x50)
    TArray<FName> ReadMonsterIdList;                                                  // 0x00A0 (size: 0x10)
    TArray<int32> ReadWeaponIdList;                                                   // 0x00B0 (size: 0x10)
    TArray<int32> ReadAchievementIdList;                                              // 0x00C0 (size: 0x10)
    TArray<int32> ReadAwardIdList;                                                    // 0x00D0 (size: 0x10)
    TArray<FName> ReadDemoIdList;                                                     // 0x00E0 (size: 0x10)
    FSBTheaterModeInfo TheaterModeInfo;                                               // 0x00F0 (size: 0x14)
    char padding_0[0x4];                                                              // 0x0104 (size: 0x4)
    TArray<int32> ReadMountImagineIdList;                                             // 0x0108 (size: 0x10)
    TArray<FSBLibraryEnemyReadData> ReadMonsterList;                                  // 0x0118 (size: 0x10)
    TMap<class FString, class FSBLibraryWeaponSaveData> ReadWeaponSaveData;           // 0x0128 (size: 0x50)
    TMap<class FString, class FSBLibraryImagineSaveData> ReadBattleImagineSaveData;   // 0x0178 (size: 0x50)
    TMap<class FString, class FSBLibraryImagineSaveData> ReadEnhanceImagineSaveData;  // 0x01C8 (size: 0x50)

}; // Size: 0x218

struct FSBLibraryWeaponSaveData
{
    TArray<FSBReadLibraryWeaponData> ReadList;                                        // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBLightMaterialSchedule
{
    class UMaterialInstanceDynamic* MaterialInstance;                                 // 0x0000 (size: 0x8)
    FName ParameterName;                                                              // 0x0008 (size: 0x8)
    float Intensity;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBLimitedTimeGroupInfo
{
    int32 GroupId;                                                                    // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDateTime EndTime;                                                                // 0x0008 (size: 0x8)
    TArray<FString> EmoteList;                                                        // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBLineSoundData
{
    FVector Start;                                                                    // 0x0000 (size: 0xC)
    FVector End;                                                                      // 0x000C (size: 0xC)

}; // Size: 0x18

struct FSBLiquidMemoryAccumulateConditionParameter
{
    ESBLiquidMemoryAccumulateConditionType ConditionType;                             // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FSBTextTableHash ConditionTypeNameId;                                             // 0x0004 (size: 0x4)
    ESBLiquidMemoryAccumulationType AccumulationType;                                 // 0x0008 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0009 (size: 0x3)
    int32 Value;                                                                      // 0x000C (size: 0x4)
    FSBTextTableHash ConditionDescId;                                                 // 0x0010 (size: 0x4)
    int32 AccumulateBottleNum;                                                        // 0x0014 (size: 0x4)
    FString RandomAccumulateTableId;                                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBLiquidMemoryAccumulateLotteryTableMasterData
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBLiquidMemoryAccumulateLotteryTableRow
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBLiquidMemoryAccumulateTokenInfo
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 LiquidMemoryId;                                                             // 0x0004 (size: 0x4)
    int32 TokenID;                                                                    // 0x0008 (size: 0x4)
    ESBLiquidMemoryAccumulateTokenType Type;                                          // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    int32 NumberOfAccumulated;                                                        // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBLiquidMemoryEfficacyParameter
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    int32 UseCount;                                                                   // 0x0004 (size: 0x4)
    float EfficacyValue;                                                              // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBLiquidMemoryEfficacyValueTableData> EfficacyValueTable;                 // 0x0010 (size: 0x10)
    FSBTextTableHash EfficacyValueDescId;                                             // 0x0020 (size: 0x4)
    FSBTextTableHash EfficacyDescId;                                                  // 0x0024 (size: 0x4)
    float OccurancyRate;                                                              // 0x0028 (size: 0x4)
    int32 Cost;                                                                       // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBLiquidMemoryEfficacyValueTableData
{
    int32 ClassLevel;                                                                 // 0x0000 (size: 0x4)
    float EfficacyValue;                                                              // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBLiquidMemoryInfo
{
    int32 LiquidMemoryIndex;                                                          // 0x0000 (size: 0x4)
    int32 CurrentLevel;                                                               // 0x0004 (size: 0x4)
    int32 AccumulatedAmount;                                                          // 0x0008 (size: 0x4)
    int32 RemainingUseCount;                                                          // 0x000C (size: 0x4)
    FDateTime RemainingUseTime;                                                       // 0x0010 (size: 0x8)
    bool ActivateFlag;                                                                // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    int32 ActivateLevel;                                                              // 0x001C (size: 0x4)
    FDateTime LastUpdatedTime;                                                        // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSBLiquidMemoryMasterData
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    int32 BottleAccumulateLimit;                                                      // 0x0004 (size: 0x4)
    ESBLiquidMemoryCategory Category;                                                 // 0x0008 (size: 0x1)
    ESBLiquidMemoryEfficacyType EfficacyType;                                         // 0x0009 (size: 0x1)
    char padding_0[0x2];                                                              // 0x000A (size: 0x2)
    FSBTextTableHash EfficacyNameId;                                                  // 0x000C (size: 0x4)
    ESBLiquidMemoryEfficacyValueType EfficacyValueType;                               // 0x0010 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0011 (size: 0x7)
    TArray<FSBLiquidMemoryEfficacyParameter> EfficacyParameters;                      // 0x0018 (size: 0x10)
    TArray<FSBLiquidMemoryAccumulateConditionParameter> AccumulatedConditionParameters; // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBLoadCaptureTargetItem
{
    FString TargetType;                                                               // 0x0000 (size: 0x10)
    FString TargetId;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBLobbyEntry
{
    int32 SearchResultsIndex;                                                         // 0x0000 (size: 0x4)
    FName DungeonId;                                                                  // 0x0004 (size: 0x8)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString OwnerName;                                                                // 0x0010 (size: 0x10)
    int32 CurrentPlayerNum;                                                           // 0x0020 (size: 0x4)
    int32 MaxPlayerNum;                                                               // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBLocalOverrideAttackMasterData : public FTableRowBase
{
    FSBAttackID AttackID;                                                             // 0x0008 (size: 0x4)
    bool bOverrideHitCount;                                                           // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    int32 HitCount;                                                                   // 0x0010 (size: 0x4)
    bool bOverrideHitInterval;                                                        // 0x0014 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0015 (size: 0x3)
    float HitInterval;                                                                // 0x0018 (size: 0x4)
    bool bOverrideAttackScale;                                                        // 0x001C (size: 0x1)
    char padding_2[0x3];                                                              // 0x001D (size: 0x3)
    float AttackScale;                                                                // 0x0020 (size: 0x4)
    bool bOverrideDamageValue1;                                                       // 0x0024 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0025 (size: 0x3)
    int32 damage_value1;                                                              // 0x0028 (size: 0x4)
    bool bOverrideDamageValue2;                                                       // 0x002C (size: 0x1)
    char padding_4[0x3];                                                              // 0x002D (size: 0x3)
    int32 damage_value2;                                                              // 0x0030 (size: 0x4)
    bool bOverrideAttackDirectionSetting;                                             // 0x0034 (size: 0x1)
    char padding_5[0x1];                                                              // 0x0035 (size: 0x1)
    FSBAttackDirectionSetting AttackDirectionSetting;                                 // 0x0036 (size: 0x8)
    bool bOverrideStunSetting;                                                        // 0x003E (size: 0x1)
    char padding_6[0x1];                                                              // 0x003F (size: 0x1)
    FSBAttackStunSetting StunSetting;                                                 // 0x0040 (size: 0x18)
    bool bOverrideHitStop;                                                            // 0x0058 (size: 0x1)
    char padding_7[0x3];                                                              // 0x0059 (size: 0x3)
    FSBAttackHitStopSetting HitStop;                                                  // 0x005C (size: 0x14)
    bool bOverrideHitKnockBack;                                                       // 0x0070 (size: 0x1)
    char padding_8[0x3];                                                              // 0x0071 (size: 0x3)
    FSBHitKnockBackSetting HitKnockBack;                                              // 0x0074 (size: 0x18)
    bool bOverrideSpecialHitEffectName;                                               // 0x008C (size: 0x1)
    char padding_9[0x3];                                                              // 0x008D (size: 0x3)
    FString special_hit_effect_name;                                                  // 0x0090 (size: 0x10)
    bool bOverrideHitEffectSize;                                                      // 0x00A0 (size: 0x1)
    char padding_10[0x3];                                                             // 0x00A1 (size: 0x3)
    int32 HitEffectSize;                                                              // 0x00A4 (size: 0x4)
    bool bOverrideHitCameraShake;                                                     // 0x00A8 (size: 0x1)
    char padding_11[0x3];                                                             // 0x00A9 (size: 0x3)
    int32 HitCameraShake;                                                             // 0x00AC (size: 0x4)

}; // Size: 0xB0

struct FSBLocationAnchorInfo
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBLocationInfo : public FTableRowBase
{
    FName LocationId;                                                                 // 0x0008 (size: 0x8)
    ESBLocationInfoType Type;                                                         // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    FName GameContentId;                                                              // 0x0014 (size: 0x8)
    FName RouteGuideGameContentId;                                                    // 0x001C (size: 0x8)
    FVector WorldCoordinate;                                                          // 0x0024 (size: 0xC)
    FVector MapCoordinate;                                                            // 0x0030 (size: 0xC)
    ESBRouteGuideArea RouteGuideArea;                                                 // 0x003C (size: 0x1)
    bool bDisableShowIconOnMap;                                                       // 0x003D (size: 0x1)
    char padding_1[0x2];                                                              // 0x003E (size: 0x2)
    FDataTableRowHandle FieldStatus;                                                  // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBLockItemData
{
    int32 storage_no;                                                                 // 0x0000 (size: 0x4)
    EItemType item_type;                                                              // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 item_id;                                                                    // 0x0008 (size: 0x4)
    int32 locked;                                                                     // 0x000C (size: 0x4)
    FString unique_id;                                                                // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBLoginBonus
{
    FString LoginBonusId;                                                             // 0x0000 (size: 0x10)
    int32 Type;                                                                       // 0x0010 (size: 0x4)
    int32 Target;                                                                     // 0x0014 (size: 0x4)
    int32 TotalDay;                                                                   // 0x0018 (size: 0x4)
    int32 SortId;                                                                     // 0x001C (size: 0x4)
    FString BannerImageId;                                                            // 0x0020 (size: 0x10)
    FString LoginBonusName;                                                           // 0x0030 (size: 0x10)
    FDateTime StartTime;                                                              // 0x0040 (size: 0x8)
    FDateTime EndTime;                                                                // 0x0048 (size: 0x8)
    int32 PublicType;                                                                 // 0x0050 (size: 0x4)
    int32 PurchaseLimitId;                                                            // 0x0054 (size: 0x4)
    TArray<FSBLoginBonusReward> Reward;                                               // 0x0058 (size: 0x10)
    int32 TablePosition;                                                              // 0x0068 (size: 0x4)
    char padding_0[0x4];                                                              // 0x006C (size: 0x4)
    FString BackImgId;                                                                // 0x0070 (size: 0x10)

}; // Size: 0x80

struct FSBLoginBonusReward
{
    int32 Day;                                                                        // 0x0000 (size: 0x4)
    bool Pickup;                                                                      // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    TArray<FSBLoginBonusRewardData> RewardData;                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBLoginBonusRewardData
{
    int32 Type;                                                                       // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString ID;                                                                       // 0x0008 (size: 0x10)
    int32 Amount;                                                                     // 0x0018 (size: 0x4)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    TArray<int32> ExtraData;                                                          // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBLoginBonusWindowData
{
    int32 TypeId;                                                                     // 0x0000 (size: 0x4)
    FName MasterId;                                                                   // 0x0004 (size: 0x8)
    int32 SortNo;                                                                     // 0x000C (size: 0x4)
    FString StartDay;                                                                 // 0x0010 (size: 0x10)
    FString EndDay;                                                                   // 0x0020 (size: 0x10)
    FDateTime EndTime;                                                                // 0x0030 (size: 0x8)
    int32 LoginCount;                                                                 // 0x0038 (size: 0x4)
    bool NeedGetAnimation;                                                            // 0x003C (size: 0x1)
    char padding_0[0x3];                                                              // 0x003D (size: 0x3)
    FString ImageUrl;                                                                 // 0x0040 (size: 0x10)
    FString TitleName;                                                                // 0x0050 (size: 0x10)
    TArray<FSBLoginBonusWindowDayData> DailyData;                                     // 0x0060 (size: 0x10)
    int32 StumpTarget;                                                                // 0x0070 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0074 (size: 0x4)
    FString BgImageUrl;                                                               // 0x0078 (size: 0x10)
    int32 LetterType;                                                                 // 0x0088 (size: 0x4)
    int32 UIPosition;                                                                 // 0x008C (size: 0x4)
    FString BackGroundId;                                                             // 0x0090 (size: 0x10)

}; // Size: 0xA0

struct FSBLoginBonusWindowDayData
{
    int32 Day;                                                                        // 0x0000 (size: 0x4)
    bool bPickup;                                                                     // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    TArray<FSBLoginBonusWindowItemData> ItemData;                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBLoginBonusWindowItemData
{
    int32 Category;                                                                   // 0x0000 (size: 0x4)
    int32 ItemId;                                                                     // 0x0004 (size: 0x4)
    int32 Value;                                                                      // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<int32> ExtraData;                                                          // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBLuckyChanceMaster
{
    int32 StackBNum;                                                                  // 0x0000 (size: 0x4)
    int32 Count;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBMachineCacheData
{
    FDateTime LastBootDate;                                                           // 0x0000 (size: 0x8)
    int32 GamepadUISpeed;                                                             // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSBMagicianProcCondition
{
    uint32 ID;                                                                        // 0x0000 (size: 0x4)
    uint8 bActive;                                                                    // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBMagicianShotProjectileLevelSetting
{
    FSBMagicianShotProjectileSetting ProjectileSetting;                               // 0x0000 (size: 0x20)
    FSBMagicianShotProjectileSetting AlternativeProjectileSetting;                    // 0x0020 (size: 0x20)
    FSBConditionCheckParam ChangeCondition;                                           // 0x0040 (size: 0x60)

}; // Size: 0xA0

struct FSBMagicianShotProjectileOffsetSetting
{
    FVector LocationOffset;                                                           // 0x0000 (size: 0xC)
    float DelayTime;                                                                  // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBMagicianShotProjectileSetting
{
    FDataTableRowHandle ProjectileHandle;                                             // 0x0000 (size: 0x10)
    TArray<FSBMagicianShotProjectileOffsetSetting> OffsetSettingList;                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBMailAttachment
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    ESBRewardItemType attachment_type;                                                // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 Amount;                                                                     // 0x0014 (size: 0x4)
    int32 attachment_id;                                                              // 0x0018 (size: 0x4)
    bool isReceived;                                                                  // 0x001C (size: 0x1)
    char padding_1[0x3];                                                              // 0x001D (size: 0x3)
    FDateTime ReceivedAt;                                                             // 0x0020 (size: 0x8)
    TArray<int32> ExtraData;                                                          // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBMailData : public FTableRowBase
{
    FString mail_id;                                                                  // 0x0008 (size: 0x10)
    FString from_name;                                                                // 0x0018 (size: 0x10)
    FString from_user_id;                                                             // 0x0028 (size: 0x10)
    FString from_character_id;                                                        // 0x0038 (size: 0x10)
    FString received_character_name;                                                  // 0x0048 (size: 0x10)
    FString transed_character_name;                                                   // 0x0058 (size: 0x10)
    FString head;                                                                     // 0x0068 (size: 0x10)
    FString Body;                                                                     // 0x0078 (size: 0x10)
    int32 Status;                                                                     // 0x0088 (size: 0x4)
    bool IsProtected;                                                                 // 0x008C (size: 0x1)
    bool Priority;                                                                    // 0x008D (size: 0x1)
    bool Transferable;                                                                // 0x008E (size: 0x1)
    bool IsAccountMail;                                                               // 0x008F (size: 0x1)
    FString Tags;                                                                     // 0x0090 (size: 0x10)
    ESBMailType MailType;                                                             // 0x00A0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00A1 (size: 0x7)
    FSBMailAttachment attachments;                                                    // 0x00A8 (size: 0x38)
    FDateTime ExpiredTime;                                                            // 0x00E0 (size: 0x8)
    FDateTime ReceivedTime;                                                           // 0x00E8 (size: 0x8)
    FSBMailExtraParameter ExtraParameter;                                             // 0x00F0 (size: 0x30)
    ESBMailPlatformType MailPlatformType;                                             // 0x0120 (size: 0x1)
    bool IsBppIrredeemable;                                                           // 0x0121 (size: 0x1)

}; // Size: 0x128

struct FSBMailExtraParameter
{
    FDateTime ExpirationDate_;                                                        // 0x0000 (size: 0x8)
    FString URL_;                                                                     // 0x0008 (size: 0x10)
    int32 CampaignID_;                                                                // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    FString SerialCode_;                                                              // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBMailLimitStatus
{
    bool bIsValid;                                                                    // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FDateTime LimitDate;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBMailRewardData
{
    TArray<FOwnItemInfo> OwnItems;                                                    // 0x0000 (size: 0x10)
    TArray<FOwnItemInfo> SoldItems;                                                   // 0x0010 (size: 0x10)
    TArray<FSBOwnEmoteData> EmoteData;                                                // 0x0020 (size: 0x10)
    TArray<FCharacterCraftRecepi> ImagineRecepis;                                     // 0x0030 (size: 0x10)
    TArray<bool> ImagineRecepiNews;                                                   // 0x0040 (size: 0x10)
    TArray<FSBMailStampCategories> Stamps;                                            // 0x0050 (size: 0x10)
    TArray<FSBMailStampCategories> StampCategories;                                   // 0x0060 (size: 0x10)
    TArray<bool> CraftRecepiNews;                                                     // 0x0070 (size: 0x10)
    TArray<FCharacterCraftRecepi> CraftRecepis;                                       // 0x0080 (size: 0x10)
    TArray<int32> RecipeSet;                                                          // 0x0090 (size: 0x10)
    TArray<int32> Achievements;                                                       // 0x00A0 (size: 0x10)
    TArray<FSBLiquidMemoryInfo> LiquidMemory;                                         // 0x00B0 (size: 0x10)
    TArray<FSBCharacterToken> Tokens;                                                 // 0x00C0 (size: 0x10)
    TArray<int32> AdventureBoards;                                                    // 0x00D0 (size: 0x10)
    TArray<int32> WarehouseAbilities;                                                 // 0x00E0 (size: 0x10)
    int32 Money;                                                                      // 0x00F0 (size: 0x4)
    int32 SoldProfit;                                                                 // 0x00F4 (size: 0x4)
    int32 Exp;                                                                        // 0x00F8 (size: 0x4)
    int32 Coins;                                                                      // 0x00FC (size: 0x4)
    FSBExtraExpParse ClassExtraExp;                                                   // 0x0100 (size: 0x18)
    int32 FreeCurrencies;                                                             // 0x0118 (size: 0x4)
    int32 VanishedMoney;                                                              // 0x011C (size: 0x4)
    int32 VanishedExp;                                                                // 0x0120 (size: 0x4)
    int32 VanishedCoins;                                                              // 0x0124 (size: 0x4)
    int32 VanishedCurrencies;                                                         // 0x0128 (size: 0x4)
    int32 VanishedGc;                                                                 // 0x012C (size: 0x4)
    int32 SeasonRankPoint;                                                            // 0x0130 (size: 0x4)
    int32 NextSeasonRankPoint;                                                        // 0x0134 (size: 0x4)
    int32 NextSeasonDiscountValue;                                                    // 0x0138 (size: 0x4)
    char padding_0[0x4];                                                              // 0x013C (size: 0x4)
    TArray<int32> VanishedAchievements;                                               // 0x0140 (size: 0x10)
    TArray<FSBCharacterToken> VanishedTokens;                                         // 0x0150 (size: 0x10)
    TArray<int32> Awards;                                                             // 0x0160 (size: 0x10)
    TArray<int32> AdventurerCardDecorations;                                          // 0x0170 (size: 0x10)

}; // Size: 0x180

struct FSBMailStampCategories
{
    int32 CategoryId;                                                                 // 0x0000 (size: 0x4)
    bool IsComplete;                                                                  // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    TArray<FSBMailStampData> Stamps;                                                  // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBMailStampData
{
    int32 StampId;                                                                    // 0x0000 (size: 0x4)
    bool IsNew;                                                                       // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBMakeupData : public FTableRowBase
{
    ESBMakeupType Type;                                                               // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 Index;                                                                      // 0x000C (size: 0x4)
    ESBCharacterGender Gender;                                                        // 0x0010 (size: 0x1)
    bool bCanReverse;                                                                 // 0x0011 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0012 (size: 0x2)
    FSBCharaCreateColorHSV DefaultColor;                                              // 0x0014 (size: 0xC)
    TSoftObjectPtr<UTexture2D> MaskTexture;                                           // 0x0020 (size: 0x28)
    bool bProjection;                                                                 // 0x0048 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0049 (size: 0x3)
    float ProjectionScale;                                                            // 0x004C (size: 0x4)
    FVector2D ProjectionOffset;                                                       // 0x0050 (size: 0x8)

}; // Size: 0x58

struct FSBManageEffectActor
{
    TWeakObjectPtr<class AActor> EffectActor;                                         // 0x0000 (size: 0x8)
    uint8 bIsAutoDestroy;                                                             // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBMapAreaIconTableRow : public FTableRowBase
{
    FName MapId;                                                                      // 0x0008 (size: 0x8)
    TSoftObjectPtr<UTexture2D> Texture;                                               // 0x0010 (size: 0x28)

}; // Size: 0x38

struct FSBMapBGConfigTableRow : public FTableRowBase
{
    FName ZoneId;                                                                     // 0x0008 (size: 0x8)
    int32 Floor;                                                                      // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    TSoftObjectPtr<UTexture2D> Texture;                                               // 0x0018 (size: 0x28)
    FVector2D CapturePosition;                                                        // 0x0040 (size: 0x8)
    FVector2D CaptureSize;                                                            // 0x0048 (size: 0x8)
    FVector2D WorldMapPosition;                                                       // 0x0050 (size: 0x8)
    float UVRange;                                                                    // 0x0058 (size: 0x4)
    float ResolutionMultiplier;                                                       // 0x005C (size: 0x4)
    FVector2D MenuMapPosition;                                                        // 0x0060 (size: 0x8)
    bool IsDividedZone;                                                               // 0x0068 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0069 (size: 0x3)
    int32 SortId;                                                                     // 0x006C (size: 0x4)
    float MenuMapScale;                                                               // 0x0070 (size: 0x4)

}; // Size: 0x78

struct FSBMapBossBGMConditionDataBase
{
    ESBMapBossBGMConditionType ConditionType;                                         // 0x0000 (size: 0x1)
    bool bIsValidAddCondition;                                                        // 0x0001 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0002 (size: 0x6)
    TArray<FSBMapBossBGMConditionValueData> ValueDataArray;                           // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBMapBossBGMConditionValueData
{
    ESBBossBGMSettingType SettingType;                                                // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 SettingValue;                                                               // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBMapBossBGMFirstConditionData : public FSBMapBossBGMConditionDataBase
{
    TArray<FSBMapBossBGMSecondConditionData> SecondConditionData;                     // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBMapBossBGMSecondConditionData : public FSBMapBossBGMConditionDataBase
{
    TArray<FSBMapBossBGMThirdConditionData> ThirdConditionData;                       // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBMapBossBGMSettingData
{
    FSBMapBossBGMFirstConditionData ConditionData;                                    // 0x0000 (size: 0x28)
    ESBBossBGMEventSettingType EventSettingType;                                      // 0x0028 (size: 0x1)
    ESBBattleBGMType Type;                                                            // 0x0029 (size: 0x1)
    char padding_0[0x6];                                                              // 0x002A (size: 0x6)
    TSoftObjectPtr<UAkAudioEvent> EventPtr;                                           // 0x0030 (size: 0x28)
    bool bIsBattleEndSetting;                                                         // 0x0058 (size: 0x1)
    bool bIsMapResultSetting;                                                         // 0x0059 (size: 0x1)

}; // Size: 0x60

struct FSBMapBossBGMSettingData_EnemyTotal
{
    FSBMapBossBGMConditionValueData ConditionData;                                    // 0x0000 (size: 0x8)
    ESBBossBGMEventSettingType EventSettingType;                                      // 0x0008 (size: 0x1)
    ESBBattleBGMType Type;                                                            // 0x0009 (size: 0x1)
    char padding_0[0x6];                                                              // 0x000A (size: 0x6)
    TSoftObjectPtr<UAkAudioEvent> EventPtr;                                           // 0x0010 (size: 0x28)
    bool bIsBattleEndSetting;                                                         // 0x0038 (size: 0x1)
    bool bIsMapResultSetting;                                                         // 0x0039 (size: 0x1)

}; // Size: 0x40

struct FSBMapBossBGMTableRow : public FTableRowBase
{
    FString Memo;                                                                     // 0x0008 (size: 0x10)
    FString ContentId;                                                                // 0x0018 (size: 0x10)
    TArray<FSBMapBossBattleSettingData> BattleDataArray;                              // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBMapBossBGMThirdConditionData : public FSBMapBossBGMConditionDataBase
{
    char padding_0[0x18];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x18

struct FSBMapBossBattleSettingData
{
    ESBMapBossBGMEnemyConditionType EnemyConditionType;                               // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FString> BossEnmeyIDArray;                                                 // 0x0008 (size: 0x10)
    TArray<FSBMapBossBGMSettingData> SettingDataArray;                                // 0x0018 (size: 0x10)
    FString EnemyTag;                                                                 // 0x0028 (size: 0x10)
    TArray<FSBMapBossBGMSettingData_EnemyTotal> SettingDataArray_EnemyTotal;          // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBMapIconVisibleSettingData
{
    int32 QuestIndex;                                                                 // 0x0000 (size: 0x4)
    EQuestStatus Status;                                                              // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 Step;                                                                       // 0x0008 (size: 0x4)
    bool Visible;                                                                     // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBMapIconVisibleSettingTableRow : public FTableRowBase
{
    FName LocationId;                                                                 // 0x0008 (size: 0x8)
    bool BaseVisible;                                                                 // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    TArray<FSBMapIconVisibleSettingData> Settings;                                    // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBMapInfo : public FTableRowBase
{
    FName ID;                                                                         // 0x0008 (size: 0x8)
    TEnumAsByte<ESBMapType> MapType;                                                  // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    FString MapName;                                                                  // 0x0018 (size: 0x10)
    FString SublevelId;                                                               // 0x0028 (size: 0x10)
    FString BGMMapId;                                                                 // 0x0038 (size: 0x10)
    FString GameMode;                                                                 // 0x0048 (size: 0x10)
    int32 MaxPlayers;                                                                 // 0x0058 (size: 0x4)
    TEnumAsByte<ESBMapRegion> MapRegion;                                              // 0x005C (size: 0x1)
    char padding_1[0x3];                                                              // 0x005D (size: 0x3)
    FName ProcessInfo;                                                                // 0x0060 (size: 0x8)
    FName SupplyInfo;                                                                 // 0x0068 (size: 0x8)
    FName RewardInfo;                                                                 // 0x0070 (size: 0x8)
    FName TipsImageName;                                                              // 0x0078 (size: 0x8)
    FName DungeonImage;                                                               // 0x0080 (size: 0x8)
    FName MapActivator;                                                               // 0x0088 (size: 0x8)
    FName EventTerm;                                                                  // 0x0090 (size: 0x8)
    TEnumAsByte<ESBMissionType> MissionType;                                          // 0x0098 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0099 (size: 0x3)
    int32 TotalPower;                                                                 // 0x009C (size: 0x4)
    int32 RecommendedBattleScore;                                                     // 0x00A0 (size: 0x4)
    int32 ClassLevel;                                                                 // 0x00A4 (size: 0x4)
    int32 LevelSync;                                                                  // 0x00A8 (size: 0x4)
    FName QualifyInfo;                                                                // 0x00AC (size: 0x8)
    char padding_3[0x4];                                                              // 0x00B4 (size: 0x4)
    FString StartPortal;                                                              // 0x00B8 (size: 0x10)
    FName DungeonDifficulty;                                                          // 0x00C8 (size: 0x8)
    FName EnemySpawnInfo;                                                             // 0x00D0 (size: 0x8)
    FName EnemyAttribute;                                                             // 0x00D8 (size: 0x8)
    FName EnemyDifficulty;                                                            // 0x00E0 (size: 0x8)
    int32 EnemyBaseLevel;                                                             // 0x00E8 (size: 0x4)
    char padding_4[0x4];                                                              // 0x00EC (size: 0x4)
    FString EnemyUseId;                                                               // 0x00F0 (size: 0x10)
    TArray<FSBBattleNpcInfo> BattleNpc;                                               // 0x0100 (size: 0x10)
    float TimeOfDay;                                                                  // 0x0110 (size: 0x4)
    int32 TimeLimit;                                                                  // 0x0114 (size: 0x4)
    FString ExitPortalSpawnTarget;                                                    // 0x0118 (size: 0x10)
    FString TravelMapName;                                                            // 0x0128 (size: 0x10)
    FString TravelPortal;                                                             // 0x0138 (size: 0x10)
    FString RetireMapName;                                                            // 0x0148 (size: 0x10)
    FString RetirePortal;                                                             // 0x0158 (size: 0x10)
    bool IsActivateRequired;                                                          // 0x0168 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0169 (size: 0x3)
    int32 SortId;                                                                     // 0x016C (size: 0x4)
    int32 EntryConditionId;                                                           // 0x0170 (size: 0x4)
    int32 EntryConditionAdventurerRank;                                               // 0x0174 (size: 0x4)
    TEnumAsByte<ESBEntryConditionPartyState> EntryConditionPartyState;                // 0x0178 (size: 0x1)
    char padding_6[0x7];                                                              // 0x0179 (size: 0x7)
    TArray<ESBClassType> EntryConditionClassType;                                     // 0x0180 (size: 0x10)
    TArray<FName> EntryConditionClearQuest;                                           // 0x0190 (size: 0x10)
    int32 EntryConditionSubClassLv;                                                   // 0x01A0 (size: 0x4)
    int32 EntryConditionSubClassBonus;                                                // 0x01A4 (size: 0x4)
    FString TipsCategory;                                                             // 0x01A8 (size: 0x10)
    int32 MaxFloor;                                                                   // 0x01B8 (size: 0x4)
    char padding_7[0x4];                                                              // 0x01BC (size: 0x4)
    FString SiteUrl;                                                                  // 0x01C0 (size: 0x10)
    ESBStackBEnableType StackBEnableType;                                             // 0x01D0 (size: 0x1)

}; // Size: 0x1D8

struct FSBMapLevelInfo : public FTableRowBase
{
    FString GameContentId;                                                            // 0x0008 (size: 0x10)
    FString MapName;                                                                  // 0x0018 (size: 0x10)
    TEnumAsByte<ESBMapType> MapType;                                                  // 0x0028 (size: 0x1)
    TEnumAsByte<ESBMapRegion> MapRegion;                                              // 0x0029 (size: 0x1)
    char padding_0[0x6];                                                              // 0x002A (size: 0x6)
    FString SublevelId;                                                               // 0x0030 (size: 0x10)
    FString BGMMapId;                                                                 // 0x0040 (size: 0x10)
    FTransform SafeSpawnPoint;                                                        // 0x0050 (size: 0x30)

}; // Size: 0x80

struct FSBMapPlaceNamePlateConfig : public FTableRowBase
{
    FName MapId;                                                                      // 0x0008 (size: 0x8)
    FVector2D MapPosition;                                                            // 0x0010 (size: 0x8)
    FName NameTextId;                                                                 // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBMarkerDebugInfo
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

struct FSBMarkerTargetInfo
{
    int32 TargetIndex;                                                                // 0x0000 (size: 0x4)
    FVector TargetLocation;                                                           // 0x0004 (size: 0xC)

}; // Size: 0x10

struct FSBMarkerTargetStateInfo
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBMasterAdventureCardDecoration
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBAdventureCardDecorationType Type;                                              // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FSBTextTableHash Name;                                                            // 0x0008 (size: 0x4)
    bool bInitialGrant;                                                               // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBMasterAwardsData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0004 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBMasterCostume
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    ESBRarity Rarity;                                                                 // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FSBTextTableHash Name;                                                            // 0x0008 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x000C (size: 0x4)
    int32 ItemLevel;                                                                  // 0x0010 (size: 0x4)
    int32 PricePlayerSells;                                                           // 0x0014 (size: 0x4)
    int32 PricePlayerBuys;                                                            // 0x0018 (size: 0x4)
    int32 StackInventoryNum;                                                          // 0x001C (size: 0x4)
    int32 StackStorageNum;                                                            // 0x0020 (size: 0x4)
    int32 SortId;                                                                     // 0x0024 (size: 0x4)
    EProtectorCategory ProtectorCategory;                                             // 0x0028 (size: 0x1)
    EEquipableGender EquipableGender;                                                 // 0x0029 (size: 0x1)
    char padding_1[0x6];                                                              // 0x002A (size: 0x6)
    FEquipableClass EquipableClass;                                                   // 0x0030 (size: 0x10)
    int32 CostumePartsId;                                                             // 0x0040 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0044 (size: 0x4)
    FString CostumePartsName;                                                         // 0x0048 (size: 0x10)
    int32 CostumePartsColorId;                                                        // 0x0058 (size: 0x4)
    int32 CostumePartsColorSaturation;                                                // 0x005C (size: 0x4)
    int32 CostumePartsColorValue;                                                     // 0x0060 (size: 0x4)
    bool IsAllowedToChangeColor;                                                      // 0x0064 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0065 (size: 0x3)
    int32 MaterialId;                                                                 // 0x0068 (size: 0x4)
    int32 DurationMinutes;                                                            // 0x006C (size: 0x4)
    FString EventTermId;                                                              // 0x0070 (size: 0x10)
    bool IsCompositeWear;                                                             // 0x0080 (size: 0x1)

}; // Size: 0x88

struct FSBMasterDataStatus
{
    ESBMasterDataStatus Status;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    class USBHttpQuery* HttpQuery;                                                    // 0x0008 (size: 0x8)
    int32 ResponseCode;                                                               // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBMasterDataStatusList
{
    TArray<FSBMasterDataStatus> StatusList;                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBMasterDungeonRankedReward
{
    FName MapId;                                                                      // 0x0000 (size: 0x8)
    ESBClassType ClassType;                                                           // 0x0008 (size: 0x1)
    ESBDungeonEvaluation Evaluation;                                                  // 0x0009 (size: 0x1)
    char padding_0[0x2];                                                              // 0x000A (size: 0x2)
    int32 MaximumValue;                                                               // 0x000C (size: 0x4)
    FName DungeonRewardSearchName;                                                    // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBMasterDungeonReward
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    FName DungeonRewardSearchName;                                                    // 0x0008 (size: 0x8)
    FName RewardId;                                                                   // 0x0010 (size: 0x8)
    ESBRewardMethod RewardMethod;                                                     // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    float Probability;                                                                // 0x001C (size: 0x4)
    ESBRewardSetType RewardSetType;                                                   // 0x0020 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0021 (size: 0x3)
    int32 SortId;                                                                     // 0x0024 (size: 0x4)
    FName EventTerm;                                                                  // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FSBMasterDxBattleContributonScoreAttenuAtion
{
    FString ManagementId;                                                             // 0x0000 (size: 0x10)
    FString GameContentId;                                                            // 0x0010 (size: 0x10)
    ESBDxBattleContributonScoreType ScoreType;                                        // 0x0020 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0021 (size: 0x3)
    int32 AttenuationLevel;                                                           // 0x0024 (size: 0x4)
    int32 StartValue;                                                                 // 0x0028 (size: 0x4)
    int32 Rate;                                                                       // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBMasterDxBattleContributonScoreConefficient
{
    FString ManagementId;                                                             // 0x0000 (size: 0x10)
    FString GameContentId;                                                            // 0x0010 (size: 0x10)
    ESBDxBattleContributonScoreType ScoreType;                                        // 0x0020 (size: 0x1)
    ESBDxBattleCoefficientScoreType CoefficientType;                                  // 0x0021 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0022 (size: 0x2)
    float CoefficientValue;                                                           // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBMasterEquipmentSeries
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBEquipmentSeries> EquipmentList;                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBMasterEventChallengeQuestDrop
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString TermId;                                                                   // 0x0010 (size: 0x10)
    int32 EntryConditionId;                                                           // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    TArray<FSBEntryAbilityData> EntryAbilitySet;                                      // 0x0028 (size: 0x10)
    TArray<FSBDropData> DropList;                                                     // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBMasterFreeBuffBuffSorting
{
    ESBFreeBuffPointType Buff_Type;                                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 BuffRate;                                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBMasterFreeBuffLotRate
{
    ESBFreeBuffPointView Buffpoint_View;                                              // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString Use_CCD;                                                                  // 0x0008 (size: 0x10)
    TArray<FSBMasterFreeBuffBuffSorting> Buff_Sorting;                                // 0x0018 (size: 0x10)
    int32 Rate;                                                                       // 0x0028 (size: 0x4)
    char padding_1[0x4];                                                              // 0x002C (size: 0x4)
    FString Term_Id;                                                                  // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FSBMasterFreeBuffPoint
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBMasterFreeBuffLotRate> Lot_Rate;                                        // 0x0008 (size: 0x10)
    bool Enable_Flag;                                                                 // 0x0018 (size: 0x1)
    bool Monday;                                                                      // 0x0019 (size: 0x1)
    bool Tuesday;                                                                     // 0x001A (size: 0x1)
    bool Wendneday;                                                                   // 0x001B (size: 0x1)
    bool Thursday;                                                                    // 0x001C (size: 0x1)
    bool Friday;                                                                      // 0x001D (size: 0x1)
    bool Saturday;                                                                    // 0x001E (size: 0x1)
    bool Sunday;                                                                      // 0x001F (size: 0x1)
    FDateTime Start_date;                                                             // 0x0020 (size: 0x8)
    FDateTime End_date;                                                               // 0x0028 (size: 0x8)
    float Respawn_rate;                                                               // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBMasterFusionItem
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    int32 NeedSlotCount;                                                              // 0x0004 (size: 0x4)
    int32 AbilityEffectPickupId;                                                      // 0x0008 (size: 0x4)
    int32 SupportItemId;                                                              // 0x000C (size: 0x4)
    int32 SupportItemAmount;                                                          // 0x0010 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FSBMasterGuildBonus
{
    FName RewardId;                                                                   // 0x0000 (size: 0x8)
    int32 Percent;                                                                    // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBMasterImagine
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBImagineCategoryType ImagineType;                                               // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FSBTextTableHash Name;                                                            // 0x0008 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x000C (size: 0x4)
    int32 Rarity;                                                                     // 0x0010 (size: 0x4)
    int32 MaxLevel;                                                                   // 0x0014 (size: 0x4)
    ESBAttribute Attribute;                                                           // 0x0018 (size: 0x1)
    bool EquipPosition1;                                                              // 0x0019 (size: 0x1)
    bool EquipPosition2;                                                              // 0x001A (size: 0x1)
    bool EquipPosition3;                                                              // 0x001B (size: 0x1)
    bool EquipPosition4;                                                              // 0x001C (size: 0x1)
    bool EquipPosition5;                                                              // 0x001D (size: 0x1)
    char padding_1[0x2];                                                              // 0x001E (size: 0x2)
    FString ParamType;                                                                // 0x0020 (size: 0x10)
    FString ImagineArts;                                                              // 0x0030 (size: 0x10)
    FString PerkType;                                                                 // 0x0040 (size: 0x10)
    int32 PricePlayerSells;                                                           // 0x0050 (size: 0x4)
    bool IsNoSale;                                                                    // 0x0054 (size: 0x1)
    bool IsDisallowRefining;                                                          // 0x0055 (size: 0x1)
    bool IsDisallowFusion;                                                            // 0x0056 (size: 0x1)
    bool IsAccounting;                                                                // 0x0057 (size: 0x1)
    bool IsIllust;                                                                    // 0x0058 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0059 (size: 0x3)
    int32 SortId;                                                                     // 0x005C (size: 0x4)
    int32 MaterialExp;                                                                // 0x0060 (size: 0x4)
    float ConvertExpRate;                                                             // 0x0064 (size: 0x4)
    int32 DurationMinutes;                                                            // 0x0068 (size: 0x4)
    char padding_3[0x4];                                                              // 0x006C (size: 0x4)
    FString EventTermId;                                                              // 0x0070 (size: 0x10)
    FSBTextTableHash HyouiName;                                                       // 0x0080 (size: 0x4)
    FSBTextTableHash HyouiDesc;                                                       // 0x0084 (size: 0x4)
    bool IsHyoui;                                                                     // 0x0088 (size: 0x1)
    bool IsStackBEnable;                                                              // 0x0089 (size: 0x1)
    char padding_4[0x6];                                                              // 0x008A (size: 0x6)
    FString StackBTypeId;                                                             // 0x0090 (size: 0x10)
    FString StackBStatusId;                                                           // 0x00A0 (size: 0x10)

}; // Size: 0xB0

struct FSBMasterItemBox
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    EItemBoxType ItemBoxType;                                                         // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 NumOfSelectOrLottery;                                                       // 0x0008 (size: 0x4)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBItemBoxContentParam> ItemBoxContents;                                   // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBMasterMountImagine
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString MountId;                                                                  // 0x0008 (size: 0x10)
    FSBTextTableHash NameTextId;                                                      // 0x0018 (size: 0x4)
    FSBTextTableHash DescTextId;                                                      // 0x001C (size: 0x4)
    float MaxStamina;                                                                 // 0x0020 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0024 (size: 0x4)
    FString BGM;                                                                      // 0x0028 (size: 0x10)
    int32 PricePlayerSells;                                                           // 0x0038 (size: 0x4)
    bool bNotSell;                                                                    // 0x003C (size: 0x1)
    bool bNotDelete;                                                                  // 0x003D (size: 0x1)
    char padding_2[0x2];                                                              // 0x003E (size: 0x2)
    int32 SortId;                                                                     // 0x0040 (size: 0x4)
    int32 DurationMinutes;                                                            // 0x0044 (size: 0x4)
    FString EventTermId;                                                              // 0x0048 (size: 0x10)
    bool IsStackBEnable;                                                              // 0x0058 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0059 (size: 0x7)
    FString StackBTypeId;                                                             // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FSBMasterPineVillageEvents
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString PreparationPeriodTermId;                                                  // 0x0008 (size: 0x10)
    FString CompetitionPeriodTermId;                                                  // 0x0018 (size: 0x10)
    FString BenefitPeriodTermId;                                                      // 0x0028 (size: 0x10)
    int32 PointTokenId;                                                               // 0x0038 (size: 0x4)
    char padding_1[0x4];                                                              // 0x003C (size: 0x4)
    TArray<FSBPineVillageRankingRewards> RankingRewards;                              // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBMasterPineVillageLeagues
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 MasterPointRankingEventId;                                                  // 0x0004 (size: 0x4)
    ESBPineVillageLeaguesType LeagueType;                                             // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 PromotionAbovePercentage;                                                   // 0x000C (size: 0x4)
    int32 DemotionBelowPercentage;                                                    // 0x0010 (size: 0x4)
    int32 ConsecutiveDayAmountForDemotionJudgement;                                   // 0x0014 (size: 0x4)
    TArray<FSBPineVillageTierRewards> TierRewards;                                    // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBMasterReward
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    ESBRewardItemType RewardType;                                                     // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 ItemId;                                                                     // 0x000C (size: 0x4)
    int32 Amount;                                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBMasterRewardControl
{
    float LunoMultiplier;                                                             // 0x0000 (size: 0x4)
    float ExpMultiplier;                                                              // 0x0004 (size: 0x4)
    float MaterialRateBoost;                                                          // 0x0008 (size: 0x4)
    float MaterialAmountMultiplier;                                                   // 0x000C (size: 0x4)
    int32 MaterialAmountAddition;                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBMasterRewardLotteryGroups
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBRewardItemType Reward_Type;                                                    // 0x0004 (size: 0x1)
    ESBRewardLotteryGroupsPickType Pick_Type;                                         // 0x0005 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0006 (size: 0x2)
    TArray<FSBMasterRewardLotteryGroupsRewards> Rewards;                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBMasterRewardLotteryGroupsRewards
{
    int32 item_id;                                                                    // 0x0000 (size: 0x4)
    int32 Critical_Rate;                                                              // 0x0004 (size: 0x4)
    int32 Slot1_Rate;                                                                 // 0x0008 (size: 0x4)
    int32 Slot2_Rate;                                                                 // 0x000C (size: 0x4)
    int32 Slot3_Rate;                                                                 // 0x0010 (size: 0x4)
    int32 Slot4_Rate;                                                                 // 0x0014 (size: 0x4)
    int32 Slot1_Rate_If_Critical;                                                     // 0x0018 (size: 0x4)
    int32 Slot2_Rate_If_Critical;                                                     // 0x001C (size: 0x4)
    int32 Slot3_Rate_If_Critical;                                                     // 0x0020 (size: 0x4)
    int32 Slot4_Rate_If_Critical;                                                     // 0x0024 (size: 0x4)
    FName Perk_Pick_ID;                                                               // 0x0028 (size: 0x8)
    int32 Min_Level;                                                                  // 0x0030 (size: 0x4)
    int32 Max_Level;                                                                  // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FSBMasterSeason
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FSBTextTableHash SeasonNameTextId;                                                // 0x0004 (size: 0x4)
    FDateTime StartDate;                                                              // 0x0008 (size: 0x8)
    FDateTime EndDate;                                                                // 0x0010 (size: 0x8)
    FDateTime ReceiveOnlyStartDate;                                                   // 0x0018 (size: 0x8)
    FDateTime ReceiveOnlyEndDate;                                                     // 0x0020 (size: 0x8)
    int32 RankupPoint;                                                                // 0x0028 (size: 0x4)
    int32 RankupFree;                                                                 // 0x002C (size: 0x4)
    int32 RankupPaid;                                                                 // 0x0030 (size: 0x4)
    int32 MaxRank;                                                                    // 0x0034 (size: 0x4)
    int32 ShopEmancipationRank;                                                       // 0x0038 (size: 0x4)
    int32 PointMax;                                                                   // 0x003C (size: 0x4)
    int32 PickupUnit;                                                                 // 0x0040 (size: 0x4)
    FSBTextTableHash GuidePaidPlanTextId;                                             // 0x0044 (size: 0x4)

}; // Size: 0x48

struct FSBMasterSeasonPass
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 SeasonId;                                                                   // 0x0004 (size: 0x4)
    ESBSeasonPassPlanState Type;                                                      // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 NeedFree;                                                                   // 0x000C (size: 0x4)
    int32 NeedPaid;                                                                   // 0x0010 (size: 0x4)
    int32 RewardRank;                                                                 // 0x0014 (size: 0x4)
    bool bUnlockPaidQuest;                                                            // 0x0018 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0019 (size: 0x7)
    FString RewardId;                                                                 // 0x0020 (size: 0x10)
    FSBTextTableHash PlanNameTextId;                                                  // 0x0030 (size: 0x4)
    FSBTextTableHash DescriptionTextId;                                               // 0x0034 (size: 0x4)
    int32 AttentionTextId;                                                            // 0x0038 (size: 0x4)

}; // Size: 0x40

struct FSBMasterSeasonPassReward
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    int32 SeasonId;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0x20

struct FSBMasterSkillType
{
    FString skill_type;                                                               // 0x0000 (size: 0x10)
    int32 LevelCap;                                                                   // 0x0010 (size: 0x4)
    int32 text_id;                                                                    // 0x0014 (size: 0x4)
    int32 desc_id;                                                                    // 0x0018 (size: 0x4)
    int32 Priority;                                                                   // 0x001C (size: 0x4)
    int32 category_id;                                                                // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBMasterTreasure
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBMasterTreasureRarityRate> Rarity_Rate;                                  // 0x0008 (size: 0x10)
    TArray<FSBMasterTreasureLotRate> Lot_Rate;                                        // 0x0018 (size: 0x10)
    float Respawn_Interval;                                                           // 0x0028 (size: 0x4)
    bool Enable_Flag;                                                                 // 0x002C (size: 0x1)
    bool Monday;                                                                      // 0x002D (size: 0x1)
    bool Tuesday;                                                                     // 0x002E (size: 0x1)
    bool Wendneday;                                                                   // 0x002F (size: 0x1)
    bool Thursday;                                                                    // 0x0030 (size: 0x1)
    bool Friday;                                                                      // 0x0031 (size: 0x1)
    bool Saturday;                                                                    // 0x0032 (size: 0x1)
    bool Sunday;                                                                      // 0x0033 (size: 0x1)
    char padding_1[0x4];                                                              // 0x0034 (size: 0x4)
    FDateTime Start_date;                                                             // 0x0038 (size: 0x8)
    FDateTime End_date;                                                               // 0x0040 (size: 0x8)
    float Respawn_rate;                                                               // 0x0048 (size: 0x4)
    int32 Respawn_warranty;                                                           // 0x004C (size: 0x4)
    float Respawn_time;                                                               // 0x0050 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0054 (size: 0x4)
    FString SE;                                                                       // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FSBMasterTreasureLotRate
{
    uint8 Lot_Flag;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    ESBTreasureBoxRewardType Reward_Type;                                             // 0x0004 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0005 (size: 0x3)
    int32 Reward_Master_Id;                                                           // 0x0008 (size: 0x4)
    int32 Reward_Amount_Min;                                                          // 0x000C (size: 0x4)
    int32 Reward_Amount_Max;                                                          // 0x0010 (size: 0x4)
    ESBTreasureBoxRarity Rarity_Min;                                                  // 0x0014 (size: 0x1)
    ESBTreasureBoxRarity Rarity_Max;                                                  // 0x0015 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0016 (size: 0x2)
    int32 Rate;                                                                       // 0x0018 (size: 0x4)
    ESBObjectConditionType condition_times;                                           // 0x001C (size: 0x1)

}; // Size: 0x20

struct FSBMasterTreasureRarityRate
{
    ESBTreasureBoxRarity Rarity;                                                      // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 Rate;                                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBMasterVersionData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString Version;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBMasterWarpPoint
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    FString GameContentId;                                                            // 0x0008 (size: 0x10)
    FString DestGameContentId;                                                        // 0x0018 (size: 0x10)
    FString Address;                                                                  // 0x0028 (size: 0x10)
    FString Portal;                                                                   // 0x0038 (size: 0x10)
    FVector2D LocationXY;                                                             // 0x0048 (size: 0x8)
    FString FieldGameContentId;                                                       // 0x0050 (size: 0x10)
    FVector2D FieldLocationXY;                                                        // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FSBMatchingConfiguration
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

struct FSBMatchingSettings
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBMaterialBaseReplaceData
{
    TSoftObjectPtr<UMaterialInterface> MaterialBase;                                  // 0x0000 (size: 0x28)
    TSoftObjectPtr<UMaterialInterface> MaterialReplace;                               // 0x0028 (size: 0x28)

}; // Size: 0x50

struct FSBMaterialBaseReplaceDataArray
{
    TArray<FSBMaterialBaseReplaceData> MaterialBaseReplaceDataArray;                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBMaterialColorInfo
{
    int32 MaterialIndex;                                                              // 0x0000 (size: 0x4)
    int32 EmissiveColorIndex;                                                         // 0x0004 (size: 0x4)
    int32 TargetTagIndex;                                                             // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBMaterialParamInfo
{
    FName MaterialParamName;                                                          // 0x0000 (size: 0x8)
    float ParamValue;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBMaterialVectorParamInfo
{
    FName MaterialParamName;                                                          // 0x0000 (size: 0x8)
    float R;                                                                          // 0x0008 (size: 0x4)
    float G;                                                                          // 0x000C (size: 0x4)
    float B;                                                                          // 0x0010 (size: 0x4)
    float A;                                                                          // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBMaterialVisibilityInfo
{
    int32 MaterialIndex;                                                              // 0x0000 (size: 0x4)
    FSBEnemyMaterialVisibilityFlag Flag;                                              // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBMeshClimbingHandsOffset
{
    float Height;                                                                     // 0x0000 (size: 0x4)
    FVector Offset;                                                                   // 0x0004 (size: 0xC)

}; // Size: 0x10

struct FSBMigrationInfo
{
    FString MapName;                                                                  // 0x0000 (size: 0x10)
    float LimitTime;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBMinMaxF
{
    float Min;                                                                        // 0x0000 (size: 0x4)
    float Max;                                                                        // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBMiniMapQuestAreaConfig : public FTableRowBase
{
    FVector Location;                                                                 // 0x0008 (size: 0xC)
    FName GameContentId;                                                              // 0x0014 (size: 0x8)
    FName RouteGuideGameContentId;                                                    // 0x001C (size: 0x8)
    ESBRouteGuideArea RouteGuideArea;                                                 // 0x0024 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0025 (size: 0x3)
    float Range;                                                                      // 0x0028 (size: 0x4)
    FLinearColor Color;                                                               // 0x002C (size: 0x10)

}; // Size: 0x40

struct FSBMissionListInfo
{
    FSBDungeonCompleteState DungeonInfo;                                              // 0x0000 (size: 0x14)
    bool BoostFree;                                                                   // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FSBMissionQuestMissionElementalBurst
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBMissionQuestMissionScore
{
    int32 Damage_Point;                                                               // 0x0000 (size: 0x4)
    int32 Damage_Count;                                                               // 0x0004 (size: 0x4)
    int32 CriticalDamege_Point;                                                       // 0x0008 (size: 0x4)
    int32 CriticalDamege_Count;                                                       // 0x000C (size: 0x4)
    int32 TakeDamege_Point;                                                           // 0x0010 (size: 0x4)
    int32 TakeDamege_Count;                                                           // 0x0014 (size: 0x4)
    int32 DestructBomb_Count;                                                         // 0x0018 (size: 0x4)
    int32 DestructObject_Count;                                                       // 0x001C (size: 0x4)
    int32 JustAvoid_Count;                                                            // 0x0020 (size: 0x4)
    int32 Dead_Count;                                                                 // 0x0024 (size: 0x4)
    int32 TreasureGet_Count;                                                          // 0x0028 (size: 0x4)
    int32 SupplierUse_Count;                                                          // 0x002C (size: 0x4)
    TArray<FSBMissionQuestMissionScoreDebuf> BadStatusCountList;                      // 0x0030 (size: 0x10)
    TArray<FSBMissionQuestMissionScoreDebuf> TakeBadStatusCountList;                  // 0x0040 (size: 0x10)
    TArray<FSBMissionQuestMissionScoreDebuf> TakeElementCountList;                    // 0x0050 (size: 0x10)
    TArray<FSBMissionQuestMissionElementalBurst> ElementalBurstCountList;             // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FSBMissionQuestMissionScoreDebuf
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBMissionQuestMissionScoreSkill
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBMissionQuestMissionSupplier
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBMissionQuestRequestParam
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

struct FSBMobBodyType : public FTableRowBase
{
    TSoftObjectPtr<USBCharaCreateData> CharaCreateData;                               // 0x0008 (size: 0x28)
    ECharaPartsRegion Region;                                                         // 0x0030 (size: 0x1)
    ENpcJob Role;                                                                     // 0x0031 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0032 (size: 0x2)
    int32 Group;                                                                      // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FSBMobMoveParameter
{
    float MeanWalkSpeedRate;                                                          // 0x0000 (size: 0x4)
    float StandardDeviationWalkSpeedRate;                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBMobRandomSpawnHairColor
{
    TArray<ESBCharaCreateColorHue> HueArray;                                          // 0x0000 (size: 0x10)
    TArray<FSBMobRandomSpawnHueAndWeight> HueAndWeightArray;                          // 0x0010 (size: 0x10)
    int32 MinValue;                                                                   // 0x0020 (size: 0x4)
    int32 MaxValue;                                                                   // 0x0024 (size: 0x4)

}; // Size: 0x48

struct FSBMobRandomSpawnHueAndWeight
{
    ESBCharaCreateColorHue Hue;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float Weight;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBMobRandomSpawnSkinColor
{
    TArray<int32> HueArray;                                                           // 0x0000 (size: 0x10)
    int32 MinValue;                                                                   // 0x0010 (size: 0x4)
    int32 MaxValue;                                                                   // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBMobRegionAndBodyTypeParam : public FTableRowBase
{
    TEnumAsByte<ESBMapRegion> Region;                                                 // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    FSBMobRegionBodyTypeParam M000;                                                   // 0x0010 (size: 0x68)
    FSBMobRegionBodyTypeParam M100;                                                   // 0x0078 (size: 0x68)
    FSBMobRegionBodyTypeParam M200;                                                   // 0x00E0 (size: 0x68)
    FSBMobRegionBodyTypeParam M300;                                                   // 0x0148 (size: 0x68)
    FSBMobRegionBodyTypeParam M400;                                                   // 0x01B0 (size: 0x68)
    FSBMobRegionBodyTypeParam M500;                                                   // 0x0218 (size: 0x68)
    FSBMobRegionBodyTypeParam F000;                                                   // 0x0280 (size: 0x68)
    FSBMobRegionBodyTypeParam F100;                                                   // 0x02E8 (size: 0x68)
    FSBMobRegionBodyTypeParam F200;                                                   // 0x0350 (size: 0x68)
    FSBMobRegionBodyTypeParam F300;                                                   // 0x03B8 (size: 0x68)
    FSBMobRegionBodyTypeParam F400;                                                   // 0x0420 (size: 0x68)
    FSBMobRegionBodyTypeParam F500;                                                   // 0x0488 (size: 0x68)

}; // Size: 0x4F0

struct FSBMobRegionBodyTypeParam
{
    FSBMobRandomSpawnSkinColor RandomSpawnSkinColor;                                  // 0x0000 (size: 0x18)
    FSBMobRandomSpawnHairColor RandomSpawnHairColor;                                  // 0x0018 (size: 0x48)
    FSBMobMoveParameter MobMoveParameter;                                             // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FSBMountEffectParams
{
    ESBMountEffectType EffectType;                                                    // 0x0000 (size: 0x1)
    bool bOneShot;                                                                    // 0x0001 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0002 (size: 0x6)
    class UParticleSystem* PSTemplate;                                                // 0x0008 (size: 0x8)
    FName SocketName;                                                                 // 0x0010 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0018 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x0024 (size: 0xC)
    bool bAttached;                                                                   // 0x0030 (size: 0x1)
    bool bCastShadow;                                                                 // 0x0031 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0032 (size: 0x2)
    float Scale;                                                                      // 0x0034 (size: 0x4)
    float MinimumIntervalTime;                                                        // 0x0038 (size: 0x4)
    char padding_2[0x4];                                                              // 0x003C (size: 0x4)
    class UAkAudioEvent* AkAudioEvent;                                                // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBMountIKParam
{
    bool bIsActiveLeftGrip;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName SocketNameLeftGrip;                                                         // 0x0004 (size: 0x8)
    bool bIsActiveRightGrip;                                                          // 0x000C (size: 0x1)
    char padding_1[0x3];                                                              // 0x000D (size: 0x3)
    FName SocketNameRightGrip;                                                        // 0x0010 (size: 0x8)
    bool bIsActiveLeftSole;                                                           // 0x0018 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0019 (size: 0x3)
    FName SocketNameLeftSole;                                                         // 0x001C (size: 0x8)
    bool bIsActiveRightSole;                                                          // 0x0024 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0025 (size: 0x3)
    FName SocketNameRightSole;                                                        // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FSBMountPlayingEffect
{
    FSBPlayingEffect PlayingEffect;                                                   // 0x0008 (size: 0xC8)

}; // Size: 0xE0

struct FSBMouseSettings
{
    TEnumAsByte<ESBKeyConfigMouseKey::Type> MoveFront;                                // 0x0000 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> MoveBack;                                 // 0x0001 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> MoveLeft;                                 // 0x0002 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> MoveRight;                                // 0x0003 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Walk;                                     // 0x0004 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Dash;                                     // 0x0005 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> AutoRun;                                  // 0x0006 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> RouteGuideAutoRun;                        // 0x0007 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Jump;                                     // 0x0008 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> OrientToCamera;                           // 0x0009 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> MainAction;                               // 0x000A (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> SubAction;                                // 0x000B (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> LeftSkill;                                // 0x000C (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> RightSkill;                               // 0x000D (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Skill1;                                   // 0x000E (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Skill2;                                   // 0x000F (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Skill3;                                   // 0x0010 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Skill4;                                   // 0x0011 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> SpecialSkill;                             // 0x0012 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Dodge;                                    // 0x0013 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Interaction;                              // 0x0014 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Reload;                                   // 0x0015 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ImagineArts;                              // 0x0016 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ImagineArts2;                             // 0x0017 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ImagineMount;                             // 0x0018 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> CameraPitchUp;                            // 0x0019 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> CameraPitchDown;                          // 0x001A (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> CameraYawLeft;                            // 0x001B (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> CameraYawRight;                           // 0x001C (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> CameraZoomIn;                             // 0x001D (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> CameraZoomOut;                            // 0x001E (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> CameraReset;                              // 0x001F (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> LockOn;                                   // 0x0020 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> LockOnTargetRight;                        // 0x0021 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> LockOnTargetLeft;                         // 0x0022 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutExec;                             // 0x0023 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutMoveLeft;                         // 0x0024 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutMoveRight;                        // 0x0025 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> MainMenu;                                 // 0x0026 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ChatWindow;                               // 0x0027 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAMyCharacter;                            // 0x0028 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAInventory;                              // 0x0029 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAQuest;                                  // 0x002A (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAMap;                                    // 0x002B (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QALibrary;                                // 0x002C (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAContents;                               // 0x002D (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAParty;                                  // 0x002E (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAGuild;                                  // 0x002F (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAMyGacha;                                // 0x0030 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAOption;                                 // 0x0031 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAPhotoMode;                              // 0x0032 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QAHUD;                                    // 0x0033 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QACommunicate;                            // 0x0034 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRing;                             // 0x0035 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRingExeF5;                        // 0x0036 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRingExeF6;                        // 0x0037 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRingExeF7;                        // 0x0038 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRingExeF8;                        // 0x0039 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRingExeF9;                        // 0x003A (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRingExeF10;                       // 0x003B (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRingExeF11;                       // 0x003C (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> ShortcutRingExeF12;                       // 0x003D (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> WholeMap;                                 // 0x003E (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Screenshot;                               // 0x003F (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMarkRegist;                           // 0x0040 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark1;                                // 0x0041 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark2;                                // 0x0042 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark3;                                // 0x0043 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark4;                                // 0x0044 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark5;                                // 0x0045 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark6;                                // 0x0046 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark7;                                // 0x0047 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark8;                                // 0x0048 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark9;                                // 0x0049 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark10;                               // 0x004A (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark11;                               // 0x004B (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark12;                               // 0x004C (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark13;                               // 0x004D (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark14;                               // 0x004E (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark15;                               // 0x004F (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark16;                               // 0x0050 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark17;                               // 0x0051 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark18;                               // 0x0052 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark19;                               // 0x0053 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark20;                               // 0x0054 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark21;                               // 0x0055 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark22;                               // 0x0056 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark23;                               // 0x0057 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> BookMark24;                               // 0x0058 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> Pushpin;                                  // 0x0059 (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> PhotoMode;                                // 0x005A (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> QuestHudChange;                           // 0x005B (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> KeyGuide;                                 // 0x005C (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> SkillPaletteChange;                       // 0x005D (size: 0x1)
    TEnumAsByte<ESBKeyConfigMouseKey::Type> NowParty;                                 // 0x005E (size: 0x1)
    char padding_0[0x1];                                                              // 0x005F (size: 0x1)
    float InputStrength;                                                              // 0x0060 (size: 0x4)
    float AimAssist_FitTargetStrength;                                                // 0x0064 (size: 0x4)
    float AimAssist_FollowTargetStrength;                                             // 0x0068 (size: 0x4)
    float AimAssist_CameraBrakeStrength;                                              // 0x006C (size: 0x4)
    uint8 bReverseMouseYAxis;                                                         // 0x0070 (size: 0x1)
    uint8 bReverseMouseXAxis;                                                         // 0x0070 (size: 0x1)

}; // Size: 0x98

struct FSBMoveSpeedSetting
{
    TArray<FName> AnimTags;                                                           // 0x0000 (size: 0x10)
    float MoveSpeedRate;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBMovieSceneAudioEventTemplate : public FMovieSceneEvalTemplate
{
    class USBMovieSceneAudioEventSection* Section;                                    // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSBMovieSceneAudioListenerTemplate : public FMovieSceneEvalTemplate
{
    char padding_0[0x2A8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2A8

struct FSBMovieSceneChoiceDialogSectionTemplate : public FMovieSceneEvalTemplate
{
    class USBTextTableAsset* TextTable;                                               // 0x0020 (size: 0x8)
    FMovieSceneChoiceDialogSectionData ChoiceDialogData;                              // 0x0028 (size: 0x88)

}; // Size: 0xB0

struct FSBMovieSceneNotifySectionTemplate : public FMovieSceneEvalTemplate
{
    class USBMovieSceneNotifySection* Section;                                        // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSBMovieSceneSkeletalAnimationSectionTemplate : public FMovieSceneSkeletalAnimationSectionTemplate
{
    class UAnimSequenceBase* FemaleAnimation;                                         // 0x0100 (size: 0x8)
    ESBRootMotionType RootMotionType;                                                 // 0x0108 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0109 (size: 0x3)
    int32 PreRollFrames;                                                              // 0x010C (size: 0x4)
    uint8 bLoop;                                                                      // 0x0110 (size: 0x1)

}; // Size: 0x118

struct FSBMovieSceneTextWindowSectionTemplate : public FMovieSceneEvalTemplate
{
    class USBTextTableAsset* TextTable;                                               // 0x0020 (size: 0x8)
    FName SpeakerId;                                                                  // 0x0028 (size: 0x8)
    FName TextId;                                                                     // 0x0030 (size: 0x8)
    ESBMovieSceneTextWindowGender Gender;                                             // 0x0038 (size: 0x1)
    bool bUseSubtitle;                                                                // 0x0039 (size: 0x1)

}; // Size: 0x40

struct FSBMultiType : public FTableRowBase
{
    int32 Int32Value;                                                                 // 0x0008 (size: 0x4)
    float FloatValue;                                                                 // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBMulticastDamageEvent
{
    float Damage;                                                                     // 0x0000 (size: 0x4)
    int32 AttackID;                                                                   // 0x0004 (size: 0x4)
    uint8 DamageHitStopTime;                                                          // 0x0008 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0009 (size: 0x1)
    FSBDamageEventStunDataForMulticast StunData;                                      // 0x000A (size: 0x4)
    char padding_1[0x2];                                                              // 0x000E (size: 0x2)
    TArray<FSBDamageEventElementDataForMulticast> ElementDataList;                    // 0x0010 (size: 0x10)
    uint8 CollisionGroupId;                                                           // 0x0020 (size: 0x1)
    int8 HitEffectAngle;                                                              // 0x0021 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0022 (size: 0x2)
    FVector_NetQuantizeNormal ShotDirection;                                          // 0x0024 (size: 0xC)
    TWeakObjectPtr<class UPrimitiveComponent> HitComponent;                           // 0x0030 (size: 0x8)
    FVector_NetQuantize ImpactPoint;                                                  // 0x0038 (size: 0xC)
    TEnumAsByte<ESBInvincibleAnimation::Type> InvincibleAnimationType;                // 0x0044 (size: 0x1)
    uint8 SkillPosition;                                                              // 0x0045 (size: 0x1)
    uint16 DamageKnockBackDistance;                                                   // 0x0046 (size: 0x2)
    uint8 DamageKnockBackTime;                                                        // 0x0048 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0049 (size: 0x7)
    FSBDamageEventCommonFlag BitFlag;                                                 // 0x0050 (size: 0x30)
    uint8 bSpecialAttack;                                                             // 0x0080 (size: 0x1)
    uint8 bResurrection;                                                              // 0x0080 (size: 0x1)
    uint8 bResurrectionNotReduceHP;                                                   // 0x0080 (size: 0x1)
    uint8 bInfiniteHitPoint;                                                          // 0x0080 (size: 0x1)
    uint8 bKeepAlive;                                                                 // 0x0080 (size: 0x1)
    uint8 bInstantDeath;                                                              // 0x0080 (size: 0x1)
    uint8 bInventoryIndex1;                                                           // 0x0080 (size: 0x1)
    uint8 bInvalidDamageFromAbility;                                                  // 0x0080 (size: 0x1)
    uint8 bMissDamageFromAbility;                                                     // 0x0081 (size: 0x1)
    char padding_4[0x2];                                                              // 0x0082 (size: 0x2)
    ESBFieldDamageType FieldDamageType;                                               // 0x0084 (size: 0x1)

}; // Size: 0x88

struct FSBMulticastDotDamageEvent
{
    float Damage;                                                                     // 0x0000 (size: 0x4)
    uint8 bInfiniteHitPoint;                                                          // 0x0004 (size: 0x1)
    uint8 bKeepAlive;                                                                 // 0x0004 (size: 0x1)
    uint8 bInstantDeath;                                                              // 0x0004 (size: 0x1)
    uint8 bSubstituteDamageBySelf;                                                    // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBNameConventions : public FTableRowBase
{
    FString Pattern;                                                                  // 0x0008 (size: 0x10)
    ESBNameConventionsType Type;                                                      // 0x0018 (size: 0x1)
    bool UseCases;                                                                    // 0x0019 (size: 0x1)

}; // Size: 0x20

struct FSBNameFloat
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    float Value;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBNetworkCafeBuffsMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    EOutGameBuffType BuffType;                                                        // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    float Value;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBNetworkCafeInfo
{
    bool bIsNetworkCafe;                                                              // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    uint32 NetworkCafePollingTime;                                                    // 0x0004 (size: 0x4)
    uint32 NetworkCafeNotificationTime;                                               // 0x0008 (size: 0x4)
    uint32 NetworkCafeTotalTimePlayedToday;                                           // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBNetworkCafeReward
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    ESBNetworkCafeRewardType Type;                                                    // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 Quantity;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBNotificationData
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    FSBNotificationDataParam SaveParam;                                               // 0x0010 (size: 0x18)

}; // Size: 0x28

struct FSBNotificationDataParam
{
    FDateTime LastDateTime;                                                           // 0x0000 (size: 0x8)
    TArray<FSBNotificationStatusData> StatusData;                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBNotificationMenuData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString LinkURL;                                                                  // 0x0008 (size: 0x10)
    FString ImagePath;                                                                // 0x0018 (size: 0x10)
    bool bIsDisplay;                                                                  // 0x0028 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0029 (size: 0x3)
    int32 ShortCutType;                                                               // 0x002C (size: 0x4)
    FSBNotificationShortCutData ShortCutData;                                         // 0x0030 (size: 0x28)
    FDateTime StartTime;                                                              // 0x0058 (size: 0x8)
    FDateTime EndTime;                                                                // 0x0060 (size: 0x8)
    FDateTime DisplayStartTime;                                                       // 0x0068 (size: 0x8)
    FDateTime DisplayEndTime;                                                         // 0x0070 (size: 0x8)
    int32 Priority;                                                                   // 0x0078 (size: 0x4)
    bool bIsAlreadyDisplay;                                                           // 0x007C (size: 0x1)

}; // Size: 0x80

struct FSBNotificationShortCutData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString StartTagName;                                                             // 0x0008 (size: 0x10)
    FVector Pos;                                                                      // 0x0018 (size: 0xC)

}; // Size: 0x28

struct FSBNotificationStatusData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    bool IsChecked;                                                                   // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FDateTime DateTime;                                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBNotifyEffectValue
{
    uint8 bIsNotifyUpdateAttackCollisionScale;                                        // 0x0000 (size: 0x1)
    uint8 bIsNotifyPrepareDestroy;                                                    // 0x0000 (size: 0x1)
    uint8 bIsNotifyUpdateBeamAndEnd;                                                  // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FSBNotifyParticleEffectFloatParams
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    float Value;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBNotifyParticleEffectParams
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    TSubclassOf<class ASBProjectileEffect> EffectActor;                               // 0x0008 (size: 0x8)
    TEnumAsByte<EEffectTarget> EffectTarget;                                          // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    FName SocketName;                                                                 // 0x0014 (size: 0x8)
    FVector LocationOffset;                                                           // 0x001C (size: 0xC)
    FRotator RotationOffset;                                                          // 0x0028 (size: 0xC)
    bool bAttached;                                                                   // 0x0034 (size: 0x1)
    bool bCastShadow;                                                                 // 0x0035 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0036 (size: 0x2)
    FName ActorParameterName;                                                         // 0x0038 (size: 0x8)
    TArray<FSBNotifyParticleEffectFloatParams> FloatParameter;                        // 0x0040 (size: 0x10)
    TArray<FSBNotifyParticleEffectVectorParams> VectorParameter;                      // 0x0050 (size: 0x10)
    float Scale;                                                                      // 0x0060 (size: 0x4)
    bool bApplyOwnerMeshScale;                                                        // 0x0064 (size: 0x1)
    bool bApplyCustomWeaponScale;                                                     // 0x0065 (size: 0x1)
    bool bIdentificationFriendOrFoe;                                                  // 0x0066 (size: 0x1)
    bool bIdentificationFriendOrFoeSendHealParam;                                     // 0x0067 (size: 0x1)
    ESBEffectVisibleType VisibleType;                                                 // 0x0068 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0069 (size: 0x7)
    TMap<class ESBAttribute, class FSBAttributeEffectInfo> AttributeEffectInfos;      // 0x0070 (size: 0x50)
    bool bSpawnLocalController;                                                       // 0x00C0 (size: 0x1)

}; // Size: 0xC8

struct FSBNotifyParticleEffectVectorParams
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FVector Value;                                                                    // 0x0008 (size: 0xC)

}; // Size: 0x14

struct FSBNotifyRuleSetting
{
    ENotifyRuleLogic NotifyRuleSetting;                                               // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<class USBAnimNotifyRule*> NotifyRules;                                     // 0x0008 (size: 0x10)
    TArray<class USBAnimNotifyRuleOnServer*> NotifyRulesOnServer;                     // 0x0018 (size: 0x10)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBNotifyStatePlayingEffect
{
    FSBPlayingEffect PlayingEffect;                                                   // 0x0008 (size: 0xC8)

}; // Size: 0xD8

struct FSBNotifyTrailParams
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    FName FirstSocketName;                                                            // 0x0008 (size: 0x8)
    FName SecondSocketName;                                                           // 0x0010 (size: 0x8)
    TEnumAsByte<ETrailWidthMode> WidthScaleMode;                                      // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    FName WidthScaleCurve;                                                            // 0x001C (size: 0x8)
    float Duration;                                                                   // 0x0024 (size: 0x4)
    TArray<FName> Tags;                                                               // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBNpcAIPathMoveRequest
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

struct FSBNpcAnimalType
{
    TSoftObjectPtr<USkeletalMesh> Mesh;                                               // 0x0000 (size: 0x28)
    TSoftClassPtr<UAnimInstance> AnimInstanceClass;                                   // 0x0028 (size: 0x28)

}; // Size: 0x50

struct FSBNpcAppearanceType
{
    ECharaPartsBody BodyType;                                                         // 0x0000 (size: 0x1)
    ENpcJob JobType;                                                                  // 0x0001 (size: 0x1)
    TEnumAsByte<ESBMapRegion> RegionType;                                             // 0x0002 (size: 0x1)

}; // Size: 0x3

struct FSBNpcChangeCharaCreateInfo
{
    FSBNpcCharaCreateType CharaCreate;                                                // 0x0000 (size: 0x78)
    TArray<FDataTableRowHandle> EventTriggerHandles;                                  // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FSBNpcCharaCreateType
{
    TSoftObjectPtr<USBCharaCreateData> CharaCreateData;                               // 0x0000 (size: 0x28)
    TSoftObjectPtr<UASAnimationSet> AnimationSet;                                     // 0x0028 (size: 0x28)
    TSoftClassPtr<UAnimInstance> CustomAnimClass;                                     // 0x0050 (size: 0x28)

}; // Size: 0x78

struct FSBNpcCurrentWaitInfo
{
    char padding_0[0x1C];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x1C

struct FSBNpcDisableOutRangeInfo
{
    bool bDisableOutRange;                                                            // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float LODMaxDistance;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBNpcInteractionSettings
{
    bool bIsValid;                                                                    // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName SelectCursorAttachBoneName;                                                 // 0x0004 (size: 0x8)
    FVector SelectCursorLocationOffset;                                               // 0x000C (size: 0xC)
    FName LookAtLocationBoneName;                                                     // 0x0018 (size: 0x8)
    FVector LookAtLocationOffset;                                                     // 0x0020 (size: 0xC)
    float ReachableDistance;                                                          // 0x002C (size: 0x4)
    float ReachableAnglePitch;                                                        // 0x0030 (size: 0x4)
    float ReachableAngleYaw;                                                          // 0x0034 (size: 0x4)
    float InteractionTurnAngle;                                                       // 0x0038 (size: 0x4)
    bool InteractionLookAt;                                                           // 0x003C (size: 0x1)

}; // Size: 0x40

struct FSBNpcJobAutoCreatePartsData : public FTableRowBase
{
    ENpcJob PartsJob;                                                                 // 0x0008 (size: 0x1)
    bool PartsNum_M000;                                                               // 0x0009 (size: 0x1)
    bool PartsNum_M100;                                                               // 0x000A (size: 0x1)
    bool PartsNum_M300;                                                               // 0x000B (size: 0x1)
    bool PartsNum_M400;                                                               // 0x000C (size: 0x1)
    bool PartsNum_M500;                                                               // 0x000D (size: 0x1)
    bool PartsNum_F000;                                                               // 0x000E (size: 0x1)
    bool PartsNum_F100;                                                               // 0x000F (size: 0x1)
    bool PartsNum_F300;                                                               // 0x0010 (size: 0x1)
    bool PartsNum_F400;                                                               // 0x0011 (size: 0x1)
    bool PartsNum_F500;                                                               // 0x0012 (size: 0x1)

}; // Size: 0x18

struct FSBNpcJobData : public FTableRowBase
{
    ENpcJob PartsJob;                                                                 // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    FName ShortName;                                                                  // 0x000C (size: 0x8)
    bool bExtraNpc;                                                                   // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FSBNpcLaneLink
{
    class ASBNpcLaneBase* Lane;                                                       // 0x0000 (size: 0x8)
    int32 FromNodeIndex;                                                              // 0x0008 (size: 0x4)
    int32 ToNodeIndex;                                                                // 0x000C (size: 0x4)
    FVector Direction;                                                                // 0x0010 (size: 0xC)
    FVector SideVector;                                                               // 0x001C (size: 0xC)
    bool HasCurveStartPoint;                                                          // 0x0028 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0029 (size: 0x3)
    FVector CurveStartPoint;                                                          // 0x002C (size: 0xC)
    bool HasCurveEndPoint;                                                            // 0x0038 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0039 (size: 0x3)
    FVector CurveEndPoint;                                                            // 0x003C (size: 0xC)
    bool bLeftToRight;                                                                // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FSBNpcLaneNode
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<int32> Neighbors;                                                          // 0x0010 (size: 0x10)
    TArray<int32> NeighborsTo;                                                        // 0x0020 (size: 0x10)

}; // Size: 0x38

struct FSBNpcLanePoint
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    float Rotation;                                                                   // 0x000C (size: 0x4)
    float Width;                                                                      // 0x0010 (size: 0x4)
    bool bBothWays;                                                                   // 0x0014 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0015 (size: 0x3)
    class ASBNpcLaneBase* OwningLane;                                                 // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBNpcLaneSpawnSettings
{
    FSBNpcAppearanceType Appearance;                                                  // 0x0000 (size: 0x3)
    char padding_0[0x1];                                                              // 0x0003 (size: 0x1)
    float Weight;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBNpcPathFindQuery
{
    int32 SearchFlags;                                                                // 0x0000 (size: 0x4)
    FName SearchPathName;                                                             // 0x0004 (size: 0x8)
    EPathDirection SearchPathDirection;                                               // 0x000C (size: 0x1)
    EPathTarget SearchPathTarget;                                                     // 0x000D (size: 0x1)

}; // Size: 0x10

struct FSBNpcScriptInfo
{
    TArray<FName> MainTriggers;                                                       // 0x0000 (size: 0x10)
    TArray<FName> SubTriggers;                                                        // 0x0010 (size: 0x10)
    bool bIsNeedFacial;                                                               // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FSBNpcSpawnAreaSettings
{
    FSBNpcAppearanceType Appearance;                                                  // 0x0000 (size: 0x3)
    char padding_0[0x1];                                                              // 0x0003 (size: 0x1)
    float Weight;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBNpcSpawnDistanceData : public FTableRowBase
{
    float WanderingNpcSpawnDistance;                                                  // 0x0008 (size: 0x4)
    float StandingNpcSpawnDistance;                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBNpcSpawnLoadReductionData : public FTableRowBase
{
    float EnterFPS;                                                                   // 0x0008 (size: 0x4)
    float ExitFPS;                                                                    // 0x000C (size: 0x4)
    int32 MaxWanderingNpcNum;                                                         // 0x0010 (size: 0x4)
    int32 MaxStandingNpcNum;                                                          // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBNpcSpawnLoadReductionInfo
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBNpcSpawnPointSettings
{
    ESBNpcSpawnPointCharacterType CharacterType;                                      // 0x0000 (size: 0x1)
    FSBNpcAppearanceType Appearance;                                                  // 0x0001 (size: 0x3)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FSBNpcCharaCreateType CharaCreate;                                                // 0x0008 (size: 0x78)
    TSoftClassPtr<ASBExtraNpcCharacter> ExtraNpcClass;                                // 0x0080 (size: 0x28)
    FSBNpcAnimalType animal;                                                          // 0x00A8 (size: 0x50)
    TArray<FSBNpcChangeCharaCreateInfo> ChangeCharaCreateInfos;                       // 0x00F8 (size: 0x10)

}; // Size: 0x110

struct FSBNpcWaitParamCooldownTimeCheck
{
    char padding_0[0xC];                                                              // 0x0000 (size: 0x0)
}; // Size: 0xC

struct FSBNpcWaitParamTableRow : public FTableRowBase
{
    ESBNpcWaitType WaitType;                                                          // 0x0008 (size: 0x4)
    bool CheckPlayEnd;                                                                // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    float PlayTimeMin;                                                                // 0x0010 (size: 0x4)
    float PlayTimeMax;                                                                // 0x0014 (size: 0x4)
    float CooldownTime;                                                               // 0x0018 (size: 0x4)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    TArray<FName> EnableWait;                                                         // 0x0020 (size: 0x10)
    TArray<ENpcJob> EnableJobType;                                                    // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FSBOperationInformation
{
    FText Body;                                                                       // 0x0000 (size: 0x18)
    FText Date;                                                                       // 0x0018 (size: 0x18)

}; // Size: 0x30

struct FSBOutGameBuffMasterData
{
    EOutGameBuffType BuffType;                                                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float MaxValue;                                                                   // 0x0004 (size: 0x4)
    bool bIsRateValue;                                                                // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBOverLimit
{
    int32 Money;                                                                      // 0x0000 (size: 0x4)
    int32 GC;                                                                         // 0x0004 (size: 0x4)
    int32 Exp;                                                                        // 0x0008 (size: 0x4)
    int32 RoseOrb;                                                                    // 0x000C (size: 0x4)
    TArray<FSBTokenOverLimit> Token;                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBOwnEmoteData
{
    FString EmoteId;                                                                  // 0x0000 (size: 0x10)
    bool bIsNew;                                                                      // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBOwnItemBoxParseData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    bool bIsNew;                                                                      // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBOwnItemListContainerData
{
    int32 Capacity;                                                                   // 0x0000 (size: 0x4)
    int32 StorageNumber;                                                              // 0x0004 (size: 0x4)
    TArray<FOwnItemInfo> Items;                                                       // 0x0008 (size: 0x10)
    bool IsCapacityBoost;                                                             // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    int32 BoostCapacity;                                                              // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBOwnedBuffItemData
{
    int32 Amount;                                                                     // 0x0000 (size: 0x4)
    EOutGameBuffType OutGameBuffType;                                                 // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FItemMasterData ItemMasterData;                                                   // 0x0008 (size: 0xD0)

}; // Size: 0xD8

struct FSBParabolaMoveParameter
{
    ESBParabolaMoveType MoveType;                                                     // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float ShotDegree;                                                                 // 0x0004 (size: 0x4)
    float ReachHeight;                                                                // 0x0008 (size: 0x4)
    float ReachTime;                                                                  // 0x000C (size: 0x4)
    uint8 bIsEnableChangeLandingSecond;                                               // 0x0010 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0011 (size: 0x3)
    FSBChangeLandingSecond ChangeLandingSecond;                                       // 0x0014 (size: 0x10)
    FSBProjectileBoundParameter BoundParameter;                                       // 0x0024 (size: 0x10)

}; // Size: 0x34

struct FSBParabora
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

struct FSBPartsBreakEffectParams
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    FName SocketName;                                                                 // 0x0008 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0010 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x001C (size: 0xC)
    float Scale;                                                                      // 0x0028 (size: 0x4)
    bool bAttached;                                                                   // 0x002C (size: 0x1)
    bool bCastShadow;                                                                 // 0x002D (size: 0x1)
    EEffectId EffectId;                                                               // 0x002E (size: 0x1)
    char padding_0[0x1];                                                              // 0x002F (size: 0x1)
    TSoftObjectPtr<UAkAudioEvent> EffectSE;                                           // 0x0030 (size: 0x28)

}; // Size: 0x58

struct FSBPartsBreakInfo
{
    FName CollsionGroupName;                                                          // 0x0000 (size: 0x8)
    int32 PartsStep;                                                                  // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBPartsBreakState
{
    FName CollisionGroupName;                                                         // 0x0000 (size: 0x8)
    int32 BreakStep;                                                                  // 0x0008 (size: 0x4)
    ESBComparisonOperator ComparisonOperator;                                         // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBPartsDamageEffectParams
{
    class UParticleSystem* PSTemplate;                                                // 0x0000 (size: 0x8)
    FName SocketName;                                                                 // 0x0008 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0010 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x001C (size: 0xC)
    float Scale;                                                                      // 0x0028 (size: 0x4)
    bool bAttached;                                                                   // 0x002C (size: 0x1)
    bool bCastShadow;                                                                 // 0x002D (size: 0x1)
    EEffectId EffectId;                                                               // 0x002E (size: 0x1)
    char padding_0[0x1];                                                              // 0x002F (size: 0x1)
    class UAkAudioEvent* AkEvent;                                                     // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FSBPartyChainBonusDamageSetting
{
    int32 NeedComboCount;                                                             // 0x0000 (size: 0x4)
    float DamageModifyRate;                                                           // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBPartyChainBonusStatusSetting
{
    int32 NeedComboCount;                                                             // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle StatusRowHandle;                                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPartyChainComboCountLogSetting
{
    int32 NeedComboCount;                                                             // 0x0000 (size: 0x4)
    ESBPartyChainComboCountLogType ShowLogType;                                       // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBPartyChainComboLimitTimeSetting
{
    int32 ComboCount;                                                                 // 0x0000 (size: 0x4)
    float LimitTime;                                                                  // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBPartyChainSettingParam
{
    TArray<FSBPartyChainComboLimitTimeSetting> PartyChainComboLimitTimeSettingList;   // 0x0000 (size: 0x10)
    int32 PartyChainComboCountOccurCoolTime;                                          // 0x0010 (size: 0x4)
    float PartyChainComboCoolTime;                                                    // 0x0014 (size: 0x4)
    float PartyChainComboLimitDistance;                                               // 0x0018 (size: 0x4)
    int32 PartyChainMaxComboCount;                                                    // 0x001C (size: 0x4)
    TArray<FSBPartyChainBonusDamageSetting> PartyChainBonusDamageSettingList;         // 0x0020 (size: 0x10)
    TArray<FSBPartyChainBonusStatusSetting> PartyChainBonusStatusSettingList;         // 0x0030 (size: 0x10)
    TArray<FSBPartyChainComboCountLogSetting> PartyChainComboCountLogSettingList;     // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBPartyMemberInfo
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 BattleScore;                                                                // 0x0014 (size: 0x4)
    bool IsActive;                                                                    // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBPartyMemberRepState
{
    FString CharacterId;                                                              // 0x0008 (size: 0x10)
    int32 OnlineStatus;                                                               // 0x0018 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x001C (size: 0x1)
    char padding_0[0x3];                                                              // 0x001D (size: 0x3)
    int32 ClassLevel;                                                                 // 0x0020 (size: 0x4)
    int32 TotalPower;                                                                 // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBPartyMemberRepStateGeneral : public FSBPartyMemberRepState
{
    FString SessionId;                                                                // 0x0028 (size: 0x10)
    TArray<FName> ActivateDungeons;                                                   // 0x0038 (size: 0x10)
    bool bConvocation;                                                                // 0x0048 (size: 0x1)
    bool bAgreeToMigration;                                                           // 0x0049 (size: 0x1)
    char padding_0[0x6];                                                              // 0x004A (size: 0x6)
    FString GameContentId;                                                            // 0x0050 (size: 0x10)
    float GameLimitTime;                                                              // 0x0060 (size: 0x4)
    bool bIsInMissionResult;                                                          // 0x0064 (size: 0x1)
    bool bIsInDungeon;                                                                // 0x0065 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0066 (size: 0x2)
    FString MapName;                                                                  // 0x0068 (size: 0x10)

}; // Size: 0x78

struct FSBPartyRecruitData
{
    FString LeaderUserID;                                                             // 0x0000 (size: 0x10)
    FString LeaderCharacterID;                                                        // 0x0010 (size: 0x10)
    FString LeaderCharacterName;                                                      // 0x0020 (size: 0x10)
    int32 Contents;                                                                   // 0x0030 (size: 0x4)
    FName SubContents;                                                                // 0x0034 (size: 0x8)
    int32 Purpose;                                                                    // 0x003C (size: 0x4)
    TArray<bool> Purpose_List;                                                        // 0x0040 (size: 0x10)
    int32 Atmosphere;                                                                 // 0x0050 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0054 (size: 0x4)
    TArray<bool> Atmosphere_List;                                                     // 0x0058 (size: 0x10)
    int32 BattleScoreStandard;                                                        // 0x0068 (size: 0x4)
    int32 BattleScoreScope;                                                           // 0x006C (size: 0x4)
    bool Target_Anyone;                                                               // 0x0070 (size: 0x1)
    bool Target_Friend;                                                               // 0x0071 (size: 0x1)
    bool Target_Team;                                                                 // 0x0072 (size: 0x1)
    char padding_1[0x5];                                                              // 0x0073 (size: 0x5)
    FString RecruitId;                                                                // 0x0078 (size: 0x10)
    FString FreeComment;                                                              // 0x0088 (size: 0x10)
    int32 CreateTime;                                                                 // 0x0098 (size: 0x4)
    char padding_2[0x4];                                                              // 0x009C (size: 0x4)
    FDateTime CreateTimeUtc;                                                          // 0x00A0 (size: 0x8)
    TArray<FSBPartyMemberInfo> PtMemberInfo;                                          // 0x00A8 (size: 0x10)
    FSBPlatformInfo PlatformInfo;                                                     // 0x00B8 (size: 0x20)

}; // Size: 0xD8

struct FSBPartyState
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBPartyStateGeneral : public FSBPartyState
{
    bool bHasConvocation;                                                             // 0x0008 (size: 0x1)
    bool bExecuteMigration;                                                           // 0x0009 (size: 0x1)
    bool bMigrationResult;                                                            // 0x000A (size: 0x1)
    char padding_0[0x5];                                                              // 0x000B (size: 0x5)
    FString MigrationSessionId;                                                       // 0x0010 (size: 0x10)
    int32 MigrationResponseCode;                                                      // 0x0020 (size: 0x4)
    bool bRetireGame;                                                                 // 0x0024 (size: 0x1)
    bool bRecruiting;                                                                 // 0x0025 (size: 0x1)
    bool bSimplycityPartyOn;                                                          // 0x0026 (size: 0x1)

}; // Size: 0x28

struct FSBPassiveArtsID
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBPassiveBallShootReduceConsumeSetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    float ActivateRate;                                                               // 0x0004 (size: 0x4)
    float ReduceAmount;                                                               // 0x0008 (size: 0x4)
    bool bApplyAllBallShootTypeSkill;                                                 // 0x000C (size: 0x1)

}; // Size: 0x10

struct FSBPassiveCategoryParamModifySetting
{
    ESBPassiveArtsModifyCategory Category;                                            // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBPassiveParamModifySetting> ParamModifySettingList;                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPassiveHPRecoveryItemRemoveStatusSetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    float ActivateRate;                                                               // 0x0004 (size: 0x4)
    TArray<ESBBattleEffectiveGroup> RemoveStatusGroupList;                            // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPassiveHandle
{
    uint8 bEnable;                                                                    // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    uint32 UniqueId;                                                                  // 0x0004 (size: 0x4)
    FSBBattleStatusMasterDataMediator MasterDataMediator;                             // 0x0008 (size: 0x70)
    ESBAbilityRequestSource RequestType;                                              // 0x0078 (size: 0x1)

}; // Size: 0x80

struct FSBPassiveLevelAttackCollisionSetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    float CollisionScale;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBPassiveLevelParamModifySetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    FSBPassiveParamModifyValue ModifyValue;                                           // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FSBPassiveParamModifySetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    FSBPassiveParamModifyValue ModifyValue;                                           // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBPassiveParamModifyValue
{
    ESBPassiveStatusParamCalcType CalcType;                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBPassiveResurrectionApplyBattleStatusSetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle ToSelfStatusAlimentHandle;                                    // 0x0008 (size: 0x10)
    FDataTableRowHandle ToTargetStatusAlimentHandle;                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBPassiveSkillID : public FSBEncryptNetSerializeID
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBPassiveStatusParamModifyValue : public FSBPassiveParamModifyValue
{
    ESBPassiveArtsModifyCategory Category;                                            // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBPassiveSuperArmorReceiveDamageDownSetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    float ReceiveDamageDownRate;                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBPawnControlAxisKey
{
    FKey Key;                                                                         // 0x0000 (size: 0x18)
    bool bInverse;                                                                    // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBPawnControlAxisMapping
{
    TArray<FSBPawnControlAxisKey> Keys;                                               // 0x0000 (size: 0x10)
    class USBPawnControlAxisAction* Action;                                           // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBPawnControlKeyMapping
{
    TArray<FInputChord> Keys;                                                         // 0x0000 (size: 0x10)
    class USBPawnControlKeyAction* Action;                                            // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBPaymentData : public FTableRowBase
{
    int32 PaymentId;                                                                  // 0x0008 (size: 0x4)
    int32 NameTextId;                                                                 // 0x000C (size: 0x4)
    int32 DescTextId;                                                                 // 0x0010 (size: 0x4)
    FName PaymentKey;                                                                 // 0x0014 (size: 0x8)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    TSoftObjectPtr<UTexture2D> Icon;                                                  // 0x0020 (size: 0x28)

}; // Size: 0x48

struct FSBPaymentLimitMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 AgeFrom;                                                                    // 0x0004 (size: 0x4)
    int32 AgeTo;                                                                      // 0x0008 (size: 0x4)
    int32 ValueLimit;                                                                 // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBPerceiveAttackSettings
{
    float VisionAngle;                                                                // 0x0000 (size: 0x4)
    float RangedAttackDistance;                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBPerceivedItemSpawnPoint : public FAIFwPerceivedItemPoint
{
    char padding_0[0x18];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x18

struct FSBPerformanceCameraData : public FTableRowBase
{
    ESBPerformanceCameraType Type;                                                    // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    float LifeSpan;                                                                   // 0x0010 (size: 0x4)
    char padding_1[0x1C];                                                             // 0x0014 (size: 0x1C)
    ESBPerformanceCameraWatchPointBase WatchPoint;                                    // 0x0030 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0031 (size: 0x3)
    FName WatchPointSocketName;                                                       // 0x0034 (size: 0x8)
    bool bKeepWatching;                                                               // 0x003C (size: 0x1)
    bool bWatchMidPoint;                                                              // 0x003D (size: 0x1)
    char padding_3[0x2];                                                              // 0x003E (size: 0x2)
    class UCurveVector* WatchPointOffsetData;                                         // 0x0040 (size: 0x8)
    ESBPerformanceCameraLocationBase LocationBase;                                    // 0x0048 (size: 0x1)
    char padding_4[0x3];                                                              // 0x0049 (size: 0x3)
    FName LocationSocketName;                                                         // 0x004C (size: 0x8)
    bool bAttach;                                                                     // 0x0054 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0055 (size: 0x3)
    class UCurveVector* LocationData;                                                 // 0x0058 (size: 0x8)
    class UAnimationAsset* LocationAnimData;                                          // 0x0060 (size: 0x8)
    ESBPerformanceCameraLocationOffsetRotation LocationOffsetRotation;                // 0x0068 (size: 0x1)
    char padding_6[0x7];                                                              // 0x0069 (size: 0x7)
    TSubclassOf<class UCameraShakeBase> CameraShake;                                  // 0x0070 (size: 0x8)
    class UCurveFloat* ScaleToOffsetZ;                                                // 0x0078 (size: 0x8)

}; // Size: 0x80

struct FSBPineVillageCharacterData
{
    int32 Rank;                                                                       // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString UserId;                                                                   // 0x0008 (size: 0x10)
    FString CharacterId;                                                              // 0x0018 (size: 0x10)
    FString shortId;                                                                  // 0x0028 (size: 0x10)
    int32 ClassType;                                                                  // 0x0038 (size: 0x4)
    int32 ClassLevel;                                                                 // 0x003C (size: 0x4)
    FString Name;                                                                     // 0x0040 (size: 0x10)
    FString Comment;                                                                  // 0x0050 (size: 0x10)
    FString FaceImagePath;                                                            // 0x0060 (size: 0x10)
    int32 BattleScore;                                                                // 0x0070 (size: 0x4)
    int32 Points;                                                                     // 0x0074 (size: 0x4)

}; // Size: 0x78

struct FSBPineVillageLeagueData
{
    TArray<FSBPineVillageLeagueEdge> LeagueEdgeValues;                                // 0x0000 (size: 0x10)
    FSBPineVillageMyLeagueData MyLeagueData;                                          // 0x0010 (size: 0x38)

}; // Size: 0x48

struct FSBPineVillageLeagueEdge
{
    TArray<int32> GroupScore;                                                         // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBPineVillageMyLeagueData
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    FString FaceImagePath;                                                            // 0x0010 (size: 0x10)
    int32 MasterPineVillageEventId;                                                   // 0x0020 (size: 0x4)
    int32 League;                                                                     // 0x0024 (size: 0x4)
    int32 Group;                                                                      // 0x0028 (size: 0x4)
    int32 Points;                                                                     // 0x002C (size: 0x4)
    int32 ConsecutiveDemotionCandidacies;                                             // 0x0030 (size: 0x4)
    bool HasPendingRankingRewards;                                                    // 0x0034 (size: 0x1)
    bool HasPendingLeagueRewards;                                                     // 0x0035 (size: 0x1)

}; // Size: 0x38

struct FSBPineVillageRankingRewards
{
    int32 MinRank;                                                                    // 0x0000 (size: 0x4)
    int32 MaxRank;                                                                    // 0x0004 (size: 0x4)
    TArray<FString> RewardIds;                                                        // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPineVillageRankingsData
{
    FDateTime RankingsUpdatedAt;                                                      // 0x0000 (size: 0x8)
    TArray<FSBPineVillageCharacterData> Rankings;                                     // 0x0008 (size: 0x10)
    FSBPineVillageCharacterData MyRanking;                                            // 0x0018 (size: 0x78)

}; // Size: 0x90

struct FSBPineVillageTierRewards
{
    int32 Group;                                                                      // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FString> RewardIds;                                                        // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPitchRotationOffsetData
{
    TSoftObjectPtr<UCurveVector> PitchRotationCurve;                                  // 0x0000 (size: 0x28)
    float MinArmLenghRatio;                                                           // 0x0028 (size: 0x4)
    float MaxArmLenghRatio;                                                           // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBPlatformInfo
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBPlatformType Type;                                                             // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    FString UserId;                                                                   // 0x0008 (size: 0x10)
    bool bPSOnly;                                                                     // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBPlayEffect
{
    EEffectId ID;                                                                     // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    class USceneComponent* AttachToComponent;                                         // 0x0008 (size: 0x8)
    FName AttachSocketName;                                                           // 0x0010 (size: 0x8)
    FVector Location;                                                                 // 0x0018 (size: 0xC)
    FRotator Rotation;                                                                // 0x0024 (size: 0xC)
    TEnumAsByte<EAttachLocation::Type> LocationType;                                  // 0x0030 (size: 0x1)
    uint8 bAutoDestroy;                                                               // 0x0031 (size: 0x1)

}; // Size: 0x38

struct FSBPlayWeaponEffect
{
    uint8 bIsPlay;                                                                    // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FSBEffectAsset Effect;                                                            // 0x0008 (size: 0x1A8)
    FSBPlayingEffect PlayingEffect;                                                   // 0x01B0 (size: 0xC8)

}; // Size: 0x278

struct FSBPlayerActionInfo
{
    TArray<class USBPlayerSkillController*> SkillControllerList;                      // 0x0008 (size: 0x10)
    class USBSkillInfoClass* SkillInfoCache;                                          // 0x0018 (size: 0x8)

}; // Size: 0x28

struct FSBPlayerActiveSkillAction : public FSBPlayerActionInfo
{
    class USBSkillInfoClass* SkillInfo;                                               // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FSBPlayerAimAssistSetting
{
    float AssistTime;                                                                 // 0x0000 (size: 0x4)
    float AssistPower;                                                                // 0x0004 (size: 0x4)
    FSBSearchEnemySetting SearchSetting;                                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPlayerAttackHitLaunchProjectile
{
    FSBAttackID AttackID;                                                             // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle RowHandle;                                                    // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPlayerAttackHitRecastSetting
{
    TArray<FSBAttackID> AttackIDList;                                                 // 0x0000 (size: 0x10)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0010 (size: 0x10)
    TArray<FSBActiveArtsID> TargetSkillList;                                          // 0x0020 (size: 0x10)
    float RecastChangeTime;                                                           // 0x0030 (size: 0x4)
    bool bRecastChangeTimeUnitPercent;                                                // 0x0034 (size: 0x1)

}; // Size: 0x38

struct FSBPlayerAttackInfoForEnemy
{
    float MinRange;                                                                   // 0x0000 (size: 0x4)
    float MaxRange;                                                                   // 0x0004 (size: 0x4)
    float HomingRange;                                                                // 0x0008 (size: 0x4)
    float LeftAngle;                                                                  // 0x000C (size: 0x4)
    float RightAngle;                                                                 // 0x0010 (size: 0x4)
    float Time;                                                                       // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBPlayerBanFinishedTimeInfo
{
    int32 Day;                                                                        // 0x0000 (size: 0x4)
    int32 Hour;                                                                       // 0x0004 (size: 0x4)
    int32 Minute;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBPlayerBuffInfo
{
    float HitPoint;                                                                   // 0x0000 (size: 0x4)
    float MagicPoint;                                                                 // 0x0004 (size: 0x4)
    float Stamina;                                                                    // 0x0008 (size: 0x4)
    float AttackPowerScale;                                                           // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBPlayerBurstBonusAttackAndElementModifySetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float AttackModifyPercent;                                                        // 0x0010 (size: 0x4)
    float ElementModifyPercent;                                                       // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBPlayerCachedProperty
{
    float HitPoint;                                                                   // 0x0000 (size: 0x4)
    float MagicPoint;                                                                 // 0x0004 (size: 0x4)
    float Stamina;                                                                    // 0x0008 (size: 0x4)
    int32 Skill1;                                                                     // 0x000C (size: 0x4)
    int32 Skill2;                                                                     // 0x0010 (size: 0x4)
    int32 Skill3;                                                                     // 0x0014 (size: 0x4)
    int32 Skill4;                                                                     // 0x0018 (size: 0x4)
    float Special;                                                                    // 0x001C (size: 0x4)
    int32 FightingStyle;                                                              // 0x0020 (size: 0x4)
    float ResurrectionPenalty;                                                        // 0x0024 (size: 0x4)
    float ImagineArtsRecastTime;                                                      // 0x0028 (size: 0x4)
    float ImagineArts2RecastTime;                                                     // 0x002C (size: 0x4)
    float SubArtsRecastTime;                                                          // 0x0030 (size: 0x4)
    float Arts1RecastTime;                                                            // 0x0034 (size: 0x4)
    float Arts2RecastTime;                                                            // 0x0038 (size: 0x4)
    float Arts3RecastTime;                                                            // 0x003C (size: 0x4)
    float Arts4RecastTime;                                                            // 0x0040 (size: 0x4)
    float Arts5RecastTime;                                                            // 0x0044 (size: 0x4)
    float Arts6RecastTime;                                                            // 0x0048 (size: 0x4)
    float Arts7RecastTime;                                                            // 0x004C (size: 0x4)
    float Arts8RecastTime;                                                            // 0x0050 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0054 (size: 0x4)
    FString FrailAilmentName;                                                         // 0x0058 (size: 0x10)
    float FrailAilmentRemainTime;                                                     // 0x0068 (size: 0x4)
    bool MountImagineRideFlag;                                                        // 0x006C (size: 0x1)

}; // Size: 0x70

struct FSBPlayerCastSkillCheatInfo
{
    float MaxStamina;                                                                 // 0x0000 (size: 0x4)
    float PreStamina;                                                                 // 0x0004 (size: 0x4)
    float ConsumeStamina;                                                             // 0x0008 (size: 0x4)
    float NeedStamina;                                                                // 0x000C (size: 0x4)
    float AfterStamina;                                                               // 0x0010 (size: 0x4)
    int8 ChargeLevel;                                                                 // 0x0014 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0015 (size: 0x3)
    float ChargeTime;                                                                 // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBPlayerCharacterCardData
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)
    FString Name;                                                                     // 0x0020 (size: 0x10)
    int32 AdventurerRank;                                                             // 0x0030 (size: 0x4)
    int32 BattleScore;                                                                // 0x0034 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0038 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0039 (size: 0x3)
    int32 ClassLevel;                                                                 // 0x003C (size: 0x4)
    int32 AdventurerCardFrameId;                                                      // 0x0040 (size: 0x4)
    int32 AdventurerCardBgColorId;                                                    // 0x0044 (size: 0x4)
    int32 FaceFrameId;                                                                // 0x0048 (size: 0x4)
    char padding_1[0x4];                                                              // 0x004C (size: 0x4)
    TArray<int32> AwardIds;                                                           // 0x0050 (size: 0x10)
    bool IsLikeSendable;                                                              // 0x0060 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0061 (size: 0x3)
    int32 OnlineStatus;                                                               // 0x0064 (size: 0x4)
    bool IsHidden;                                                                    // 0x0068 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0069 (size: 0x7)
    FString ImageUrl;                                                                 // 0x0070 (size: 0x10)
    FVector2D TrimmingCoordinate;                                                     // 0x0080 (size: 0x8)
    float Scale;                                                                      // 0x0088 (size: 0x4)

}; // Size: 0x90

struct FSBPlayerCharacterParamInfo
{
    float AttackPower;                                                                // 0x0000 (size: 0x4)
    float DefencePower;                                                               // 0x0004 (size: 0x4)
    ESBPlayerClassBattleRange BattleRange;                                            // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    float RayLengthForPlayerReticle;                                                  // 0x000C (size: 0x4)
    bool bCheckPlayerReticle;                                                         // 0x0010 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0011 (size: 0x3)
    float TargetCursorNearColorRange;                                                 // 0x0014 (size: 0x4)
    FSBActiveArtsID DefaultMainSkill;                                                 // 0x0018 (size: 0x4)
    FSBActiveArtsID DefaultSubSkill;                                                  // 0x001C (size: 0x4)
    FSBActiveArtsID DefaultAerialSkill;                                               // 0x0020 (size: 0x4)
    FSBActiveArtsID DefaultActiveArts1;                                               // 0x0024 (size: 0x4)
    FSBActiveArtsID DefaultActiveArts2;                                               // 0x0028 (size: 0x4)
    FSBActiveArtsID DefaultActiveArts3;                                               // 0x002C (size: 0x4)
    FSBActiveArtsID DefaultActiveArts4;                                               // 0x0030 (size: 0x4)
    FSBActiveArtsID DefaultSpecialSkill;                                              // 0x0034 (size: 0x4)
    FSBActiveArtsID DefaultDodgeSkill;                                                // 0x0038 (size: 0x4)
    FSBActiveArtsID DefaultEnemyStepJumpSkill;                                        // 0x003C (size: 0x4)
    FSBActiveArtsID DefaultUkemiSkill;                                                // 0x0040 (size: 0x4)
    FSBActiveArtsID DefaultSkillCancelStepSkill;                                      // 0x0044 (size: 0x4)
    FSBActiveArtsID DefaultActiveArts5;                                               // 0x0048 (size: 0x4)
    FSBActiveArtsID DefaultActiveArts6;                                               // 0x004C (size: 0x4)
    FSBActiveArtsID DefaultActiveArts7;                                               // 0x0050 (size: 0x4)
    FSBActiveArtsID DefaultActiveArts8;                                               // 0x0054 (size: 0x4)
    class UDataTable* SkillDataTable;                                                 // 0x0058 (size: 0x8)
    class UDataTable* PassiveSkillDataTable;                                          // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FSBPlayerClassData : public FTableRowBase
{
    ESBClassType ClassType;                                                           // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TSoftClassPtr<ASBPlayerCharacter> CharacterBP;                                    // 0x0010 (size: 0x28)
    int32 ViewPriority;                                                               // 0x0038 (size: 0x4)

}; // Size: 0x40

struct FSBPlayerClassKeyConfigData
{
    ESBClassType ClassType;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FSBGamePadSettings GamePadSetting;                                                // 0x0008 (size: 0x88)
    FSBKeyboardSettings KeyboardSetting;                                              // 0x0090 (size: 0x98)
    FSBMouseSettings MouseSetting;                                                    // 0x0128 (size: 0x98)
    bool bIsDashToggle;                                                               // 0x01C0 (size: 0x1)
    bool bIsEnableMainAttackHoldCombo;                                                // 0x01C1 (size: 0x1)
    bool bIsEnableMoveInputCommand;                                                   // 0x01C2 (size: 0x1)
    ESBMoveInputCommandInterval MoveInputCommandInterval;                             // 0x01C3 (size: 0x1)
    bool bIsSubPaletteHold;                                                           // 0x01C4 (size: 0x1)

}; // Size: 0x1C8

struct FSBPlayerClassKeyConfigDataDiff
{
    ESBClassType ClassType;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBActionGamepadKeyPair> GamepadButtonDiffList;                            // 0x0008 (size: 0x10)
    TArray<FSBKeyconfigFloatParamValuePair> GamepadFloatParamDiffList;                // 0x0018 (size: 0x10)
    TArray<FSBActionKeyboardKeyPair> KeyboardButtonDiffList;                          // 0x0028 (size: 0x10)
    TArray<FSBKeyconfigFloatParamValuePair> KeyboardFloatParamDiffList;               // 0x0038 (size: 0x10)
    TArray<FSBActionMouseKeyPair> MouseButtonDiffList;                                // 0x0048 (size: 0x10)
    TArray<FSBKeyconfigFloatParamValuePair> MouseFloatParamDiffList;                  // 0x0058 (size: 0x10)
    uint8 bSwitchAnalogStick;                                                         // 0x0068 (size: 0x1)
    uint8 bReverseCameraPitch;                                                        // 0x0068 (size: 0x1)
    uint8 bReverseCameraYaw;                                                          // 0x0068 (size: 0x1)
    uint8 bReverseMouseYAxis;                                                         // 0x0068 (size: 0x1)
    uint8 bReverseMouseXAxis;                                                         // 0x0068 (size: 0x1)
    uint8 bDashToggle;                                                                // 0x0068 (size: 0x1)
    uint8 bEnableHoldAutoAttack;                                                      // 0x0068 (size: 0x1)
    uint8 bMoveKeyDodge;                                                              // 0x0068 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0069 (size: 0x3)
    ESBMoveInputCommandInterval MoveInputCommandInterval;                             // 0x006C (size: 0x1)
    char padding_2[0x3];                                                              // 0x006D (size: 0x3)
    uint8 bHoldSubPalette;                                                            // 0x0070 (size: 0x1)

}; // Size: 0x78

struct FSBPlayerEndGuardBreakStatusAilment
{
    FDataTableRowHandle StatusAilmentHandle;                                          // 0x0000 (size: 0x10)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBPlayerEquipPassiveImagine
{
    FString UniqueId;                                                                 // 0x0000 (size: 0x10)
    ESBPlayerPassiveImagineSlotType Slot;                                             // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBPlayerEquipWeaponParameterCache
{
    ESBAttribute ElementType;                                                         // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBPlayerFollowParam
{
    float StopDist;                                                                   // 0x0000 (size: 0x4)
    float WalkDist;                                                                   // 0x0004 (size: 0x4)
    float DashStartDist;                                                              // 0x0008 (size: 0x4)
    float DashEndDist;                                                                // 0x000C (size: 0x4)
    FVector TargetOffset;                                                             // 0x0010 (size: 0xC)

}; // Size: 0x1C

struct FSBPlayerImagineSkillAction : public FSBPlayerActionInfo
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

struct FSBPlayerInterpMoveSetting
{
    float NearGoalBrakeDist;                                                          // 0x0000 (size: 0x4)
    float SmoothingCompleteDist;                                                      // 0x0004 (size: 0x4)
    float SmoothingCompleteDegree;                                                    // 0x0008 (size: 0x4)
    float SpeedThreshold;                                                             // 0x000C (size: 0x4)
    float SpeedAcceleration;                                                          // 0x0010 (size: 0x4)
    float SpeedDeceleration;                                                          // 0x0014 (size: 0x4)
    float FlyingVelocityZ;                                                            // 0x0018 (size: 0x4)
    float FlyingZLimit;                                                               // 0x001C (size: 0x4)
    float RotateYawScale;                                                             // 0x0020 (size: 0x4)
    float RotateYawScaleNearAdjustDist;                                               // 0x0024 (size: 0x4)
    float RotateYawScaleNearAdjustScale;                                              // 0x0028 (size: 0x4)
    float SetTargetZThreshold;                                                        // 0x002C (size: 0x4)
    float ForceModeSpeedZeroAngle;                                                    // 0x0030 (size: 0x4)
    float SwimmingZSpeed;                                                             // 0x0034 (size: 0x4)
    float MaxFloorDist;                                                               // 0x0038 (size: 0x4)
    float FallMaxTime;                                                                // 0x003C (size: 0x4)

}; // Size: 0x40

struct FSBPlayerJointGestureInfo
{
    FName EmoteName;                                                                  // 0x0000 (size: 0x8)
    TWeakObjectPtr<class ASBPlayerCharacter> TargetCharacter;                         // 0x0008 (size: 0x8)
    TEnumAsByte<ESBJointGestureStatusType> StatusType;                                // 0x0010 (size: 0x1)
    bool bSender;                                                                     // 0x0011 (size: 0x1)
    TEnumAsByte<ESBJankenHandType> JankenHandType;                                    // 0x0012 (size: 0x1)

}; // Size: 0x14

struct FSBPlayerLoadCompleteParam
{
    ESBAppearEffectType AppearEffectType;                                             // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FSBPlayerMiniMapInfo
{
    FName MiniMapId;                                                                  // 0x0000 (size: 0x8)
    bool RouteVisibility;                                                             // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBPlayerNamedEnemyParam
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString ID;                                                                       // 0x0010 (size: 0x10)
    int32 Level;                                                                      // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBPlayerPassiveArtsReplication
{
    TArray<int32> PassiveArtsIDList;                                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBPlayerPassiveSkillData : public FTableRowBase
{
    int32 PassiveSkillID;                                                             // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TSoftClassPtr<USBPlayerPassiveSkill> PassiveSkill;                                // 0x0010 (size: 0x28)
    TArray<FSBPassiveCategoryParamModifySetting> CategoryParamModifySettingList;      // 0x0038 (size: 0x10)
    TSoftObjectPtr<UTexture2D> Icon;                                                  // 0x0048 (size: 0x28)
    TSoftObjectPtr<UTexture2D> LargeIcon;                                             // 0x0070 (size: 0x28)
    TArray<FSBActiveArtsID> CorrespondActiveArtsList;                                 // 0x0098 (size: 0x10)
    int32 DisplayPriority;                                                            // 0x00A8 (size: 0x4)

}; // Size: 0xB8

struct FSBPlayerPresetEquipItem
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString UniqueId;                                                                 // 0x0008 (size: 0x10)
    bool Change;                                                                      // 0x0018 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0019 (size: 0x3)
    int32 Type;                                                                       // 0x001C (size: 0x4)
    int32 SlotId;                                                                     // 0x0020 (size: 0x4)
    ESBPlayerPresetCarryStates CarryStates;                                           // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FSBPlayerPresetEquipList
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    int32 DataIndex;                                                                  // 0x0010 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0014 (size: 0x1)
    ESBPlayerPresetType PresetType;                                                   // 0x0015 (size: 0x1)

}; // Size: 0x18

struct FSBPlayerPresetEquipSet
{
    TArray<FSBPlayerPresetEquipList> List;                                            // 0x0000 (size: 0x10)
    TArray<FSBPlayerPresetEquipItem> item;                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBPlayerReadedData
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    TMap<class FString, class FSBCharacterReadedData> CharacterData;                  // 0x0010 (size: 0x50)

}; // Size: 0x60

struct FSBPlayerRepStateCheatInfo
{
    float Stamina;                                                                    // 0x0000 (size: 0x4)
    uint8 bDash;                                                                      // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBPlayerSessionData
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    FText DisplayName;                                                                // 0x0010 (size: 0x18)
    FString SessionId;                                                                // 0x0028 (size: 0x10)
    int32 OnlineStatus;                                                               // 0x0038 (size: 0x4)
    FName ContentId;                                                                  // 0x003C (size: 0x8)

}; // Size: 0x48

struct FSBPlayerSignificanceAnimUpdateRateSetting
{
    float Significance;                                                               // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<float> ThresholdList;                                                      // 0x0008 (size: 0x10)
    int32 SkipInerpolationNum;                                                        // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBPlayerSkillAdditionalInputLaunchProjectile
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TArray<FDataTableRowHandle> ProjectileHandleList;                                 // 0x0010 (size: 0x10)
    bool IsLaunchAnimNotifyStateEnd;                                                  // 0x0020 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0021 (size: 0x3)
    int32 NotifyStateIndex;                                                           // 0x0024 (size: 0x4)
    int32 LaunchAdditionalInputCount;                                                 // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FSBPlayerSkillCastLaunchProjectile
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TArray<FDataTableRowHandle> ProjectileHandleList;                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBPlayerSkillCastStatusAilment
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TArray<FDataTableRowHandle> StatusAlimentHandleList;                              // 0x0010 (size: 0x10)
    TArray<FSBConditionCheckParam> TimeModifyConditionList;                           // 0x0020 (size: 0x10)
    int32 TimeModifyRate;                                                             // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBPlayerSkillChargeLevelSetting
{
    float ChargeTime;                                                                 // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBConditionCheckParam> ChargeConditionList;                               // 0x0010 (size: 0x10)
    TArray<FSBEffectAsset> ChargeEffectList;                                          // 0x0020 (size: 0x10)
    TArray<FDataTableRowHandle> ProjectileHandleList;                                 // 0x0030 (size: 0x10)
    TArray<FSBChargeProjectileChangeCondition> ProjectileChangeConditionList;         // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSBPlayerSkillChargeSetting : public FSBPlayerSkillChargeSettingBase
{
    TArray<FSBPlayerSkillChargeLevelSetting> LevelSettingList;                        // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBPlayerSkillChargeSettingBase
{
    TArray<FSBConditionCheckIntParam> ChargeSpeedModifyList;                          // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPlayerSkillData : public FTableRowBase
{
    int32 SkillId;                                                                    // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TSoftClassPtr<USBSkillInfoClass> SkillInfo;                                       // 0x0010 (size: 0x28)
    TArray<TSoftObjectPtr<UTexture2D>> IconAssetList;                                 // 0x0038 (size: 0x10)
    TArray<TSoftObjectPtr<UTexture2D>> LargeIconAssetList;                            // 0x0048 (size: 0x10)
    TSoftObjectPtr<UTexture2D> DetailIconAsset;                                       // 0x0058 (size: 0x28)
    int32 DisplayPriority;                                                            // 0x0080 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0084 (size: 0x4)
    TMap<int32, FSBSkillBuffData> BufIconMap;                                         // 0x0088 (size: 0x50)
    ESBSkillIconBgType BgType;                                                        // 0x00D8 (size: 0x1)
    ESBSkillElementIconType ElementType;                                              // 0x00D9 (size: 0x1)
    char padding_2[0x6];                                                              // 0x00DA (size: 0x6)
    TMap<int32, ESBSkillIconBgType> ExpansionBgType;                                  // 0x00E0 (size: 0x50)
    TMap<int32, ESBSkillElementIconType> ExpansionElementType;                        // 0x0130 (size: 0x50)

}; // Size: 0x180

struct FSBPlayerSkillIDForReplicate
{
    int32 Skill1ID;                                                                   // 0x0000 (size: 0x4)
    int32 Skill2ID;                                                                   // 0x0004 (size: 0x4)
    int32 Skill3ID;                                                                   // 0x0008 (size: 0x4)
    int32 Skill4ID;                                                                   // 0x000C (size: 0x4)
    int32 Skill5ID;                                                                   // 0x0010 (size: 0x4)
    int32 Skill6ID;                                                                   // 0x0014 (size: 0x4)
    int32 Skill7ID;                                                                   // 0x0018 (size: 0x4)
    int32 Skill8ID;                                                                   // 0x001C (size: 0x4)
    FString ImagineArts1UniqueID;                                                     // 0x0020 (size: 0x10)
    FString ImagineArts2UniqueID;                                                     // 0x0030 (size: 0x10)
    FString ImagineMountUniqueID;                                                     // 0x0040 (size: 0x10)
    FName ImagineArts1Name;                                                           // 0x0050 (size: 0x8)
    FName ImagineArts2Name;                                                           // 0x0058 (size: 0x8)
    FName ImagineMountName;                                                           // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FSBPlayerSkillInActionEffectSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TArray<FSBEffectAsset> InActionEffectList;                                        // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBPlayerSkillInStatusAilmentPriorityTable
{
    TArray<FSBPlayerSkillStatusAilmentPrioritySection> PrioritySection;               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBPlayerSkillRecastTimeModifyParam
{
    float ModifyValue;                                                                // 0x0000 (size: 0x4)
    float ModifyTimeRate;                                                             // 0x0004 (size: 0x4)
    int32 ModifyRate;                                                                 // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBPlayerSkillStatusAilmentPriorityData
{
    int8 UseSlotIndex;                                                                // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FDataTableRowHandle StatusAilmentRowHandle;                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBPlayerSkillStatusAilmentPrioritySection
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TArray<FSBPlayerSkillStatusAilmentPriorityData> PriorityDataArray;                // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBPlayerSkillStatusAilmentTimeModifyParam
{
    int32 StatusAilmentIndex;                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0008 (size: 0x10)
    int32 ModifyRate;                                                                 // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBPlayerSkillTagPreset
{
    ESBPlayerSkillActionType ActionType;                                              // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FName> NeedTags;                                                           // 0x0008 (size: 0x10)
    TArray<FName> ForbidTags;                                                         // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBPlayerSortSave
{
    TMap<TEnumAsByte<ESBSortFilterSaveType::Type>, TEnumAsByte<ESBItemSortType::Type>> SortTypes; // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FSBPlayerStatePrimaryRepForCity
{
    TWeakObjectPtr<class APlayerState> State;                                         // 0x0004 (size: 0x8)

}; // Size: 0x14

struct FSBPlayerStateRepForCity
{
    TWeakObjectPtr<class APlayerState> State;                                         // 0x0004 (size: 0x8)

}; // Size: 0x14

struct FSBPlayerStatusMapTravelMasterData
{
    FName SettingName;                                                                // 0x0000 (size: 0x8)
    TEnumAsByte<ESBMapType> SourceMapType;                                            // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    FString SourceMapName;                                                            // 0x0010 (size: 0x10)
    TEnumAsByte<ESBMapType> DestMapType;                                              // 0x0020 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0021 (size: 0x7)
    FString DestMapName;                                                              // 0x0028 (size: 0x10)
    ESBPlayerStatusTravelType StatusTravelType;                                       // 0x0038 (size: 0x1)
    bool bInheritanceHP;                                                              // 0x0039 (size: 0x1)
    char padding_2[0x2];                                                              // 0x003A (size: 0x2)
    float SetHpRate;                                                                  // 0x003C (size: 0x4)
    bool bInheritanceST;                                                              // 0x0040 (size: 0x1)
    bool bInheritanceArtsRecastTime;                                                  // 0x0041 (size: 0x1)
    char padding_3[0x2];                                                              // 0x0042 (size: 0x2)
    float SetArtsRecastTimeRate;                                                      // 0x0044 (size: 0x4)
    bool bInheritanceSpecialSkillRecastTime;                                          // 0x0048 (size: 0x1)
    char padding_4[0x3];                                                              // 0x0049 (size: 0x3)
    float SetSpecialSkillRecastTimeRate;                                              // 0x004C (size: 0x4)
    bool bInheritanceBattleImagineRecastTime;                                         // 0x0050 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0051 (size: 0x3)
    float SetBattleImagineRecastTimeRate;                                             // 0x0054 (size: 0x4)
    bool bInheritanceFrailAilmentEffectTime;                                          // 0x0058 (size: 0x1)
    bool bInheritanceMountImagineStatus;                                              // 0x0059 (size: 0x1)

}; // Size: 0x60

struct FSBPlayerStatusMasterCommonData
{
    FName Class;                                                                      // 0x0000 (size: 0x8)
    int32 primary_rate_limit;                                                         // 0x0008 (size: 0x4)
    int32 primary_rate_floor;                                                         // 0x000C (size: 0x4)
    int32 str_factor_of_ap;                                                           // 0x0010 (size: 0x4)
    int32 dex_factor_of_ap;                                                           // 0x0014 (size: 0x4)
    int32 int_factor_of_ap;                                                           // 0x0018 (size: 0x4)
    int32 mnd_factor_of_ap;                                                           // 0x001C (size: 0x4)
    int32 ap_rate_limit;                                                              // 0x0020 (size: 0x4)
    int32 ap_rate_floor;                                                              // 0x0024 (size: 0x4)
    int32 attack_type;                                                                // 0x0028 (size: 0x4)
    int32 vit_factor_of_dp;                                                           // 0x002C (size: 0x4)
    int32 str_factor_of_dp;                                                           // 0x0030 (size: 0x4)
    int32 dp_rate_limit;                                                              // 0x0034 (size: 0x4)
    int32 dp_rate_floor;                                                              // 0x0038 (size: 0x4)
    int32 int_factor_of_rp;                                                           // 0x003C (size: 0x4)
    int32 mnd_factor_of_rp;                                                           // 0x0040 (size: 0x4)
    int32 rp_rate_limit;                                                              // 0x0044 (size: 0x4)
    int32 rp_rate_floor;                                                              // 0x0048 (size: 0x4)
    int32 dex_factor_of_cr;                                                           // 0x004C (size: 0x4)
    int32 mnd_factor_of_cr;                                                           // 0x0050 (size: 0x4)
    int32 dex_decay_rate_of_cr;                                                       // 0x0054 (size: 0x4)
    int32 cr_limit;                                                                   // 0x0058 (size: 0x4)
    int32 str_factor_of_cp;                                                           // 0x005C (size: 0x4)
    int32 int_factor_of_cp;                                                           // 0x0060 (size: 0x4)
    int32 vit_factor_of_hp;                                                           // 0x0064 (size: 0x4)
    int32 hp_rate_limit;                                                              // 0x0068 (size: 0x4)
    int32 hp_rate_floor;                                                              // 0x006C (size: 0x4)
    int32 vit_factor_of_st;                                                           // 0x0070 (size: 0x4)
    int32 st_rate_limit;                                                              // 0x0074 (size: 0x4)
    int32 st_rate_floor;                                                              // 0x0078 (size: 0x4)
    int32 st_base_value;                                                              // 0x007C (size: 0x4)
    int32 fire_resist_value;                                                          // 0x0080 (size: 0x4)
    int32 ice_resist_value;                                                           // 0x0084 (size: 0x4)
    int32 thunder_resist_value;                                                       // 0x0088 (size: 0x4)
    int32 earth_resist_value;                                                         // 0x008C (size: 0x4)
    int32 light_resist_value;                                                         // 0x0090 (size: 0x4)
    int32 darkness_resist_value;                                                      // 0x0094 (size: 0x4)
    int32 slash_resist_value;                                                         // 0x0098 (size: 0x4)
    int32 bow_resist_value;                                                           // 0x009C (size: 0x4)
    int32 thrust_resist_value;                                                        // 0x00A0 (size: 0x4)

}; // Size: 0xA4

struct FSBPlayerStatusMasterDataRaw
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FName Class;                                                                      // 0x0004 (size: 0x8)
    int32 Lv;                                                                         // 0x000C (size: 0x4)
    int32 Exp;                                                                        // 0x0010 (size: 0x4)
    int32 hp;                                                                         // 0x0014 (size: 0x4)
    int32 STR;                                                                        // 0x0018 (size: 0x4)
    int32 VIT;                                                                        // 0x001C (size: 0x4)
    int32 DEX;                                                                        // 0x0020 (size: 0x4)
    int32 INT;                                                                        // 0x0024 (size: 0x4)
    int32 MND;                                                                        // 0x0028 (size: 0x4)
    int32 Ap;                                                                         // 0x002C (size: 0x4)
    int32 DP;                                                                         // 0x0030 (size: 0x4)
    int32 RP;                                                                         // 0x0034 (size: 0x4)
    int32 CR;                                                                         // 0x0038 (size: 0x4)
    int32 Cp;                                                                         // 0x003C (size: 0x4)
    int32 PCL;                                                                        // 0x0040 (size: 0x4)
    int32 ICL;                                                                        // 0x0044 (size: 0x4)
    int32 Class_Shared_Ability_Num;                                                   // 0x0048 (size: 0x4)

}; // Size: 0x4C

struct FSBPlayerSyncImportantParam
{
    char padding_0[0x20];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x20

struct FSBPlayerTransformSetting
{
    ESBPlayerTransformCharacter CharacterType;                                        // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftClassPtr<ASBPlayerTransformCharacter> TransformCharacter;                    // 0x0008 (size: 0x28)
    FSBEffectAsset TransformStartEffectSetting;                                       // 0x0030 (size: 0x1A8)
    FSBEffectAsset TransformEndEffectSetting;                                         // 0x01D8 (size: 0x1A8)

}; // Size: 0x380

struct FSBPlayerVoiceBankTable : public FTableRowBase
{
    TSoftObjectPtr<UAkAudioBank> BankAsset;                                           // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBPlayerVoiceSkillTableRow : public FTableRowBase
{
    int32 SkillId;                                                                    // 0x0008 (size: 0x4)
    int32 SkillLevel;                                                                 // 0x000C (size: 0x4)
    int32 SkillCount;                                                                 // 0x0010 (size: 0x4)
    int32 SkillChargeLevel;                                                           // 0x0014 (size: 0x4)
    class UAkAudioEvent* Event;                                                       // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBPlayerVoiceVariables
{
    class UAkAudioEvent* Event;                                                       // 0x0000 (size: 0x8)
    ESBCharacterGender Gender;                                                        // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 VoiceId;                                                                    // 0x000C (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0010 (size: 0x1)
    ESBAkEventLOD LOD;                                                                // 0x0011 (size: 0x1)

}; // Size: 0x18

struct FSBPlayerWarpEffect
{
    class UParticleSystem* RayEmitter;                                                // 0x0000 (size: 0x8)
    float RaySpawnDelay;                                                              // 0x0008 (size: 0x4)
    int32 RaySpawnCount;                                                              // 0x000C (size: 0x4)
    class UParticleSystem* SphereEmitter;                                             // 0x0010 (size: 0x8)
    FVector SpherePosition;                                                           // 0x0018 (size: 0xC)
    float SphereSpawnDelay;                                                           // 0x0024 (size: 0x4)
    float SphereLifeTime;                                                             // 0x0028 (size: 0x4)
    char padding_0[0x4];                                                              // 0x002C (size: 0x4)
    class UCurveFloat* SphereMoveCurve;                                               // 0x0030 (size: 0x8)
    float SphereMoveScale;                                                            // 0x0038 (size: 0x4)
    char padding_1[0x4];                                                              // 0x003C (size: 0x4)
    class UParticleSystem* AdditionalEffect;                                          // 0x0040 (size: 0x8)
    float AdditionalEffectSpawnDelay;                                                 // 0x0048 (size: 0x4)
    float MaterialParamDelay;                                                         // 0x004C (size: 0x4)
    float MaterialParamTime;                                                          // 0x0050 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0054 (size: 0x4)
    class UAkAudioEvent* Sound;                                                       // 0x0058 (size: 0x8)
    FAkEventVariables SoundParam;                                                     // 0x0060 (size: 0x40)
    float WarpSoundDelay;                                                             // 0x00A0 (size: 0x4)
    ESBEffectVisibleType VisibleType;                                                 // 0x00A4 (size: 0x1)

}; // Size: 0xA8

struct FSBPlayerWarpPoint
{
    FName WarpPointId;                                                                // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSBPlayingEffect
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC8

struct FSBPreJoinSessionDummyClientData
{
    char padding_0[0xA8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xA8

struct FSBPreJoinSessionFirstData
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

struct FSBPredictProjectilePoint
{
    FVector Point;                                                                    // 0x0000 (size: 0xC)
    FVector Velocity;                                                                 // 0x000C (size: 0xC)
    FVector Normal;                                                                   // 0x0018 (size: 0xC)
    float Distance;                                                                   // 0x0024 (size: 0x4)
    float DeltaTime;                                                                  // 0x0028 (size: 0x4)
    uint8 bHitGround;                                                                 // 0x002C (size: 0x1)
    uint8 bHitActor;                                                                  // 0x002C (size: 0x1)
    uint8 bHitInRange;                                                                // 0x002C (size: 0x1)

}; // Size: 0x30

struct FSBProductData : public FSBShopItem
{
    int32 ShopItemId;                                                                 // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    FString ItemName;                                                                 // 0x0020 (size: 0x10)
    int32 ItemPosition;                                                               // 0x0030 (size: 0x4)
    int32 SortId;                                                                     // 0x0034 (size: 0x4)
    TArray<int32> CategoryId;                                                         // 0x0038 (size: 0x10)
    FString ItemDescription;                                                          // 0x0048 (size: 0x10)
    FString ItemCaution;                                                              // 0x0058 (size: 0x10)
    FString CoinCaution;                                                              // 0x0068 (size: 0x10)
    TSoftObjectPtr<UTexture2D> Thumbnail;                                             // 0x0078 (size: 0x28)
    int32 TextureId;                                                                  // 0x00A0 (size: 0x4)
    char padding_1[0x4];                                                              // 0x00A4 (size: 0x4)
    FDateTime StartDate;                                                              // 0x00A8 (size: 0x8)
    FDateTime EndDate;                                                                // 0x00B0 (size: 0x8)
    int32 LimitNum;                                                                   // 0x00B8 (size: 0x4)
    int32 RequiredRank;                                                               // 0x00BC (size: 0x4)
    int32 RequiredPoints;                                                             // 0x00C0 (size: 0x4)
    bool EnableCoupon;                                                                // 0x00C4 (size: 0x1)
    char padding_2[0x3];                                                              // 0x00C5 (size: 0x3)
    int32 Ribbon;                                                                     // 0x00C8 (size: 0x4)
    int32 PeriodRibbon;                                                               // 0x00CC (size: 0x4)
    int32 CautionGender;                                                              // 0x00D0 (size: 0x4)
    bool PaidOnly;                                                                    // 0x00D4 (size: 0x1)

}; // Size: 0xD8

struct FSBProjectTextVersion
{
    char padding_0[0x1];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x1

struct FSBProjectileAlongGroundParameter
{
    float GroundOffsetHeight;                                                         // 0x0000 (size: 0x4)
    float DisappearFallHeight;                                                        // 0x0004 (size: 0x4)
    EProjectileFollowSlopeRotType FollowSlopeRotType;                                 // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    float CheckPitchDist;                                                             // 0x000C (size: 0x4)
    float CheckRollDist;                                                              // 0x0010 (size: 0x4)
    float AlongPitchMax;                                                              // 0x0014 (size: 0x4)
    float AlongRollMax;                                                               // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBProjectileBoundParameter
{
    uint8 bShouldBounce;                                                              // 0x0000 (size: 0x1)
    uint8 bBounceAngleAffectsFriction;                                                // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float Bounciness;                                                                 // 0x0004 (size: 0x4)
    float Friction;                                                                   // 0x0008 (size: 0x4)
    float BounceVelocityStopSimulatingThreshold;                                      // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBProjectileCacheHandle
{
    uint32 CacheID;                                                                   // 0x0000 (size: 0x4)
    TWeakObjectPtr<class AActor> Instigator;                                          // 0x0004 (size: 0x8)
    TWeakObjectPtr<class AActor> Owner;                                               // 0x000C (size: 0x8)
    TWeakObjectPtr<class AActor> Spawner;                                             // 0x0014 (size: 0x8)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    FSBProjectileSelectHandle LaunchHandle;                                           // 0x0020 (size: 0x18)

}; // Size: 0x38

struct FSBProjectileChainMovementConfig
{
    FSBProjectileChainMovementTriggerSetting ChainMovementTrigger;                    // 0x0000 (size: 0x28)
    class USBProjectileChainMovementParamBase* ChainMovementParam;                    // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FSBProjectileChainMovementTriggerSetting
{
    FName ChangeLabel;                                                                // 0x0000 (size: 0x8)
    float ElapsedTime;                                                                // 0x0008 (size: 0x4)
    uint8 isChangeOnHomingTargetArrive;                                               // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    float ArriveDist;                                                                 // 0x0010 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0014 (size: 0x4)
    TArray<FName> IncludeAnimTagArray;                                                // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBProjectileCharge
{
    EProjectileChargeLevel ChargeLevel;                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float ChargeRate;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBProjectileChargeParam
{
    EProjectileChargeLevel ChargeLevel;                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float ScaleVelocity;                                                              // 0x0004 (size: 0x4)
    float ScaleCollision;                                                             // 0x0008 (size: 0x4)
    float ScaleDamage;                                                                // 0x000C (size: 0x4)
    FDataTableRowHandle SwitchEffect;                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBProjectileCollsionConfig
{
    uint8 bEnableAttack;                                                              // 0x0000 (size: 0x1)
    uint8 bEnableDamaged;                                                             // 0x0000 (size: 0x1)
    uint8 bIsUseDamagedCollisionAsBlocking;                                           // 0x0000 (size: 0x1)
    uint8 bDisablePartsHit;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FCollisionHitSetting HitSetting;                                                  // 0x0004 (size: 0x28)
    FVector CollisionScaleVector;                                                     // 0x002C (size: 0xC)
    uint8 ScaleVectorFromZero;                                                        // 0x0038 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0039 (size: 0x7)
    class UCurveBase* CollisionScaleCurve;                                            // 0x0040 (size: 0x8)
    TArray<FCollisionOnOffData> CollisionOnOffDataList;                               // 0x0048 (size: 0x10)
    bool bIsUseImpactPointExecAttackHit;                                              // 0x0058 (size: 0x1)

}; // Size: 0x60

struct FSBProjectileConfigInfo : public FTableRowBase
{
    EProjectileType ProjectileType;                                                   // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TSoftClassPtr<ASBProjectileBase> CustomProjectileTemplate;                        // 0x0010 (size: 0x28)
    EProjectileNetworkSpawnType NetworkSpawnType;                                     // 0x0038 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0039 (size: 0x3)
    FProjectileSpawnInfo SpawnInfo;                                                   // 0x003C (size: 0x6C)
    FSBProjectilePostAttachConfig PostAttachConfig;                                   // 0x00A8 (size: 0x4)
    char padding_2[0x4];                                                              // 0x00AC (size: 0x4)
    FProjectileDestroyConditionConfig DestroyCondition;                               // 0x00B0 (size: 0x58)
    FSBProjectileHealthConditionConfig HealthConditionConfig;                         // 0x0108 (size: 0x8)
    bool IsTargetable;                                                                // 0x0110 (size: 0x1)
    ESBClassType TargetClass;                                                         // 0x0111 (size: 0x1)
    bool bIsTargetInstigatorPlayerOnly;                                               // 0x0112 (size: 0x1)
    bool bIsContinuousUpdateTargetInfo;                                               // 0x0113 (size: 0x1)
    char padding_3[0x4];                                                              // 0x0114 (size: 0x4)
    FProjectileSelfDeadChainConfig SelfDeadChainConfig;                               // 0x0118 (size: 0x30)
    FProjectileHitChainConfig HitChainConfig;                                         // 0x0148 (size: 0x70)
    TArray<FProjectileOrderedChainConfig> OrderedChainConfigList;                     // 0x01B8 (size: 0x10)
    FDataTableRowHandle EffectTableHandle;                                            // 0x01C8 (size: 0x10)
    TArray<FSBConditionCheckEffectTableHandle> ConditionCheckEffectTableHandle;       // 0x01D8 (size: 0x10)
    TArray<FProjectileMeshConfig> MeshConfigList;                                     // 0x01E8 (size: 0x10)
    FProjectileSummonImagineConfig SummonImagineConfig;                               // 0x01F8 (size: 0x40)
    ESBProjectileSplashSize SplashSize;                                               // 0x0238 (size: 0x1)
    char padding_4[0x7];                                                              // 0x0239 (size: 0x7)
    TSubclassOf<class UUserWidget> NamePlateWidget;                                   // 0x0240 (size: 0x8)
    TArray<FProjectileCameraShake> CameraShakeList;                                   // 0x0248 (size: 0x10)
    float CameraShakeLimitDistance;                                                   // 0x0258 (size: 0x4)
    bool bIsCameraShakeAllPlayer;                                                     // 0x025C (size: 0x1)
    char padding_5[0x3];                                                              // 0x025D (size: 0x3)
    FProjectileGroundCollisionConfig GroundCollisionConfig;                           // 0x0260 (size: 0xC)
    char padding_6[0x4];                                                              // 0x026C (size: 0x4)
    FSBProjectileCollsionConfig CollisionConfig;                                      // 0x0270 (size: 0x60)
    FProjectileDynamicCollision CollisionShape;                                       // 0x02D0 (size: 0x60)
    FSBAttackID AttackID;                                                             // 0x0330 (size: 0x4)
    char padding_7[0x4];                                                              // 0x0334 (size: 0x4)
    TSubclassOf<class USBDamageType> DamageType;                                      // 0x0338 (size: 0x8)
    float LimitDamage;                                                                // 0x0340 (size: 0x4)
    uint8 bIsForceLimitDamage;                                                        // 0x0344 (size: 0x1)
    char padding_8[0x3];                                                              // 0x0345 (size: 0x3)
    EDamageSide DamageSideInfo;                                                       // 0x0348 (size: 0x1)
    char padding_9[0x3];                                                              // 0x0349 (size: 0x3)
    uint8 bTreateFriendByParty;                                                       // 0x034C (size: 0x1)
    uint8 bIsDisableHitTargetLimit;                                                   // 0x034C (size: 0x1)
    char padding_10[0x3];                                                             // 0x034D (size: 0x3)
    EReceiveDamageSide ReceiveDamageSideInfo;                                         // 0x0350 (size: 0x1)
    char padding_11[0x7];                                                             // 0x0351 (size: 0x7)
    TArray<FDataTableRowHandle> StatusAliments;                                       // 0x0358 (size: 0x10)
    TArray<FDataTableRowHandle> SelfStatusAliments;                                   // 0x0368 (size: 0x10)
    TArray<FSBProjectileOverlapStatusAlimentConfig> OverlapStatusAlimentConfigs;      // 0x0378 (size: 0x10)
    FProjectileMoveBaseConfig MoveBaseConfig;                                         // 0x0388 (size: 0x40)
    FProjectileHomingConfig MoveHomingConfig;                                         // 0x03C8 (size: 0x40)
    FSBParabolaMoveParameter ParabolaMoveConfig;                                      // 0x0408 (size: 0x34)
    FSBProjectileAlongGroundParameter AlongGroundConfig;                              // 0x043C (size: 0x1C)
    FProjectileBeamConfig BeamConfig;                                                 // 0x0458 (size: 0x50)
    TArray<FSBProjectileChainMovementConfig> ChainMovementConfig;                     // 0x04A8 (size: 0x10)
    FProjectileRapidConfig RapidConfig;                                               // 0x04B8 (size: 0x48)
    FProjectileWideShotRapidConfig WideShotConfig;                                    // 0x0500 (size: 0x50)
    FProjectileAreaAttackConfig AreaAttackConfig;                                     // 0x0550 (size: 0x30)
    FProjectileForecastConfig ForecastConfig;                                         // 0x0580 (size: 0x40)
    FProjectilePartyShotRapidConfig PartyShotConfig;                                  // 0x05C0 (size: 0x8)
    FAkEventVariables AkEventConfig;                                                  // 0x05C8 (size: 0x40)
    FAkEventVariables EndAkEventConfig;                                               // 0x0608 (size: 0x40)
    FName ProjectileUniqueTag;                                                        // 0x0648 (size: 0x8)

}; // Size: 0x650

struct FSBProjectileDebugTickableConfig : public FTableRowBase
{
    TSubclassOf<class USBProjectileTickable_BlueprintBase> Object;                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBProjectileFoliageReaction
{
    bool bSpawnReaction;                                                              // 0x0000 (size: 0x1)
    bool bAttachToEffect;                                                             // 0x0001 (size: 0x1)
    bool bRepeat;                                                                     // 0x0002 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0003 (size: 0x1)
    float RepeatIntervalTime;                                                         // 0x0004 (size: 0x4)
    float RepeatRandomRange;                                                          // 0x0008 (size: 0x4)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    FSBFoliageReactionSpawn ReactionSpawnParam;                                       // 0x0010 (size: 0x28)

}; // Size: 0x38

struct FSBProjectileHealthConditionConfig
{
    float HitPoint;                                                                   // 0x0000 (size: 0x4)
    bool bIsChangeHitPoint;                                                           // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBProjectileHitRelativeDamage
{
    EDamageType CalcDamageType;                                                       // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSubclassOf<class USBDamageType> EventSBDamageType;                               // 0x0008 (size: 0x8)
    float DamageScale;                                                                // 0x0010 (size: 0x4)
    float Damage;                                                                     // 0x0014 (size: 0x4)
    float Damage2;                                                                    // 0x0018 (size: 0x4)
    float LimitDamage;                                                                // 0x001C (size: 0x4)
    FSBAttackThroughConfig ThroughConfig;                                             // 0x0020 (size: 0x8)
    TArray<FDataTableRowHandle> StatusAliments;                                       // 0x0028 (size: 0x10)
    TArray<FDataTableRowHandle> SelfStatusAliments;                                   // 0x0038 (size: 0x10)
    FDataTableRowHandle EffectHandle;                                                 // 0x0048 (size: 0x10)

}; // Size: 0x58

struct FSBProjectileHitTargetLimitInfo
{
    uint64 AuthoritySpawnID;                                                          // 0x0000 (size: 0x8)
    TArray<class AActor*> HitActorList;                                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBProjectileIdentifyHandle
{
    TWeakObjectPtr<class APawn> Instigator;                                           // 0x0000 (size: 0x8)
    uint64 SpawnUniqueID;                                                             // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBProjectileInfo : public FTableRowBase
{
    FSBProjectileMainEffect MainEffectConfig;                                         // 0x0008 (size: 0x138)
    FProjectileMuzzleEffectConfig MuzzleEffectConfig;                                 // 0x0140 (size: 0x88)
    FProjectileSelfDeadEffectConfig SelfDeadEffectConfig;                             // 0x01C8 (size: 0xA0)
    FProjectileHitEffectConfig HitEffectConfig;                                       // 0x0268 (size: 0x80)
    FProjectileGroundHitEffectConfig GroundHitEffectConfig;                           // 0x02E8 (size: 0x50)
    FProjectileShieldHitEffectConfig ShieldHitEffectConfig;                           // 0x0338 (size: 0x58)
    TArray<FSBProjectileFoliageReaction> SpawnFoliageReactions;                       // 0x0390 (size: 0x10)
    FProjectileBeamEffectConfig BeamEffectConfig;                                     // 0x03A0 (size: 0x1B8)
    ESBProjectileEffectVisibleType ProjectileVisibleType;                             // 0x0558 (size: 0x1)
    bool bIsChangeLightingChannel;                                                    // 0x0559 (size: 0x1)

}; // Size: 0x560

struct FSBProjectileMainEffect
{
    float DelayTime;                                                                  // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FParticleParameter ParticleParam;                                                 // 0x0008 (size: 0x90)
    FEffectActorParameter EffectActorParam;                                           // 0x0098 (size: 0x60)
    uint8 bIsNotifyWhenGroundHit;                                                     // 0x00F8 (size: 0x1)
    char padding_1[0x7];                                                              // 0x00F9 (size: 0x7)
    FAkEventSwitch AkEventSwitch;                                                     // 0x0100 (size: 0x20)
    FShapeEffectParameter ShapeEffectParam;                                           // 0x0120 (size: 0x14)

}; // Size: 0x138

struct FSBProjectileManageEffect
{
    class UParticleSystem* Particle;                                                  // 0x0000 (size: 0x8)
    FAkEventVariables AkEvent;                                                        // 0x0008 (size: 0x40)

}; // Size: 0x48

struct FSBProjectileMasterInfo : public FTableRowBase
{
    class UDataTable* ConfigInfo;                                                     // 0x0008 (size: 0x8)
    class UDataTable* EffectInfo;                                                     // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBProjectileMeshCollision : public FProjectileCollisionParamBase
{
    ESBProjectileMeshCollisionType MeshType;                                          // 0x001C (size: 0x1)
    char padding_0[0x3];                                                              // 0x001D (size: 0x3)
    FProjectileCylinderMeshConfig CylinderSetting;                                    // 0x0020 (size: 0x20)
    TSoftObjectPtr<UStaticMesh> CustomMeshCollision;                                  // 0x0040 (size: 0x28)

}; // Size: 0x68

struct FSBProjectileOverlapStatusAlimentConfig
{
    TArray<FDataTableRowHandle> OverlapStatusAliments;                                // 0x0000 (size: 0x10)
    EStatusTargetSide OverlapStatusTargetSide;                                        // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBProjectilePostAttachConfig
{
    uint8 bIsSameRotatorFromAttach;                                                   // 0x0000 (size: 0x1)
    uint8 bIsCauseHitAttach;                                                          // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FSBProjectilePreCalcDirection
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

struct FSBProjectilePreMarkedTarget
{
    uint8 bIsUseDummyTarget;                                                          // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FVector TargetPos;                                                                // 0x0004 (size: 0xC)

}; // Size: 0x10

struct FSBProjectileSelectHandle
{
    class UDataTable* DataTable;                                                      // 0x0000 (size: 0x8)
    FName RowName;                                                                    // 0x0008 (size: 0x8)
    int32 TableRowIndex;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBProjectileShareHitKeyConfig
{
    FDataTableRowHandle ShareProjectileConfigHandle;                                  // 0x0000 (size: 0x10)
    EProjectileShareGroup ShareGroup;                                                 // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    float EnableShareHitTime;                                                         // 0x0014 (size: 0x4)
    float RemainEnableShareHitTime;                                                   // 0x0018 (size: 0x4)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    class AActor* Instigator;                                                         // 0x0020 (size: 0x8)
    class AActor* Spawner;                                                            // 0x0028 (size: 0x8)
    uint64 AuthoritySpawnerSpawnID;                                                   // 0x0030 (size: 0x8)
    TArray<FSBProjectileShareHitOverlap> OverlapHitDisableActorList;                  // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBProjectileShareHitOverlap
{
    class AActor* HitActor;                                                           // 0x0000 (size: 0x8)
    float RemainReHitTime;                                                            // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FSBProjectileStability
{
    float HorizontalHalfAngle;                                                        // 0x0000 (size: 0x4)
    float VerticalHalfAngle;                                                          // 0x0004 (size: 0x4)
    bool bVerticalUpOnly;                                                             // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBProjectileTrailImpactInfo
{
    uint8 bIsPaintDecal;                                                              // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSoftObjectPtr<UMaterialInterface> DecalMaterial;                                 // 0x0008 (size: 0x28)
    float PaintDecalLength;                                                           // 0x0030 (size: 0x4)
    FRotator PaintDecalOffsetRot;                                                     // 0x0034 (size: 0xC)
    FVector PaintDecalSize;                                                           // 0x0040 (size: 0xC)
    float PaintDecalLifeTime;                                                         // 0x004C (size: 0x4)

}; // Size: 0x50

struct FSBPurchaseCondition : public FTableRowBase
{
    TArray<FString> MissionId;                                                        // 0x0008 (size: 0x10)
    TArray<bool> MissionCleared;                                                      // 0x0018 (size: 0x10)
    TArray<int32> QuestID;                                                            // 0x0028 (size: 0x10)
    TArray<bool> QuestCleared;                                                        // 0x0038 (size: 0x10)
    int32 PlayDays;                                                                   // 0x0048 (size: 0x4)
    int32 SeasonId;                                                                   // 0x004C (size: 0x4)
    int32 SeasonLevel;                                                                // 0x0050 (size: 0x4)

}; // Size: 0x58

struct FSBPurchaseConditionMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBCondition> AdventurerRank;                                              // 0x0008 (size: 0x10)
    TArray<FSBCondition> ClassLv;                                                     // 0x0018 (size: 0x10)
    TArray<FSBCondition> Appearance;                                                  // 0x0028 (size: 0x10)
    TArray<FSBCondition> Mission;                                                     // 0x0038 (size: 0x10)
    TArray<FSBCondition> Quest;                                                       // 0x0048 (size: 0x10)
    TArray<FSBCondition> PlayDays;                                                    // 0x0058 (size: 0x10)
    TArray<FSBCondition> Season;                                                      // 0x0068 (size: 0x10)

}; // Size: 0x78

struct FSBPurchaseFSResponse
{
    int32 PayAmount;                                                                  // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FString> MailList_ItemId;                                                  // 0x0008 (size: 0x10)
    TArray<FString> MailList_BonusId;                                                 // 0x0018 (size: 0x10)
    bool bValidSeasonPassInfo;                                                        // 0x0028 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0029 (size: 0x3)
    FSBSeasonPassInfo SeasonPassInfo;                                                 // 0x002C (size: 0x1C)
    int32 AdventurerRank;                                                             // 0x0048 (size: 0x4)
    int32 ClassType;                                                                  // 0x004C (size: 0x4)
    int32 ClassLevel;                                                                 // 0x0050 (size: 0x4)
    int32 Gender;                                                                     // 0x0054 (size: 0x4)
    int32 PlayDays;                                                                   // 0x0058 (size: 0x4)
    char padding_2[0x4];                                                              // 0x005C (size: 0x4)
    TArray<FString> MissionList_Id;                                                   // 0x0060 (size: 0x10)
    TArray<bool> MissionList_Cleared;                                                 // 0x0070 (size: 0x10)
    TArray<int32> QuestList_Id;                                                       // 0x0080 (size: 0x10)
    TArray<bool> QuestList_Cleared;                                                   // 0x0090 (size: 0x10)
    TArray<int32> SeasonList_Id;                                                      // 0x00A0 (size: 0x10)
    TArray<int32> SeasonList_Rank;                                                    // 0x00B0 (size: 0x10)

}; // Size: 0xC0

struct FSBPurchaseRoPSResponse
{
    FString URL;                                                                      // 0x0000 (size: 0x10)
    FString OrderID;                                                                  // 0x0010 (size: 0x10)
    int32 FreeRoseOrb;                                                                // 0x0020 (size: 0x4)
    int32 PaidRoseOrb;                                                                // 0x0024 (size: 0x4)
    bool IsWM;                                                                        // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FSBQualityLevels
{
    float ResolutionQuality;                                                          // 0x0000 (size: 0x4)
    int32 ViewDistanceQuality;                                                        // 0x0004 (size: 0x4)
    int32 AntiAliasingQuality;                                                        // 0x0008 (size: 0x4)
    int32 ShadowQuality;                                                              // 0x000C (size: 0x4)
    int32 PostProcessQuality;                                                         // 0x0010 (size: 0x4)
    int32 TextureQuality;                                                             // 0x0014 (size: 0x4)
    int32 EffectsQuality;                                                             // 0x0018 (size: 0x4)
    int32 FoliageQuality;                                                             // 0x001C (size: 0x4)
    float CPUBenchmarkResults;                                                        // 0x0020 (size: 0x4)
    float GPUBenchmarkResults;                                                        // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBQuestAdditionalRewardUIInfo
{
    int32 ClearCount;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FRewardInfo> RewardInfos;                                                  // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBQuestListFilterSetting
{
    TArray<bool> bFlag;                                                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBQuestPreconditionUIInfo
{
    FString ConditionString;                                                          // 0x0000 (size: 0x10)
    bool bIsConditionSatisfied;                                                       // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBQuestProgressItemUIInfo
{
    EQuestConditionType ConditionType;                                                // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString ConditionString;                                                          // 0x0008 (size: 0x10)
    FString ProgressString;                                                           // 0x0018 (size: 0x10)
    bool bCompleted;                                                                  // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FSBQuestUpdatedItemsAtJoin
{
    EItemType Type;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ID;                                                                         // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBQuickShotChargeSendStatusAilmentSetting
{
    int32 ChargeLevel;                                                                // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle StatusAilmentHandle;                                          // 0x0008 (size: 0x10)
    TArray<FSBConditionCheckParam> ChangeStatusAilmentConditionList;                  // 0x0018 (size: 0x10)
    FDataTableRowHandle ChangedStatusAilmentHandle;                                   // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBRTPCEventData
{
    ESBAkEventRTPCType RTPCType;                                                      // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FString> EventNameArray;                                                   // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBRaidBattleActiveTime
{
    FString StartDate;                                                                // 0x0000 (size: 0x10)
    FString EndDate;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBRaidBattleData
{
    char padding_0[0x98];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x98

struct FSBRaidBattleGameScore
{
    float TotalScore;                                                                 // 0x0004 (size: 0x4)
    int32 RankingRank;                                                                // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBRaidBattleGateData
{
    FString GateId;                                                                   // 0x0000 (size: 0x10)
    FString MapId;                                                                    // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBRaidBattleMasterData
{
    FString RaidId;                                                                   // 0x0000 (size: 0x10)
    FString MapId;                                                                    // 0x0010 (size: 0x10)
    FString RewardId;                                                                 // 0x0020 (size: 0x10)
    float TotalRankingGCMultiplier;                                                   // 0x0030 (size: 0x4)
    float ClassRankingGCMultiplier;                                                   // 0x0034 (size: 0x4)
    float AwardGCMultiplier;                                                          // 0x0038 (size: 0x4)
    float AwardMostDamageMultiplier;                                                  // 0x003C (size: 0x4)
    float AwardInstaneousDumageMultiplier;                                            // 0x0040 (size: 0x4)
    float AwardBuffMultiplier;                                                        // 0x0044 (size: 0x4)
    float AwardResurrectionMultiplier;                                                // 0x0048 (size: 0x4)
    float AwardDebuffMultiplier;                                                      // 0x004C (size: 0x4)
    float AwardGimmickAttackMultiplier;                                               // 0x0050 (size: 0x4)
    float AwardLastAttakMultiplier;                                                   // 0x0054 (size: 0x4)
    float AwardMostTakeHitsMultiplier;                                                // 0x0058 (size: 0x4)
    char padding_0[0x4];                                                              // 0x005C (size: 0x4)
    FString TermId;                                                                   // 0x0060 (size: 0x10)
    TArray<FSBRaidBattleGateData> GateData;                                           // 0x0070 (size: 0x10)

}; // Size: 0x80

struct FSBRaidBattleResult
{
    FSBRaidBattleResultPersonal PersonalData;                                         // 0x0000 (size: 0x20)
    FSBRaidBattleResultRanking RankingData;                                           // 0x0020 (size: 0x20)
    FSBRaidBattleResultAward AwardPlayerData;                                         // 0x0040 (size: 0x10)
    bool GameClear;                                                                   // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FSBRaidBattleResultAward
{
    TArray<FSBRaidBattleResultAwardParam> AwardPlayerList;                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBRaidBattleResultAwardParam
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 Level;                                                                      // 0x0014 (size: 0x4)
    int32 AwardedFlag;                                                                // 0x0018 (size: 0x4)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    FString CharacterId;                                                              // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBRaidBattleResultPersonal
{
    int32 AwardedFlagBit;                                                             // 0x0000 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 TotalRanking;                                                               // 0x0008 (size: 0x4)
    int32 ClassRanking;                                                               // 0x000C (size: 0x4)
    TArray<FSBRaidBattleGameScore> ScoreList;                                         // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBRaidBattleResultRanking
{
    TArray<FSBRaidBattleResultRankingParam> TotalTopList;                             // 0x0000 (size: 0x10)
    TArray<FSBRaidBattleResultRankingParam> ClassTopList;                             // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBRaidBattleResultRankingParam
{
    int32 RankingRank;                                                                // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString Name;                                                                     // 0x0008 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0018 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0019 (size: 0x3)
    int32 Level;                                                                      // 0x001C (size: 0x4)
    FString CharacterId;                                                              // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBRaidBattleSettingData
{
    FSBRaidBattleMasterData MasterData;                                               // 0x0000 (size: 0x80)
    FString TermId;                                                                   // 0x0080 (size: 0x10)
    TArray<FSBMasterReward> RewardList;                                               // 0x0090 (size: 0x10)
    bool IsRaidMasterSet;                                                             // 0x00A0 (size: 0x1)
    bool IsMapMasterSet;                                                              // 0x00A1 (size: 0x1)

}; // Size: 0xA8

struct FSBRaidReward
{
    FSBDungeonClearAddRewardInfo TotalRankReward;                                     // 0x0000 (size: 0x88)
    FSBDungeonClearAddRewardInfo ClassRankReward;                                     // 0x0088 (size: 0x88)
    TArray<FSBDungeonClearAddRewardInfo> Award;                                       // 0x0110 (size: 0x10)

}; // Size: 0x120

struct FSBRandomDungeonAriaConnectInfo
{
    uint32 ConnectWayFlags;                                                           // 0x0000 (size: 0x4)
    int32 DungeonMapSerialNum;                                                        // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBRandomDungeonMakeParamInfo
{
    ERoomMakeFunction MakeFucnction;                                                  // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TSubclassOf<class ASBRandomDungeonFieldMeshActor> CellActorClass;                 // 0x0008 (size: 0x8)
    FString LevelName;                                                                // 0x0010 (size: 0x10)

}; // Size: 0x28

struct FSBRandomDungeonMakeParamTable : public FTableRowBase
{
    TArray<FSBRandomDungeonMakeParamInfo> FSBRandomDungeonMakeParamSet;               // 0x0008 (size: 0x10)
    FName RowComment;                                                                 // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBRandomLightMaterialPreviewParams
{
    class UMaterialInstanceDynamic* MaterialInstance;                                 // 0x0000 (size: 0x8)
    FName ParameterName;                                                              // 0x0008 (size: 0x8)
    float Intensity;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBRandomSwitchs
{
    int32 RandomSwitch1;                                                              // 0x0000 (size: 0x4)
    int32 RandomSwitch2;                                                              // 0x0004 (size: 0x4)
    int32 RandomSwitch3;                                                              // 0x0008 (size: 0x4)
    int32 RandomSwitch4;                                                              // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBRankingRewardData
{
    FString Ranking_Id;                                                               // 0x0000 (size: 0x10)
    FString Content_Id;                                                               // 0x0010 (size: 0x10)
    ESBClassType Class_Type;                                                          // 0x0020 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0021 (size: 0x3)
    int32 Rank;                                                                       // 0x0024 (size: 0x4)
    int32 reward_id;                                                                  // 0x0028 (size: 0x4)
    char padding_1[0x4];                                                              // 0x002C (size: 0x4)
    FString Reward_Text;                                                              // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FSBReadBookmarkSaveData
{
    TArray<FName> ReadBookmarkList;                                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBReadLibraryImagineData
{
    int32 ImagineIndex;                                                               // 0x0000 (size: 0x4)
    bool ReadRecipeTab;                                                               // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBReadLibraryItemData
{
    int32 ItemIndex;                                                                  // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<int32> ReadMakeList;                                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBReadLibraryWeaponData
{
    int32 WeaponIndex;                                                                // 0x0000 (size: 0x4)
    bool ReadRecipeTab;                                                               // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBRebellionHateCollectHitStatusAilmentConfig
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0008 (size: 0x10)
    int32 HitCount;                                                                   // 0x0018 (size: 0x4)
    ESBMagnitudeRelation HitCountRelation;                                            // 0x001C (size: 0x1)
    char padding_0[0x3];                                                              // 0x001D (size: 0x3)
    TArray<FDataTableRowHandle> SelfStatusAilmentHandleList;                          // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBRebellionLargeShieldAdjustTimeSetting
{
    float AddTimeSec;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBRebellionLargeShieldChargeLevelSetting
{
    float NeedEnergy;                                                                 // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FSBEffectAsset ShieldEffect;                                                      // 0x0010 (size: 0x1A8)
    FSBEffectAsset ShieldEffectEnd;                                                   // 0x01B8 (size: 0x1A8)
    TArray<FDataTableRowHandle> ProjectileHandleList;                                 // 0x0360 (size: 0x10)
    TArray<FSBGuardEffectSetting> GuardEffectSettingList;                             // 0x0370 (size: 0x10)

}; // Size: 0x380

struct FSBRebellionLargeShieldGuardSucceededSelfStatusAilment
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TArray<FDataTableRowHandle> RowHandleList;                                        // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBRebellionShieldDashDamageUpConfig
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0008 (size: 0x10)
    TArray<FSBRebellionShieldDashDamageUpStepConfig> DamageUpStepSettingList;         // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBRebellionShieldDashDamageUpStepConfig
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0008 (size: 0x10)
    float DamageUpRate;                                                               // 0x0018 (size: 0x4)
    char padding_0[0x4];                                                              // 0x001C (size: 0x4)
    FSBEffectAsset DamageUpEffect;                                                    // 0x0020 (size: 0x1A8)

}; // Size: 0x1C8

struct FSBRebellionSpecialSkillHandle
{
    TArray<FDataTableRowHandle> BurstHandle;                                          // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBRecastTimeInfo
{
    FDateTime Finish;                                                                 // 0x0000 (size: 0x8)
    float Max;                                                                        // 0x0008 (size: 0x4)
    int32 ItemIndex;                                                                  // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBRecipeCondition
{
    int32 RecepiId;                                                                   // 0x0000 (size: 0x4)
    ESBRecipeType RecipeType;                                                         // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBRecipeReleaseConditionMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBRewardItemType RewardType;                                                     // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 ItemId;                                                                     // 0x0008 (size: 0x4)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBRecipeCondition> RecipeCondition;                                       // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBReferenceReplaceData
{
    class UMaterialInstance* MaterialInstanceBase;                                    // 0x0000 (size: 0x8)
    class UMaterialInstance* MaterialInstanceForImagine;                              // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBReferenceReplaceDataSet
{
    class USkeletalMesh* BaseMesh;                                                    // 0x0000 (size: 0x8)
    TArray<FSBReferenceReplaceData> ReplaceDataArray;                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBRegionData : public FTableRowBase
{
    FName ID;                                                                         // 0x0008 (size: 0x8)
    int32 NameTextId;                                                                 // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    TArray<FName> Maps;                                                               // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBRegularBuffArrowLevelSetting
{
    float NeedAmount;                                                                 // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FSBBlasterHoldingArrowEffectSetting HoldArrowSetting;                             // 0x0010 (size: 0x1B8)
    TArray<FSBEffectAsset> ChargeEffectList;                                          // 0x01C8 (size: 0x10)
    TArray<FDataTableRowHandle> ProjectileHandleList;                                 // 0x01D8 (size: 0x10)
    TArray<FSBChargeProjectileChangeCondition> ProjectileChangeConditionList;         // 0x01E8 (size: 0x10)

}; // Size: 0x1F8

struct FSBRepGraphFrequencyDistConfig : public FTableRowBase
{
    class UCurveFloat* FrequencyDistCurve;                                            // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBRepTargetController
{
    TArray<FSBRepTargetInfoForPlayer> TargetList;                                     // 0x0000 (size: 0x10)

}; // Size: 0x20

struct FSBRepTargetInfoForPlayer
{
    TWeakObjectPtr<class AActor> TargetActor;                                         // 0x0000 (size: 0x8)

}; // Size: 0x20

struct FSBReplicationPlayerSyncImportant
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

struct FSBReportedDetail
{
    FString ReportedCharacterId;                                                      // 0x0000 (size: 0x10)
    FDateTime ReportedTime;                                                           // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBReportedInfo
{
    TArray<FSBReportedDetail> ReportedDetails;                                        // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBRequiredColoringItemForCostumeInfo : public FTableRowBase
{
    EProtectorCategory CostumePartsType;                                              // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 RequiredDyeAmount;                                                          // 0x000C (size: 0x4)
    int32 RequiredToningAgent;                                                        // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBRequiredParam_SpawnEmitterByProjectileID
{
    class UDataTable* Table;                                                          // 0x0000 (size: 0x8)
    int8 KeyIndex;                                                                    // 0x0008 (size: 0x1)
    EProjectileEffectType Type;                                                       // 0x0009 (size: 0x1)
    ESBEffectVisibleType VisibleType;                                                 // 0x000A (size: 0x1)
    char padding_0[0x1];                                                              // 0x000B (size: 0x1)
    FVector_NetQuantize Pos;                                                          // 0x000C (size: 0xC)
    bool bAutoDestroy;                                                                // 0x0018 (size: 0x1)
    bool bHeal;                                                                       // 0x0019 (size: 0x1)

}; // Size: 0x20

struct FSBResearchTeamData
{
    FSBResearchTeamOverview Overview;                                                 // 0x0000 (size: 0x28)
    int32 ItemDropIncRate;                                                            // 0x0028 (size: 0x4)
    int32 TresureboxDropIncRate;                                                      // 0x002C (size: 0x4)
    int32 MaterialIncNum;                                                             // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FSBResearchTeamMasterData_Buff
{
    FString MapId;                                                                    // 0x0000 (size: 0x10)
    int32 IncRateMaterial;                                                            // 0x0010 (size: 0x4)
    int32 IncRateDropTresurebox;                                                      // 0x0014 (size: 0x4)
    int32 IncNumMaterial;                                                             // 0x0018 (size: 0x4)
    int32 RecipeId;                                                                   // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBResearchTeamMasterData_CostTime
{
    FString MapId;                                                                    // 0x0000 (size: 0x10)
    int32 TokenID;                                                                    // 0x0010 (size: 0x4)
    int32 Cost;                                                                       // 0x0014 (size: 0x4)
    int32 Duration;                                                                   // 0x0018 (size: 0x4)
    int32 CoolTime;                                                                   // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBResearchTeamOverview
{
    FString GameContentsId;                                                           // 0x0000 (size: 0x10)
    ESBResearchTeamStatus SupporterStatus;                                            // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    FDateTime SupporterEffectEndTime;                                                 // 0x0018 (size: 0x8)
    FDateTime SupporterEffectReuseTime;                                               // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSBResidentAkEventTableRow : public FTableRowBase
{
    class UAkAudioEvent* Event;                                                       // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBResonanceSpearSpreadHitCharacter
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBReturnLocation
{
    bool bIsValid;                                                                    // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FVector Location;                                                                 // 0x0004 (size: 0xC)
    float Yaw;                                                                        // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBRewardBoostElement
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 BoostId;                                                                    // 0x0004 (size: 0x4)
    ESBRewardBoostType AbilityType;                                                   // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 AbilityID;                                                                  // 0x000C (size: 0x4)
    int32 LimitCount;                                                                 // 0x0010 (size: 0x4)
    int32 RemainingCount;                                                             // 0x0014 (size: 0x4)
    ESBRewardBoostResetPattern ResetPattern;                                          // 0x0018 (size: 0x1)

}; // Size: 0x28

struct FSBRewardBoostFangExpeditionMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBRewardBoostFangExpeditionType Type;                                            // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 Value;                                                                      // 0x0008 (size: 0x4)
    FSBTextTableHash DescTextId;                                                      // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBRewardBoostInfo
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    bool bEnable;                                                                     // 0x0004 (size: 0x1)
    bool bIsValidActiveFrom;                                                          // 0x0005 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0006 (size: 0x2)
    FDateTime ActiveFrom;                                                             // 0x0008 (size: 0x8)
    bool bIsValidActiveUntil;                                                         // 0x0010 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0011 (size: 0x7)
    FDateTime ActiveUntil;                                                            // 0x0018 (size: 0x8)
    FString EventTermId;                                                              // 0x0020 (size: 0x10)
    int32 MaxBoostEffects;                                                            // 0x0030 (size: 0x4)
    int32 ResetPattern;                                                               // 0x0034 (size: 0x4)
    TArray<FSBRewardBoostElement> ElementList;                                        // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBRewardBoostLiquidMemoryMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 LiquidMemoryId;                                                             // 0x0004 (size: 0x4)
    int32 BottleAccumulateLimitBonus;                                                 // 0x0008 (size: 0x4)
    FSBTextTableHash DescTextId;                                                      // 0x000C (size: 0x4)
    int32 SortId;                                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBRewardBoostMissionMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FName DugeonRewardId;                                                             // 0x0004 (size: 0x8)
    FSBTextTableHash DescTextId;                                                      // 0x000C (size: 0x4)
    float LunoMultiplier;                                                             // 0x0010 (size: 0x4)
    float ExpMultiplier;                                                              // 0x0014 (size: 0x4)
    float MaterialRateBoost;                                                          // 0x0018 (size: 0x4)
    float MaterialAmountMultiplier;                                                   // 0x001C (size: 0x4)
    int32 MaterialAmountAddition;                                                     // 0x0020 (size: 0x4)
    int32 SortId;                                                                     // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBRewardBoostStackBMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBRewardBoostStackBItemType ItemType;                                            // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 ItemId;                                                                     // 0x0008 (size: 0x4)
    int32 StackBNumMin;                                                               // 0x000C (size: 0x4)
    int32 StackBNumMax;                                                               // 0x0010 (size: 0x4)
    int32 SupportItemId;                                                              // 0x0014 (size: 0x4)
    float DiscountLuno;                                                               // 0x0018 (size: 0x4)
    float SuccessRate;                                                                // 0x001C (size: 0x4)
    float DiscountSupportRate;                                                        // 0x0020 (size: 0x4)
    int32 DiscountSupportAmount;                                                      // 0x0024 (size: 0x4)
    FSBTextTableHash DescTextId;                                                      // 0x0028 (size: 0x4)

}; // Size: 0x2C

struct FSBRewardBoostTooltipData
{
    FText EffectText;                                                                 // 0x0000 (size: 0x18)
    FDateTime EndDateTime;                                                            // 0x0018 (size: 0x8)
    int32 LimitCount;                                                                 // 0x0020 (size: 0x4)
    int32 RemainingCount;                                                             // 0x0024 (size: 0x4)
    ESBRewardBoostResetPattern ResetPattern;                                          // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FSBRewardToken
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)
    int32 After;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBRichTextShortSyntaxData : public FTableRowBase
{
    FString ShortText;                                                                // 0x0008 (size: 0x10)
    FString ActualText;                                                               // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBRmShopCategory
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0004 (size: 0x4)
    int32 Type;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBRmShopHistory : public FTableRowBase
{
    FString Explanation;                                                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBRmShopMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Type;                                                                       // 0x0004 (size: 0x4)
    int32 Name;                                                                       // 0x0008 (size: 0x4)
    int32 Description;                                                                // 0x000C (size: 0x4)
    TSoftObjectPtr<UTexture2D> Banner;                                                // 0x0010 (size: 0x28)
    TArray<FSBRmShopCategory> Category;                                               // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBRoseOrbShopItemMasterData
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    int32 ShopId;                                                                     // 0x0004 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0008 (size: 0x4)
    int32 Price;                                                                      // 0x000C (size: 0x4)
    int32 Tax;                                                                        // 0x0010 (size: 0x4)
    int32 Amount_Paid;                                                                // 0x0014 (size: 0x4)
    int32 Amount_Free;                                                                // 0x0018 (size: 0x4)
    int32 PurchaseLimit;                                                              // 0x001C (size: 0x4)
    int32 PurchaseStock;                                                              // 0x0020 (size: 0x4)
    int32 SortId;                                                                     // 0x0024 (size: 0x4)
    FString SpFlags;                                                                  // 0x0028 (size: 0x10)
    int32 TextureId;                                                                  // 0x0038 (size: 0x4)
    FSBTextTableHash Description;                                                     // 0x003C (size: 0x4)
    FSBTextTableHash DetailDescription;                                               // 0x0040 (size: 0x4)
    int32 Ribbon;                                                                     // 0x0044 (size: 0x4)
    int32 PeriodRibbon;                                                               // 0x0048 (size: 0x4)
    int32 BonusId;                                                                    // 0x004C (size: 0x4)
    FDateTime StartDate;                                                              // 0x0050 (size: 0x8)
    FDateTime EndDate;                                                                // 0x0058 (size: 0x8)

}; // Size: 0x60

struct FSBRouteGuideAreaPoly
{
    TArray<FVector2D> Vertex;                                                         // 0x0000 (size: 0x10)
    FVector Center;                                                                   // 0x0010 (size: 0xC)

}; // Size: 0x20

struct FSBRouteGuideDebugInfo
{
    FName CurrentLevelName;                                                           // 0x0000 (size: 0x8)
    FName TargetLevelName;                                                            // 0x0008 (size: 0x8)
    FVector TargetLocation;                                                           // 0x0010 (size: 0xC)
    float Range;                                                                      // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBRouteGuideDestination : public FTableRowBase
{
    FName DestinationActorTag;                                                        // 0x0008 (size: 0x8)
    ESBRouteGuideArea Layer;                                                          // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBRouteGuideDestinationLevelLink : public FTableRowBase
{
    FName DepartureLevelName;                                                         // 0x0008 (size: 0x8)
    FName DestinationLevelName;                                                       // 0x0010 (size: 0x8)
    FVector Location;                                                                 // 0x0018 (size: 0xC)
    ESBRouteGuideArea RouteGuideArea;                                                 // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FSBRouteGuideDestinationList : public FTableRowBase
{
    FName DestinationLevelName;                                                       // 0x0008 (size: 0x8)
    class UDataTable* DestinationTable;                                               // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBRouteGuideLevelLinkSearch
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    ESBRouteGuideArea RouteGuideArea;                                                 // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    int32 SearchDepth;                                                                // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBSMCTargetInfo
{
    FSBSquadMemberTarget Target;                                                      // 0x0000 (size: 0xC)
    FName Faction;                                                                    // 0x000C (size: 0x8)
    int32 ClusterNo;                                                                  // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBSaveProjectileBaseSpawnParam
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

struct FSBSaveProjectileSequencerSpawnParam : public FSBSaveProjectileBaseSpawnParam
{
    FProjectileAttachInfo AttachInfo;                                                 // 0x00B8 (size: 0x40)
    uint8 SkillIDPosition;                                                            // 0x00F8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00F9 (size: 0x3)
    int32 SkillId;                                                                    // 0x00FC (size: 0x4)

}; // Size: 0x100

struct FSBSaveRangedProjectileSpawnParam : public FSBSaveProjectileBaseSpawnParam
{
    FVector Direction;                                                                // 0x00B8 (size: 0xC)
    float InitialSpeed;                                                               // 0x00C4 (size: 0x4)
    float PenetrateTime;                                                              // 0x00C8 (size: 0x4)
    uint8 SkillIDPosition;                                                            // 0x00CC (size: 0x1)
    char padding_0[0x3];                                                              // 0x00CD (size: 0x3)
    int32 SkillId;                                                                    // 0x00D0 (size: 0x4)
    char padding_1[0x14];                                                             // 0x00D4 (size: 0x14)
    FProjectileAttachInfo AttachInfo;                                                 // 0x00E8 (size: 0x40)

}; // Size: 0x128

struct FSBScalability
{
    FSBQualityLevels QualityLevels;                                                   // 0x0000 (size: 0x28)
    int32 ScreenPercentage;                                                           // 0x0028 (size: 0x4)
    float ViewDistanceScale;                                                          // 0x002C (size: 0x4)
    int32 PostProcessAAQuality;                                                       // 0x0030 (size: 0x4)
    int32 SkeletalMeshLODBias;                                                        // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FSBScbClassConditionsData
{
    ESBClassType ClassType;                                                           // 0x0000 (size: 0x1)
    bool bCompleted;                                                                  // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    int32 CurrentLevel;                                                               // 0x0004 (size: 0x4)
    int32 NextLevel;                                                                  // 0x0008 (size: 0x4)
    int32 STR;                                                                        // 0x000C (size: 0x4)
    int32 VIT;                                                                        // 0x0010 (size: 0x4)
    int32 DEX;                                                                        // 0x0014 (size: 0x4)
    int32 INT;                                                                        // 0x0018 (size: 0x4)
    int32 MND;                                                                        // 0x001C (size: 0x4)
    int32 hp;                                                                         // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FSBScbClassData
{
    ESBClassType ClassType;                                                           // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 MaxRank;                                                                    // 0x0004 (size: 0x4)
    int32 Rank;                                                                       // 0x0008 (size: 0x4)
    int32 STR;                                                                        // 0x000C (size: 0x4)
    int32 VIT;                                                                        // 0x0010 (size: 0x4)
    int32 DEX;                                                                        // 0x0014 (size: 0x4)
    int32 INT;                                                                        // 0x0018 (size: 0x4)
    int32 MND;                                                                        // 0x001C (size: 0x4)
    int32 hp;                                                                         // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FSBScbMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 Level;                                                                      // 0x0008 (size: 0x4)
    int32 AddSTR;                                                                     // 0x000C (size: 0x4)
    int32 AddVIT;                                                                     // 0x0010 (size: 0x4)
    int32 AddDEX;                                                                     // 0x0014 (size: 0x4)
    int32 AddINT;                                                                     // 0x0018 (size: 0x4)
    int32 AddMND;                                                                     // 0x001C (size: 0x4)
    int32 AddHp;                                                                      // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FSBScenarioFlagData : public FTableRowBase
{
    FName Name;                                                                       // 0x0008 (size: 0x8)
    FString Description;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBScoreAttackResult
{
    int32 TotalScore;                                                                 // 0x0000 (size: 0x4)
    int32 BestScore;                                                                  // 0x0004 (size: 0x4)
    ESBDungeonEvaluation RankGrade;                                                   // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 MaxComboCount;                                                              // 0x000C (size: 0x4)
    int32 MaxComboBonus;                                                              // 0x0010 (size: 0x4)
    int32 KillCount;                                                                  // 0x0014 (size: 0x4)
    int32 KillCountBonus;                                                             // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBScoreAttackSettings : public FTableRowBase
{
    float StartTimeLimit;                                                             // 0x0008 (size: 0x4)
    float EnemyDamageScore;                                                           // 0x000C (size: 0x4)
    float EnemyKillBonus;                                                             // 0x0010 (size: 0x4)
    float ComboLimitTime;                                                             // 0x0014 (size: 0x4)
    float ScoreSupplierTime;                                                          // 0x0018 (size: 0x4)
    float ScoreSupplierRate;                                                          // 0x001C (size: 0x4)
    TMap<int32, float> ComboBonus;                                                    // 0x0020 (size: 0x50)
    TMap<FString, int32> GimmickScore;                                                // 0x0070 (size: 0x50)
    TMap<int32, int32> ResultKillBonus;                                               // 0x00C0 (size: 0x50)
    TMap<int32, int32> ResultMaxComboBonus;                                           // 0x0110 (size: 0x50)

}; // Size: 0x160

struct FSBScriptActorActionData : public FTableRowBase
{
    TArray<FName> TransitionCommands;                                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBScriptActorCreateDesc
{
    int32 Priority;                                                                   // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    class USBScriptAsset* Asset;                                                      // 0x0008 (size: 0x8)
    FString Code;                                                                     // 0x0010 (size: 0x10)
    FString LocalFileName;                                                            // 0x0020 (size: 0x10)
    bool bDisablePlayerControll;                                                      // 0x0030 (size: 0x1)
    bool bTermByPlayerHealth;                                                         // 0x0031 (size: 0x1)

}; // Size: 0x98

struct FSBScriptDefineData : public FTableRowBase
{
    FString Name;                                                                     // 0x0008 (size: 0x10)
    ESBScriptVariableType Type;                                                       // 0x0018 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0019 (size: 0x7)
    FString Value;                                                                    // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBScriptRequestInfo
{
    FSBScriptActorCreateDesc CreateDesc;                                              // 0x0000 (size: 0x98)
    class AActor* Owner;                                                              // 0x0098 (size: 0x8)
    bool bForce;                                                                      // 0x00A0 (size: 0x1)

}; // Size: 0xA8

struct FSBScriptSEData
{
    class UAkAudioEvent* Event;                                                       // 0x0000 (size: 0x8)
    class AActor* Actor;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x60

struct FSBScriptSETableRow : public FTableRowBase
{
    TSoftObjectPtr<UAkAudioEvent> Event;                                              // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBSearchEnemySetting
{
    float SearchTargetRange;                                                          // 0x0000 (size: 0x4)
    int32 SearchRangeScoreMax;                                                        // 0x0004 (size: 0x4)
    float SearchAngle;                                                                // 0x0008 (size: 0x4)
    int32 SearchAngleScoreMax;                                                        // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBSeasonPassInfo
{
    int32 SeasonId;                                                                   // 0x0000 (size: 0x4)
    ESBSeasonPassPlanState PassType;                                                  // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 Rank;                                                                       // 0x0008 (size: 0x4)
    int32 Point;                                                                      // 0x000C (size: 0x4)
    int32 Discount;                                                                   // 0x0010 (size: 0x4)
    int32 NextSeasonDiscount;                                                         // 0x0014 (size: 0x4)
    int32 NextSeasonPoint;                                                            // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBSeasonPassQuestConditionData
{
    ESBMissionQuestType Type;                                                         // 0x0000 (size: 0x1)
    ESBMissionQuestItemType ItemType;                                                 // 0x0001 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0002 (size: 0x6)
    FString ItemIdString;                                                             // 0x0008 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0018 (size: 0x1)
    ESBMissionQuestPlaceType PlaceType;                                               // 0x0019 (size: 0x1)
    char padding_1[0x6];                                                              // 0x001A (size: 0x6)
    FString MapId;                                                                    // 0x0020 (size: 0x10)
    FString CondtionId;                                                               // 0x0030 (size: 0x10)
    int32 Value;                                                                      // 0x0040 (size: 0x4)

}; // Size: 0x48

struct FSBSeasonPassQuestInfo
{
    int32 DailyQuestReloadCount;                                                      // 0x0000 (size: 0x4)
    int32 DailyQuestReloadCountMax;                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBSeasonPassQuestItemData
{
    FString QuestID;                                                                  // 0x0000 (size: 0x10)
    FString GroupId;                                                                  // 0x0010 (size: 0x10)
    ESBSeasonPassQuestType Type;                                                      // 0x0020 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0021 (size: 0x7)
    FSBSeasonPassQuestConditionData ConditionData;                                    // 0x0028 (size: 0x48)
    int32 Count;                                                                      // 0x0070 (size: 0x4)
    int32 Priority;                                                                   // 0x0074 (size: 0x4)
    ESBSeasonPassQuestPlanState Plan;                                                 // 0x0078 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0079 (size: 0x3)
    FSBTextTableHash QuestNameId;                                                     // 0x007C (size: 0x4)
    int32 Progress;                                                                   // 0x0080 (size: 0x4)
    bool IsAchieve;                                                                   // 0x0084 (size: 0x1)
    bool IsRewarded;                                                                  // 0x0085 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0086 (size: 0x2)
    int32 RankPoint;                                                                  // 0x0088 (size: 0x4)
    int32 ForceAchievementPriceType;                                                  // 0x008C (size: 0x4)
    int32 ForceAchievementPriceCount;                                                 // 0x0090 (size: 0x4)
    char padding_3[0x4];                                                              // 0x0094 (size: 0x4)
    FDateTime Period;                                                                 // 0x0098 (size: 0x8)
    FString TermId;                                                                   // 0x00A0 (size: 0x10)
    bool UsePeriod;                                                                   // 0x00B0 (size: 0x1)
    char padding_4[0x7];                                                              // 0x00B1 (size: 0x7)
    TArray<FName> RewardIdList;                                                       // 0x00B8 (size: 0x10)
    bool ProgressAchievemented;                                                       // 0x00C8 (size: 0x1)

}; // Size: 0xD0

struct FSBSeasonPassQuestListData
{
    ESBSeasonPassQuestCycleType Cycle;                                                // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    TArray<FSBSeasonPassQuestItemData> ItemList;                                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBSeasonPassQuestListManager
{
    TArray<FSBSeasonPassQuestListData> QuestDataList;                                 // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBSeasonPassReceivedRewardInfo
{
    FName ID;                                                                         // 0x0000 (size: 0x8)
    int32 SeasonId;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBSeasonPassShopItemMasterData : public FSBFlatShopItemMasterData
{
    int32 SeasonId;                                                                   // 0x0078 (size: 0x4)

}; // Size: 0x80

struct FSBSeasonPassShopPurchaseLimitMasterData : public FSBFlatShopPurchaseLimitMasterData
{
    int32 RequiredRank;                                                               // 0x0018 (size: 0x4)
    int32 RequiredPoints;                                                             // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBSendIdentifiedMaterialsToWarehouseData
{
    TArray<FOwnItemInfo> DirtyItems;                                                  // 0x0000 (size: 0x10)
    TArray<FOwnItemInfo> MoveItems;                                                   // 0x0010 (size: 0x10)
    TArray<FOwnItemInfo> IgnoredItems;                                                // 0x0020 (size: 0x10)
    int32 SaleProfits;                                                                // 0x0030 (size: 0x4)
    bool DoesUserBelongsToParty;                                                      // 0x0034 (size: 0x1)
    bool bIsAuto;                                                                     // 0x0035 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0036 (size: 0x2)
    FDateTime AutoDeliverlyStartTime;                                                 // 0x0038 (size: 0x8)
    FDateTime AutoDeliverlyExpirationTime;                                            // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBSenseDebugDrawData
{
    bool bIsValid;                                                                    // 0x0000 (size: 0x1)
    bool bIsBox;                                                                      // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    FVector Extent;                                                                   // 0x0004 (size: 0xC)
    int32 Sides;                                                                      // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBSenserData
{
    TArray<FAIFwParameterizedBTRequest> Sensers;                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBServerDamageEvent : public FSBDamageEvent
{
    uint8 bForceCritical;                                                             // 0x01A0 (size: 0x1)
    uint8 ParityForServerDamageEvent;                                                 // 0x01A1 (size: 0x1)
    uint8 bNoDeactivateSleep;                                                         // 0x01A2 (size: 0x1)
    uint8 bNoDeactivateTransform;                                                     // 0x01A3 (size: 0x1)

}; // Size: 0x1A8

struct FSBServerEntry
{
    FString ServerName;                                                               // 0x0000 (size: 0x10)
    FString CurrentPlayers;                                                           // 0x0010 (size: 0x10)
    FString MaxPlayers;                                                               // 0x0020 (size: 0x10)
    FString GameType;                                                                 // 0x0030 (size: 0x10)
    FString MapName;                                                                  // 0x0040 (size: 0x10)
    FString Ping;                                                                     // 0x0050 (size: 0x10)
    int32 SearchResultsIndex;                                                         // 0x0060 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0064 (size: 0x4)
    FString ServerAddress;                                                            // 0x0068 (size: 0x10)
    FString SessionId;                                                                // 0x0078 (size: 0x10)
    FString WarpPointTag;                                                             // 0x0088 (size: 0x10)

}; // Size: 0x98

struct FSBShopItem
{
    int32 ProductId;                                                                  // 0x0000 (size: 0x4)
    int32 PurchaseLimitId;                                                            // 0x0004 (size: 0x4)
    int32 StockNum;                                                                   // 0x0008 (size: 0x4)
    int32 Price;                                                                      // 0x000C (size: 0x4)
    bool ViewType;                                                                    // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 WorldStockNum;                                                              // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBShopItemRoPS
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    int32 ShopId;                                                                     // 0x0004 (size: 0x4)
    FSBTextTableHash ItemNameId;                                                      // 0x0008 (size: 0x4)
    int32 Price;                                                                      // 0x000C (size: 0x4)
    int32 AmountPaid;                                                                 // 0x0010 (size: 0x4)
    int32 AmountFree;                                                                 // 0x0014 (size: 0x4)
    int32 LimitCount;                                                                 // 0x0018 (size: 0x4)
    int32 PurchaseCount;                                                              // 0x001C (size: 0x4)
    int32 OrderID;                                                                    // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    FString SpFlag;                                                                   // 0x0028 (size: 0x10)
    int32 TextureId;                                                                  // 0x0038 (size: 0x4)
    FSBTextTableHash ItemDescriptionId;                                               // 0x003C (size: 0x4)
    FSBTextTableHash ItemDetailDescriptionId;                                         // 0x0040 (size: 0x4)
    int32 BonusId;                                                                    // 0x0044 (size: 0x4)
    FDateTime EndDate;                                                                // 0x0048 (size: 0x8)

}; // Size: 0x50

struct FSBShopSettingData
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    ESBEventShopStorage EventShopStorageSelect;                                       // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBShortPinInfo
{
    FString PinId;                                                                    // 0x0000 (size: 0x10)
    ESBShortPinType ShortPinType;                                                     // 0x0010 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0011 (size: 0x7)
    class ASBCharacter* OwnerCharacter;                                               // 0x0018 (size: 0x8)
    class ASBCharacter* TargetCharacter;                                              // 0x0020 (size: 0x8)
    FVector_NetQuantize PinLocation;                                                  // 0x0028 (size: 0xC)
    char padding_1[0x4];                                                              // 0x0034 (size: 0x4)
    FDateTime SetTime;                                                                // 0x0038 (size: 0x8)
    bool AddNew;                                                                      // 0x0040 (size: 0x1)

}; // Size: 0x48

struct FSBShortcutDatas
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    TArray<FSBCharacterShortcutInfos> Infos;                                          // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBShortcutRingCommandData : public FTableRowBase
{
    bool bEnable;                                                                     // 0x0008 (size: 0x1)
    EShortcutIconCommandID ID;                                                        // 0x0009 (size: 0x1)
    char padding_0[0x6];                                                              // 0x000A (size: 0x6)
    class UTexture2D* IconTexture;                                                    // 0x0010 (size: 0x8)
    class USBTextTableAsset* TextTableAssetData;                                      // 0x0018 (size: 0x8)
    FName TextId;                                                                     // 0x0020 (size: 0x8)
    class USBTextTableAsset* ToolTipTextTableAssetData;                               // 0x0028 (size: 0x8)
    FName ToolTipTextId;                                                              // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FSBSkillAction
{
    FSBPlayerActiveSkillAction MainActionInfo;                                        // 0x0050 (size: 0x38)
    FSBPlayerActiveSkillAction SubActionInfo;                                         // 0x0088 (size: 0x38)
    FSBPlayerActiveSkillAction AerialActionInfo;                                      // 0x00C0 (size: 0x38)
    FSBPlayerActiveSkillAction Skill1ActionInfo;                                      // 0x00F8 (size: 0x38)
    FSBPlayerActiveSkillAction Skill2ActionInfo;                                      // 0x0130 (size: 0x38)
    FSBPlayerActiveSkillAction Skill3ActionInfo;                                      // 0x0168 (size: 0x38)
    FSBPlayerActiveSkillAction Skill4ActionInfo;                                      // 0x01A0 (size: 0x38)
    FSBPlayerActiveSkillAction SpecialActionInfo;                                     // 0x01D8 (size: 0x38)
    FSBPlayerActiveSkillAction DodgeActionInfo;                                       // 0x0210 (size: 0x38)
    FSBPlayerImagineSkillAction ImagineArts1ActionInfo;                               // 0x0248 (size: 0x40)
    FSBPlayerImagineSkillAction ImagineArts2ActionInfo;                               // 0x0288 (size: 0x40)
    FSBPlayerImagineSkillAction ImagineMountActionInfo;                               // 0x02C8 (size: 0x40)
    FSBPlayerActiveSkillAction EnemyStepJumpActionInfo;                               // 0x0308 (size: 0x38)
    FSBPlayerActiveSkillAction UkemiActionInfo;                                       // 0x0340 (size: 0x38)
    FSBPlayerActiveSkillAction SkillCancelStepActionInfo;                             // 0x0378 (size: 0x38)
    FSBPlayerActiveSkillAction Skill5ActionInfo;                                      // 0x03B0 (size: 0x38)
    FSBPlayerActiveSkillAction Skill6ActionInfo;                                      // 0x03E8 (size: 0x38)
    FSBPlayerActiveSkillAction Skill7ActionInfo;                                      // 0x0420 (size: 0x38)
    FSBPlayerActiveSkillAction Skill8ActionInfo;                                      // 0x0458 (size: 0x38)

}; // Size: 0x4A0

struct FSBSkillBuffData
{
    TArray<FName> BuffList;                                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBSkillDataMasterData
{
    int32 SkillId;                                                                    // 0x0000 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0004 (size: 0x4)
    TArray<FSBTextTableHash> DescArray;                                               // 0x0008 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x0018 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0019 (size: 0x3)
    int32 ClassLevel;                                                                 // 0x001C (size: 0x4)
    ESBSkillType SkillType;                                                           // 0x0020 (size: 0x1)
    ESBSkillAbilityType AbilityType;                                                  // 0x0021 (size: 0x1)
    char padding_1[0x16];                                                             // 0x0022 (size: 0x16)
    int32 ConditionSkillId1;                                                          // 0x0038 (size: 0x4)
    int32 ConditionSkillLevel1;                                                       // 0x003C (size: 0x4)
    int32 ConditionSkillId2;                                                          // 0x0040 (size: 0x4)
    int32 ConditionSkillLevel2;                                                       // 0x0044 (size: 0x4)
    int32 CannotLearnSkillId;                                                         // 0x0048 (size: 0x4)
    int32 SwitchSkillId;                                                              // 0x004C (size: 0x4)
    bool IsDefaultSkill;                                                              // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FSBSkillForecastSetting
{
    TSoftClassPtr<ASBSkillForecast> ForecastActor;                                    // 0x0000 (size: 0x28)
    FVector AttackCollisionSize;                                                      // 0x0028 (size: 0xC)
    float MaxStepHeight;                                                              // 0x0034 (size: 0x4)
    float StepDetectPrecision;                                                        // 0x0038 (size: 0x4)
    float FloorCheckHeight;                                                           // 0x003C (size: 0x4)

}; // Size: 0x40

struct FSBSkillMarkerDecalOverrideSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    TSoftObjectPtr<UMaterialInterface> DecalMaterial;                                 // 0x0010 (size: 0x28)

}; // Size: 0x38

struct FSBSkillMarkerSetting
{
    TSoftClassPtr<ASBSkillMarker> MarkerActor;                                        // 0x0000 (size: 0x28)
    TArray<FSBSkillMarkerDecalOverrideSetting> MarkerDecalOverrideSettingList;        // 0x0028 (size: 0x10)
    uint8 bSetMarkerRadius;                                                           // 0x0038 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0039 (size: 0x3)
    float MarkerRadius;                                                               // 0x003C (size: 0x4)
    TEnumAsByte<ESBSkillMarkerPlace::Type> MarkerPlaceType;                           // 0x0040 (size: 0x1)
    TEnumAsByte<ESBSkillMarkerAim::Type> MarkerAimType;                               // 0x0041 (size: 0x1)
    TEnumAsByte<ESBSkillMarkerAim::Type> MarkerAimTypeLockon;                         // 0x0042 (size: 0x1)
    TEnumAsByte<ESBSkillMarkerRayCollision::Type> MarkerAimRayCollision;              // 0x0043 (size: 0x1)
    TEnumAsByte<ESBSkillMarkerRange::Type> MarkerRangeType;                           // 0x0044 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0045 (size: 0x3)
    float RangeMin;                                                                   // 0x0048 (size: 0x4)
    float RangeMax;                                                                   // 0x004C (size: 0x4)
    float HeightRange;                                                                // 0x0050 (size: 0x4)
    float MarkerColRadius;                                                            // 0x0054 (size: 0x4)
    bool bCanAdjustRangeByMoveInput;                                                  // 0x0058 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0059 (size: 0x3)
    float InitialRange;                                                               // 0x005C (size: 0x4)
    float RangeControlSpeed;                                                          // 0x0060 (size: 0x4)
    bool bCanTurn;                                                                    // 0x0064 (size: 0x1)
    EGameInput MarkerTurnButton;                                                      // 0x0065 (size: 0x1)
    bool bShowMarkerAnytime;                                                          // 0x0066 (size: 0x1)
    bool bStampMarkerAtLaunchProjectile;                                              // 0x0067 (size: 0x1)
    float StampLifeTime;                                                              // 0x0068 (size: 0x4)

}; // Size: 0x70

struct FSBSkillMasteryParam
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    int32 ConditionClassLevel;                                                        // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBSkillParam
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    int32 SkillId;                                                                    // 0x0010 (size: 0x4)
    int32 SkillLV;                                                                    // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBSkillSettingConditionCheckData
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    TArray<int32> PassiveSkillIDList;                                                 // 0x0008 (size: 0x10)
    int32 StackBNum;                                                                  // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBSkillTreeHorizonBranchData
{
    TArray<FCharaSkillMasteryInfo> SkillList;                                         // 0x0000 (size: 0x10)
    ESkillTreeHorizonBranchType ForegroundBranchType;                                 // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBSkinData
{
    FSBSkinMaterialData DefaultMuscle;                                                // 0x0000 (size: 0x50)
    FSBSkinMaterialData LowMuscle;                                                    // 0x0050 (size: 0x50)
    FSBSkinMaterialData HighMuscle;                                                   // 0x00A0 (size: 0x50)

}; // Size: 0xF0

struct FSBSkinMaterialData
{
    TSoftObjectPtr<UMaterialInstance> UpperMaterial;                                  // 0x0000 (size: 0x28)
    TSoftObjectPtr<UMaterialInstance> LowerMaterial;                                  // 0x0028 (size: 0x28)

}; // Size: 0x50

struct FSBSkySphereLightSource
{
    class UCurveLinearColor* LightColor;                                              // 0x0000 (size: 0x8)
    class UCurveFloat* LightIntensity;                                                // 0x0008 (size: 0x8)
    class UCurveFloat* ToonIntensityScale;                                            // 0x0010 (size: 0x8)
    class ADirectionalLight* DirectionalLightActor;                                   // 0x0018 (size: 0x8)
    float SunDiskPitch;                                                               // 0x0020 (size: 0x4)
    float SunDiskYaw;                                                                 // 0x0024 (size: 0x4)
    float RotationTimeMin;                                                            // 0x0028 (size: 0x4)
    float RotationTimeMax;                                                            // 0x002C (size: 0x4)
    float RoundSpeed;                                                                 // 0x0030 (size: 0x4)
    float RoundOffset;                                                                // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FSBSmasherAttackLevelSetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    int32 AttackLevelLimit;                                                           // 0x0004 (size: 0x4)
    TArray<float> NextAttackLevelSecondList;                                          // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBSmasherBoostCartridgeConsumptionSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float Consumption;                                                                // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBSmasherDamageUpRateModifyConditionSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    int32 DamageUpRate;                                                               // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBSmasherMoveSpeedSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float MoveSpeedRate;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBSmasherReloadAmountSetting
{
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0000 (size: 0x10)
    float ReloadAddAmount;                                                            // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBSmasherReloadSettingGroup
{
    TArray<FSBSmasherReloadAmountSetting> NormalReloadSettingList;                    // 0x0000 (size: 0x10)
    TArray<FSBSmasherReloadAmountSetting> QuickReloadSettingList;                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBSoundEnemyIdTableRow : public FTableRowBase
{
    FString AppearanceId;                                                             // 0x0008 (size: 0x10)
    FString CharaBPId;                                                                // 0x0018 (size: 0x10)
    FString SoundId;                                                                  // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSBSoundEventTermData
{
    TSoftObjectPtr<UAkAudioEvent> StartEventTerm;                                     // 0x0000 (size: 0x28)
    TSoftObjectPtr<UAkAudioEvent> EndEventTerm;                                       // 0x0028 (size: 0x28)

}; // Size: 0x50

struct FSBSoundQuestProgressStateData
{
    FName QuestID;                                                                    // 0x0000 (size: 0x8)
    FName StateGroupName;                                                             // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBSpawnActionSetting
{
    float Probability;                                                                // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    class USBUtilityOption* UtilityOption;                                            // 0x0008 (size: 0x8)
    FString InitAnimStateName;                                                        // 0x0010 (size: 0x10)
    TArray<FString> PassStateMachineNames;                                            // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBSpawnAndDestructCounter
{
    int32 RespawnCounter;                                                             // 0x0000 (size: 0x4)
    int32 DestroyCounter;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBSpawnDecalAtLocationParam : public FSBSpawnDecalBase
{
    class AActor* SourceActor;                                                        // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FSBSpawnDecalAttachedParam : public FSBSpawnDecalBase
{
    class USceneComponent* AttachToComponent;                                         // 0x0038 (size: 0x8)
    FName AttachPointName;                                                            // 0x0040 (size: 0x8)
    TEnumAsByte<EAttachLocation::Type> LocationType;                                  // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FSBSpawnDecalBase
{
    class UMaterialInterface* DecalMaterial;                                          // 0x0000 (size: 0x8)
    FVector DecalSize;                                                                // 0x0008 (size: 0xC)
    FVector Location;                                                                 // 0x0014 (size: 0xC)
    FRotator Rotation;                                                                // 0x0020 (size: 0xC)
    float LifeSpan;                                                                   // 0x002C (size: 0x4)
    ESBEffectVisibleType VisibleType;                                                 // 0x0030 (size: 0x1)
    bool IsVisibleByHiddenSourceActor;                                                // 0x0031 (size: 0x1)

}; // Size: 0x38

struct FSBSpawnEmitterAtLocationParam : public FSBSpawnEmitterBase
{
    class AActor* SourceActor;                                                        // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBSpawnEmitterAttachedParam : public FSBSpawnEmitterBase
{
    class USceneComponent* AttachToComponent;                                         // 0x0040 (size: 0x8)
    FName AttachPointName;                                                            // 0x0048 (size: 0x8)
    TEnumAsByte<EAttachLocation::Type> LocationType;                                  // 0x0050 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0051 (size: 0x7)
    class AActor* OverwriteSourceActor;                                               // 0x0058 (size: 0x8)

}; // Size: 0x60

struct FSBSpawnEmitterBase
{
    class UParticleSystem* EmitterTemplate;                                           // 0x0000 (size: 0x8)
    EEffectId EffectId;                                                               // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    FVector Location;                                                                 // 0x000C (size: 0xC)
    FRotator Rotation;                                                                // 0x0018 (size: 0xC)
    FVector Scale;                                                                    // 0x0024 (size: 0xC)
    bool IsUseEffectScale;                                                            // 0x0030 (size: 0x1)
    bool IsAutoDestroy;                                                               // 0x0031 (size: 0x1)
    EPSCPoolMethod PoolingMethod;                                                     // 0x0032 (size: 0x1)
    bool bOverrideLightingChannels;                                                   // 0x0033 (size: 0x1)
    FLightingChannels OverrideLightingChannels;                                       // 0x0034 (size: 0x1)
    bool bOverrideElementType;                                                        // 0x0035 (size: 0x1)
    ESBAttribute OverrideElementType;                                                 // 0x0036 (size: 0x1)
    ESBEffectVisibleType VisibleType;                                                 // 0x0037 (size: 0x1)
    bool IsVisibleByHiddenSourceActor;                                                // 0x0038 (size: 0x1)
    ESBEffectCullingType CullingType;                                                 // 0x0039 (size: 0x1)

}; // Size: 0x40

struct FSBSpawnNiagaraAtLocationParam : public FSBSpawnNiagaraBase
{
    class AActor* SourceActor;                                                        // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBSpawnNiagaraAttachedParam : public FSBSpawnNiagaraBase
{
    class USceneComponent* AttachToComponent;                                         // 0x0040 (size: 0x8)
    FName AttachPointName;                                                            // 0x0048 (size: 0x8)
    TEnumAsByte<EAttachLocation::Type> LocationType;                                  // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FSBSpawnNiagaraBase
{
    EEffectId EffectId;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    class UNiagaraSystem* NiagaraTemplate;                                            // 0x0008 (size: 0x8)
    FVector Location;                                                                 // 0x0010 (size: 0xC)
    FRotator Rotation;                                                                // 0x001C (size: 0xC)
    FVector Scale;                                                                    // 0x0028 (size: 0xC)
    bool IsUseEffectScale;                                                            // 0x0034 (size: 0x1)
    bool IsAutoDestroy;                                                               // 0x0035 (size: 0x1)
    ENCPoolMethod PoolingMethod;                                                      // 0x0036 (size: 0x1)
    bool bOverrideLightingChannels;                                                   // 0x0037 (size: 0x1)
    FLightingChannels OverrideLightingChannels;                                       // 0x0038 (size: 0x1)
    bool bOverrideElementType;                                                        // 0x0039 (size: 0x1)
    ESBAttribute OverrideElementType;                                                 // 0x003A (size: 0x1)
    ESBEffectVisibleType VisibleType;                                                 // 0x003B (size: 0x1)
    bool IsVisibleByHiddenSourceActor;                                                // 0x003C (size: 0x1)
    ESBEffectCullingType CullingType;                                                 // 0x003D (size: 0x1)

}; // Size: 0x40

struct FSBSpawnWeaponLoadParam
{
    TEnumAsByte<ESBWeaponEquipType> EquipType;                                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName AssetName;                                                                  // 0x0004 (size: 0x8)
    FSBCharaCreateColorHSV ColorHSV;                                                  // 0x000C (size: 0xC)
    int32 MaterialIndex;                                                              // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBSpecialHitEffect
{
    FName EffectName;                                                                 // 0x0000 (size: 0x8)
    FSBEffectAsset Effect;                                                            // 0x0008 (size: 0x1A8)

}; // Size: 0x1B0

struct FSBSpeedRateCorrection
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

struct FSBSplineMeshInstanceSetting
{
    int32 SplineMeshIndex;                                                            // 0x0000 (size: 0x4)
    float SplineMeshDistance;                                                         // 0x0004 (size: 0x4)
    FVector SplineMeshLocation;                                                       // 0x0008 (size: 0xC)
    FRotator SplineMeshRotation;                                                      // 0x0014 (size: 0xC)

}; // Size: 0x20

struct FSBSplitDamageUESetting
{
    FSBAttackID AttackID;                                                             // 0x0000 (size: 0x4)
    int32 SplitNum;                                                                   // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBSquadMemberContext
{
    class AActor* Actor;                                                              // 0x0000 (size: 0x8)
    ESBSMCSituation Situation;                                                        // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    FName Faction;                                                                    // 0x000C (size: 0x8)
    FName Group;                                                                      // 0x0014 (size: 0x8)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    TArray<FSBSMCTargetInfo> TargetList;                                              // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBSquadMemberTarget
{
    float Priority;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBStackBIdScale
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    float Scale;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBStackBImagineParam
{
    FString pattern_id;                                                               // 0x0000 (size: 0x10)
    int32 stackb_num;                                                                 // 0x0010 (size: 0x4)
    float effect_duration_time_scale;                                                 // 0x0014 (size: 0x4)
    int32 add_offensive_power;                                                        // 0x0018 (size: 0x4)
    int32 attribute_power;                                                            // 0x001C (size: 0x4)
    int32 add_str;                                                                    // 0x0020 (size: 0x4)
    int32 add_vit;                                                                    // 0x0024 (size: 0x4)
    int32 add_dex;                                                                    // 0x0028 (size: 0x4)
    int32 add_mnd;                                                                    // 0x002C (size: 0x4)
    int32 add_int;                                                                    // 0x0030 (size: 0x4)
    int32 add_defensive_power;                                                        // 0x0034 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x0038 (size: 0x4)
    char padding_0[0x4];                                                              // 0x003C (size: 0x4)
    TArray<FSBStackBIdScale> StatusScales;                                            // 0x0040 (size: 0x10)
    TArray<FSBStackBIdScale> HyouiScales;                                             // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FSBStackBMasterData
{
    FString stackb_id;                                                                // 0x0000 (size: 0x10)
    int32 stackb_num;                                                                 // 0x0010 (size: 0x4)
    int32 Rate;                                                                       // 0x0014 (size: 0x4)
    int32 need_luno;                                                                  // 0x0018 (size: 0x4)
    int32 item_need_count;                                                            // 0x001C (size: 0x4)
    int32 support_item_id;                                                            // 0x0020 (size: 0x4)
    int32 support_item_need_counter;                                                  // 0x0024 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FSBStackBPerk
{
    FString UniqueId;                                                                 // 0x0000 (size: 0x10)
    FSBCharacterWeaponPerkData Perk;                                                  // 0x0010 (size: 0x1C)

}; // Size: 0x30

struct FSBStackBSelect
{
    FString UniqueId;                                                                 // 0x0000 (size: 0x10)
    int32 SelectID;                                                                   // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSBStackBTicketData
{
    int32 token_id;                                                                   // 0x0000 (size: 0x4)
    ESBStackBTicketType Type;                                                         // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 need_count;                                                                 // 0x0008 (size: 0x4)
    ESBStackBItemType ItemType;                                                       // 0x000C (size: 0x1)
    char padding_1[0x3];                                                              // 0x000D (size: 0x3)
    int32 level_min;                                                                  // 0x0010 (size: 0x4)
    int32 level_max;                                                                  // 0x0014 (size: 0x4)
    int32 success_rate;                                                               // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBStackBUseTicket
{
    int32 token_id;                                                                   // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBStackBWeaponParam
{
    FString pattern_id;                                                               // 0x0000 (size: 0x10)
    int32 stackb_num;                                                                 // 0x0010 (size: 0x4)
    int32 add_offensive_power;                                                        // 0x0014 (size: 0x4)
    int32 add_str;                                                                    // 0x0018 (size: 0x4)
    int32 add_vit;                                                                    // 0x001C (size: 0x4)
    int32 add_dex;                                                                    // 0x0020 (size: 0x4)
    int32 add_mnd;                                                                    // 0x0024 (size: 0x4)
    int32 add_int;                                                                    // 0x0028 (size: 0x4)
    int32 add_critical_point;                                                         // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBStaminaSettings
{
    float Dash;                                                                       // 0x0000 (size: 0x4)
    float Jump;                                                                       // 0x0004 (size: 0x4)
    float RenewStamina;                                                               // 0x0008 (size: 0x4)
    float StaminaDelay;                                                               // 0x000C (size: 0x4)

}; // Size: 0x28

struct FSBStampCategoryData : public FTableRowBase
{
    int32 CategoryId;                                                                 // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TSoftObjectPtr<UTexture2D> IconTexture;                                           // 0x0010 (size: 0x28)

}; // Size: 0x38

struct FSBStampCategoryMasterData
{
    int32 CategoryId;                                                                 // 0x0000 (size: 0x4)
    FSBTextTableHash CategoryNameTextId;                                              // 0x0004 (size: 0x4)
    int32 InitialGrant;                                                               // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TArray<FSBStampMasterData> StampMasterList;                                       // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBStampData : public FTableRowBase
{
    int32 ID;                                                                         // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    TSoftObjectPtr<UTexture2D> Texture;                                               // 0x0010 (size: 0x28)
    TSoftObjectPtr<UTexture2D> IconTexture;                                           // 0x0038 (size: 0x28)
    TSoftObjectPtr<UAkAudioEvent> Voice;                                              // 0x0060 (size: 0x28)

}; // Size: 0x88

struct FSBStampHistoryDatas
{
    TArray<int32> StampIds;                                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBStampMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 InitialGrant;                                                               // 0x0004 (size: 0x4)
    FString TermId;                                                                   // 0x0008 (size: 0x10)
    FSBTextTableHash NameTextId;                                                      // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBStartSkillSetting
{
    TArray<FName> NeedTags;                                                           // 0x0000 (size: 0x10)
    TArray<FName> ForbidTags;                                                         // 0x0010 (size: 0x10)
    float NeedStamina;                                                                // 0x0020 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0024 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> StaminaModifySettingList;                     // 0x0028 (size: 0x10)
    bool bUnsheathOnly;                                                               // 0x0038 (size: 0x1)
    bool bWalkingOnly;                                                                // 0x0039 (size: 0x1)
    bool bNotifyWalkingOnly;                                                          // 0x003A (size: 0x1)

}; // Size: 0x40

struct FSBStatusAilmentAdjustParam
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBStatusAilmentHandle
{
    FDataTableRowHandle RowHandle;                                                    // 0x0008 (size: 0x10)
    FSBStatusAilmentAdjustParam AdjustParam;                                          // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBStatusAilmentID : public FSBEncryptNetSerializeID
{
    char padding_0[0x8];                                                              // 0x0000 (size: 0x0)
}; // Size: 0x8

struct FSBStatusAilmentIconConfig
{
    ESBStatusAilmentIconType StatusAilmentIcon;                                       // 0x0000 (size: 0x1)
    ESBStatusAilmentIconCombineCategory StatusAilmentIconCombineCategory;             // 0x0001 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0002 (size: 0x2)
    float RemainTime;                                                                 // 0x0004 (size: 0x4)
    int32 UniqueHandle;                                                               // 0x0008 (size: 0x4)
    bool bIsImmune;                                                                   // 0x000C (size: 0x1)
    bool bIsRegist;                                                                   // 0x000D (size: 0x1)

}; // Size: 0x10

struct FSBStatusAilmentMaterialEffect
{
    FName MaterialParamName;                                                          // 0x0000 (size: 0x8)
    float SetValue;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBStatusAilmentWhenRespawnIfAbilityFlagWhenDead
{
    ESBAbilityFlags AbilityFlagWhenDead;                                              // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FDataTableRowHandle StatusAilmentHandle;                                          // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBStatusAlimentConfig : public FTableRowBase
{
    int32 ID;                                                                         // 0x0008 (size: 0x4)
    float IncidenceRate;                                                              // 0x000C (size: 0x4)
    TArray<FSBAbilityParts> Parts;                                                    // 0x0010 (size: 0x10)
    ESBBattleEffectiveGroup BattleEffectiveGroup;                                     // 0x0020 (size: 0x1)
    ESBAbilityFlags Flag;                                                             // 0x0021 (size: 0x1)
    ESBAbilityExpirationType ExpirationType;                                          // 0x0022 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0023 (size: 0x1)
    float EffectiveTime;                                                              // 0x0024 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> AdditionalEffectiveTimeList;                  // 0x0028 (size: 0x10)
    int32 ExpirationValue;                                                            // 0x0038 (size: 0x4)
    char padding_1[0x4];                                                              // 0x003C (size: 0x4)
    TArray<FSBAbilityConditionInfo> TriggerCondisions;                                // 0x0040 (size: 0x10)
    uint8 bTriggerCondIsContinueCond;                                                 // 0x0050 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0051 (size: 0x7)
    TArray<FSBAbilityConditionInfo> FinishCondisions;                                 // 0x0058 (size: 0x10)
    EStatusAilmentDuplicateType DuplicateType;                                        // 0x0068 (size: 0x1)
    ESBBattleEffectiveFeel FeelType;                                                  // 0x0069 (size: 0x1)
    char padding_3[0x2];                                                              // 0x006A (size: 0x2)
    uint8 bExcludeBadConditionHitOnFeelNegative;                                      // 0x006C (size: 0x1)
    uint8 bExcludeExtendTimeOnFeelNegative;                                           // 0x006C (size: 0x1)
    char padding_4[0x3];                                                              // 0x006D (size: 0x3)
    float HateScale;                                                                  // 0x0070 (size: 0x4)
    FSBBattleStatusProjectileID ProjectileId;                                         // 0x0074 (size: 0x8)
    FSBBattleStatusEffectID EffectId;                                                 // 0x007C (size: 0x8)
    bool bHideDamageUI;                                                               // 0x0084 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0085 (size: 0x3)
    uint8 bVisibleIcon;                                                               // 0x0088 (size: 0x1)
    char padding_6[0x3];                                                              // 0x0089 (size: 0x3)
    ESBStatusAilmentIconType IconType;                                                // 0x008C (size: 0x1)
    ESBStatusAilmentIconCombineCategory IconCombineCategory;                          // 0x008D (size: 0x1)

}; // Size: 0x90

struct FSBStatusAlimentPointGravityConfig
{
    FVector_NetQuantize10 GravityPoint;                                               // 0x0000 (size: 0xC)
    FVector_NetQuantize10 GravityVector;                                              // 0x000C (size: 0xC)

}; // Size: 0x18

struct FSBStatusAlimentUIIconInfo
{
    ESBBattleEffective StatusAliment;                                                 // 0x0010 (size: 0x1)
    bool bIsEnableActiveTime;                                                         // 0x0011 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0012 (size: 0x2)
    float RemainTime;                                                                 // 0x0014 (size: 0x4)
    int32 Priority;                                                                   // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBStatusUIRequestInfo
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString Text;                                                                     // 0x0010 (size: 0x10)
    float RemainTime;                                                                 // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FSBStepListTargetEnemyData
{
    FString EnemyId;                                                                  // 0x0000 (size: 0x10)
    int32 LevelMin;                                                                   // 0x0010 (size: 0x4)
    int32 LevelMax;                                                                   // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBStorageItemAPIResponseData
{
    TArray<FOwnItemInfo> DirtyItems;                                                  // 0x0000 (size: 0x10)
    TArray<FSBActiveItemData> ActiveItems;                                            // 0x0010 (size: 0x10)
    TArray<FString> InactiveItems;                                                    // 0x0020 (size: 0x10)
    TArray<FOwnItemInfo> ExpiredItems;                                                // 0x0030 (size: 0x10)
    int32 AddExp;                                                                     // 0x0040 (size: 0x4)
    FSBExtraExpParse ClassExtraExp;                                                   // 0x0044 (size: 0x18)

}; // Size: 0x60

struct FSBStorageItemBoxData
{
    int32 storage_no;                                                                 // 0x0000 (size: 0x4)
    int32 item_id;                                                                    // 0x0004 (size: 0x4)
    FString unique_id;                                                                // 0x0008 (size: 0x10)
    TArray<int32> selected_element;                                                   // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBStorageItemBoxResultData
{
    TArray<FOwnItemInfo> DirtyItems;                                                  // 0x0000 (size: 0x10)
    TArray<FOwnItemInfo> ExpiredItems;                                                // 0x0010 (size: 0x10)
    TArray<FSBOwnEmoteData> EmoteData;                                                // 0x0020 (size: 0x10)
    TArray<int32> MoneyData;                                                          // 0x0030 (size: 0x10)
    TArray<int32> BpData;                                                             // 0x0040 (size: 0x10)
    TArray<FSBOwnItemBoxParseData> AchievementData;                                   // 0x0050 (size: 0x10)
    TArray<FSBOwnItemBoxParseData> StampSingle;                                       // 0x0060 (size: 0x10)
    TArray<FSBOwnItemBoxParseData> StampSet;                                          // 0x0070 (size: 0x10)
    TArray<FSBOwnItemBoxParseData> ImagineRecipe;                                     // 0x0080 (size: 0x10)
    TArray<FSBOwnItemBoxParseData> CraftRecipe;                                       // 0x0090 (size: 0x10)
    TArray<FSBCharacterToken> Token;                                                  // 0x00A0 (size: 0x10)
    char padding_0[0x10];                                                             // 0x00B0 (size: 0x10)
    TArray<FSBItemBoxResultItemData> BagItems;                                        // 0x00C0 (size: 0x10)
    TArray<FSBItemBoxResultItemData> BagEquipments;                                   // 0x00D0 (size: 0x10)
    TArray<FSBItemBoxResultItemData> StorageItems;                                    // 0x00E0 (size: 0x10)
    TArray<FSBItemBoxResultItemData> OtherItems;                                      // 0x00F0 (size: 0x10)
    int32 GameServerError;                                                            // 0x0100 (size: 0x4)

}; // Size: 0x108

struct FSBStorageItemData
{
    int32 storage_no;                                                                 // 0x0000 (size: 0x4)
    EItemType item_type;                                                              // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 item_id;                                                                    // 0x0008 (size: 0x4)
    int32 Amount;                                                                     // 0x000C (size: 0x4)
    FString unique_id;                                                                // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBStunInfo
{
    int32 StunLevel;                                                                  // 0x0000 (size: 0x4)
    ESBStunDirection StunDirection;                                                   // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 AttackOriginalStunValue;                                                    // 0x0008 (size: 0x4)
    bool bIsLevelDiff;                                                                // 0x000C (size: 0x1)
    char padding_1[0x3];                                                              // 0x000D (size: 0x3)
    int32 LevelDiff;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBSublevelLoad : public FTableRowBase
{
    TArray<FSBLevelTerm> Sublevels;                                                   // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBSupplyMasterData
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    TArray<FSBDungeonSupply> Supply;                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBSurfaceFootprint
{
    TEnumAsByte<EPhysicalSurface> PhysicalSurface;                                    // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    class UParticleSystem* FootprintEffect;                                           // 0x0008 (size: 0x8)
    class UNiagaraSystem* NiagaraEffect;                                              // 0x0010 (size: 0x8)
    class UMaterialInstance* FootprintDecal;                                          // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBSurfaceFootprintSettingList
{
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPWalkStart;                          // 0x0000 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pWalkStartSetting;                            // 0x0028 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPWalk;                               // 0x0030 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pWalkSetting;                                 // 0x0058 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPRun;                                // 0x0060 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pRunSetting;                                  // 0x0088 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPDash;                               // 0x0090 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pDashSetting;                                 // 0x00B8 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPJump;                               // 0x00C0 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pJumpSetting;                                 // 0x00E8 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPLandingS;                           // 0x00F0 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pLandingSSetting;                             // 0x0118 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPLandingM;                           // 0x0120 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pLandingMSetting;                             // 0x0148 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPDown;                               // 0x0150 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pDownSetting;                                 // 0x0178 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPDownM;                              // 0x0180 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pDownMSetting;                                // 0x01A8 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPHeavyAttack;                        // 0x01B0 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pHeavyAttackSetting;                          // 0x01D8 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPStep;                               // 0x01E0 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pStepSetting;                                 // 0x0208 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPSwimming;                           // 0x0210 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pSwimmingSetting;                             // 0x0238 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPDirectWaterIn;                      // 0x0240 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pDirectWaterInSetting;                        // 0x0268 (size: 0x8)
    TSoftClassPtr<USBSurfaceFootprintSetting> m_FPDirectWaterOut;                     // 0x0270 (size: 0x28)
    class USBSurfaceFootprintSetting* m_pDirectWaterOutSetting;                       // 0x0298 (size: 0x8)
    TArray<FSBFootprintSoundAdditionalSwitchSetting> m_AdditionalSwitchSetting;       // 0x02A0 (size: 0x10)

}; // Size: 0x2B0

struct FSBSwimMeshOffsetParam
{
    float MinHeightOffsetZ;                                                           // 0x0000 (size: 0x4)
    float MaxHeightOffsetZ;                                                           // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBSwimMeshOffsetParam_Body
{
    FSBSwimMeshOffsetParam S;                                                         // 0x0000 (size: 0x8)
    FSBSwimMeshOffsetParam M;                                                         // 0x0008 (size: 0x8)
    FSBSwimMeshOffsetParam L;                                                         // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBSwimMeshOffsetParam_Gender
{
    FSBSwimMeshOffsetParam_Body Male;                                                 // 0x0000 (size: 0x18)
    FSBSwimMeshOffsetParam_Body Female;                                               // 0x0018 (size: 0x18)

}; // Size: 0x30

struct FSBSyncImportantInfoForPlayer : public FSBRepTargetController
{
    TWeakObjectPtr<class AActor> Player;                                              // 0x0020 (size: 0x8)

}; // Size: 0x48

struct FSBSyntheAbilityData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Perk1Value1;                                                                // 0x0004 (size: 0x4)
    int32 Perk2Value1;                                                                // 0x0008 (size: 0x4)
    int32 Perk1Value2;                                                                // 0x000C (size: 0x4)
    int32 Perk2Value2;                                                                // 0x0010 (size: 0x4)
    int32 Accuracy;                                                                   // 0x0014 (size: 0x4)
    int32 Weight;                                                                     // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBSyntheAbilityPickUp
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 TotalWeight;                                                                // 0x0004 (size: 0x4)
    TArray<FSBSyntheAbilityData> DataList;                                            // 0x0008 (size: 0x10)
    TArray<float> RateList;                                                           // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBSyntheTokenData
{
    ESBTokenConsumeType ConsumeType;                                                  // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 SlotNum;                                                                    // 0x0004 (size: 0x4)
    int32 FreeTokenCost;                                                              // 0x0008 (size: 0x4)
    int32 PaidTokenCost;                                                              // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBSystemSETableRow : public FTableRowBase
{
    TSoftObjectPtr<UAkAudioEvent> Event;                                              // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBTelopDataParam : public FTableRowBase
{
    ESBTelopPlayType PlayType;                                                        // 0x0008 (size: 0x1)
    ESBTelopType TelopType;                                                           // 0x0009 (size: 0x1)
    char padding_0[0x2];                                                              // 0x000A (size: 0x2)
    int32 Priority;                                                                   // 0x000C (size: 0x4)
    int32 TextId;                                                                     // 0x0010 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0014 (size: 0x4)
    class UAkAudioEvent* SE;                                                          // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBTelopOverrideData : public FTableRowBase
{
    ESBTelopPlayType PlayType;                                                        // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TArray<ESBTelopPlayType> AbortType;                                               // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBTelopPlayParam
{
    ESBTelopPlayType PlayType;                                                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName Name;                                                                       // 0x0004 (size: 0x8)
    char padding_1[0x4];                                                              // 0x000C (size: 0x4)
    FText STR;                                                                        // 0x0010 (size: 0x18)
    FText SubStr;                                                                     // 0x0028 (size: 0x18)
    int32 Value;                                                                      // 0x0040 (size: 0x4)
    int32 ValueMax;                                                                   // 0x0044 (size: 0x4)
    int32 BGIndex;                                                                    // 0x0048 (size: 0x4)
    FVector2D Position;                                                               // 0x004C (size: 0x8)
    ESBRewardItemType RewardItemType;                                                 // 0x0054 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0055 (size: 0x3)
    int32 ID;                                                                         // 0x0058 (size: 0x4)
    int32 Amount;                                                                     // 0x005C (size: 0x4)

}; // Size: 0x60

struct FSBTermsOfService
{
    FText Title;                                                                      // 0x0000 (size: 0x18)
    FText Explanation;                                                                // 0x0018 (size: 0x18)
    FText Contents;                                                                   // 0x0030 (size: 0x18)

}; // Size: 0x48

struct FSBTermsOfUseInfo
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Term_Id;                                                                    // 0x0004 (size: 0x4)
    int32 Type;                                                                       // 0x0008 (size: 0x4)
    int32 Revision;                                                                   // 0x000C (size: 0x4)
    int32 Platform;                                                                   // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FString Lang;                                                                     // 0x0018 (size: 0x10)
    FString Title;                                                                    // 0x0028 (size: 0x10)
    FString Desc;                                                                     // 0x0038 (size: 0x10)
    FString Content;                                                                  // 0x0048 (size: 0x10)
    int32 Sort_Id;                                                                    // 0x0058 (size: 0x4)

}; // Size: 0x60

struct FSBTexelColorInfo
{
    int32 X;                                                                          // 0x0000 (size: 0x4)
    int32 Y;                                                                          // 0x0004 (size: 0x4)
    FColor Color;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBTextData
{
    FSBTextId ID;                                                                     // 0x0000 (size: 0x14)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FString Text;                                                                     // 0x0018 (size: 0x10)
    TMap<class FName, class FString> MetaData;                                        // 0x0028 (size: 0x50)
    FSBTextVersion Version;                                                           // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FSBTextId
{
    FName IdString;                                                                   // 0x0000 (size: 0x8)
    FName FallbackId;                                                                 // 0x0008 (size: 0x8)
    int32 IdNumber;                                                                   // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBTextTableAssetData : public FTableRowBase
{
    TSoftObjectPtr<USBTextTableAsset> Asset;                                          // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSBTextTableDatabase
{
    class USBTextTableAsset* Common;                                                  // 0x0000 (size: 0x8)
    class USBTextTableAsset* QuestCommon;                                             // 0x0008 (size: 0x8)
    class USBTextTableAsset* CharacterName;                                           // 0x0010 (size: 0x8)
    class USBTextTableAsset* LocationName;                                            // 0x0018 (size: 0x8)
    class USBTextTableAsset* PlayerClassName;                                         // 0x0020 (size: 0x8)
    class USBTextTableAsset* PartySystemTextTable;                                    // 0x0028 (size: 0x8)
    class USBTextTableAsset* ZoneName;                                                // 0x0030 (size: 0x8)
    class USBTextTableAsset* ZoneShortName;                                           // 0x0038 (size: 0x8)
    class USBTextTableAsset* BattleLogMessage;                                        // 0x0040 (size: 0x8)
    class USBTextTableAsset* SystemLogMessage;                                        // 0x0048 (size: 0x8)
    class USBTextTableAsset* Activity;                                                // 0x0050 (size: 0x8)
    class USBTextTableAsset* KeyName;                                                 // 0x0058 (size: 0x8)
    class USBTextTableAsset* KeyShortName;                                            // 0x0060 (size: 0x8)
    TMap<class FName, class USBTextTableAsset*> KeyNameSkin;                          // 0x0068 (size: 0x50)
    TMap<class FName, class USBTextTableAsset*> KeyShortNameSkin;                     // 0x00B8 (size: 0x50)
    class USBTextTableAsset* WarpPoint;                                               // 0x0108 (size: 0x8)
    class USBTextTableAsset* Dungeon;                                                 // 0x0110 (size: 0x8)
    class USBTextTableAsset* DungeonClearCondition;                                   // 0x0118 (size: 0x8)
    class USBTextTableAsset* EventTriggerName;                                        // 0x0120 (size: 0x8)
    class USBTextTableAsset* SendMailData;                                            // 0x0128 (size: 0x8)
    class USBTextTableAsset* LiquidMemoryEfficacyLogMessage;                          // 0x0130 (size: 0x8)
    class USBTextTableAsset* SBRetCode;                                               // 0x0138 (size: 0x8)
    class USBTextTableAsset* UncheaterMessage;                                        // 0x0140 (size: 0x8)
    class USBTextTableAsset* FixedPhrase;                                             // 0x0148 (size: 0x8)
    class USBTextTableAsset* WeaponTypeText;                                          // 0x0150 (size: 0x8)
    class USBTextTableAsset* GraphicsOptionText;                                      // 0x0158 (size: 0x8)
    class USBTextTableAsset* OutGameBuffTypeText;                                     // 0x0160 (size: 0x8)
    class USBTextTableAsset* ObjectNameText;                                          // 0x0168 (size: 0x8)
    class USBTextTableAsset* AdventureBoardText;                                      // 0x0170 (size: 0x8)
    class USBTextTableAsset* SystemMessageText;                                       // 0x0178 (size: 0x8)
    class USBTextTableAsset* NotifyMessageText;                                       // 0x0180 (size: 0x8)
    class UDataTable* TextAssets;                                                     // 0x0188 (size: 0x8)
    class UDataTable* TextAssetsByFlavorText;                                         // 0x0190 (size: 0x8)

}; // Size: 0x198

struct FSBTextTableHash
{
    int32 TextId;                                                                     // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSBTextVersion
{
    TArray<int32> Versions;                                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBTextureReplaceData : public FTableRowBase
{
    EMaterialType MaterialType;                                                       // 0x0008 (size: 0x1)
    ECharaPartsLocation CharaPartsLocation;                                           // 0x0009 (size: 0x1)
    char padding_0[0x6];                                                              // 0x000A (size: 0x6)
    TSoftObjectPtr<UTexture2D> Texture;                                               // 0x0010 (size: 0x28)

}; // Size: 0x38

struct FSBTheaterData
{
    FName RowName;                                                                    // 0x0000 (size: 0x8)
    ESBDemoType ScenarioType;                                                         // 0x0008 (size: 0x1)
    ESBDemoMediaType MediaType;                                                       // 0x0009 (size: 0x1)
    char padding_0[0x2];                                                              // 0x000A (size: 0x2)
    int32 Chapter;                                                                    // 0x000C (size: 0x4)
    FName LevelName;                                                                  // 0x0010 (size: 0x8)
    FString DemoTitle;                                                                // 0x0018 (size: 0x10)
    FString DemoDescript;                                                             // 0x0028 (size: 0x10)
    TSoftObjectPtr<UTexture2D> Thumbnail;                                             // 0x0038 (size: 0x28)

}; // Size: 0x60

struct FSBTheaterModeInfo
{
    bool PlayedDemo;                                                                  // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 SelectedCategoryId;                                                         // 0x0004 (size: 0x4)
    int32 SelectedListId;                                                             // 0x0008 (size: 0x4)
    float CategoryOffset;                                                             // 0x000C (size: 0x4)
    float ListOffset;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBTickerMessageInfo
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString Text;                                                                     // 0x0008 (size: 0x10)
    FDateTime StartTime;                                                              // 0x0018 (size: 0x8)
    FDateTime EndTime;                                                                // 0x0020 (size: 0x8)
    float MessageSpeed;                                                               // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FSBTileKey
{
    char padding_0[0xC];                                                              // 0x0000 (size: 0x0)
}; // Size: 0xC

struct FSBTimeNotifyEvent
{
    bool bIsNotify;                                                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FSBGameTime BeginTime;                                                            // 0x0004 (size: 0xC)
    FSBGameTime EndTime;                                                              // 0x0010 (size: 0xC)
    char padding_1[0x4];                                                              // 0x001C (size: 0x4)
    class USBTimeNotify* TimeNotify;                                                  // 0x0020 (size: 0x8)
    class USBTimeNotifyState* TimeNotifyState;                                        // 0x0028 (size: 0x8)
    bool bCanUseRandomTimeSetting;                                                    // 0x0030 (size: 0x1)
    bool bCanUseNotifyStateRandomTimeSetting;                                         // 0x0031 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0032 (size: 0x2)
    FSBGameTime RandomDelayOfBeginTime;                                               // 0x0034 (size: 0xC)
    bool bDelayEndTimeAsBeginTime;                                                    // 0x0040 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0041 (size: 0x3)
    FSBGameTime RandomDelayOfEndTime;                                                 // 0x0044 (size: 0xC)
    bool bChangeDelayValueEveryday;                                                   // 0x0050 (size: 0x1)

}; // Size: 0x88

struct FSBTokenOverLimit
{
    int32 TokenID;                                                                    // 0x0000 (size: 0x4)
    int32 OverLimit;                                                                  // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBTokenState
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString UserId;                                                                   // 0x0010 (size: 0x10)
    FString CharacterId;                                                              // 0x0020 (size: 0x10)
    int32 TokenID;                                                                    // 0x0030 (size: 0x4)
    int32 Amount;                                                                     // 0x0034 (size: 0x4)
    FDateTime RegisteDate;                                                            // 0x0038 (size: 0x8)
    FDateTime LastRecoveryDate;                                                       // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBTokenStates
{
    TArray<FSBTokenState> TokenStates;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBTowerChallengeData : public FTableRowBase
{
    ETowerChallengeAchieveType Type;                                                  // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    FString Value1;                                                                   // 0x0010 (size: 0x10)
    FString Value2;                                                                   // 0x0020 (size: 0x10)
    float LimitTime;                                                                  // 0x0030 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0034 (size: 0x4)
    FDataTableRowHandle ChallengeRegulationHandle;                                    // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBTrackGeneraterInstanceSetting
{
    bool IsIndividuallyLeftGuardRailVisible;                                          // 0x0000 (size: 0x1)
    bool LeftGuardRailVisible;                                                        // 0x0001 (size: 0x1)
    bool IsIndividuallyRightGuardRailVisible;                                         // 0x0002 (size: 0x1)
    bool RightGuardRailVisible;                                                       // 0x0003 (size: 0x1)
    float TrackBank;                                                                  // 0x0004 (size: 0x4)
    float TrackWidth;                                                                 // 0x0008 (size: 0x4)
    float TrackThickness;                                                             // 0x000C (size: 0x4)
    bool IsIndividuallyLeftGuardRailLocationOffset;                                   // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    float LeftGuardRailLocationOffset;                                                // 0x0014 (size: 0x4)
    bool IsIndividuallyRightGuardRailLocationOffset;                                  // 0x0018 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0019 (size: 0x3)
    float RightGuardRailLocationOffset;                                               // 0x001C (size: 0x4)
    bool IsIndividuallyLeftGuardRailMeshReverse;                                      // 0x0020 (size: 0x1)
    bool LeftGuardRailMeshReverse;                                                    // 0x0021 (size: 0x1)
    bool IsIndividuallyRightGuardRailMeshReverse;                                     // 0x0022 (size: 0x1)
    bool RightGuardRailMeshReverse;                                                   // 0x0023 (size: 0x1)
    char padding_2[0x4];                                                              // 0x0024 (size: 0x4)
    class UStaticMesh* ChangeTrackMesh;                                               // 0x0028 (size: 0x8)
    class UStaticMesh* ChangeLeftGuardRailMesh;                                       // 0x0030 (size: 0x8)
    class UStaticMesh* ChangeRightGuardRailMesh;                                      // 0x0038 (size: 0x8)
    bool IsIndividuallyTrackForwardAxis;                                              // 0x0040 (size: 0x1)
    TEnumAsByte<ESplineMeshAxis::Type> TrackForwardAxis;                              // 0x0041 (size: 0x1)
    bool IsIndividuallyLeftGuardRailForwardAxis;                                      // 0x0042 (size: 0x1)
    TEnumAsByte<ESplineMeshAxis::Type> LeftGuardRailForwardAxis;                      // 0x0043 (size: 0x1)
    bool IsIndividuallyRightGuardRailForwardAxis;                                     // 0x0044 (size: 0x1)
    TEnumAsByte<ESplineMeshAxis::Type> RightGuardRailForwardAxis;                     // 0x0045 (size: 0x1)

}; // Size: 0x48

struct FSBTransableCharacterData
{
    FString user_id;                                                                  // 0x0000 (size: 0x10)
    FString character_id;                                                             // 0x0010 (size: 0x10)
    FString Name;                                                                     // 0x0020 (size: 0x10)
    int32 Level;                                                                      // 0x0030 (size: 0x4)
    ESBClassType ClassType;                                                           // 0x0034 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0035 (size: 0x3)
    FString IconName;                                                                 // 0x0038 (size: 0x10)
    FString Comment;                                                                  // 0x0048 (size: 0x10)
    ESBTensionTagType Tag;                                                            // 0x0058 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0059 (size: 0x3)
    int32 OnlineStatus;                                                               // 0x005C (size: 0x4)
    FSBPlatformInfo PlatformInfo;                                                     // 0x0060 (size: 0x20)
    bool isFriend;                                                                    // 0x0080 (size: 0x1)
    bool isPartyMember;                                                               // 0x0081 (size: 0x1)
    bool IsPartyLeader;                                                               // 0x0082 (size: 0x1)
    char padding_2[0x5];                                                              // 0x0083 (size: 0x5)
    FString LastLogin;                                                                // 0x0088 (size: 0x10)
    bool isPs_only;                                                                   // 0x0098 (size: 0x1)
    char padding_3[0x7];                                                              // 0x0099 (size: 0x7)
    FDateTime FriendRegistratedDate;                                                  // 0x00A0 (size: 0x8)

}; // Size: 0xA8

struct FSBTravelOption
{
    FString SpawnPortalName;                                                          // 0x0000 (size: 0x10)
    int32 PassageCost;                                                                // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FString SessionId;                                                                // 0x0018 (size: 0x10)
    FName GameContentId;                                                              // 0x0028 (size: 0x8)
    FString MapName;                                                                  // 0x0030 (size: 0x10)
    FString GameMode;                                                                 // 0x0040 (size: 0x10)
    bool bReturnToPreviousMap;                                                        // 0x0050 (size: 0x1)
    bool bKeepLocation;                                                               // 0x0051 (size: 0x1)
    char padding_1[0x6];                                                              // 0x0052 (size: 0x6)
    FString FriendId;                                                                 // 0x0058 (size: 0x10)
    FString LeaderId;                                                                 // 0x0068 (size: 0x10)
    FString ExtraOption;                                                              // 0x0078 (size: 0x10)
    bool bGMJumper;                                                                   // 0x0088 (size: 0x1)
    ESBPreJoinMode JoinMode;                                                          // 0x0089 (size: 0x1)
    char padding_2[0x2];                                                              // 0x008A (size: 0x2)
    int32 RetryMaxCnt;                                                                // 0x008C (size: 0x4)

}; // Size: 0x90

struct FSBTraverseDungeonInfo
{
    FVector2D Position;                                                               // 0x0000 (size: 0x8)
    FVector2D Size;                                                                   // 0x0008 (size: 0x8)
    int32 Floor;                                                                      // 0x0010 (size: 0x4)
    FName TraverseName;                                                               // 0x0014 (size: 0x8)

}; // Size: 0x1C

struct FSBTraversePointDataTable : public FTableRowBase
{
    FName MapId;                                                                      // 0x0008 (size: 0x8)
    FName AreaId;                                                                     // 0x0010 (size: 0x8)
    int32 Floor;                                                                      // 0x0018 (size: 0x4)
    char padding_0[0xC];                                                              // 0x001C (size: 0xC)
    class UTexture2D* Texture;                                                        // 0x0028 (size: 0x8)
    FVector2D MapPosition;                                                            // 0x0030 (size: 0x8)
    FVector2D Size;                                                                   // 0x0038 (size: 0x8)
    FName NextMap;                                                                    // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FSBTreasureBoxBody : public FTableRowBase
{
    ESBTreasureBoxRarity Rarity;                                                      // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TSoftObjectPtr<UStaticMesh> BodyMesh;                                             // 0x0010 (size: 0x28)
    TSoftObjectPtr<UStaticMesh> BodyMesh1;                                            // 0x0038 (size: 0x28)

}; // Size: 0x60

struct FSBTreasureBoxEntryInfo
{
    TSubclassOf<class ASBFieldActorTreasureBox> TargetClass;                          // 0x0000 (size: 0x8)
    FString ObjectId;                                                                 // 0x0008 (size: 0x10)
    FString Tag;                                                                      // 0x0018 (size: 0x10)
    char padding_0[0x8];                                                              // 0x0028 (size: 0x8)
    FTransform Transform;                                                             // 0x0030 (size: 0x30)
    ESBTreasureBoxRarity Rarity;                                                      // 0x0060 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0061 (size: 0x3)
    float TimeLimit;                                                                  // 0x0064 (size: 0x4)
    int32 TreasureId;                                                                 // 0x0068 (size: 0x4)
    bool bDebugSpawn;                                                                 // 0x006C (size: 0x1)
    char padding_2[0x3];                                                              // 0x006D (size: 0x3)
    int32 ObjecDropMinMoney;                                                          // 0x0070 (size: 0x4)
    int32 ObjecDropMaxMoney;                                                          // 0x0074 (size: 0x4)

}; // Size: 0x80

struct FSBTreasureBoxLotResult
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)
    ESBTreasureBoxRewardType Type;                                                    // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 OverLimitAmount;                                                            // 0x000C (size: 0x4)
    int32 OverLimitCurrencies;                                                        // 0x0010 (size: 0x4)
    int32 OverLimitBPCoin;                                                            // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSBTreasureBoxLotSimulateResult
{
    int32 ItemId;                                                                     // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)
    int32 Count;                                                                      // 0x0008 (size: 0x4)
    ESBTreasureBoxRewardType Type;                                                    // 0x000C (size: 0x1)
    ESBTreasureBoxRarity BoxRarity;                                                   // 0x000D (size: 0x1)

}; // Size: 0x10

struct FSBTreasureBoxOpeningLotResult
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 Amount;                                                                     // 0x0004 (size: 0x4)
    ESBTreasureBoxRewardType Type;                                                    // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    FString ObjectId;                                                                 // 0x0010 (size: 0x10)
    FString EntriedTag;                                                               // 0x0020 (size: 0x10)
    FString MapName;                                                                  // 0x0030 (size: 0x10)
    FString ContentIdName;                                                            // 0x0040 (size: 0x10)
    FDateTime GatheredAt;                                                             // 0x0050 (size: 0x8)
    FDateTime RespawnAt;                                                              // 0x0058 (size: 0x8)

}; // Size: 0x60

struct FSBTreasureBoxRespawnInfo
{
    FString WorldName;                                                                // 0x0000 (size: 0x10)
    int32 TreasureId;                                                                 // 0x0010 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0014 (size: 0x4)
    FDateTime RespawnTime;                                                            // 0x0018 (size: 0x8)
    bool PickupAtOnce;                                                                // 0x0020 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0021 (size: 0x7)
    FString EntriedObjectId;                                                          // 0x0028 (size: 0x10)
    FString EntriedTag;                                                               // 0x0038 (size: 0x10)
    bool RespawnInterval;                                                             // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FSBTutorialHelpCommonData
{
    FName TextId;                                                                     // 0x0000 (size: 0x8)
    ESBTutorialHelpTextDispType TextType;                                             // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TSoftObjectPtr<UTexture2D> Texture;                                               // 0x0010 (size: 0x28)
    FString MovieFile;                                                                // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBTutorialHelpData : public FTableRowBase
{
    FName TitleTextId;                                                                // 0x0008 (size: 0x8)
    ESBTutorialHelpCategoryType CategoryType;                                         // 0x0010 (size: 0x1)
    bool bNotifyMode;                                                                 // 0x0011 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0012 (size: 0x6)
    TArray<FSBTutorialHelpCommonData> CommonData;                                     // 0x0018 (size: 0x10)
    bool CommandMenuAutoShowTutorialHelp;                                             // 0x0028 (size: 0x1)
    bool IsDefaultShow;                                                               // 0x0029 (size: 0x1)
    bool IsBookmarkAdd;                                                               // 0x002A (size: 0x1)
    char padding_1[0x1];                                                              // 0x002B (size: 0x1)
    int32 Priority;                                                                   // 0x002C (size: 0x4)
    FSBTutorialHelpTriggerCondition TriggerCondition;                                 // 0x0030 (size: 0x1C)

}; // Size: 0x50

struct FSBTutorialHelpTriggerCondition
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    FName QuestID;                                                                    // 0x0004 (size: 0x8)
    EQuestStatus QuestStatus;                                                         // 0x000C (size: 0x1)
    char padding_0[0x3];                                                              // 0x000D (size: 0x3)
    FName ClearMissionId;                                                             // 0x0010 (size: 0x8)
    int32 WarehouseAbilityId;                                                         // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FSBUIAkEventRequest
{
    TSoftObjectPtr<UAkAudioEvent> Event;                                              // 0x0000 (size: 0x28)
    char padding_0[0x20];                                                             // 0x0028 (size: 0x20)
    class UObject* WorldContextObject;                                                // 0x0048 (size: 0x8)

}; // Size: 0x50

struct FSBUIAkEventSetting
{
    int32 Priority;                                                                   // 0x0000 (size: 0x4)
    ESBUiAkEventCategory Category;                                                    // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBUniqueBossBGMSettingData
{
    ESBBossBGMSettingType SettingType;                                                // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 SettingValue;                                                               // 0x0004 (size: 0x4)
    class UAkAudioEvent* Event;                                                       // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBUniqueEnemyVoiceTableRow : public FTableRowBase
{
    FString EnemyId;                                                                  // 0x0008 (size: 0x10)
    FString VoiceType;                                                                // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBUnlockStampCategoryData
{
    int32 CategoryId;                                                                 // 0x0000 (size: 0x4)
    int32 Timestamp;                                                                  // 0x0004 (size: 0x4)
    TArray<FSBUnlockStampData> StampList;                                             // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBUnlockStampData
{
    int32 StampId;                                                                    // 0x0000 (size: 0x4)
    int32 Timestamp;                                                                  // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSBUnsheatheWeaponEffect : public FSBPlayWeaponEffect
{
    uint8 bUnsheathe;                                                                 // 0x0278 (size: 0x1)

}; // Size: 0x280

struct FSBUseCheckDialogFlags
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

struct FSBUserCoupon
{
    bool IsValid;                                                                     // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString CouponCode;                                                               // 0x0008 (size: 0x10)
    int32 ClaimedRewardLevel;                                                         // 0x0018 (size: 0x4)
    int32 CountQuest;                                                                 // 0x001C (size: 0x4)
    int32 CouponId;                                                                   // 0x0020 (size: 0x4)
    int32 UseCount;                                                                   // 0x0024 (size: 0x4)
    FDateTime ExpireDate;                                                             // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FSBUserOnlineAccountCharacter
{
    FString ID;                                                                       // 0x0000 (size: 0x10)
    FString shortId;                                                                  // 0x0010 (size: 0x10)
    FString Name;                                                                     // 0x0020 (size: 0x10)
    ESBClassType Role;                                                                // 0x0030 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0031 (size: 0x7)
    FString ReturnSessionId;                                                          // 0x0038 (size: 0x10)
    FString LastMapName;                                                              // 0x0048 (size: 0x10)
    FString PermanentDeletedAt;                                                       // 0x0058 (size: 0x10)
    char padding_1[0x50];                                                             // 0x0068 (size: 0x50)
    bool bCompletedTutorial;                                                          // 0x00B8 (size: 0x1)
    char padding_2[0x7];                                                              // 0x00B9 (size: 0x7)
    TArray<FString> ActivateWarppoints;                                               // 0x00C0 (size: 0x10)
    int32 CommandMenuPlayerAvatarPoseId;                                              // 0x00D0 (size: 0x4)

}; // Size: 0xD8

struct FSBUtilityCondition
{
    class USBUtilityDataProvider* Data;                                               // 0x0000 (size: 0x8)
    float MinValue;                                                                   // 0x0008 (size: 0x4)
    float MaxValue;                                                                   // 0x000C (size: 0x4)
    ESBUtilityScoreFunction Function;                                                 // 0x0010 (size: 0x1)
    bool bInverse;                                                                    // 0x0011 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0012 (size: 0x2)
    float ScaleX;                                                                     // 0x0014 (size: 0x4)
    float ScaleY;                                                                     // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSBUtilityOptionInstance
{
    class USBUtilityOption* Option;                                                   // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FSBUtilitySystem
{
    class USBUtilityBrainComponent* OwnerComp;                                        // 0x0000 (size: 0x8)
    TArray<class USBUtilityOption*> DefaultOptions;                                   // 0x0008 (size: 0x10)
    TArray<FSBUtilityOptionInstance> OptionInstances;                                 // 0x0018 (size: 0x10)

}; // Size: 0x40

struct FSBValueDataByID
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int16 Value;                                                                      // 0x0004 (size: 0x2)

}; // Size: 0x8

struct FSBValueDataByIDListData
{
    TArray<FSBValueDataByID> ValueDataByIDList;                                       // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSBVertEdge
{
    char padding_0[0x10];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x10

struct FSBVertsData
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

struct FSBVoiceEffectCharaPartsNameTableRow : public FTableRowBase
{
    FName CharaPartsName;                                                             // 0x0008 (size: 0x8)
    bool bIsEnable;                                                                   // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FSBWarehouseAbilityCharacterInfo
{
    int32 RecipeId;                                                                   // 0x0000 (size: 0x4)
    ESBWarehouseAbilityCharacterStatus Status;                                        // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FSBWarehouseAbilityCollectionMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 RecipeId;                                                                   // 0x0004 (size: 0x4)
    FName EnemyId;                                                                    // 0x0008 (size: 0x8)
    int32 ItemId;                                                                     // 0x0010 (size: 0x4)
    FName GameContentId;                                                              // 0x0014 (size: 0x8)
    FName EventTermId;                                                                // 0x001C (size: 0x8)
    int32 LunoBonus;                                                                  // 0x0024 (size: 0x4)
    int32 ExpBonus;                                                                   // 0x0028 (size: 0x4)
    bool bImmediateAppraisal;                                                         // 0x002C (size: 0x1)
    char padding_0[0x3];                                                              // 0x002D (size: 0x3)
    float ItemDropRateBonus;                                                          // 0x0030 (size: 0x4)
    float TreasureAppearanceRateBonus;                                                // 0x0034 (size: 0x4)
    int32 SortId;                                                                     // 0x0038 (size: 0x4)

}; // Size: 0x3C

struct FSBWarehouseAbilityCondition
{
    ESBWarehouseAbilityConditionType Type;                                            // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName TargetId;                                                                   // 0x0004 (size: 0x8)
    int32 Amount;                                                                     // 0x000C (size: 0x4)
    FName TriggerValue;                                                               // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBWarehouseAbilityConditionUIInfo
{
    FText ConditionText;                                                              // 0x0000 (size: 0x18)
    FText ProgressText;                                                               // 0x0018 (size: 0x18)
    bool bIsCleard;                                                                   // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FSBWarehouseAbilityLevelButtonUiInfo
{
    int32 PublishedAbilityNum;                                                        // 0x0000 (size: 0x4)
    int32 MasteredAbilityNum;                                                         // 0x0004 (size: 0x4)
    bool bIsNew;                                                                      // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBWarehouseAbilityListUIInfo
{
    int32 RecipeId;                                                                   // 0x0000 (size: 0x4)
    int32 Level;                                                                      // 0x0004 (size: 0x4)
    FText Name;                                                                       // 0x0008 (size: 0x18)
    bool bIsMastered;                                                                 // 0x0020 (size: 0x1)
    bool bIsNew;                                                                      // 0x0021 (size: 0x1)

}; // Size: 0x28

struct FSBWarehouseAbilityMasteringProgress
{
    ESBWarehouseAbilityConditionType ConditionType;                                   // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FName TargetId;                                                                   // 0x0004 (size: 0x8)
    int32 CurrentValue;                                                               // 0x000C (size: 0x4)
    int32 ClearValue;                                                                 // 0x0010 (size: 0x4)
    FName TriggerValue;                                                               // 0x0014 (size: 0x8)

}; // Size: 0x1C

struct FSBWarehouseAbilityMissionMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 RecipeId;                                                                   // 0x0004 (size: 0x4)
    FName DugeonRewardId;                                                             // 0x0008 (size: 0x8)
    int32 SortId;                                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBWarehouseAbilityNotifyUIInfo
{
    FText RecipeName;                                                                 // 0x0000 (size: 0x18)
    ESBWarehouseAbilityCharacterStatus Status;                                        // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSBWarehouseAbilityProductionMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 RecipeId;                                                                   // 0x0004 (size: 0x4)
    ESBWarehouseAbilityProductionType Type;                                           // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    int32 CraftRecipeId;                                                              // 0x000C (size: 0x4)
    int32 ItemId;                                                                     // 0x0010 (size: 0x4)
    float SuccessRateBonus;                                                           // 0x0014 (size: 0x4)
    float ExpBonus;                                                                   // 0x0018 (size: 0x4)
    float AccuracyBonus;                                                              // 0x001C (size: 0x4)
    float RefiningCostReduction;                                                      // 0x0020 (size: 0x4)
    float CraftCostReduction;                                                         // 0x0024 (size: 0x4)
    int32 SortId;                                                                     // 0x0028 (size: 0x4)
    FSBTextTableHash DescTextId;                                                      // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBWarehouseAbilityRecipeMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0004 (size: 0x4)
    FSBTextTableHash Description;                                                     // 0x0008 (size: 0x4)
    int32 Level;                                                                      // 0x000C (size: 0x4)
    ESBWarehouseAbilityCategory Category;                                             // 0x0010 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0011 (size: 0x3)
    int32 SortId;                                                                     // 0x0014 (size: 0x4)
    FName MapId;                                                                      // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSBWarehouseAbilityStoringMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 RecipeId;                                                                   // 0x0004 (size: 0x4)
    int32 ItemId;                                                                     // 0x0008 (size: 0x4)
    int32 AmountBonus;                                                                // 0x000C (size: 0x4)
    int32 MaxStackIncrease;                                                           // 0x0010 (size: 0x4)
    FName EventTermId;                                                                // 0x0014 (size: 0x8)
    int32 SortId;                                                                     // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBWarehouseAbilityTokenMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 TokenID;                                                                    // 0x0004 (size: 0x4)
    int32 RecoveryBonusAmount;                                                        // 0x0008 (size: 0x4)
    int32 SortId;                                                                     // 0x000C (size: 0x4)
    FSBTextTableHash DescTextId;                                                      // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBWarehouseAbilityZoneMasterData
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    int32 RecipeId;                                                                   // 0x0004 (size: 0x4)
    FName GameContentId;                                                              // 0x0008 (size: 0x8)
    int32 SortId;                                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBWarpDestinationLocationInfo
{
    bool bValid;                                                                      // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FVector ToWarpLocation;                                                           // 0x0004 (size: 0xC)
    FRotator ToWarpRotation;                                                          // 0x0010 (size: 0xC)
    FRotator WarpAfterCameraRotation;                                                 // 0x001C (size: 0xC)
    float WarpAppearRandomDistanceX;                                                  // 0x0028 (size: 0x4)
    float WarpAppearRandomDistanceY;                                                  // 0x002C (size: 0x4)

}; // Size: 0x30

struct FSBWarpPointInfo
{
    FName DestinationName;                                                            // 0x0000 (size: 0x8)
    FName LevelName;                                                                  // 0x0008 (size: 0x8)
    int32 Value;                                                                      // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSBWaterDepthSoundData
{
    class UAkComponent* AkComponent;                                                  // 0x0000 (size: 0x8)

}; // Size: 0x28

struct FSBWeaponAnimationPlayParam
{
    FName AnimationName;                                                              // 0x0000 (size: 0x8)
    bool bLooping;                                                                    // 0x0008 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0009 (size: 0x3)
    float PlayRate;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSBWeaponAnimationSetting
{
    class UAnimationAsset* Animation;                                                 // 0x0000 (size: 0x8)
    FName AnimationName;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSBWeaponAnimationTagPlayParam : public FSBWeaponAnimationPlayParam
{
    FName AnimTag;                                                                    // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSBWeaponAsset
{
    TSoftClassPtr<ASBWeapon> WeaponBase;                                              // 0x0000 (size: 0x28)
    TSoftObjectPtr<USkeletalMesh> Mesh;                                               // 0x0028 (size: 0x28)
    TSoftObjectPtr<UCharaPartsColorWeaponList> ColorList;                             // 0x0050 (size: 0x28)
    TArray<TSoftObjectPtr<UCharaPartsMaterialSet>> MaterialSetList;                   // 0x0078 (size: 0x10)
    TArray<FSBEnvironmentWeaponEffect> EnvironmentEffectList;                         // 0x0088 (size: 0x10)
    TArray<FSBUnsheatheWeaponEffect> UnsheatheEffectList;                             // 0x0098 (size: 0x10)

}; // Size: 0xB0

struct FSBWeaponAssetData : public FTableRowBase
{
    bool IsTwinWeapon;                                                                // 0x0008 (size: 0x1)
    bool IsTwinWeaponAssetDiff;                                                       // 0x0009 (size: 0x1)
    char padding_0[0x6];                                                              // 0x000A (size: 0x6)
    FSBWeaponAsset WeaponAsset1;                                                      // 0x0010 (size: 0xB0)
    FSBWeaponAsset WeaponAsset2;                                                      // 0x00C0 (size: 0xB0)

}; // Size: 0x178

struct FSBWeaponAttach
{
    TEnumAsByte<ESBWeaponAttach> AttachSocket;                                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FVector Location;                                                                 // 0x0004 (size: 0xC)
    FRotator Rotation;                                                                // 0x0010 (size: 0xC)
    FVector Scale3D;                                                                  // 0x001C (size: 0xC)

}; // Size: 0x28

struct FSBWeaponBallHammerSettings : public FTableRowBase
{
    TSoftObjectPtr<USkeletalMesh> BallSkeletalMesh;                                   // 0x0008 (size: 0x28)
    FName BallRootSocketName;                                                         // 0x0030 (size: 0x8)
    TArray<int32> BallMaterialIndexList;                                              // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FSBWeaponColorInfo
{
    int32 InventoryWeaponIndex;                                                       // 0x0000 (size: 0x4)
    int32 WeaponMaterialIndex;                                                        // 0x0004 (size: 0x4)
    int32 EmissiveColorIndex;                                                         // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSBWeaponItemData
{
    int32 WeaponID;                                                                   // 0x0000 (size: 0x4)
    int32 SpecialPerkID;                                                              // 0x0004 (size: 0x4)
    int32 SpecialPerkValue;                                                           // 0x0008 (size: 0x4)
    int32 PerkUnlockNum;                                                              // 0x000C (size: 0x4)
    TArray<FSBCharacterWeaponPerkData> PerkList;                                      // 0x0010 (size: 0x10)
    int32 UsedPerkSlot;                                                               // 0x0020 (size: 0x4)
    int32 AppearanceWeaponId;                                                         // 0x0024 (size: 0x4)
    int32 AppearanceWeaponStickerId;                                                  // 0x0028 (size: 0x4)
    char padding_0[0x4];                                                              // 0x002C (size: 0x4)
    FDateTime AppearanceWeaponStickerReleaseTime;                                     // 0x0030 (size: 0x8)
    bool bIsAppearanceWeaponStickerAttached;                                          // 0x0038 (size: 0x1)
    bool IsTermLimited;                                                               // 0x0039 (size: 0x1)
    char padding_1[0x6];                                                              // 0x003A (size: 0x6)
    FDateTime ExpiryDateTime;                                                         // 0x0040 (size: 0x8)
    bool IsDecayed;                                                                   // 0x0048 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0049 (size: 0x3)
    int32 StackBNum;                                                                  // 0x004C (size: 0x4)

}; // Size: 0x50

struct FSBWeaponKillerPerkPickMasterData
{
    FName Table_Id;                                                                   // 0x0000 (size: 0x8)
    int32 Perk_Id;                                                                    // 0x0008 (size: 0x4)
    int32 Weight;                                                                     // 0x000C (size: 0x4)
    int32 Success_Min_Value;                                                          // 0x0010 (size: 0x4)
    int32 Success_Max_Value;                                                          // 0x0014 (size: 0x4)
    int32 Big_Success_Min_Value;                                                      // 0x0018 (size: 0x4)
    int32 Big_Success_Max_Value;                                                      // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSBWeaponLevelStatusMasterData
{
    int32 Level;                                                                      // 0x0000 (size: 0x4)
    int32 Ap;                                                                         // 0x0004 (size: 0x4)
    int32 Cp;                                                                         // 0x0008 (size: 0x4)
    int32 STR;                                                                        // 0x000C (size: 0x4)
    int32 VIT;                                                                        // 0x0010 (size: 0x4)
    int32 DEX;                                                                        // 0x0014 (size: 0x4)
    int32 INT;                                                                        // 0x0018 (size: 0x4)
    int32 MND;                                                                        // 0x001C (size: 0x4)
    int32 Attribute;                                                                  // 0x0020 (size: 0x4)
    int32 Special;                                                                    // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSBWeaponLevelStatusPatternMasterData
{
    FName PatternId;                                                                  // 0x0000 (size: 0x8)
    TArray<FSBWeaponLevelStatusMasterData> LevelStatus;                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSBWeaponMasterData
{
    int32 WeaponID;                                                                   // 0x0000 (size: 0x4)
    FSBTextTableHash Name;                                                            // 0x0004 (size: 0x4)
    FSBTextTableHash Desc;                                                            // 0x0008 (size: 0x4)
    char padding_0[0x4];                                                              // 0x000C (size: 0x4)
    FString MainWeaponAssetName;                                                      // 0x0010 (size: 0x10)
    FString SubWeaponAssetName;                                                       // 0x0020 (size: 0x10)
    int32 MaterialId;                                                                 // 0x0030 (size: 0x4)
    int32 ColorId;                                                                    // 0x0034 (size: 0x4)
    int32 ColorSaturation;                                                            // 0x0038 (size: 0x4)
    int32 ColorValue;                                                                 // 0x003C (size: 0x4)
    int32 PricePlayerBuys;                                                            // 0x0040 (size: 0x4)
    int32 PricePlayerSells;                                                           // 0x0044 (size: 0x4)
    ESBClassType EquipClass;                                                          // 0x0048 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0049 (size: 0x3)
    int32 EquipLevel;                                                                 // 0x004C (size: 0x4)
    ESBAttribute Attribute;                                                           // 0x0050 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0051 (size: 0x3)
    int32 AttributeDamage;                                                            // 0x0054 (size: 0x4)
    int32 Level;                                                                      // 0x0058 (size: 0x4)
    FName StatusTable;                                                                // 0x005C (size: 0x8)
    float BaseExperience;                                                             // 0x0064 (size: 0x4)
    float ExperienceConversionRate;                                                   // 0x0068 (size: 0x4)
    int32 SortId;                                                                     // 0x006C (size: 0x4)
    TEnumAsByte<ESBWeaponType> WeaponType;                                            // 0x0070 (size: 0x1)
    bool IsNoDissolution;                                                             // 0x0071 (size: 0x1)
    bool IsForWeaponSticker;                                                          // 0x0072 (size: 0x1)
    char padding_3[0x1];                                                              // 0x0073 (size: 0x1)
    int32 DurationMinutes;                                                            // 0x0074 (size: 0x4)
    FString EventTermId;                                                              // 0x0078 (size: 0x10)
    bool bIsStackBEnable;                                                             // 0x0088 (size: 0x1)
    char padding_4[0x7];                                                              // 0x0089 (size: 0x7)
    FString StackBTypeId;                                                             // 0x0090 (size: 0x10)
    FString StackBStatusId;                                                           // 0x00A0 (size: 0x10)

}; // Size: 0xB0

struct FSBWeaponMaterialParam
{
    FLinearColor EdgeColor01;                                                         // 0x0000 (size: 0x10)
    FLinearColor EdgeColor02;                                                         // 0x0010 (size: 0x10)
    FLinearColor EdgeEmissiveColor;                                                   // 0x0020 (size: 0x10)
    float EdgeEmissiveStrength;                                                       // 0x0030 (size: 0x4)

}; // Size: 0x34

struct FSBWeaponPerkUIInfo
{
    FString NameText;                                                                 // 0x0000 (size: 0x10)
    FString DescText;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBWholeMapDatas
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    FSBWholeMapEditParam EditData;                                                    // 0x0010 (size: 0x24)

}; // Size: 0x38

struct FSBWholeMapEditParam
{
    float Opacity;                                                                    // 0x0000 (size: 0x4)
    float IconScale;                                                                  // 0x0004 (size: 0x4)
    float ZoomCity;                                                                   // 0x0008 (size: 0x4)
    float ZoomField;                                                                  // 0x000C (size: 0x4)
    float ZoomDungeon;                                                                // 0x0010 (size: 0x4)
    FVector2D WindowSize;                                                             // 0x0014 (size: 0x8)
    int32 WindowSizeScaleIndex;                                                       // 0x001C (size: 0x4)
    bool PinVisible;                                                                  // 0x0020 (size: 0x1)

}; // Size: 0x24

struct FSBWindSoundTableRow : public FTableRowBase
{
    TSoftObjectPtr<UParticleSystem> WindParticle;                                     // 0x0008 (size: 0x28)
    class UAkAudioEvent* StartEvent;                                                  // 0x0030 (size: 0x8)
    class UAkAudioEvent* EndEvent;                                                    // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FSBWishListCharacterData
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    TArray<FSBWishListData> Lists;                                                    // 0x0010 (size: 0x10)
    TArray<FSBWishListData> Checked;                                                  // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSBWishListData
{
    ESBWishListType Type;                                                             // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ID;                                                                         // 0x0004 (size: 0x4)
    bool IsChecked;                                                                   // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSBWordData : public FTableRowBase
{
    FString BodyText;                                                                 // 0x0008 (size: 0x10)
    FString RubyText;                                                                 // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSBWorldUIDataTable : public FTableRowBase
{
    ESBWorldUIType WorldUIType;                                                       // 0x0008 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0009 (size: 0x7)
    TArray<ESBUIType> DisableUIType;                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSBZoneData : public FTableRowBase
{
    FName ID;                                                                         // 0x0008 (size: 0x8)
    int32 NameTextId;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSDigitalSignageData : public FTableRowBase
{
    TSoftObjectPtr<UTexture> Texture;                                                 // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FSSBActiveOutGameBuffData
{
    EOutGameBuffType BuffType;                                                        // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    float BuffValue;                                                                  // 0x0004 (size: 0x4)
    EOutGameBuffSourceType SourceType;                                                // 0x0008 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0009 (size: 0x3)
    int32 SourceId;                                                                   // 0x000C (size: 0x4)
    FString SourceUniqueId;                                                           // 0x0010 (size: 0x10)
    FDateTime LimitTime;                                                              // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FSendAdventureCardResult
{
    bool bIsFriendMax;                                                                // 0x0000 (size: 0x1)
    bool bCannotSend;                                                                 // 0x0001 (size: 0x1)
    bool bTargetFriendMax;                                                            // 0x0002 (size: 0x1)
    bool bMyFriendMax;                                                                // 0x0003 (size: 0x1)
    bool bCharacterExist;                                                             // 0x0004 (size: 0x1)
    bool bIsBlock;                                                                    // 0x0005 (size: 0x1)
    bool bIsAlreadySend;                                                              // 0x0006 (size: 0x1)
    bool bIsPSOnlyDiff;                                                               // 0x0007 (size: 0x1)

}; // Size: 0x8

struct FSendableLikePlayer
{
    FString CharacterId;                                                              // 0x0000 (size: 0x10)
    FString UserId;                                                                   // 0x0010 (size: 0x10)
    bool IsSendable;                                                                  // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FShapeEffectParameter
{
    ESBShapeSoundType ShapeSoundType;                                                 // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    FCircleEffectParameter CircleEffectParam;                                         // 0x0004 (size: 0x10)

}; // Size: 0x14

struct FShopItemInfo
{
    int32 ID;                                                                         // 0x0000 (size: 0x4)
    EItemType ItemType;                                                               // 0x0004 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0005 (size: 0x3)
    int32 ItemIndex;                                                                  // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FShopItemMasterData
{
    FName TableName;                                                                  // 0x0000 (size: 0x8)
    TArray<FShopItemInfo> ItemInfoList;                                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FShopPurchaseItemInfo
{
    EItemType ItemType;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ItemIndex;                                                                  // 0x0004 (size: 0x4)
    int32 ItemAmount;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FShortcutInfo
{
    TArray<FShortcutItemInfo> ItemInfos;                                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FShortcutItemInfo
{
    EShortcutType Type;                                                               // 0x0000 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0001 (size: 0x3)
    int32 ItemIndex;                                                                  // 0x0004 (size: 0x4)
    FString ImagineUniqueId;                                                          // 0x0008 (size: 0x10)
    FString EmotionCommand;                                                           // 0x0018 (size: 0x10)
    FString StampUniqueId;                                                            // 0x0028 (size: 0x10)
    int32 FixedPhraseIndex;                                                           // 0x0038 (size: 0x4)
    int32 CommandIndex;                                                               // 0x003C (size: 0x4)
    FString WarpId;                                                                   // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FSkinColorByRegion
{
    int32 Hue;                                                                        // 0x0000 (size: 0x4)
    int32 MinValue;                                                                   // 0x0004 (size: 0x4)
    int32 MaxValue;                                                                   // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSmasherModifyMaxHPBoostCartridge
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    float ModifyPercentMaxHP;                                                         // 0x0004 (size: 0x4)
    float ModifyAddMaxBoostCartridge;                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSmasherShockWaveProjectileHandleSetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle ShockWaveProjectileHandle;                                    // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSmasherStatusAlimentSkillSetting
{
    int32 SkillLevel;                                                                 // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FDataTableRowHandle StatusAliment;                                                // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FTacticalSkillInfo
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    bool enable;                                                                      // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FTargetingInfo
{
    FTargetingRangeInfos TargetingRangeInfo;                                          // 0x0000 (size: 0x28)
    bool IsEnableAutoTarget;                                                          // 0x0028 (size: 0x1)
    bool IsEnableAutoTargetCursor;                                                    // 0x0029 (size: 0x1)
    bool IsEnableLockOn;                                                              // 0x002A (size: 0x1)
    char padding_0[0x1];                                                              // 0x002B (size: 0x1)
    float LockOnTargetChangeInputThreshold;                                           // 0x002C (size: 0x4)
    float LockOnBlockMaxDeltaTime;                                                    // 0x0030 (size: 0x4)
    bool IsLockOnInScreenCheck;                                                       // 0x0034 (size: 0x1)

}; // Size: 0x38

struct FTargetingRangeInfo
{
    float Length;                                                                     // 0x0000 (size: 0x4)
    float Angle;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FTargetingRangeInfos : public FTableRowBase
{
    TArray<FTargetingRangeInfo> Landing;                                              // 0x0008 (size: 0x10)
    TArray<FTargetingRangeInfo> Flying;                                               // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FTerrainErrorPt : public FTableRowBase
{
    float Idx;                                                                        // 0x0008 (size: 0x4)
    int32 Part;                                                                       // 0x000C (size: 0x4)
    float X;                                                                          // 0x0010 (size: 0x4)
    float Y;                                                                          // 0x0014 (size: 0x4)
    float Z;                                                                          // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FTowerChallengeAchieve
{
    ETowerChallengeAchieveType Type;                                                  // 0x0000 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0001 (size: 0x7)
    FString KillEnemyId;                                                              // 0x0008 (size: 0x10)
    int32 KillEnemyAmount;                                                            // 0x0018 (size: 0x4)
    int32 DestructObjectAmount;                                                       // 0x001C (size: 0x4)
    FString DestructObjectTag;                                                        // 0x0020 (size: 0x10)
    int32 CorrectItemID;                                                              // 0x0030 (size: 0x4)
    int32 CorrectItemAmount;                                                          // 0x0034 (size: 0x4)
    int32 FreeCounter;                                                                // 0x0038 (size: 0x4)
    char padding_1[0x4];                                                              // 0x003C (size: 0x4)
    FText FreeText;                                                                   // 0x0040 (size: 0x18)

}; // Size: 0x58

struct FTowerChallengeInfo
{
    TArray<FTowerChallengeAchieve> Achieves;                                          // 0x0000 (size: 0x10)
    float TimeLimit;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FTowerChallengeProgressInfo
{
    int32 RestEnemyCount;                                                             // 0x0000 (size: 0x4)
    int32 KillEnemyAmount;                                                            // 0x0004 (size: 0x4)
    int32 DestructObjectAmount;                                                       // 0x0008 (size: 0x4)
    int32 CorrectItemAmount;                                                          // 0x000C (size: 0x4)
    int32 FreeCounter;                                                                // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FUnlockedQuestInfo
{
    int32 QuestIndex;                                                                 // 0x0000 (size: 0x4)
    bool bAcceptable;                                                                 // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FUpdateCardData
{
    FString PlayerId;                                                                 // 0x0000 (size: 0x10)
    FString CharacterId;                                                              // 0x0010 (size: 0x10)
    ESBTensionTagType TensionTag;                                                     // 0x0020 (size: 0x1)
    bool bUpdateTensionTag;                                                           // 0x0021 (size: 0x1)
    bool SendCardFormParty;                                                           // 0x0022 (size: 0x1)
    bool bUpdateSendCardFormParty;                                                    // 0x0023 (size: 0x1)
    bool SendCardReceiveCard;                                                         // 0x0024 (size: 0x1)
    bool bUpdateSendCardReceiveCard;                                                  // 0x0025 (size: 0x1)
    bool NoOverride;                                                                  // 0x0026 (size: 0x1)
    bool bUpdateNoOverride;                                                           // 0x0027 (size: 0x1)
    FString ShortComment;                                                             // 0x0028 (size: 0x10)
    bool bUpdateShortComment;                                                         // 0x0038 (size: 0x1)
    bool bUpdateBackGroundColor;                                                      // 0x0039 (size: 0x1)
    char padding_0[0x2];                                                              // 0x003A (size: 0x2)
    int32 BackGroundColorId;                                                          // 0x003C (size: 0x4)
    bool bUpdateAdventureCardFrame;                                                   // 0x0040 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0041 (size: 0x3)
    int32 AdventureCardFrameId;                                                       // 0x0044 (size: 0x4)
    bool bUpdateFaceFrame;                                                            // 0x0048 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0049 (size: 0x3)
    int32 FaceFrameId;                                                                // 0x004C (size: 0x4)
    bool bUpdateIsHidden;                                                             // 0x0050 (size: 0x1)
    bool bIsHidden;                                                                   // 0x0051 (size: 0x1)

}; // Size: 0x58

struct FValidHitOverlapActorInfo
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

struct FVector_NetRoughDirection : public FVector
{
    char padding_0[0xC];                                                              // 0x0000 (size: 0x0)
}; // Size: 0xC

struct FWarpCostData : public FTableRowBase
{
    TArray<FWarpCostDestData> DestData;                                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FWarpCostDestData
{
    FName DestMapName;                                                                // 0x0000 (size: 0x8)
    int32 Cost;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FWarpPointMasterData : public FTableRowBase
{
    FName ID;                                                                         // 0x0008 (size: 0x8)
    FString MapName;                                                                  // 0x0010 (size: 0x10)
    FString Portal;                                                                   // 0x0020 (size: 0x10)
    FVector2D LocationXY;                                                             // 0x0030 (size: 0x8)
    bool isLocal;                                                                     // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FWatermarkSetting
{
    int32 BorderWidth;                                                                // 0x0000 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0004 (size: 0x4)
    FString ImagePath;                                                                // 0x0008 (size: 0x10)

}; // Size: 0x18

class ASBAIControllerBase : public AAIController
{
    class USBAILookAtControlComponent* LookAtControlComponent;                        // 0x0330 (size: 0x8)

}; // Size: 0x338

class ASBAIControllerBot : public AAIController
{
    class UAIFwBlackboardComponent* AIFwBlackboardComponent;                          // 0x0330 (size: 0x8)
    class UAIFwPerceptionComponent* AIFwPerceptionComponent;                          // 0x0338 (size: 0x8)
    float DistanceToAllowDash;                                                        // 0x0340 (size: 0x4)
    float DistanceToStartBraking;                                                     // 0x0344 (size: 0x4)
    float DistanceToWalk;                                                             // 0x0348 (size: 0x4)
    char padding_0[0x4];                                                              // 0x034C (size: 0x4)
    class APawn* MasterPawn;                                                          // 0x0350 (size: 0x8)

}; // Size: 0x358

class ASBAIController_Enemy : public ASBAIControllerBase
{
    class UAIFwBlackboardComponent* AIFwBlackboardComponent;                          // 0x0338 (size: 0x8)
    class USBAIPerceptionComponent* SBAIPerceptionComponent;                          // 0x0340 (size: 0x8)
    class UAIFwHTNPlanningComponent* HTNPlanningComponent;                            // 0x0348 (size: 0x8)
    class USBUtilityBrainComponent* UtilityBrainComponent;                            // 0x0350 (size: 0x8)
    class USBAITacticalComponent* TacticalComponent;                                  // 0x0358 (size: 0x8)
    class UAIFwReactiveComponent* ReactiveComponent;                                  // 0x0360 (size: 0x8)
    class USBEnemyEmotionComponent* EmotionComponent;                                 // 0x0368 (size: 0x8)
    class USBSquadMemberComponent* SquadMemberComponent;                              // 0x0370 (size: 0x8)
    class USBAIRoleComponent* RoleComponent;                                          // 0x0378 (size: 0x8)
    class USBAIComboComponent* ComboComponent;                                        // 0x0380 (size: 0x8)
    class USBAICustomComponent* AICustomComponent;                                    // 0x0388 (size: 0x8)
    class USBHateManagementComponent* HateManagementComponent;                        // 0x0390 (size: 0x8)
    class USBAIAttackHitComponent* AttackHitComponent;                                // 0x0398 (size: 0x8)
    FAIFwParameterizedBTRequest TargetingQuery;                                       // 0x03A0 (size: 0x18)
    FSBAIController_EnemyOnSensedActorDelegate OnSensedActorDelegate;                 // 0x03B8 (size: 0x10)
    void SBSensedActorDelegate(class AActor* Actor);
    FSBAIController_EnemyOnLostActorDelegate OnLostActorDelegate;                     // 0x03C8 (size: 0x10)
    void SBSensedActorDelegate(class AActor* Actor);
    class USBAISkillAssets_TacticalSkill* TacticalSkillAssetTable;                    // 0x03D8 (size: 0x8)
    class USBAISkillAssets_ReactiveSkill* ReactiveSkillAssetTable;                    // 0x03E0 (size: 0x8)
    TArray<class UDataTable*> TacticalSkillTables;                                    // 0x03E8 (size: 0x10)
    TArray<class UDataTable*> ReactiveSkillTables;                                    // 0x03F8 (size: 0x10)
    TArray<class UDataTable*> ComboTables;                                            // 0x0408 (size: 0x10)
    TSubclassOf<class UNavigationQueryFilter> GroundNavigationFilterClass;            // 0x0418 (size: 0x8)
    TSubclassOf<class UNavigationQueryFilter> TidalAreaNavigationFilterClass;         // 0x0420 (size: 0x8)
    char padding_0[0xF0];                                                             // 0x0428 (size: 0xF0)
    float EncounterSignalRange;                                                       // 0x0518 (size: 0x4)
    float EncounterSignalRange_Dungeon;                                               // 0x051C (size: 0x4)
    float NormalFlyingHeight;                                                         // 0x0520 (size: 0x4)
    float NormalFlyingHeightTolerance;                                                // 0x0524 (size: 0x4)
    float BattleFlyingHeight;                                                         // 0x0528 (size: 0x4)
    float BattleFlyingHeightTolerance;                                                // 0x052C (size: 0x4)
    char padding_1[0x10];                                                             // 0x0530 (size: 0x10)
    class AActor* TargetActorCache;                                                   // 0x0540 (size: 0x8)
    class AActor* FixedTarget;                                                        // 0x0548 (size: 0x8)
    class ASBCharacter* OrderSource;                                                  // 0x0550 (size: 0x8)
    class AActor* OrderedTarget;                                                      // 0x0558 (size: 0x8)
    char padding_2[0x8];                                                              // 0x0560 (size: 0x8)
    class ASBAIFlyingMoveDestination* FlyingMoveDest;                                 // 0x0568 (size: 0x8)
    float BuddyFollowingSpringStiffness;                                              // 0x0570 (size: 0x4)
    float BuddyFollowingDampingConstant;                                              // 0x0574 (size: 0x4)
    class ASBAIFollowTargetActor* BuddyFollowingActor;                                // 0x0578 (size: 0x8)
    class APawn* MasterPawnCache;                                                     // 0x0580 (size: 0x8)
    char padding_3[0x158];                                                            // 0x0588 (size: 0x158)
    class UDataTable* ActionLotteryTable;                                             // 0x06E0 (size: 0x8)
    float ActionLotteryStallDuration;                                                 // 0x06E8 (size: 0x4)
    float MoveToAttackTimeout;                                                        // 0x06EC (size: 0x4)
    class USBAIEnemyActionOrderList* ActionOrderList;                                 // 0x06F0 (size: 0x8)

    void TakeStimulation();
    bool SetTidalAreaNaigationFilterClass();
    bool SetGroundNaigationFilterClass();
    void SetDefaultTerritoryRange(float Range);
    void SetActionArea(ESBAIActionAreaType AreaType, const FVector& Origin, float Radius);
    void OnCharacterDeadForActionLotteryModifier(class AActor* Actor);
    void OnCharacterDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    bool IsInCurrentActionArea(const FVector& Location);
    class AActor* GetTargetActor();
    float GetDefaultTerritoryRange();
    void DisableActionArea(ESBAIActionAreaType AreaType);
    ESBAICanAttackResult CanAttackTargetSimple(bool bAllowTurn, bool bAllowMove);
}; // Size: 0x720

class ASBAIController_Imagine : public ASBAIControllerBase
{
    class UAIFwBlackboardComponent* AIFwBlackboardComponent;                          // 0x0338 (size: 0x8)

}; // Size: 0x340

class ASBAIController_Npc : public ASBAIControllerBase
{
    class USBUtilityBrainComponent* UtilityBrainComponent;                            // 0x0338 (size: 0x8)
    class UAIFwBlackboardComponent* AIFwBlackboardComponent;                          // 0x0340 (size: 0x8)

    bool RemoveTalkOption();
    void AddTalkOption(class USBUtilityOption* InOption);
}; // Size: 0x350

class ASBAIDirector : public AAIFwAIDirector
{
    class USBAIWorldProfilerComponent* WorldProfilerComponent;                        // 0x0238 (size: 0x8)
    TSubclassOf<class ASBRootCoordinator> RootCoordinatorClass;                       // 0x0240 (size: 0x8)
    class ASBRootCoordinator* RootCoordinator;                                        // 0x0248 (size: 0x8)
    TSubclassOf<class ASBEnemySpawner> EnemySpawnerClass;                             // 0x0250 (size: 0x8)
    class ASBEnemySpawner* EnemySpawner;                                              // 0x0258 (size: 0x8)
    TSubclassOf<class ASBNpcSpawner> NpcSpawnerClass;                                 // 0x0260 (size: 0x8)
    class ASBNpcSpawner* NpcSpawner;                                                  // 0x0268 (size: 0x8)
    FSBAIDirectorOnActorDeadDelegete OnActorDeadDelegete;                             // 0x0270 (size: 0x10)
    void OnActorDeadDelegete(class AActor* Actor);

    void RunSpawnTreeWithEncounterVolume(class UObject* WorldContextObject, class ASBEncounterVolume* EncounterVolume);
    void OnActorDeadDelegete__DelegateSignature(class AActor* Actor);
    void OnActorDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Actor);
}; // Size: 0x280

class ASBAIFlyingMoveDestination : public ANavigationObjectBase
{
    char padding_0[0x250];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x250

class ASBAIFollowTargetActor : public ANavigationObjectBase
{
    class AActor* BaseActor;                                                          // 0x0250 (size: 0x8)

}; // Size: 0x298

class ASBAIGroup : public AActor
{
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0228 (size: 0x8)
    class UAIFwHierarchyComponent* HierarchyComponent;                                // 0x0230 (size: 0x8)
    class AController* Leader;                                                        // 0x0238 (size: 0x8)

}; // Size: 0x240

class ASBAIPlayerMonitor : public AActor
{
    class USBSquadMemberComponent* SquadMemberComponent;                              // 0x0228 (size: 0x8)
    class ASBPlayerCharacter* PlayerCharacter;                                        // 0x0230 (size: 0x8)

    void OnPlayerDestroyed(class AActor* Actor);
}; // Size: 0x238

class ASBActorManagerActor : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x228

class ASBAilmentRespawnPoint : public ANavigationObjectBase
{
    FName PlayerStartTag;                                                             // 0x0250 (size: 0x8)

}; // Size: 0x258

class ASBAimCamera : public ACameraActor
{
    char padding_0[0xA20];                                                            // 0x0000 (size: 0x0)
}; // Size: 0xA20

class ASBAkEventTriggerAreaBox : public ATriggerBox
{
    FSBAkEventTriggerAreaData TriggerAreaData;                                        // 0x0230 (size: 0x38)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x268

class ASBAkEventTriggerAreaSphere : public ATriggerSphere
{
    FSBAkEventTriggerAreaData TriggerAreaData;                                        // 0x0230 (size: 0x38)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x268

class ASBAkEventTriggerAreaVolume : public ATriggerVolume
{
    FSBAkEventTriggerAreaData TriggerAreaData;                                        // 0x0260 (size: 0x38)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x298

class ASBAkEventTriggerBox : public ATriggerBox
{
    bool IsActive;                                                                    // 0x0230 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0231 (size: 0x7)
    FString CategoryName;                                                             // 0x0238 (size: 0x10)
    class UAkAudioEvent* BeginOverlapAkEvent;                                         // 0x0248 (size: 0x8)
    class UAkAudioEvent* EndOverlapAkEvent;                                           // 0x0250 (size: 0x8)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x258

class ASBAkEventTriggerSphere : public ATriggerSphere
{
    bool IsActive;                                                                    // 0x0230 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0231 (size: 0x7)
    FString CategoryName;                                                             // 0x0238 (size: 0x10)
    class UAkAudioEvent* BeginOverlapAkEvent;                                         // 0x0248 (size: 0x8)
    class UAkAudioEvent* EndOverlapAkEvent;                                           // 0x0250 (size: 0x8)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x258

class ASBAkEventTriggerVolume : public ATriggerVolume
{
    bool IsActive;                                                                    // 0x0260 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0261 (size: 0x7)
    FString CategoryName;                                                             // 0x0268 (size: 0x10)
    class UAkAudioEvent* BeginOverlapAkEvent;                                         // 0x0278 (size: 0x8)
    class UAkAudioEvent* EndOverlapAkEvent;                                           // 0x0280 (size: 0x8)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x288

class ASBAnimalCharacter : public ASBMobCharacter
{
    TArray<FAnimalWaitParamInfo> AnimalWaitParamTable;                                // 0x0728 (size: 0x10)
    class USBCameraTransparentBoxComponent* CameraTransparentComponent;               // 0x0738 (size: 0x8)

}; // Size: 0x740

class ASBAnimationSamplingLevelScriptActor : public ALevelScriptActor
{
    TArray<class TSubclassOf<UActorComponent>> DestroyComponentClasses;               // 0x0230 (size: 0x10)

}; // Size: 0x240

class ASBAreaSoundVolume : public ATriggerVolume
{
    FString Category;                                                                 // 0x0260 (size: 0x10)
    TSoftObjectPtr<AActor> LocationSourceSoftPtr;                                     // 0x0270 (size: 0x28)
    class UAkAudioEvent* AudioEvent;                                                  // 0x0298 (size: 0x8)
    class UAkAudioEvent* BeginOverlapEvent;                                           // 0x02A0 (size: 0x8)
    class UAkAudioEvent* EndOverlapEvent;                                             // 0x02A8 (size: 0x8)
    class UAkComponent* AkComponent;                                                  // 0x02B0 (size: 0x8)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x2B8

class ASBArenaEnemyWaveCounter : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x228

class ASBAttachableObject : public AASCharacter
{
    FName AttachSocketName;                                                           // 0x0580 (size: 0x8)
    char padding_0[0x18];                                                             // 0x0588 (size: 0x18)
    FDataTableRowHandle ThrowProjectileHandle;                                        // 0x05A0 (size: 0x10)
    class ASBPlayerCharacter* HaveObjectPlayer;                                       // 0x05B0 (size: 0x8)
    FSBAttachableObjectOnSetHaveObjectPlayerDelegate OnSetHaveObjectPlayerDelegate;   // 0x05B8 (size: 0x10)
    void OnSetHaveObjectPlayer();

    void SetServerPlayerSocketLocationAndRotation(FVector InLocation, FRotator InRotation);
    void OnSetHaveObjectPlayer__DelegateSignature();
    void OnRequestDestroyObject(bool bIsImmediate);
    void OnRep_HaveObjectPlayer();
    void OnReleaseObject(bool IsObjectDestroy);
    void GetServerPlayerSocketLocationAndRotation(FVector& OutLocation, FRotator& OutRotation);
}; // Size: 0x5D0

class ASBAutoCreatedNavLinkProxy : public ASBSegmentNavLinkProxy
{
    bool Blocked;                                                                     // 0x0270 (size: 0x1)

}; // Size: 0x278

class ASBAutoCreatedSwitchableNavModifierVolume : public ASBSwitchableNavModifierVolume
{
    TWeakObjectPtr<class AActor> CreaterActor;                                        // 0x02C0 (size: 0x8)

}; // Size: 0x2D0

class ASBAutoCreatedWallNavLinkProxy : public ASBAutoCreatedNavLinkProxy
{
    FName ClimbingWallActorName;                                                      // 0x0278 (size: 0x8)

}; // Size: 0x288

class ASBAutoLinkNullAreaVolume : public AVolume
{
    char padding_0[0x260];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x260

class ASBAutoPlayAgent : public AActor
{
    class APlayerController* PlayerController;                                        // 0x0228 (size: 0x8)

}; // Size: 0x240

class ASBAutoPlayInteractionAgent : public ASBAutoPlayAgent
{
    class UPathFollowingComponent* PathFollowingComp;                                 // 0x0240 (size: 0x8)

}; // Size: 0x258

class ASBAutoPlayMoveAgent : public ASBAutoPlayAgent
{
    class UPathFollowingComponent* PathFollowingComp;                                 // 0x0240 (size: 0x8)

}; // Size: 0x258

class ASBBGMAreaCoverTriggerBox : public ATriggerBox
{
    FSBBGMTriggerData BGMTriggerData;                                                 // 0x0230 (size: 0x30)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x260

class ASBBGMAreaCoverTriggerSphere : public ATriggerSphere
{
    FSBBGMTriggerData BGMTriggerData;                                                 // 0x0230 (size: 0x30)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x260

class ASBBGMAreaCoverTriggerVolume : public ATriggerVolume
{
    FSBBGMTriggerData BGMTriggerData;                                                 // 0x0260 (size: 0x30)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x290

class ASBBGMAreaPassTriggerBox : public ATriggerBox
{
    FSBBGMTriggerData BGMTriggerData;                                                 // 0x0230 (size: 0x30)

    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x260

class ASBBGMAreaPassTriggerSphere : public ATriggerSphere
{
    FSBBGMTriggerData BGMTriggerData;                                                 // 0x0230 (size: 0x30)

    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x260

class ASBBGMAreaPassTriggerVolume : public ATriggerVolume
{
    FSBBGMTriggerData BGMTriggerData;                                                 // 0x0260 (size: 0x30)

    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x290

class ASBBGMSwitchBossManager : public AActor
{
    char padding_0[0x430];                                                            // 0x0000 (size: 0x0)

    void OnBossDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void Multicast_RequestBGM(int32 BGMAssetIndex, bool IsBossEnd);
}; // Size: 0x430

class ASBBattleArea : public AActor
{
    class UCapsuleComponent* CapsuleRoot;                                             // 0x0228 (size: 0x8)
    class UStaticMeshComponent* StaticMesh;                                           // 0x0230 (size: 0x8)
    bool bIsValidBGMGameModeList;                                                     // 0x0238 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0239 (size: 0x7)
    TArray<ESBBGMMapGameMode> BGMGameModeList;                                        // 0x0240 (size: 0x10)
    ESBBattleBGMType BattleBGMType;                                                   // 0x0250 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0251 (size: 0x7)
    class UAkAudioEvent* BattleBGMEvent;                                              // 0x0258 (size: 0x8)
    TArray<FSBBGMBattleAreaContentIdData> BGMContentIdDataList;                       // 0x0260 (size: 0x10)
    bool bAvailableWall;                                                              // 0x0270 (size: 0x1)
    bool bAvailableArea;                                                              // 0x0271 (size: 0x1)
    char padding_2[0x6];                                                              // 0x0272 (size: 0x6)
    TArray<class ASBPlayerCharacter*> PlayerList;                                     // 0x0278 (size: 0x10)
    TSubclassOf<class UNavArea> NavModifierArea;                                      // 0x0288 (size: 0x8)

    void PlayerCountDown(class ASBPlayerCharacter* PlayerCharacter, float Time);
    bool NotifyPlayerLeave(class ASBPlayerCharacter* Player);
    void NotifyBattleAreaStart();
    void NotifyBattleAreaClear();
    void InitAfterSublevelLoaded();
    int32 GetPlayerNumInArea();
    int32 GetAlivePlayerNumInArea();
    void ChangeNavModifierArea(TSubclassOf<class UNavArea> InNavModifierArea);
}; // Size: 0x290

class ASBBattleHUD : public AHUD
{
    class USBStatusAlimentNotifyWidgetOwner* StatusAlimentNotifyWidgetOwner;          // 0x0328 (size: 0x8)

    void ShowSimpleAlertByID(const FName& TextId);
    void OnMasterDataAvailable();
    void OnMapLevelInfo();
    void OnGameSettingAfter();
    class USBTimerRespawnHUD* GetTimerRespawnHUD();
    class USBTextWindowBase* GetTextWindowSkit();
    class USBTextWindowBase* GetTextWindowDemo();
    class USBTextWindow* GetTextWindow();
    class USBTelopManager* GetTelopManager();
    class UUserWidget* GetNotifyMessage();
    class USBLayoutableHUD* GetLayoutableHUD();
    class UUserWidget* GetChatHUD();
    class USBBattleContentsHUD* GetBattleContentsHUD();
}; // Size: 0x330

class ASBBattleNpcAssetHolder : public AActor
{
    char padding_0[0x240];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x240

class ASBBhtSignalManager : public AActor
{
    ESBBhtState BhtSignalState;                                                       // 0x0228 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0229 (size: 0x7)
    FSBBhtSignalManagerOnRepBhtSignalStateDelegate OnRepBhtSignalStateDelegate;       // 0x0230 (size: 0x10)
    void OnRepBhtSignalStateDelegate();
    FName ProfileDataId;                                                              // 0x0240 (size: 0x8)
    float CoolDownTimeMin;                                                            // 0x0248 (size: 0x4)

    void SetCoolDownTime(float Time);
    void SetChallengeQuestStatus(bool bWorking, float CoolTime);
    void SetBhtSignalState(ESBBhtState NewState);
    void ResetBhtSignalStatus();
    void OnRepBhtSignalStateDelegate__DelegateSignature();
    void OnRep_BhtSignalState();
    ESBBhtState GetBhtSignalState();
    void DmpBhtSignalStatus();
    void BP_OnRep_BhtSignalState();
}; // Size: 0x250

class ASBCaptureStudioBaseActor : public AASCharacterBase
{
    TArray<class UObject*> LoadedAssets;                                              // 0x0508 (size: 0x10)

    bool RequestLoadAsset_Imagine(const FSBCaptureStudioImagineData& InData);
    bool RequestLoadAsset(const TArray<FSoftObjectPath>& InAssets);
    void OnAssetLoadedInternal();
    void OnAssetLoaded(const bool bInResult);
}; // Size: 0x520

class ASBCaptureStudioCreationCharacter : public ASBCaptureStudioBaseActor
{
    class USBCharaCreateComponent* CharaCreateComponent;                              // 0x0520 (size: 0x8)
    class USBCharaPartsFaceComponent* FaceComp;                                       // 0x0528 (size: 0x8)

    bool SetCharaCreateData(class USBCharaCreateData* InCharaCreateData);
    void OnCreateLoaded(const bool bInResult);
    bool IsValidCharaCreateData();
    bool InitCharaCreateComponent();
    bool ApplyCharaCreateComponent();
}; // Size: 0x530

class ASBCarry : public AASCharacter
{
    bool IsCarryUp;                                                                   // 0x0598 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0599 (size: 0x7)
    class ASBPlayerCharacter* CarryingPlayer;                                         // 0x05A0 (size: 0x8)
    FSBCarryOnSetCarryingPlayerDelegate OnSetCarryingPlayerDelegate;                  // 0x05A8 (size: 0x10)
    void OnSetCarryingPlayer();

    void UpdateServerTmpLocationAndRotation(FVector InLocation, FRotator InRotation);
    void SetIsCarryUp(bool sw);
    void ServerUpdateCarryObjectLocationAndRotation(FVector InVector, FRotator InRotation);
    void RequestUpdateCarryObjectLocationAndRotation(FVector InVector, FRotator InRotation);
    void OnSetCarryingPlayer__DelegateSignature();
    void OnRep_CarryingPlayer();
    void GetServerTmpLocationAndRotation(FVector& OutLocation, FRotator& OutRotation);
    void ClientUpdateCarryObjectLocationAndRotation(FVector InVector, FRotator InRotation);
}; // Size: 0x5C0

class ASBCharaCreateCharacter : public ASBCreationCharacter
{
    float Height;                                                                     // 0x1408 (size: 0x4)
    FName WeaponAttachPointCustom;                                                    // 0x140C (size: 0x40)
    char padding_0[0x24];                                                             // 0x144C (size: 0x24)
    bool IsViewerMode;                                                                // 0x1470 (size: 0x1)
    bool SetMannequinParts;                                                           // 0x1471 (size: 0x1)
    bool IsUseCharaSelect;                                                            // 0x1472 (size: 0x1)

    void ShowWeapon_Debug(bool bShow);
    void SetWeaponAttachSocketCustom(TEnumAsByte<ESBWeaponAttach> WeaponAttach, FName SocketName);
    void SetSliderValue(int32 Index, float Value);
    void SetCostumeSetName(FName CostumeSetName);
    void ImportCharacter();
    FName GetWeaponAttachSocketCustom(TEnumAsByte<ESBWeaponAttach> WeaponAttach);
    float GetSliderValue(int32 Index);
    FName GetSliderName(int32 Index);
    float GetHeight();
    TArray<class USBCharaPartsComponent*> GetExtraCharaPartsComponentList();
    void ExportCharacter();
    void ChangeBoneDisplay();
}; // Size: 0x1480

class ASBCharaCreateHUD : public AHUD
{
    char padding_0[0x318];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x318

class ASBCharacter : public AASCharacter
{
    FSBCharacterOnReplicatedPlayerState OnReplicatedPlayerState;                      // 0x06B0 (size: 0x10)
    void OnReplicatedPlayerState();
    char padding_0[0x50];                                                             // 0x06C0 (size: 0x50)
    TArray<class UObject*> LoadedAssets;                                              // 0x0710 (size: 0x10)
    TArray<class UObject*> m_HoldingAssets;                                           // 0x0720 (size: 0x10)
    char padding_1[0x8];                                                              // 0x0730 (size: 0x8)
    class ASBBattleArea* CurrentBattleArea;                                           // 0x0738 (size: 0x8)
    char padding_2[0x8];                                                              // 0x0740 (size: 0x8)
    FString CharacterName;                                                            // 0x0748 (size: 0x10)
    float CurrentHitPoint;                                                            // 0x0758 (size: 0x4)
    float Weight;                                                                     // 0x075C (size: 0x4)
    char padding_3[0x8];                                                              // 0x0760 (size: 0x8)
    float ImpulsePow;                                                                 // 0x0768 (size: 0x4)
    float Stamina;                                                                    // 0x076C (size: 0x4)
    char padding_4[0x30];                                                             // 0x0770 (size: 0x30)
    TArray<FSBCollisionGroupInfo> CollisionGroupInfo;                                 // 0x07A0 (size: 0x10)
    TArray<FSBCollisionGroupHitPointInfo> CollisionGroupHitPointInfo;                 // 0x07B0 (size: 0x10)
    char padding_5[0x4];                                                              // 0x07C0 (size: 0x4)
    float ResistAbsorbValue;                                                          // 0x07C4 (size: 0x4)
    class USBPartsDamageAnimParamter* PartsDamageAnimParamter;                        // 0x07C8 (size: 0x8)
    char padding_6[0x48];                                                             // 0x07D0 (size: 0x48)
    FDataTableRowHandle m_DamageReactionPattern;                                      // 0x0818 (size: 0x10)
    TArray<FSBElementResistanceSetting> m_ElementResistanceList;                      // 0x0828 (size: 0x10)
    float ElementStatusEffectSpawnNumScale;                                           // 0x0838 (size: 0x4)
    float ElementStatusEffectSizeScale;                                               // 0x083C (size: 0x4)
    char padding_7[0x50];                                                             // 0x0840 (size: 0x50)
    FSBElementDamageCondition m_ElementDamageEarth;                                   // 0x0890 (size: 0x50)
    FSBElementDamageCondition m_ElementDamageFire;                                    // 0x08E0 (size: 0x50)
    FSBElementDamageCondition m_ElementDamageIce;                                     // 0x0930 (size: 0x50)
    FSBElementDamageCondition m_ElementDamageThunder;                                 // 0x0980 (size: 0x50)
    FSBElementDamageCondition m_ElementDamageLight;                                   // 0x09D0 (size: 0x50)
    FSBElementDamageCondition m_ElementDamageDarkness;                                // 0x0A20 (size: 0x50)
    float FreezeAilmentMashingInput;                                                  // 0x0A70 (size: 0x4)
    float FreezeAilmentAttackMagnification;                                           // 0x0A74 (size: 0x4)
    char padding_8[0x10];                                                             // 0x0A78 (size: 0x10)
    float m_ElementDamageResetTimer;                                                  // 0x0A88 (size: 0x4)
    char padding_9[0x4];                                                              // 0x0A8C (size: 0x4)
    float CurrentElementalBurstBonusTimer;                                            // 0x0A90 (size: 0x4)
    int8 CurrentElementalBurstBonusLevel;                                             // 0x0A94 (size: 0x1)
    char padding_10[0x3];                                                             // 0x0A95 (size: 0x3)
    float CurrentElementalBurstBonusGaugeRate;                                        // 0x0A98 (size: 0x4)
    char padding_11[0xC];                                                             // 0x0A9C (size: 0xC)
    FSBCharacterOnStartElementalBurstDelegate OnStartElementalBurstDelegate;          // 0x0AA8 (size: 0x10)
    void OnStartElementalBurstDelegate(ESBAttribute ElementType);
    FSBCharacterOnEndElementalBurstDelegate OnEndElementalBurstDelegate;              // 0x0AB8 (size: 0x10)
    void OnEndElementalBurstDelegate(ESBAttribute ElementType);
    FSBCharacterOnInterruptElementalBurstDelegate OnInterruptElementalBurstDelegate;  // 0x0AC8 (size: 0x10)
    void OnInterruptElementalBurstDelegate(ESBAttribute ElementType);
    char padding_12[0x4];                                                             // 0x0AD8 (size: 0x4)
    float FlashTime;                                                                  // 0x0ADC (size: 0x4)
    char padding_13[0xC];                                                             // 0x0AE0 (size: 0xC)
    bool m_bPushOutDisabled;                                                          // 0x0AEC (size: 0x1)
    char padding_14[0x3];                                                             // 0x0AED (size: 0x3)
    TArray<class AActor*> PushOutIgnoreActors;                                        // 0x0AF0 (size: 0x10)
    char padding_15[0xC0];                                                            // 0x0B00 (size: 0xC0)
    FSBCharacterOnCharacterDeadDelegete OnCharacterDeadDelegete;                      // 0x0BC0 (size: 0x10)
    void OnCharacterDeadDelegete(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    FSBCharacterOnCharacterTakeDamage OnCharacterTakeDamage;                          // 0x0BD0 (size: 0x10)
    void OnCharacterTakeDamage(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    FSBCharacterOnCharacterTakeDamageWhenAttackHit OnCharacterTakeDamageWhenAttackHit; // 0x0BE0 (size: 0x10)
    void OnCharacterTakeDamageWhenAttackHit(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    char padding_16[0x40];                                                            // 0x0BF0 (size: 0x40)
    FSBDamageInfo LastDamageInfo;                                                     // 0x0C30 (size: 0x58)
    char padding_17[0x78];                                                            // 0x0C88 (size: 0x78)
    TEnumAsByte<ESBCounterDamageState::Type> CounterDamageState;                      // 0x0D00 (size: 0x1)
    char padding_18[0x3];                                                             // 0x0D01 (size: 0x3)
    FSBCounterDamageRate CounterDamageRate;                                           // 0x0D04 (size: 0x18)
    char padding_19[0x34];                                                            // 0x0D1C (size: 0x34)
    TArray<FSBInventoryWeapon> InventoryWeapons;                                      // 0x0D50 (size: 0x10)
    TArray<FSBSpawnWeaponLoadParam> CurrentSpawnWeapons;                              // 0x0D60 (size: 0x10)
    TArray<FSBEquipWeapon> EquipWeapons;                                              // 0x0D70 (size: 0x10)
    FName WeaponAttachPoint;                                                          // 0x0D80 (size: 0x40)
    char padding_20[0x58];                                                            // 0x0DC0 (size: 0x58)
    FSBPlayEffect LastPlayEffect;                                                     // 0x0E18 (size: 0x38)
    TArray<FSBSpecialHitEffect> m_SpecialHitEffectList;                               // 0x0E50 (size: 0x10)
    char padding_21[0x20];                                                            // 0x0E60 (size: 0x20)
    uint8 bIsApplyIdentificationFriendOrFoe;                                          // 0x0E80 (size: 0x1)
    char padding_22[0x5F];                                                            // 0x0E81 (size: 0x5F)
    class USBProjectileSpawnComponent* SpawnComp;                                     // 0x0EE0 (size: 0x8)
    class USBBattleStatusComponent* BattleStatusComp;                                 // 0x0EE8 (size: 0x8)
    class USBProjectileShareHitComponent* ProjectileShareHitComp;                     // 0x0EF0 (size: 0x8)
    class USBProjectileSendNetDataComponent* SendNetDataComp;                         // 0x0EF8 (size: 0x8)
    char padding_23[0x18];                                                            // 0x0F00 (size: 0x18)
    uint8 bIsGround;                                                                  // 0x0F18 (size: 0x1)
    char padding_24[0x7];                                                             // 0x0F19 (size: 0x7)
    TArray<FSBMoveSpeedSetting> m_MoveSpeedSetting;                                   // 0x0F20 (size: 0x10)
    char padding_25[0x8];                                                             // 0x0F30 (size: 0x8)
    class USBAnimationControlComponent* AnimationControlComp;                         // 0x0F38 (size: 0x8)
    char padding_26[0x8];                                                             // 0x0F40 (size: 0x8)
    class USBDemoParameterComponent* DemoParameterComp;                               // 0x0F48 (size: 0x8)
    class UAIFwFactionComponent* FactionComponent;                                    // 0x0F50 (size: 0x8)
    class USBFactionInfluenceSourceComponent* FactionInfluenceComponent;              // 0x0F58 (size: 0x8)
    class USBAISharedInfoComponent* AISharedInfoComponent;                            // 0x0F60 (size: 0x8)
    class USBMovementPredictComponent* MovePredictComponent;                          // 0x0F68 (size: 0x8)
    char padding_27[0x8];                                                             // 0x0F70 (size: 0x8)
    class USBActorVisibilityComponent* ActorVisibilityComponent;                      // 0x0F78 (size: 0x8)
    char padding_28[0x28];                                                            // 0x0F80 (size: 0x28)
    int32 VillageCollisionCount;                                                      // 0x0FA8 (size: 0x4)
    bool bForceMipStreaming;                                                          // 0x0FAC (size: 0x1)

    void VerifyEquipWeapon();
    void UnequipWeapon(int32 InventoryIndex);
    void StopWeaponAnimation(int32 InventoryIndex);
    void StopKnockBack();
    void StatusAlimentNotify();
    void SpawnInventoryWeapons(const TArray<FSBSpawnWeaponLoadParam>& NewSpawnWeapons, const TArray<FSBSpawnWeaponLoadParam>& LastSpawnWeapons);
    void SetPushOutDisabled(bool bDisabled);
    void SetKnockBack(FVector Vec, float Distance, float Time);
    void SetForceMipStreaming(bool bEnable);
    void SetEquipWeapon(TEnumAsByte<ESBWeaponAttach> WeaponAttach, int32 NewInventoryIndex, FVector Location, FRotator Rotation, FVector Scale3D);
    void ServerUpdateAttackManageNumberMap();
    void ServerTakeStatusAilment(const FSBStatusAilmentHandle& StatusHandle, class AActor* InstigatorActor, class AActor* StatusDst, class AActor* Spawner, FVector_NetQuantize SpawnerLocation, ESBAbilityRequestSource RequestType);
    void ServerTakeDeactiveStatusGroup(ESBBattleEffectiveGroup StatusGroup, const class AActor* StatusCauser);
    void ServerTakeDeactiveStatusAilment(const FSBStatusAilmentHandle& StatusHandle, class AActor* InstigatorActor, class AActor* Spawner, FVector_NetQuantize SpawnerLocation, bool bForceDelete);
    void ServerTakeDeactiveExceptStatusAliment(const TArray<FDataTableRowHandle>& StatusHandles, class AActor* InstigatorActor, class AActor* StatusDst, bool bPassive);
    void ServerTakeDeactiveBattleStatusID(FSBStatusAilmentID ID, class AActor* InstigatorActor, class AActor* StatusDst, class AActor* Spawner, FVector_NetQuantize SpawnerLocation, bool bForceDelete);
    void ServerTakeDamage(const FSBServerDamageEvent& DamageEventEncrypted, class AController* EventInstigator, class AActor* DamageCauser);
    void ServerSetVelocity(const FVector& Vector);
    void ServerSetSuperArmorAnimationParam(bool bSuperArmor, int32 DamageAdjust);
    void ServerSetPushOutDisabled(bool bDisabled);
    void ServerSetInvincibleMotion(bool bInvincible, TEnumAsByte<ESBInvincibleAnimation::Type> InvincibleAnimationType);
    void ServerResetElementDamageAll();
    void ServerPlayInvincibleAnimationEffect(TEnumAsByte<ESBInvincibleAnimation::Type> InvincibleAnimationType);
    void ServerNotifyTakeDeath();
    void ServerNotifyProjectileDestroy(FSBProjectileIdentifyHandle InIdentifyHandle);
    void ServerInitAnim();
    void ServerGiveStatusAilment(const FSBStatusAilmentHandle& StatusHandle, class AActor* StatusDst, class AActor* Spanwer, FVector_NetQuantize SpawnerLocation, ESBAbilityRequestSource RequestType);
    void ServerGiveDeactiveExceptStatusAliment(const TArray<FDataTableRowHandle>& StatusHandles, class AActor* StatusDst, bool bPassive);
    void ServerGiveDeactiveBattleStatusIDDelegate(class ASBCharacter* Sender, FSBStatusAilmentID ID, class AActor* StatusDst, class AActor* Spawner, FVector_NetQuantize SpawnerLocation, bool bForceDelete);
    void ServerGiveDeactiveBattleStatusID(FSBStatusAilmentID ID, class AActor* StatusDst, class AActor* Spawner, FVector_NetQuantize SpawnerLocation, bool bForceDelete);
    void ServerGiveDamageDelegateHit(const FSBDamageEvent& DamageEventEncrypted, class AActor* DamageSrc, class AActor* DamageDst, int64 UTCHitTime, uint64 Handle);
    void ServerGiveDamage(const FSBDamageEvent& DamageEventEncrypted, class AActor* DamageDst);
    void ServerGiveBattleStatusIDDelegate(class ASBCharacter* Sender, FSBStatusAilmentID ID, class AActor* StatusDst, class AActor* Spanwer, FVector_NetQuantize SpawnerLocation);
    void ServerGiveBattleStatusID(FSBStatusAilmentID ID, class AActor* StatusDst, class AActor* Spanwer, FVector_NetQuantize SpawnerLocation, ESBAbilityRequestSource RequestType);
    void ServerDecAilmentTimerMashingInput();
    void ServerChangeDamageReactionPattern(const FDataTableRowHandle& Handle);
    void Server_SpawnInventoryWeapons(const TArray<FSBSpawnWeaponLoadParam>& NewSpawnWeapons, const TArray<FSBSpawnWeaponLoadParam>& LastSpawnWeapons);
    void Server_SheatheWeapon();
    void Server_SetEquipWeaponByEquipTypes(const TArray<TEnumAsByte<ESBWeaponEquipType>>& EquipTypes);
    void Server_SetEquipWeapon(TEnumAsByte<ESBWeaponAttach> WeaponAttach, int32 NewInventoryIndex, FVector Location, FRotator Rotation, FVector Scale3D);
    void ResetHitAttackFlag();
    void ResetElementDamageAll();
    void RequestServerGiveStatusAlimentByDelay(FDataTableRowHandle StatusHandle, class AActor* StatusDst, class AActor* StatusSpawner, float Remain);
    void RequestServerGiveStatusAliment(FDataTableRowHandle StatusHandle, class AActor* StatusDst, class AActor* StatusSpawner);
    void RequestServerGiveDeactiveStatusAlimentByDelay(FDataTableRowHandle StatusHandle, class AActor* StatusDst, class AActor* StatusSpawner, bool bForceDelete);
    void RequestServerGiveDeactiveStatusAliment(FDataTableRowHandle StatusHandle, class AActor* StatusDst, class AActor* StatusSpawner, bool bForceDelete);
    void RequestServerGiveDeactiveExceptStatusAliment(TArray<FDataTableRowHandle> StatusHandles, class AActor* StatusDst, bool bPassive);
    void RequestLoadAsset();
    void RequestDisableRootMotion(FName RequestName);
    void Request_SheatheWeapon();
    void Request_SetEquipWeaponByEquipTypes(const TArray<TEnumAsByte<ESBWeaponEquipType>>& EquipTypes);
    void Request_SetEquipWeaponByEquipType(TEnumAsByte<ESBWeaponEquipType> EquipType);
    void Request_SetEquipWeapon(TEnumAsByte<ESBWeaponAttach> WeaponAttach, int32 NewInventoryIndex, const FVector& Location, const FRotator& Rotation, const FVector& Scale3D);
    void RegistStatusAlimentNotify(ESBStatusAilmentIconType StatusAliment, bool bImmune);
    void RegistSlashDisk(class USBAnimNotifyState_SlashDisk* NotifyState, class UParticleSystemComponent* Effect, FRotator EndRotation, FVector ScaleOffset, float SlashAngle, float SlashTime, FName SocketName, FVector WeaponDirection, bool bSpawnSlashDiskParticle, float SlashDiskParticleDistCycle, class UParticleSystem* SlashDiskParticle);
    void RegistHitSlomoEffect(class UParticleSystemComponent* Effect);
    void ReceiveEndInitialLoad();
    void ReceiveEndAssetLoad();
    void ReceiveBeginAssetLoad();
    void PrintStringWithFrameNumber(FString inString, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration);
    void PrintString(FString inString, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration);
    void PlayWeaponAnimation(int32 InventoryIndex, int32 AnimationIndex, bool bLooping, float PlayRate);
    void OnStopDemo();
    void OnStartElementalBurstDelegate__DelegateSignature(ESBAttribute ElementType);
    void OnReplicatedPlayerState__DelegateSignature();
    void OnRep_LastPlayEffect();
    void OnRep_EquipWeapons();
    void OnRep_CurrentSpawnWeapons(const TArray<FSBSpawnWeaponLoadParam> LastSpawnWeapons);
    void OnRep_CurrentHitPoint();
    void OnRep_CollisionGroupHitPointInfo();
    void OnPlayDemo();
    void OnInterruptElementalBurstDelegate__DelegateSignature(ESBAttribute ElementType);
    void OnEndElementalBurstDelegate__DelegateSignature(ESBAttribute ElementType);
    void OnClientSendImportantBattleEffective(const FSBEffectiveImpotantStatusParam& PrevParam, const FSBEffectiveImpotantStatusParam& NewParam);
    void OnClientSendEffectiveBattleStatusParam(const FSBEffectiveStatusParam& StatusParam, bool bUpdateBaseStatus);
    void OnCharacterTakeDamageWhenAttackHit__DelegateSignature(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void OnCharacterTakeDamage__DelegateSignature(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void OnCharacterServerTakeDamageBeforeCalcDamageAttacker__DelegateSignature(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself, bool bInvincible);
    void OnCharacterServerTakeDamageBeforeCalcDamage__DelegateSignature(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself, bool bInvincible);
    void OnCharacterServerGiveDamageWhenBack__DelegateSignature(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void OnCharacterServerGiveDamage__DelegateSignature(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void OnCharacterDeadDelegete__DelegateSignature(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void MulticastUpdateAttackManageNumberMap(const TArray<int32>& AttackIDList, const TArray<int32>& ManageNumberList);
    void MulticastTakeDamageWithGeneralParam(const FSBMulticastDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser, const TArray<FSBDamageEventGeneralParam>& GeneralParamList);
    void MulticastTakeDamage(const FSBMulticastDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
    void MulticastSetPushOutDisabled(bool bDisabled);
    void MulticastPlayInvincibleAnimationEffect(TEnumAsByte<ESBInvincibleAnimation::Type> InvincibleAnimationType);
    void MulticastNotifyStartElementBurst(ESBAttribute ElementType);
    void MulticastNotifyInterruptElementBurst(ESBAttribute ElementType);
    void MulticastNotifyEndElementBurst(ESBAttribute ElementType);
    void MulticastInitAnim();
    void MulticastDotTakeDamage(const FSBMulticastDotDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
    void MulticastChangeDamageReactionPattern(const FDataTableRowHandle& Handle);
    bool LoadAssetClass(const TSoftClassPtr<UObject>& AssetClass);
    bool LoadAsset(const TSoftObjectPtr<UObject>& Asset);
    bool IsWithinDistanceToGround(float CheckDistance);
    bool IsWeaponLoading();
    bool IsVillageCollisionCount();
    bool IsPlayingWeaponAnimation(int32 InventoryIndex);
    bool IsPlayDemo();
    bool IsMovingOnGround();
    bool IsMounting();
    bool IsMountAction();
    bool IsLoadedAllMipStreaming();
    bool IsLoadBattleAsset();
    bool IsInitialLoadCompleted();
    bool IsCollisionGroupBroken(FName GroupName);
    bool IsBurstBonusNow();
    void IncrementVillageCollisionCount();
    bool HasAnimTagsAny(const TArray<FName>& Tag);
    bool HasAnimTagsAll(const TArray<FName>& Tag);
    float GetWeight();
    class USBWeaponVisibilityComponent* GetWeaponVisibilityComponent();
    TArray<class ASBWeapon*> GetWeaponsByWeaponType(TEnumAsByte<ESBWeaponType> WeaponType);
    TArray<class ASBWeapon*> GetWeaponsByEquipType(TEnumAsByte<ESBWeaponEquipType> WeaponEquipType);
    class ASBWeapon* GetWeaponByInventoryIndex(int32 InventoryIndex);
    TArray<FName> GetWeaponAttachPoint();
    int32 GetVillageCollisionCount();
    float GetTotalElementDamageValue();
    FSBCharacterStatus GetStatus();
    float GetStaminaReduceCorrectRate();
    float GetStaminaRecoveryRate();
    float GetStamina();
    float GetSBCharacterMoveSpeedRate();
    float GetRemainElementBurstBonusTime();
    float GetReloadSpeedRate();
    float GetMoveSpeedRate();
    float GetMaxHitPointBase();
    FSBDamageInfo GetLastGuardInfo();
    FSBDamageInfo GetLastDamageInfo();
    float GetJumpVelocityRate();
    ESBInvincibleLevel GetInvincibleLevel();
    TArray<FSBInventoryWeapon> GetInventoryWeapons();
    int32 GetInventoryWeaponNum();
    bool GetInventoryWeaponByInventoryIndex(const int32 InventoryIndex, FSBInventoryWeapon& OutInventoryWeapon);
    float GetInitialHitPoint();
    class USBGuardComponent* GetGuardComponent();
    TArray<FSBEquipWeapon> GetEquipWeapons();
    float GetElementResistanceBP(ESBAttribute ElementType);
    float GetElementDamageValue(ESBAttribute ElementType);
    FDataTableRowHandle GetDamageReactionPattern();
    float GetDamageDownTimer();
    TArray<class ASBWeapon*> GetCurrentWeaponsByEquipType(TEnumAsByte<ESBWeaponEquipType> WeaponEquipType);
    class ASBWeapon* GetCurrentWeaponByWeaponAttach(TEnumAsByte<ESBWeaponAttach> WeaponAttach);
    float GetCurrentStaminaRate();
    float GetCurrentStamina();
    int32 GetCurrentElementBurstBonusLevel();
    float GetCurrentElementBurstBonusGaugeRate();
    FSBCollisionGroupInfo GetCollisionGroupInfoByGroupName(FName GroupName);
    FSBCollisionGroupInfo GetCollisionGroupInfo(int32 ID);
    int32 GetCollisionGroupIdByGroupName(FName GroupName);
    void FieldDead(ESBFieldDamageType FieldDamageType, class AActor* DamageCauser);
    void EndDisableRootMotion(FName RequestName);
    void DecrementVillageCollisionCount();
    void DebugSetInventoryWeapon(bool IsSheathe, int32 InventoryIndex, FSBWeaponAttach SetParam);
    void DebugServer_RequestSetPhysicsAccumDamage(class ASBCharacter* Character);
    void DebugLogInventoryWeapon();
    void DebugClient_SetPhysicsAccumDamage(float AccumDamage, class ASBCharacter* Character);
    void ClientSetVelocity(const FVector& Vector);
    void Client_SpawnInventoryWeapons(const TArray<FSBSpawnWeaponLoadParam>& NewSpawnWeapons, const TArray<FSBSpawnWeaponLoadParam>& LastSpawnWeapons);
    void Client_SetEquipWeaponByEquipTypes(const TArray<TEnumAsByte<ESBWeaponEquipType>>& EquipTypes);
    void Client_SetEquipWeapon(TEnumAsByte<ESBWeaponAttach> WeaponAttach, int32 NewInventoryIndex, FVector Location, FRotator Rotation, FVector Scale3D);
    void ClearVillageCollisionCount();
    void ClampCharacterParam();
    void ChangeDamageReactionPattern(const FDataTableRowHandle& Handle);
    void AddHitPoint(float AddValue);
}; // Size: 0xFC0

class ASBCharacterAnimationSamplingActor_AttackRange : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x228

class ASBCharacterAnimationSamplingAttackTrigger : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    void SetHitState(bool bHit);
}; // Size: 0x228

class ASBCheatCheckPoint_TA : public AActor
{
    int32 AttackID;                                                                   // 0x0228 (size: 0x4)
    int32 IdentityID;                                                                 // 0x022C (size: 0x4)
    float MinSeconds;                                                                 // 0x0230 (size: 0x4)

    void OnOverlapBegin(class AActor* OtherActor, const FDateTime& LocalStartTime);
}; // Size: 0x238

class ASBCheerfulItemBase : public AActor
{
    char padding_0[0x230];                                                            // 0x0000 (size: 0x0)

    void OnDeactivate();
    void OnAdditionalActivate();
    void OnActivate();
}; // Size: 0x230

class ASBCheerfulItem_Firework : public ASBCheerfulItem_HandheldBase
{
    char padding_0[0x2A0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2A0

class ASBCheerfulItem_FlowerShower : public ASBCheerfulItem_HandheldBase
{
    char padding_0[0x2A0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2A0

class ASBCheerfulItem_GlowStick : public ASBCheerfulItem_HandheldBase
{
    char padding_0[0x2A0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2A0

class ASBCheerfulItem_HandheldBase : public ASBCheerfulItemBase
{
    class USBSkeletalMeshComponent* Mesh;                                             // 0x0230 (size: 0x8)
    class USBParticleSystemComponent* ParticleSystem;                                 // 0x0238 (size: 0x8)
    class USBParticleSystemComponent* ActivationEffectParticleSystem;                 // 0x0240 (size: 0x8)
    class USBParticleSystemComponent* DeactivationEffectParticleSystem;               // 0x0248 (size: 0x8)
    float m_FadeOutTimeAtDestroySelf;                                                 // 0x0250 (size: 0x4)
    bool bShowActivationTimingEffect;                                                 // 0x0254 (size: 0x1)
    bool bShowDeactivationTimingEffect;                                               // 0x0255 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0256 (size: 0x2)
    float m_DelayDestroySelfTime;                                                     // 0x0258 (size: 0x4)

}; // Size: 0x2A0

class ASBCheerfulItem_PartyPopper : public ASBCheerfulItem_HandheldBase
{
    TArray<int32> m_HiddenTargetCapAndStringMaterialIndexList;                        // 0x02A0 (size: 0x10)

}; // Size: 0x2D0

class ASBCheerfulItem_Snowman : public ASBCheerfulItem_HandheldBase
{
    char padding_0[0x2A0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2A0

class ASBCityGameMode : public ASBGameMode
{
    char padding_0[0x3F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x3F8

class ASBClimbPoint : public AActor
{
    bool isVisibleUIIcon_;                                                            // 0x0228 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0229 (size: 0x3)
    int32 Floor_;                                                                     // 0x022C (size: 0x4)

    bool IsVisibleUIIcon();
    int32 GetFloor();
}; // Size: 0x230

class ASBCollisionDisableVolume : public AVolume
{
    FName GameContentId;                                                              // 0x0260 (size: 0x8)

}; // Size: 0x270

class ASBCombatCoordinator : public ASBSquadAI
{
    class USBAIRoleDistributionComponent* RoleDistributionComponent;                  // 0x0250 (size: 0x8)
    class USBAICommanderComponent* CommanderComponent;                                // 0x0258 (size: 0x8)
    class UAIFwHTNPlanningComponent* HTNPlanningComponent;                            // 0x0260 (size: 0x8)
    class USBUtilityBrainComponent* UtilityBrainComponent;                            // 0x0268 (size: 0x8)
    class USBAITacticalComponent* TacticalComponent;                                  // 0x0270 (size: 0x8)
    class USBUtilityOption* CurrentLeaderStrategy;                                    // 0x0278 (size: 0x8)
    char padding_0[0x20];                                                             // 0x0280 (size: 0x20)
    TMap<class FString, class USBAICommand*> NamedCommand;                            // 0x02A0 (size: 0x50)

    void SetTarget(FName TargetFaction, int32 TargetClusterNo);
    bool IsInConvexHull(const FVector& TestLocation);
    bool IsInAttackerConvexHull(const FVector& TestLocation);
    TArray<class AActor*> GetTargetClusterMembers();
    float GetDistanceToConvexHull2D(const FVector& Point);
}; // Size: 0x430

class ASBCoopActionConductor : public AActor
{
    FString Command;                                                                  // 0x0228 (size: 0x10)
    TArray<FString> TargetEnemies;                                                    // 0x0238 (size: 0x10)
    int32 MaxMember;                                                                  // 0x0248 (size: 0x4)
    float RequisitionRadius;                                                          // 0x024C (size: 0x4)
    TArray<TWeakObjectPtr<ASBEnemyCharacter>> Members;                                // 0x0250 (size: 0x10)

    void ImportTargetActor(class ASBEnemyCharacter* EnemyCharacter);
    class AActor* GetTargetActor();
}; // Size: 0x268

class ASBCoopActionConductor_Charge : public ASBCoopActionConductor
{
    float GatherDuration;                                                             // 0x0268 (size: 0x4)
    float StartCheckGatherDelay;                                                      // 0x026C (size: 0x4)
    float GatherCorrectSpeedRate;                                                     // 0x0270 (size: 0x4)
    float GatherStandbyRadius;                                                        // 0x0274 (size: 0x4)
    float ChargeDuration;                                                             // 0x0278 (size: 0x4)
    float ChargeCorrectSpeedRate;                                                     // 0x027C (size: 0x4)
    float MarkDistance;                                                               // 0x0280 (size: 0x4)
    float ChargeStandbyRadius;                                                        // 0x0284 (size: 0x4)
    float StuckThresholdSpeed;                                                        // 0x0288 (size: 0x4)
    float StartCheckStuckDelay;                                                       // 0x028C (size: 0x4)
    float StartingPointNumParam;                                                      // 0x0290 (size: 0x4)
    float StartingPointRandomRadius;                                                  // 0x0294 (size: 0x4)
    float RequisitionInterval;                                                        // 0x0298 (size: 0x4)
    float RabbitAngle;                                                                // 0x029C (size: 0x4)

}; // Size: 0x398

class ASBCoopActionConductor_DeathScythe_FinalAttack : public ASBCoopActionConductor
{
    float RequisitionInterval;                                                        // 0x0268 (size: 0x4)
    int32 AnchorCenterID;                                                             // 0x026C (size: 0x4)
    int32 AnchorLocationID;                                                           // 0x0270 (size: 0xC)
    float LoopDuration;                                                               // 0x027C (size: 0x4)
    float LapTime;                                                                    // 0x0280 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0284 (size: 0x4)
    class UParticleSystem* ParticleSpiritBall;                                        // 0x0288 (size: 0x8)
    float BaseScaleSpiritBall;                                                        // 0x0290 (size: 0x4)
    float HeightSpiritBall;                                                           // 0x0294 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0298 (size: 0x4)
    bool bDispSpiritBall;                                                             // 0x029C (size: 0x1)
    char padding_2[0x13];                                                             // 0x029D (size: 0x13)
    class UParticleSystemComponent* ParticleCompnentSpiritBall;                       // 0x02B0 (size: 0x8)

}; // Size: 0x2C8

class ASBCoopActionConductor_Spell : public ASBCoopActionConductor
{
    float FirstTargetRange;                                                           // 0x0268 (size: 0x4)
    float TargetingRange;                                                             // 0x026C (size: 0x4)
    int32 LocationActorID;                                                            // 0x0270 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0274 (size: 0x4)
    TArray<int32> PowerRequiredMemberNum;                                             // 0x0278 (size: 0x10)
    float RequisitionInterval;                                                        // 0x0288 (size: 0x4)
    float PowerRadius;                                                                // 0x028C (size: 0x4)
    bool bChantOnTheSpot;                                                             // 0x0290 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0291 (size: 0x3)
    float ChantRadius;                                                                // 0x0294 (size: 0x4)
    float ChantStepSize;                                                              // 0x0298 (size: 0x4)
    float ChantDuration;                                                              // 0x029C (size: 0x4)
    float SpiritBallDisappearDuration;                                                // 0x02A0 (size: 0x4)
    float CastDuration;                                                               // 0x02A4 (size: 0x4)
    class UParticleSystem* ParticleSpiritBall;                                        // 0x02A8 (size: 0x8)
    float BaseScaleSpiritBall;                                                        // 0x02B0 (size: 0x4)
    float MinScaleSpiritBall;                                                         // 0x02B4 (size: 0x4)
    float MaxScaleSpiritBall;                                                         // 0x02B8 (size: 0x4)
    FVector LocationSpiritBall;                                                       // 0x02BC (size: 0xC)
    class UParticleSystem* ParticleMagicSupply;                                       // 0x02C8 (size: 0x8)
    float BaseScaleMagicSupply;                                                       // 0x02D0 (size: 0x4)
    char padding_2[0x4];                                                              // 0x02D4 (size: 0x4)
    TArray<class UAkAudioEvent*> PlaySoundList;                                       // 0x02D8 (size: 0x10)
    class UAkAudioEvent* StopSound;                                                   // 0x02E8 (size: 0x8)
    int32 SpellPower;                                                                 // 0x02F0 (size: 0x4)
    TWeakObjectPtr<class ASBEnemyCharacter> SpellCaster;                              // 0x02F4 (size: 0x8)
    bool bDispSpiritBall;                                                             // 0x02FC (size: 0x1)
    bool bDispMagicSquare;                                                            // 0x02FD (size: 0x1)
    bool bDispMagicSupplies;                                                          // 0x02FE (size: 0x1)
    char padding_3[0x29];                                                             // 0x02FF (size: 0x29)
    TArray<TWeakObjectPtr<ASBEnemyCharacter>> Suppliers;                              // 0x0328 (size: 0x10)
    class UParticleSystemComponent* ParticleCompnentSpiritBall;                       // 0x0338 (size: 0x8)

    float GetChantRemainingTime();
}; // Size: 0x3A0

class ASBCreationCharacter : public ASBCharacter
{
    bool bCreationCharacter;                                                          // 0x0FC0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0FC1 (size: 0x7)
    FSBCharaCreateParameter CharaCreateParameter;                                     // 0x0FC8 (size: 0x3C0)
    class USBCharaCreateComponent* CharaCreateComponent;                              // 0x1388 (size: 0x8)
    class USBCharaPartsFaceComponent* FaceComp;                                       // 0x1390 (size: 0x8)
    char padding_1[0x18];                                                             // 0x1398 (size: 0x18)
    FSBCreationCharacterOnConstructionCharacterDelegate OnConstructionCharacterDelegate; // 0x13B0 (size: 0x10)
    void OnConstructionCharacer(bool bWasSuccessful, int32 Reason);
    FSBCreationCharacterOnUploadedCharaCreateDataDelegate OnUploadedCharaCreateDataDelegate; // 0x13C0 (size: 0x10)
    void OnUploadCharaCreateData(bool bWasSuccessful, int32 Reason);
    FSBCreationCharacterOnDownloadedCharaCreateDataDelegate OnDownloadedCharaCreateDataDelegate; // 0x13D0 (size: 0x10)
    void OnDownloadedCharaCreateData(bool bWasSuccessful);
    char padding_2[0x20];                                                             // 0x13E0 (size: 0x20)
    bool bDoUpdateLookAt;                                                             // 0x1400 (size: 0x1)

    void UploadCharaCreateParameter();
    void UploadCharaCreateDataEx(FString InCharacterId, ESBCharacterGender InGender, ESBClassType InClassType, FString InCharacterName);
    void UploadCharaCreateData(FString InCharacterId, ESBCharacterGender InGender);
    void UpdateParts();
    void UpdateHeightLength();
    void UpdateEquipCostume(class ASBPlayerController* PC);
    bool UpdateCostumeParam(FString UniqueId, const FCostumeData& InCostumeData);
    void UpdateCharacter();
    void SetStelth(bool bInStelth);
    void SetParts(ECharaPartsLocation PartsLocation, FName PartsName);
    void SetNakedBody(bool bInNakedBodyFlag);
    void SetGender(ESBCharacterGender InGender);
    void SetCreationCharacterScalarParameterValue(FName ParameterName, float Value);
    void SetCharaCreateParameter(const FSBCharaCreateParameter& NewParameter, bool InIgnoreCostumeParts, bool InIgnoreAccessoryParts);
    void SetAdditionalColor(TEnumAsByte<ESBAdditionalColor::Type> Type);
    void ServerUpdateParts(const FSBCharaCreateParameter& InCharaCreateParameter);
    void ServerSetParts(ECharaPartsLocation PartsLocation, FName PartsName);
    void ServerSetCharaCreateParameter(const FSBCharaCreateParameter& NewParameter);
    void ResetCrtBone();
    void RequestEmote(const FName& EmoteName, const class ASBCreationCharacter* TargetPlayer);
    void OnUploadCharaCreateData__DelegateSignature(bool bWasSuccessful, int32 Reason);
    void OnRep_CharaCreateParameter(const FSBCharaCreateParameter& LastParameter);
    void OnDownloadedCharaCreateData__DelegateSignature(bool bWasSuccessful);
    void OnConstructionCharacer__DelegateSignature(bool bWasSuccessful, int32 Reason);
    bool IsPartsForClass(ECharaPartsLocation PartsLocation, int32 PartsId, ESBClassType ClassType);
    bool IsEmoteRequested();
    int32 GetVoiceId();
    FSBCharaCreateParameter GetNakedCharaCreateParameter();
    ESBCharacterGender GetGender();
    class ASBCreationCharacter* GetEmoteTargetPlayer();
    float GetCustomWeaponScale();
    FString GetCreationId();
    bool GetCostumeParam(FString UniqueId, FCostumeData& OutCostumeData);
    class USBColoringShopComponent* GetColoringShopComponent();
    class USBAestheShopComponent* GetAestheShopComponent();
    void DownloadCharaCreateData(FString InCharacterId);
    bool ConstructionCharacter(ESBCharacterGender InGender, ESBClassType InClassType, FString InCharacterName, class USBAestheShopComponent* InAestheShopComponent);
    void ClientUpdateCharaCreateParameter(const FSBCharaCreateParameter& InParameter);
    void ClearEmoteRequest();
}; // Size: 0x1410

class ASBDebugCameraController : public ADebugCameraController
{
    class APlayerCameraManager* OriginalPlayerCameraManager;                          // 0x0680 (size: 0x8)

}; // Size: 0x688

class ASBDebugParamLevelDesign : public AActor
{
    TArray<FSBDebugWaveEnemyParamSettingBase> DebugWaveEnemyParamSettingCommmon;      // 0x0228 (size: 0x10)
    int32 WaveEnemyLv;                                                                // 0x0238 (size: 0x4)

    void SetWaveEnemyLv(int32 SetEnemyLv);
    int32 GetWaveEnemyLv();
}; // Size: 0x240

class ASBDebugSpawnPointRender : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x228

class ASBDebugTerrainCheck : public AActor
{
    bool Checking;                                                                    // 0x0228 (size: 0x1)
    bool Execute;                                                                     // 0x0229 (size: 0x1)
    char padding_0[0x2];                                                              // 0x022A (size: 0x2)
    float FallTime;                                                                   // 0x022C (size: 0x4)
    float ZeroSpeedFallTime;                                                          // 0x0230 (size: 0x4)
    float StandTime;                                                                  // 0x0234 (size: 0x4)
    int32 TraceCount;                                                                 // 0x0238 (size: 0x4)
    float StartX;                                                                     // 0x023C (size: 0x4)
    float StartY;                                                                     // 0x0240 (size: 0x4)
    float CurX;                                                                       // 0x0244 (size: 0x4)
    float CurY;                                                                       // 0x0248 (size: 0x4)
    float EndX;                                                                       // 0x024C (size: 0x4)
    float EndY;                                                                       // 0x0250 (size: 0x4)
    float TopZ;                                                                       // 0x0254 (size: 0x4)
    float BtmZ;                                                                       // 0x0258 (size: 0x4)
    float UnitSize;                                                                   // 0x025C (size: 0x4)
    char padding_1[0x8];                                                              // 0x0260 (size: 0x8)
    FVector tmpVec;                                                                   // 0x0268 (size: 0xC)
    char padding_2[0xC];                                                              // 0x0274 (size: 0xC)
    FTransform CurTrans;                                                              // 0x0280 (size: 0x30)
    TArray<class ANavMeshBoundsVolume*> NavMeshVolumes;                               // 0x02B0 (size: 0x10)
    TArray<FVector> TraceList;                                                        // 0x02C0 (size: 0x10)
    TArray<FVector> ErrorPoint;                                                       // 0x02D0 (size: 0x10)
    TWeakObjectPtr<class ASBPlayerCharacter> PlayerCharacter;                         // 0x02E0 (size: 0x8)

}; // Size: 0x340

class ASBDebugTerrainCheckSpawner : public AActor
{
    TSubclassOf<class ASBDebugTerrainCheck> BPDebugTerrainCheck;                      // 0x0228 (size: 0x8)

    void ShowResult(class UObject* WorldContextObject);
    void GetResult(class UObject* WorldContextObject, TArray<FTerrainErrorPt>& ErrorPts);
}; // Size: 0x238

class ASBDebugTerrainCheckVolume : public AActor
{
    class UBoxComponent* BoxVolume;                                                   // 0x0228 (size: 0x8)

}; // Size: 0x230

class ASBDemoPlayerCharacter : public ASBCreationCharacter
{
    char padding_0[0x1410];                                                           // 0x0000 (size: 0x0)

    TSoftObjectPtr<UASAnimationSet> GetDemoAnimationSet();
}; // Size: 0x1410

class ASBDestructible : public ADestructibleActor
{
    class UStaticMeshComponent* StaticMeshComponent;                                  // 0x02B0 (size: 0x8)
    class USphereComponent* HindranceComponent;                                       // 0x02B8 (size: 0x8)
    class USBCollisionGroupComponent* CollisionGroupComponent;                        // 0x02C0 (size: 0x8)
    float CurrentHitPoint;                                                            // 0x02C8 (size: 0x4)
    float MaxHitPoint;                                                                // 0x02CC (size: 0x4)
    ESBDestrcutibleDamageType TakeDamageType;                                         // 0x02D0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x02D1 (size: 0x7)
    class ASBBattleArea* CurrentBattleArea;                                           // 0x02D8 (size: 0x8)
    FName ProfileDataId;                                                              // 0x02E0 (size: 0x8)
    bool IsViewDamageValue;                                                           // 0x02E8 (size: 0x1)
    char padding_1[0x7];                                                              // 0x02E9 (size: 0x7)
    class UParticleSystem* DamageParticle;                                            // 0x02F0 (size: 0x8)
    class UAkAudioEvent* DamageAudio;                                                 // 0x02F8 (size: 0x8)
    class UParticleSystem* DestructParticle;                                          // 0x0300 (size: 0x8)
    class UAkAudioEvent* DestructAudio;                                               // 0x0308 (size: 0x8)
    ESBDestrcutibleType DestrcutibleType;                                             // 0x0310 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0311 (size: 0x7)
    FSBDestructibleOnDestructibleObjectDestructDelegete OnDestructibleObjectDestructDelegete; // 0x0318 (size: 0x10)
    void OnDestructibleObjectDestructDelegete(class ASBDestructible* Myself);
    bool bDestructed;                                                                 // 0x0328 (size: 0x1)
    bool bIsRespawn;                                                                  // 0x0329 (size: 0x1)
    bool bIsRespawnDebugDraw;                                                         // 0x032A (size: 0x1)
    char padding_3[0x1];                                                              // 0x032B (size: 0x1)
    float RespawnIntervalTime;                                                        // 0x032C (size: 0x4)
    float RespawnHindrance;                                                           // 0x0330 (size: 0x4)
    bool bContentHide;                                                                // 0x0334 (size: 0x1)
    char padding_4[0x3];                                                              // 0x0335 (size: 0x3)
    FSBSpawnAndDestructCounter SpawnAndDestructCounter;                               // 0x0338 (size: 0x8)
    bool IsDxBattleMode;                                                              // 0x0340 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0341 (size: 0x3)
    float DxBarrierDamagedRate;                                                       // 0x0344 (size: 0x4)
    float DxPlayerDamagedRate;                                                        // 0x0348 (size: 0x4)
    bool IsDxBattleInfinityHP;                                                        // 0x034C (size: 0x1)
    char padding_6[0x3];                                                              // 0x034D (size: 0x3)
    float DestructCount;                                                              // 0x0350 (size: 0x4)
    ESBTreasureBoxRewardType DropItemReward;                                          // 0x0354 (size: 0x1)
    char padding_7[0x3];                                                              // 0x0355 (size: 0x3)
    int32 DropMinMoney;                                                               // 0x0358 (size: 0x4)
    int32 DropMaxMoney;                                                               // 0x035C (size: 0x4)
    bool IsDestructibleDropTreasure;                                                  // 0x0360 (size: 0x1)
    bool IsDropItem;                                                                  // 0x0361 (size: 0x1)

    void ServerTakeDamage(const FSBDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageSrc);
    void ResultTreasure(class AActor* InOtherActor, FRotator ViewRotation, int32 TreasureId, ESBTreasureBoxRarity TreasureRarity, int32 LotRate);
    void RespawnDestructible();
    void RespawnDebugDraw(bool sw, float Timer, float Duration);
    void ResetInitialRespawnIntervalTime(float IntervalTime);
    void ResetInitialIsRespawn(bool IsRespawn);
    void ResetInitialHitPoint(float hp);
    void ReadyToRespawn();
    void PostGetTreasure(ESBTreasureBoxLotResult Result, const TArray<FSBTreasureBoxLotResult>& LotResults);
    void OnRep_SpawnAndDestructCounter();
    void OnDestructibleObjectDestructDelegete__DelegateSignature(class ASBDestructible* Myself);
    void MulticastTakeDamage(const FSBMulticastDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
    void MulticastDamageReaction(float CurrentHP, FVector_NetQuantizeNormal Direction, float Strength, class AActor* DamageCauser, const FSBDamageEvent& DamageEvent);
    bool IsSpawnAndDestructCounterByDestroyCheck();
    bool IsDebugDxGateInfinityHP();
    FVector GetTakeDamagePoint();
    FName GetProfileDataId();
    void ExecRespawn();
    void ExecDestroy(FVector_NetQuantizeNormal Direction, float Strength, class AActor* DamageCauser);
    void DropTreasureSetupClient();
    ESBTreasureBoxRewardType DropTreasureSetup(int32 LotRate, int32 MoneyLotRate, int32 BuffRotRate, bool IsUseRandomSeed, bool& IsDropItem);
    void Destruct(FVector Direction, float Strength, class AActor* DamageCauser);
    void Damaged(float CurrentHP, FHitResult HitInfo, FVector Direction, float Strength, class AActor* DamageCauser);
    bool CheckRespawnable();
}; // Size: 0x3B8

class ASBDhcMeasurer : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    void ResetTargetPlayerStatus(class ASBPlayerCharacter* Player);
    void ResetTargetEnemyStatus(class ASBEnemyCharacter* Enemy);
}; // Size: 0x228

class ASBDigitalSignageBase : public AActor
{
    FString GroupId;                                                                  // 0x0228 (size: 0x10)
    TArray<FDigitalSignageTextrueParam> TextureParamList;                             // 0x0238 (size: 0x10)
    bool bDataSetting;                                                                // 0x0248 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0249 (size: 0x7)
    FSBDigitalSignageBaseOnDigitalSignageTextureDownLoadCompleteDelegete OnDigitalSignageTextureDownLoadCompleteDelegete; // 0x0250 (size: 0x10)
    void OnDigitalSignageTextureDownLoadCompleteDelegete(FString InFilePath);
    TArray<FString> DownLoadTexturePathList;                                          // 0x0260 (size: 0x10)

    void SetupTexture();
    void OnDigitalSignageTextureDownLoadCompleteDelegete__DelegateSignature(FString InFilePath);
    bool IsParameterSetting();
    int32 GetVTileNum(int32 TextureCnt);
    int32 GetUTileNum(int32 TextureCnt);
    TArray<FDigitalSignageTextrueParam> GetTextureParamList();
    int32 GetTextureMaxCount();
    int32 GetTextureCnt();
    int32 GetStatusBit();
    void GetNetworkDataPath(FString& OutPath);
    FString GetGroupId();
    FDateTime GetCheckDateTime();
    void DownLoadTextureRelease();
    void DownLoadTextureComplete(FString InFilePath);
    void CreateTextureParamList();
    void ClearTextureParamList();
    void AddDownLoadTexture(FString InFilePath);
}; // Size: 0x270

class ASBDungeonCameraDemo : public AActor
{
    FSBDungeonCameraDemoOnEndDungeonCameraDemo OnEndDungeonCameraDemo;                // 0x0228 (size: 0x10)
    void OnEndDungeonCameraDemo();

    void SetDungeonDemoCameraStatus(ESBDungeonCameraDemoStatus DemoStatus);
    void RequestDemoStart();
    void OnEndDungeonCameraDemo__DelegateSignature();
    ESBDungeonCameraDemoStatus GetDungeonDemoCameraStatus();
}; // Size: 0x240

class ASBDungeonClearCheck : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    bool LookTAPoint(class ASBPlayerCharacter* PlayerCharacter);
    void HandleWithCause(class ASBPlayerCharacter* PlayerCharacter, bool BlockClearDungeon, FString Cause, float DelayTime);
}; // Size: 0x228

class ASBDungeonEntryCloseVolume : public AVolume
{
    char padding_0[0x260];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x260

class ASBDungeonStandbyArea : public AActor
{
    bool bAvailable;                                                                  // 0x0228 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0229 (size: 0x7)
    FString WaitClearConditionScript;                                                 // 0x0230 (size: 0x10)

    bool OverlapSomeone();
    bool OverlapAll();
    void OnRep_Available();
    void OnClearConditionScriptEndOnePlayer(int32 EndScrpitId, FString EndScrpitName);
    void OnClearConditionScriptEndAllPlayers(int32 EndScrpitId, FString EndScrpitName);
    void OnClearConditionScriptEndAll();
    void OnClearConditionScriptEnd();
}; // Size: 0x240

class ASBDungeonWall : public AActor
{
    char padding_0[0x230];                                                            // 0x0000 (size: 0x0)

    void SpawnWall();
    void OnSublevelInitialLoaded();
    void NotifySublevelInitialLoaded();
    void EraseWall();
}; // Size: 0x230

class ASBDxBattleGameInstance : public AActor
{
    ESBDxBattleGameStatus m_Status;                                                   // 0x0230 (size: 0x1)
    ESBDxBattleGameResult m_Result;                                                   // 0x0231 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0232 (size: 0x2)
    int32 m_CurStep;                                                                  // 0x0234 (size: 0x4)
    char padding_1[0x170];                                                            // 0x0238 (size: 0x170)
    TArray<FSBDxBattleGameScore> DebugPlayerScoreList;                                // 0x03A8 (size: 0x10)
    char padding_2[0x8];                                                              // 0x03B8 (size: 0x8)
    TMap<class ASBDestructible*, class FPlayerScore> ScoreMap;                        // 0x03C0 (size: 0x50)
    char padding_3[0x8];                                                              // 0x0410 (size: 0x8)
    FSBDxBattleGameInstanceOnShowTearOffLogDelegate OnShowTearOffLogDelegate;         // 0x0418 (size: 0x10)
    void OnShowTearOffLogDelegate(const class ASBPlayerCharacter* PlayerCharacter);

    void SetResult(const ESBDxBattleGameResult InResult);
    void SetMapMasterData(const FSBMapInfo& InMaster);
    void SetDefenseMasterData(const FSBDxBattleMasterData& InMaster);
    void ServerDebugDrawViewContributionValue(const class ASBPlayerCharacter* Character, float InSeconds);
    void Server_SetScore(ESBDxBattleScore ScoreType, const class ASBPlayerCharacter* pPlayer, const float InPoint);
    void Server_LeavePlayer(class ASBPlayerCharacter* InLeaveMember);
    void Server_JoinPlayer(class ASBPlayerCharacter* InJoinMember);
    void Server_AddWholeScore(ESBDxBattleWholeScore ScoreType, const uint32 InPoint);
    void Server_AddScore(ESBDxBattleScore ScoreType, const class ASBPlayerCharacter* pPlayer, const float InPoint);
    void RequestDebugDrawViewContributionValue(const class ASBPlayerCharacter* Character, float InSeconds);
    void OnShowTearOffLogDelegate__DelegateSignature(const class ASBPlayerCharacter* PlayerCharacter);
    void OnRep_CurStep();
    void OnAssetLoaded();
    void NotifyDestructibletEnemyBuffer(const class ASBDestructible* InDestructObject, const class ASBPlayerCharacter* InAttacker);
    void NotifyDestructibleEnemyGate(const class ASBDestructible* InDestructObject, const class ASBPlayerCharacter* InAttacker);
    class ASBPlayerCharacter* GetHighScorePlayer(const class ASBDestructible* InDestructObject, const class ASBPlayerCharacter* PlayerCharacter);
    bool GetDebugViewContributionValue();
    float GetAwardPointRatio(class UObject* WorldContextObject);
    void DebugDrawViewContributionValue(const class ASBPlayerCharacter* Character, float InSeconds, TArray<FSBDxBattleGameScore>& InViewPlayerScoreList);
    void ClientDebugDrawViewContributionValue(const class ASBPlayerCharacter* Character, float InSeconds);
}; // Size: 0x428

class ASBEncounterVolume : public AVolume
{
    TArray<class ASBSpawnArea*> SpawnAreas;                                           // 0x0260 (size: 0x10)
    FAIFwParameterizedBTRequest SpawnQuery;                                           // 0x0270 (size: 0x18)
    class USBSpawnSourceComponent* SpawnSourceComponent;                              // 0x0288 (size: 0x8)
    class USBEncounterTypeBase* EncounterType;                                        // 0x0290 (size: 0x8)
    bool bSpawnEvenIfRemaining;                                                       // 0x0298 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0299 (size: 0x3)
    float CooldownTime;                                                               // 0x029C (size: 0x4)
    TArray<class AActor*> SpawnedActors;                                              // 0x02A0 (size: 0x10)
    char padding_1[0x8];                                                              // 0x02B0 (size: 0x8)
    FTimerHandle CooldownFinishTimerHandle;                                           // 0x02B8 (size: 0x8)
    FTimerHandle RequestSpawnTimerHandle;                                             // 0x02C0 (size: 0x8)
    FSBEncounterVolumeOnCooldownDelegate OnCooldownDelegate;                          // 0x02C8 (size: 0x10)
    void OnCooldownDelegate(class ASBEncounterVolume* EncounterVolume);
    FSBEncounterVolumeOnActorSpawnedDelegate OnActorSpawnedDelegate;                  // 0x02D8 (size: 0x10)
    void SBOnActorSpawnedDelegate(class AActor* Actor);
    FSBEncounterVolumeOnActorDestroyedDelegate OnActorDestroyedDelegate;              // 0x02E8 (size: 0x10)
    void SBOnDestroyedSpawnedDelegate(class AActor* Actor);

    void SBOnDestroyedSpawnedDelegate__DelegateSignature(class AActor* Actor);
    void SBOnActorSpawnedDelegate__DelegateSignature(class AActor* Actor);
    void RequestSpawn();
    void RequestActivate();
    void OnCooldownDelegate__DelegateSignature(class ASBEncounterVolume* EncounterVolume);
    void OnActorDestroyed(class AActor* Actor);
    void DeleteSpawnedEnemies();
}; // Size: 0x2F8

class ASBEnemyAnimationSamplingLevelScriptActor : public ASBAnimationSamplingLevelScriptActor
{
    char padding_0[0x240];                                                            // 0x0000 (size: 0x0)

    void InitializeSpawnedEnemyForEditor(class ASBEnemyCharacter* SpawnedEnemy);
}; // Size: 0x240

class ASBEnemyCharacter : public ASBEnemyCreationCharacter
{
    class ASBEnemyMetaInfo* MetaInfo;                                                 // 0x1150 (size: 0x8)
    char padding_0[0x4];                                                              // 0x1158 (size: 0x4)
    float MaxStaminaEasyCBT;                                                          // 0x115C (size: 0x4)
    float MaxStaminaNormalCBT;                                                        // 0x1160 (size: 0x4)
    float MaxStaminaHardCBT;                                                          // 0x1164 (size: 0x4)
    float StaminaRecoverySpeedEasyCBT;                                                // 0x1168 (size: 0x4)
    float StaminaRecoverySpeedNormalCBT;                                              // 0x116C (size: 0x4)
    float StaminaRecoverySpeedHardCBT;                                                // 0x1170 (size: 0x4)
    char padding_1[0x1];                                                              // 0x1174 (size: 0x1)
    bool bIsInvincibleMode;                                                           // 0x1175 (size: 0x1)
    bool bIsAutoHealMode;                                                             // 0x1176 (size: 0x1)
    char padding_2[0x1];                                                              // 0x1177 (size: 0x1)
    class USBEnemyDeathEffectComponent* DeathEffectComp;                              // 0x1178 (size: 0x8)
    bool ReceiveDeadFast;                                                             // 0x1180 (size: 0x1)
    char padding_3[0x7];                                                              // 0x1181 (size: 0x7)
    FSBEnemyCharacterOnFadeOutDeath OnFadeOutDeath;                                   // 0x1188 (size: 0x10)
    void EnemyFadeOutDeath();
    class USBEnemyTideComponent* TideComp;                                            // 0x1198 (size: 0x8)
    class USBEnemyExitEffectComponent* ExitEffectComp;                                // 0x11A0 (size: 0x8)
    char padding_4[0x4];                                                              // 0x11A8 (size: 0x4)
    float WeightBias;                                                                 // 0x11AC (size: 0x4)
    char padding_5[0x4];                                                              // 0x11B0 (size: 0x4)
    FName EnemyContentId;                                                             // 0x11B4 (size: 0x8)
    int32 DungeonPlayerNum;                                                           // 0x11BC (size: 0x4)
    char padding_6[0x41];                                                             // 0x11C0 (size: 0x41)
    bool bCumulateEnemy;                                                              // 0x1201 (size: 0x1)
    char padding_7[0x6];                                                              // 0x1202 (size: 0x6)
    FSBEnemyCharacterOnEnemyTakeAnyDamage OnEnemyTakeAnyDamage;                       // 0x1208 (size: 0x10)
    void EnemyTakeAnyDamageSignature(class ASBEnemyCharacter* DamagedActor, float Damage, const FSBDamageEvent& DamageEvent, class AController* InstigatedBy, class AActor* DamageCauser);
    FString EnemyId;                                                                  // 0x1218 (size: 0x10)
    FString EnemyAppearanceId;                                                        // 0x1228 (size: 0x10)
    class UDataTable* EnemyActionParamTable;                                          // 0x1238 (size: 0x8)
    class USBEnemyBadZoneAvoidanceComponent* BadZoneAvoidanceComp;                    // 0x1240 (size: 0x8)
    class USBEnemyPhaseComponent* PhaseComp;                                          // 0x1248 (size: 0x8)
    class USBEnemyModifierComponent* ModifierComp;                                    // 0x1250 (size: 0x8)
    class USBEnemyActionParamComponent* ActionParamComp;                              // 0x1258 (size: 0x8)
    class USBEnemyBattleConditionComponent* BattleConditionComp;                      // 0x1260 (size: 0x8)
    class USBEnemyBlendSpaceInputComponent* BlendSpaceInputComp;                      // 0x1268 (size: 0x8)
    class USBEnemyPartsManagerComponent* PartsManagerComp;                            // 0x1270 (size: 0x8)
    class USBEnemyTargetingComponent* TargetingComp;                                  // 0x1278 (size: 0x8)
    class USBAdjustRootMotionComponent* AdjustRootMotionComp;                         // 0x1280 (size: 0x8)
    class USBEnemyStanceComponent* StanceComp;                                        // 0x1288 (size: 0x8)
    class USBEnemySummonComponent* SummonComponent;                                   // 0x1290 (size: 0x8)
    class USBEnemyChantMarkerManagerComponent* MarkerManagerComp;                     // 0x1298 (size: 0x8)
    class USBEnemySenseChangerComponent* SenseChangerComp;                            // 0x12A0 (size: 0x8)
    class USBEnemyDropComponent* EnemyDropComp;                                       // 0x12A8 (size: 0x8)
    class USBDelegateHitAuthComponent* DelegateHitAuthComp;                           // 0x12B0 (size: 0x8)
    class USBCharacterAnimationSamplingComponent* AnimationSamplingComp;              // 0x12B8 (size: 0x8)
    class USBStateInitializerComponent* StateInitializerComponent;                    // 0x12C0 (size: 0x8)
    class USBEnemyCollisionHitComponent* CollisionHitComp;                            // 0x12C8 (size: 0x8)
    class USBCharacterChanceTimeDownComponent* ChanceTimeDownComp;                    // 0x12D0 (size: 0x8)
    class USBEnemyDxBattleComponent* EnemyDxBattleComp;                               // 0x12D8 (size: 0x8)
    class UAbilitySystemComponent* AbilitySystemComp;                                 // 0x12E0 (size: 0x8)
    class USBEnemyConditionalVoiceComponent* ConditionalVoiceComp;                    // 0x12E8 (size: 0x8)
    class USBExecDelegateWithConditionComponent* ExecDelegateWithConditionComp;       // 0x12F0 (size: 0x8)
    class USBEnemyBuddyRevivalComponent* BuddyRevivalComp;                            // 0x12F8 (size: 0x8)
    class USBEnemyStateMachineReplayComponent* StateMachineReplayComp;                // 0x1300 (size: 0x8)
    class USBCharacterLoopCounterComponent* ActionUniqueCounterComp;                  // 0x1308 (size: 0x8)
    class USBEnemySABComponent* SABComp;                                              // 0x1310 (size: 0x8)
    class USBEnemySpecializerComponent* EnemySpecializerComponent;                    // 0x1318 (size: 0x8)
    char padding_8[0x58];                                                             // 0x1320 (size: 0x58)
    class USBCharacterAnimationSamplingAsset* AnimationSamplingAsset;                 // 0x1378 (size: 0x8)
    bool bUseLocalTestParameter;                                                      // 0x1380 (size: 0x1)
    char padding_9[0x7];                                                              // 0x1381 (size: 0x7)
    int32 EnemyLevel;                                                                 // 0x1388 (size: 0x4)
    char padding_10[0x1C];                                                            // 0x138C (size: 0x1C)
    bool IsBoss;                                                                      // 0x13A8 (size: 0x1)
    char padding_11[0x3];                                                             // 0x13A9 (size: 0x3)
    float ElementDamageBias;                                                          // 0x13AC (size: 0x4)
    int32 ResistRate;                                                                 // 0x13B0 (size: 0x4)
    int32 ResistDot;                                                                  // 0x13B4 (size: 0x4)
    FName DungeonAttribute;                                                           // 0x13B8 (size: 0x8)
    TArray<FSBBattleStatusResistanceSetting> BattleStatusResistanceList;              // 0x13C0 (size: 0x10)
    char padding_12[0x4];                                                             // 0x13D0 (size: 0x4)
    bool bCanBeParalyzed;                                                             // 0x13D4 (size: 0x1)
    bool bNeedsToShowElementalBurstEffects;                                           // 0x13D5 (size: 0x1)
    char padding_13[0x2];                                                             // 0x13D6 (size: 0x2)
    FSBEnemyCharacterOnAddActorTagByEnemySet OnAddActorTagByEnemySet;                 // 0x13D8 (size: 0x10)
    void OnAddActorTagByEnemySet(const FName& ActorTag);
    FName ActorTagByEnemySet;                                                         // 0x13E8 (size: 0x8)
    int32 EnemyLibActiveTime;                                                         // 0x13F0 (size: 0x4)
    bool bIsNonActive;                                                                // 0x13F4 (size: 0x1)
    char padding_14[0x3];                                                             // 0x13F5 (size: 0x3)
    float HitpointToBlockDamage;                                                      // 0x13F8 (size: 0x4)
    char padding_15[0x54];                                                            // 0x13FC (size: 0x54)
    TArray<FTacticalSkillInfo> TacticalSkillInfos;                                    // 0x1450 (size: 0x10)
    int32 TacticalSkillDebugMode;                                                     // 0x1460 (size: 0x4)
    float TempAimBSY;                                                                 // 0x1464 (size: 0x4)
    float TempAimBSX;                                                                 // 0x1468 (size: 0x4)
    FVector SpawnLocation;                                                            // 0x146C (size: 0xC)
    FRotator SpawnRotation;                                                           // 0x1478 (size: 0xC)
    FName SpawnEffectSocketName;                                                      // 0x1484 (size: 0x8)
    FVector SpawnEffectAttachOffset;                                                  // 0x148C (size: 0xC)
    FVector SpawnEffectScale;                                                         // 0x1498 (size: 0xC)
    bool bSpawnEffectEnabled;                                                         // 0x14A4 (size: 0x1)
    bool bIsCalcEffectScaleByBoundingBox;                                             // 0x14A5 (size: 0x1)
    char padding_16[0x2];                                                             // 0x14A6 (size: 0x2)
    float BattleStatusEffectScale;                                                    // 0x14A8 (size: 0x4)
    char padding_17[0x4];                                                             // 0x14AC (size: 0x4)
    class UParticleSystem* OrderedAttackParticle;                                     // 0x14B0 (size: 0x8)
    FName OrderedAttackParticleSocketName;                                            // 0x14B8 (size: 0x8)
    class UParticleSystemComponent* OrderedAttackParticleCompnent;                    // 0x14C0 (size: 0x8)
    bool bOrderedAttackParticlePlay;                                                  // 0x14C8 (size: 0x1)
    bool bEnableMountOverlap;                                                         // 0x14C9 (size: 0x1)
    char padding_18[0xB2];                                                            // 0x14CA (size: 0xB2)
    bool bIsDebugMode;                                                                // 0x157C (size: 0x1)
    char padding_19[0x3];                                                             // 0x157D (size: 0x3)
    TSoftObjectPtr<UASStateMachine> StateMachine;                                     // 0x1580 (size: 0x28)
    TSoftObjectPtr<UASAnimationSet> AnimationSet;                                     // 0x15A8 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> UpperBodyStateMachine;                            // 0x15D0 (size: 0x28)
    char padding_20[0x18];                                                            // 0x15F8 (size: 0x18)
    int32 RepActionIndex;                                                             // 0x1610 (size: 0x4)
    char padding_21[0x4];                                                             // 0x1614 (size: 0x4)
    class AActor* TargetActorCache;                                                   // 0x1618 (size: 0x8)
    TArray<FCustomFlagInfo> CustomFlagInfos;                                          // 0x1620 (size: 0x10)
    char padding_22[0x4];                                                             // 0x1630 (size: 0x4)
    uint32 CustomFlags;                                                               // 0x1634 (size: 0x4)
    bool bIsSummonEnemy;                                                              // 0x1638 (size: 0x1)
    char padding_23[0x7];                                                             // 0x1639 (size: 0x7)
    class AActor* OrderedTarget;                                                      // 0x1640 (size: 0x8)
    FSBEnemyCharacterOnBuddyDelegate OnBuddyDelegate;                                 // 0x1648 (size: 0x10)
    void OnBuddyDelegate();
    class APawn* BuddyCharacter;                                                      // 0x1658 (size: 0x8)
    bool bBuddy;                                                                      // 0x1660 (size: 0x1)
    bool bDisableBuddyHPGauge;                                                        // 0x1661 (size: 0x1)
    char padding_24[0x6];                                                             // 0x1662 (size: 0x6)
    class APawn* MasterPawn;                                                          // 0x1668 (size: 0x8)
    FSBElementDamageSetting DefaultAttackElement;                                     // 0x1670 (size: 0x10)
    char padding_25[0x10];                                                            // 0x1680 (size: 0x10)
    bool bDodging;                                                                    // 0x1690 (size: 0x1)
    ESBPerceiveLevel DefaultDodgeLevel;                                               // 0x1691 (size: 0x1)
    bool bJumping;                                                                    // 0x1692 (size: 0x1)
    bool bOverrideCameraTransparentCheckDistance;                                     // 0x1693 (size: 0x1)
    FSBCameraShieldingTransparentParam CameraShieldingTransparentParam;               // 0x1694 (size: 0x8)
    char padding_26[0xC];                                                             // 0x169C (size: 0xC)
    TSubclassOf<class ASBAIController_Imagine> ImagineAIControllerClass;              // 0x16A8 (size: 0x8)
    char padding_27[0x10];                                                            // 0x16B0 (size: 0x10)
    class AActor* InitializeAnchor1;                                                  // 0x16C0 (size: 0x8)
    class AActor* IFPAnchor1;                                                         // 0x16C8 (size: 0x8)
    class AActor* ActivateAnchor1;                                                    // 0x16D0 (size: 0x8)
    char padding_28[0x20];                                                            // 0x16D8 (size: 0x20)
    TArray<FSBEnemyWarpEffectInfo> WarpEffectInfoList;                                // 0x16F8 (size: 0x10)
    char padding_29[0x8];                                                             // 0x1708 (size: 0x8)
    TArray<uint8> ProcessingAnimNotifyOnServer;                                       // 0x1710 (size: 0x10)
    char padding_30[0x10];                                                            // 0x1720 (size: 0x10)
    FSBEnemyCharacterOnAnimNotfyBroadcastDelegate OnAnimNotfyBroadcastDelegate;       // 0x1730 (size: 0x10)
    void OnAnimNotifyBroadcastDelegate(class ASBEnemyCharacter* Enemy, const FName& BroadcastString);

    void UpdateTacticalSkillInfo(FString Command, bool bIsActivated);
    void UpdateMaterialEmissiveColor(bool bResult);
    void UpdateChangedMaterial(bool bResult);
    bool TraceTarget(const FVector& TargetLocation);
    void StartAppearingBlindnessTimer();
    void SetLightingChannelsForCapture();
    void SetInvincibleMode(bool InValue);
    void SetEnemyLevel(int32 Level);
    void SetEnemyID(FString ID);
    void SetEnemyControlDummyTargetEnable(bool InIsEnable);
    void SetCustomFlag(FString FlagName, bool bEnabled);
    void SetAutoHealMode(bool InValue);
    void SelfDeath();
    void RPC_SyncCurrentHitPointOnClientByServer(float hp);
    void RPC_SetHitpointToBlockDamate(float Value);
    void RPC_ExecStartDeathEffect();
    void ResetAllCustomFlags();
    void RecvExecCustomFlag(FString FlagName);
    void RecvExecCustomActionStateEnd(FString ActionName);
    void RecvExecCustomActionStateBegin(FString ActionName);
    void RecvExecCustomAction(FString ActionName);
    void ReceiveStartDeathEffect();
    void ReceiveSelfDeath();
    void ReceiveDead();
    void PlayWarpEffect(FVector From, FVector To, int32 NewWarpEffectIndex);
    void PartsBreak(FName PartsName, bool bSoon);
    void OnRep_TacticalSkillDebugMode();
    void OnRep_EnemyLevel();
    void OnRep_EnemyId();
    void OnRep_EnemyContentId();
    void OnRep_DungeonPlayerNum();
    void OnRep_DungeonAttribute();
    void OnRep_CustomFlags();
    void OnRep_bIsDebugMode();
    void OnRep_bBuddy();
    void OnRep_ActorTagByEnemySet();
    void OnEnemyMasterDataAvailable();
    void OnBuddyDelegate__DelegateSignature();
    void OnAnimNotifyBroadcastDelegate__DelegateSignature(class ASBEnemyCharacter* Enemy, const FName& BroadcastString);
    void OnAddActorTagByEnemySet__DelegateSignature(const FName& ActorTag);
    void NotifyTerminateAsImagine();
    void NotifyPostSpawnProjectile(uint32 AnimNotifyID);
    void NotifyBossBurstToAllPlayer(ESBAttribute Attribute);
    void MulticastVanishDeath(float WaitTime);
    void MulticastTriggerAnimNotifyByNotifyRuleOnServer(uint16 AnimSequenceIndex, uint16 AnimNotifyIndex);
    void MulticastSelfDeath();
    void MulticastOnSpawned(bool bSpawnWithEffect);
    void MulticastNotifyBossBurst();
    void MulticastFadeOutDeath();
    void MulticastExit();
    void MulticastEndExit();
    void MulticastDebugErrorTextOnServer(FString ErrorText, bool ShowErrorText);
    void MulticastDead(bool bInNoPlayerAround);
    void MultiCastChangeVisibility(bool bVisible, ESBActorHiddenType HiddenType);
    bool IsUnableActionCondition();
    bool IsTargetActor(const class AActor* Actor);
    bool IsSummonEnemy();
    bool IsSubmargedExit();
    bool IsSABReaction();
    bool IsRunOutOfStamina();
    bool IsNonActive();
    bool IsNamedEnemy();
    bool IsInvincibleMode();
    bool IsInstantBattleTransition();
    bool IsCustomFlagEnabled(FString FlagName);
    bool IsCumulateEnemy();
    bool IsBuddy();
    bool IsBossEnemy();
    bool IsBattle();
    bool IsAutoHealMode();
    void GoAway();
    void GiveStatusAliment(FDataTableRowHandle StatusHandle);
    void GiveDeactiveStatusAliment(FDataTableRowHandle StatusHandle);
    class UDataTable* GetVoiceDataTable();
    class UAkComponent* GetVoiceComponent();
    TArray<FTacticalSkillInfo> GetTacticalSkillInfos();
    int32 GetTacticalSkillDebugMode();
    class UASStateMachine* GetStateMachine();
    bool GetIsJustSpawned();
    int32 GetEnemyLevel();
    FString GetEnemyId();
    FString GetEnemyAppearanceId();
    class UDataTable* GetConditionVoiceDataTable();
    float GetChaseEndRange();
    class UASAnimationSet* GetAnimationSet();
    class UASStateMachine* GetAimStateMachine();
    void ForceCurrentHitPointReplicated();
    void FadeOutDead();
    void EnemyTakeAnyDamageSignature__DelegateSignature(class ASBEnemyCharacter* DamagedActor, float Damage, const FSBDamageEvent& DamageEvent, class AController* InstigatedBy, class AActor* DamageCauser);
    void EnemyFadeOutDeath__DelegateSignature();
    void DebugMulticastHitPointForceSync(float InCurrentHitPoint, float InMaxHitPoint);
    void Dead(bool bInNoPlayerAround);
    void ChangeVisibility(bool bVisible, ESBActorHiddenType HiddenType);
    void CancelGuardBreak();
    void BeginElementBurst(ESBAttribute Attribute);
    void AdjustCurrentStamina(const float AddValue, bool bNotify, int32 CorrectValue, bool bApplyStatusValue);
    void AddActorTagByEnemySet(const FName& Tag);
}; // Size: 0x1740

class ASBEnemyCharacterActionViewer : public AActor
{
    char padding_0[0x248];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x248

class ASBEnemyCreationCharacter : public ASBCharacter
{
    class USBCharaPartsFaceComponent* FaceComp;                                       // 0x0FC0 (size: 0x8)
    class USBCharaCreateComponent* CharaCreateComponent;                              // 0x0FC8 (size: 0x8)

}; // Size: 0xFD0

class ASBEnemyFieldSpawner : public AActor
{
    class USBEnemySpawnSystemComponent* SpawnSystemComponent;                         // 0x0228 (size: 0x8)
    class USBEnemyFieldSpawnTideComponent* FieldSpawnTideComponent;                   // 0x0230 (size: 0x8)
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0238 (size: 0x8)
    FAIFwParameterizedBTRequest FindSpawnPointQuery;                                  // 0x0240 (size: 0x18)

    bool IsCompletedGenerateEnemySpawnPoints();
}; // Size: 0x2E8

class ASBEnemyHabitat : public AVolume
{
    TArray<FSBEnemyHabitatSettings> Enemies;                                          // 0x0260 (size: 0x10)
    float Density;                                                                    // 0x0270 (size: 0x4)
    float RespawnTime;                                                                // 0x0274 (size: 0x4)
    bool bInTideArea;                                                                 // 0x0278 (size: 0x1)
    char padding_0[0x37];                                                             // 0x0279 (size: 0x37)
    TArray<FVector> DebugSpawnLocations;                                              // 0x02B0 (size: 0x10)
    bool bDebugShowSpawnLocation;                                                     // 0x02C0 (size: 0x1)

    void RemoveMetaInfo(class AActor* Actor);
    void OnRep_DebugShowSpawnLocations();
    void LoadEnemyAssets();
    int32 GetSpawnedEnemyCount();
    int32 GetMaxEnemyCount();
    void GenerateSpawnPoints(TArray<FSBEnemySpawnHabitat>& OutSpawnHabitats);
}; // Size: 0x2C8

class ASBEnemyMetaInfo : public AActor
{
    class USBInfluenceSourceComponent* DensitySourceComp;                             // 0x0228 (size: 0x8)
    class USBInfluenceSourceComponent* RestrictionSourceComp;                         // 0x0230 (size: 0x8)
    class ASBEnemyCharacter* OwnerEnemy;                                              // 0x0238 (size: 0x8)

    void OnOwnerDestroyed(class AActor* DestroyedActor);
    void OnOwnerDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
}; // Size: 0x248

class ASBEnemyMotionViewer : public APawn
{
    FName AnimationSearchPath;                                                        // 0x0288 (size: 0x8)

    void SetPlaySpeed(float in_playspeed);
    void SetPlayCharacterInstance(class ASBCharacter* in_PlayCharacterInstance);
    void SetLoopAnimation(bool in_bLoop);
    void SetIsResetTransform(bool in_bResetTransform);
    void PlayAnimSequenceList(const TArray<FString> playanimnamelist);
    class ASBCharacter* GetPlayCharacterInstance();
    TArray<FName> GetAnimSequenceList(FString FilterCharaID, FString FilterString);
}; // Size: 0x2D8

class ASBEnemySenseChanger : public AVolume
{
    ESenseChangerType SenseChangerType;                                               // 0x0260 (size: 0x1)
    bool bAffectAllEnemys;                                                            // 0x0261 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0262 (size: 0x6)
    TArray<FString> TargetEnemyIDs;                                                   // 0x0268 (size: 0x10)
    char padding_1[0x28];                                                             // 0x0278 (size: 0x28)
    FSBSenseDebugDrawData DebugDrawData;                                              // 0x02A0 (size: 0x14)

    void Activate(bool bActivate);
}; // Size: 0x2B8

class ASBEnemySpawner : public AActor
{
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0228 (size: 0x8)
    class UAIFwHierarchyComponent* HierarchyComponent;                                // 0x0230 (size: 0x8)
    class UAIFwSmartObjectUserComponent* SmartObjectUserComponent;                    // 0x0238 (size: 0x8)
    TSubclassOf<class ASBEnemyFieldSpawner> FieldSpawnerClass;                        // 0x0240 (size: 0x8)
    class ASBEnemyFieldSpawner* FieldSpawner;                                         // 0x0248 (size: 0x8)
    class USBActorManager* ActorManager;                                              // 0x0250 (size: 0x8)

    void OnEnemyDestroyed(class AActor* Actor);
}; // Size: 0x2F0

class ASBEnemySupplierSpawnVolume : public ASBTriggerVolume
{
    TArray<class ASBEnemySupplierSpot*> EnemySupplierAssetLists;                      // 0x0260 (size: 0x10)

}; // Size: 0x270

class ASBEnemySupplierSpot : public AActor
{
    char padding_0[0x230];                                                            // 0x0000 (size: 0x0)

    void ServerActorWakeup();
    void RequestActorWakeup();
    void OverlapEndByPlayer();
    void ActorWakeup();
}; // Size: 0x230

class ASBEnemyWaveSpawner : public AActor
{
    FSBEnemyWaveSpawnerOnWaveStarted OnWaveStarted;                                   // 0x0228 (size: 0x10)
    void OnWaveStartedSignature(int32 WaveNo);
    FSBEnemyWaveSpawnerOnAssetLoadBegan OnAssetLoadBegan;                             // 0x0238 (size: 0x10)
    void OnAssetLoadCompletedSignature();
    FSBEnemyWaveSpawnerOnAssetLoadCompleted OnAssetLoadCompleted;                     // 0x0248 (size: 0x10)
    void OnAssetLoadCompletedSignature();
    TMap<class FString, class UDataTable*> WaveTables;                                // 0x0258 (size: 0x50)
    TMap<class FName, class ASBSpawnArea*> SpawnAreas;                                // 0x02A8 (size: 0x50)
    class USBEnemySpawnSystemComponent* SpawnSystemComponent;                         // 0x02F8 (size: 0x8)
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0300 (size: 0x8)
    FAIFwParameterizedBTRequest SpawnTree;                                            // 0x0308 (size: 0x18)

    void StartWave();
    void SetWaveSettings(FString WaveName);
    void RequestAssetLoad();
    void OnWaveStartedSignature__DelegateSignature(int32 WaveNo);
    void OnAssetLoadCompletedSignature__DelegateSignature();
    void OnAssetLoadBeganSignature__DelegateSignature();
    bool IsAssetLoading();
    bool IsAssetLoaded();
    int32 GetTotalWaveCount();
    int32 GetTotalEnemyCount();
    int32 GetCurrentWaveNo();
}; // Size: 0x350

class ASBEngramCannon : public ASBFieldGimmickProjectileSpawnerBase
{
    ESBEngramCannonStatus EngramCannonStatus;                                         // 0x0248 (size: 0x1)
    ESBEngramCannonAttributeBullet EngramCannonAttribute;                             // 0x0249 (size: 0x1)
    bool IsDebugInitStatus;                                                           // 0x024A (size: 0x1)
    char padding_0[0x1];                                                              // 0x024B (size: 0x1)
    FRotator PlayerInputRotation;                                                     // 0x024C (size: 0xC)
    FRotator PlayerInputRotationBase;                                                 // 0x0258 (size: 0xC)
    bool IsChargeGaugeUseItem;                                                        // 0x0264 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0265 (size: 0x3)
    float InitChargeGauge;                                                            // 0x0268 (size: 0x4)
    float ChargeGauge;                                                                // 0x026C (size: 0x4)
    float ChargeGaugeRate;                                                            // 0x0270 (size: 0x4)
    float ChargeCoolTime;                                                             // 0x0274 (size: 0x4)
    float ChargeGaugeTime;                                                            // 0x0278 (size: 0x4)
    char padding_2[0x4];                                                              // 0x027C (size: 0x4)
    FTimerHandle ChargeGaugeTimerHandle;                                              // 0x0280 (size: 0x8)
    FRotator NowCannonRotation;                                                       // 0x0288 (size: 0xC)

    void SetProjectleMesh(class USkeletalMeshComponent* InBaseMesh);
    void SetPlayerInputRotation(FRotator InRotation, bool isNotify);
    void ServerUpdateCannonRotation(FRotator InRotation);
    void ServerStatusChange(ESBEngramCannonStatus InChangeStatus);
    void ServerAddChargeGauge(float AddGauge);
    void RequestUpdateCannonRotation(FRotator InRotation);
    void RequestStatusChange(ESBEngramCannonStatus ToChangeStatus);
    void RequestAddChargeGauge(float AddGauge);
    void OnEngramCannonStatus(ESBEngramCannonStatus NotifyEngramCannonStatus);
    void OnEngramCannonShotting(class AActor* OtherActor);
    void OnEngramCannonRiddingPlayerInput(FRotator InputRotation);
    void OnEngramCannonPlayerExit(bool bSuccessed, ESBEngramCannonStatus InEngramCannonStatus);
    void OnEngramCannonMoveStop();
    void OnEngramCannonMove();
    void InitPlayerInputRotation(FRotator InRotation);
    FRotator GetPlayerInputRotation();
    FRotator GetNowCannonRotation();
    float GetChargeGarge();
    void ClientUpdateCannonRotation(FRotator InRotation);
    void ClientStatusChange(ESBEngramCannonStatus InChangeStatus);
    void ClientEventNotifyStatus();
    void ClearChargeGauge(float SetCoolTime);
    void ChargeGargeTimerStart(float SetTimeRate);
    float ChargeGargeTimerRate();
    FRotator AddPlayerInputRotation();
}; // Size: 0x298

class ASBEventPoint : public AActor
{
    FName QuestID;                                                                    // 0x0228 (size: 0x8)
    FText Label;                                                                      // 0x0230 (size: 0x18)
    class UShapeComponent* SensorComponent;                                           // 0x0248 (size: 0x8)
    class UShapeComponent* CachedSensorComponent;                                     // 0x0250 (size: 0x8)

    int32 StartScript(const FSBScriptActorCreateDesc InCreateDesc);
    void QueryStartScript();
    void HandleSensorComponentBeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& OverlapInfo);
}; // Size: 0x258

class ASBEventPointDefault : public ASBEventPoint
{
    TArray<FName> Events;                                                             // 0x0258 (size: 0x10)

}; // Size: 0x268

class ASBEventPointOffline : public ASBEventPointDefault
{
    char padding_0[0x270];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x270

class ASBEventPointSingle : public ASBEventPoint
{
    FSBScriptActorCreateDesc CreateDesc;                                              // 0x0258 (size: 0x98)

}; // Size: 0x2F0

class ASBEventScheduledActor : public AActor
{
    FSBEventScheduledActorOnEventTermStart OnEventTermStart;                          // 0x0228 (size: 0x10)
    void SBOnEventTermsDelegate();
    FSBEventScheduledActorOnEventTermEnd OnEventTermEnd;                              // 0x0238 (size: 0x10)
    void SBOnEventTermsDelegate();

    void SBOnEventTermsDelegate__DelegateSignature();
    void NotifyEventTermStart(FString TermId);
    void NotifyEventTermEnd(FString TermId);
    bool CheckInTerm(FString InTermId);
    bool BindCheckerByEventTermId(FString TermId);
}; // Size: 0x248

class ASBEventTermSoundTriggerBox : public ATriggerBox
{
    bool IsActive;                                                                    // 0x0230 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0231 (size: 0x7)
    FSBSoundEventTermData SoundEventTermData;                                         // 0x0238 (size: 0x50)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x288

class ASBEventTermSoundTriggerSphere : public ATriggerSphere
{
    bool IsActive;                                                                    // 0x0230 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0231 (size: 0x7)
    FSBSoundEventTermData SoundEventTermData;                                         // 0x0238 (size: 0x50)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x288

class ASBEventTermSoundTriggerVolume : public ATriggerVolume
{
    bool IsActive;                                                                    // 0x0260 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0261 (size: 0x7)
    FSBSoundEventTermData SoundEventTermData;                                         // 0x0268 (size: 0x50)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x2B8

class ASBExitPortal : public APawn
{
    FSBExitPortalOnExitDecided OnExitDecided;                                         // 0x0288 (size: 0x10)
    void OnExitDecided();

    void OnExitDecided__DelegateSignature();
    void CallOnExitDecided();
}; // Size: 0x298

class ASBExtraFootHold : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    bool IsPlayerAerialAttacking(class ASBPlayerCharacter* TmpLocalPlayer);
    void DebugFlyinStatusChange();
}; // Size: 0x228

class ASBExtraNpcCharacter : public ASBNpcCharacter
{
    char padding_0[0x920];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x920

class ASBFactionCoordinator : public ASBSquadAI
{
    TSubclassOf<class ASBSquadAI> RelaxedCoordinatorClass;                            // 0x0240 (size: 0x8)
    char padding_0[0x8];                                                              // 0x0248 (size: 0x8)
    TSubclassOf<class ASBSquadAI> CombatCoordinatorClass;                             // 0x0250 (size: 0x8)
    TArray<FSBCombatCoordinatorGroup> CombatCoordinatorGroups;                        // 0x0258 (size: 0x10)

}; // Size: 0x2B8

class ASBFallingRock : public AActor
{
    char padding_0[0x230];                                                            // 0x0000 (size: 0x0)

    void StartFallingRock(FVector StartLocation);
    void ServerFallingRockStart(FVector StartLocation);
    void RequestFallingRockStart(FVector InRotation);
    void OnStartFallingRock(FVector StartLocation);
    void OnFallingRockStart(FVector StartLocation);
    void MulticastFallingRockStart(FVector StartLocation);
    void ClientFallingRockStart(FVector StartLocation);
}; // Size: 0x230

class ASBFieldActorConditionPoint : public ASBFieldActorPoint
{
    bool bConditionPointEnable;                                                       // 0x02C0 (size: 0x1)
    bool bDebugDraw;                                                                  // 0x02C1 (size: 0x1)
    char padding_0[0x6];                                                              // 0x02C2 (size: 0x6)
    FSBConditionPointProjectileParams Params;                                         // 0x02C8 (size: 0x28)
    class UAkAudioEvent* ExposionAudio;                                               // 0x02F0 (size: 0x8)
    class UParticleSystemComponent* ParticleComp;                                     // 0x02F8 (size: 0x8)
    class USBInteractionTargetComponent* InteractionTargetComponent;                  // 0x0300 (size: 0x8)
    class UStaticMeshComponent* StaticMeshComponent;                                  // 0x0308 (size: 0x8)
    class USphereComponent* HindranceComponent;                                       // 0x0310 (size: 0x8)
    class USBBattleStatusComponent* BattleStatusComponent;                            // 0x0318 (size: 0x8)
    class USBCollisionGroupComponent* CollisionGroupComponent;                        // 0x0320 (size: 0x8)
    class ASBBattleArea* CurrentBattleArea;                                           // 0x0328 (size: 0x8)

    FVector GetTakeDamagePoint();
}; // Size: 0x358

class ASBFieldActorFreeBuffPoint : public ASBFieldActorPoint
{
    class USBInteractionTargetComponent* InteractionTargetComponent;                  // 0x0260 (size: 0x8)
    char padding_0[0x38];                                                             // 0x0268 (size: 0x38)
    FTransform InitTransform;                                                         // 0x02A0 (size: 0x30)
    class ASBMobCharacter* TargetNpc;                                                 // 0x02D0 (size: 0x8)
    char padding_1[0x8];                                                              // 0x02D8 (size: 0x8)
    FSBFieldActorFreeBuffPointOnUpdateInfoDelegate OnUpdateInfoDelegate;              // 0x02E0 (size: 0x10)
    void OnUpdateInfoDelegate();

    bool UpdateNpcActivation();
    void PostInteracFreeBufftPoint(ESBFreeBuffPointLotResult Result, const TArray<ESBFreeBuffPointType>& BuffTypes);
    void OverlapBeginFreeBuffPoint(class AActor* InOtherActor, FRotator ViewRotation, const class UDataTable* DataTable);
    void OnUpdateInfoDelegate__DelegateSignature();
    bool IsSpawned();
    bool IsNpcBuffPoint();
    void InteractFreeBuffPoint(class AActor* InOtherActor, const FRotator& ViewRotation);
    FName GetNpcProfileDataId();
    bool GetIsActivate();
    ESBFreeBuffPointView GetBuffPointView();
    void BuffActivate(const TArray<ESBFreeBuffPointType>& BuffTypes);
    void Appear();
}; // Size: 0x300

class ASBFieldActorGatherPoint : public ASBFieldActorPoint
{
    class USBInteractionTargetComponent* InteractionTargetComponent;                  // 0x0260 (size: 0x8)
    char padding_0[0x31];                                                             // 0x0268 (size: 0x31)
    ESBTreasureBoxRarity GatherRarity;                                                // 0x0299 (size: 0x1)
    char padding_1[0x6];                                                              // 0x029A (size: 0x6)
    FTransform InitTransform;                                                         // 0x02A0 (size: 0x30)

    void Suicide();
    void PostInteractPoint(ESBGatherPointLotResult Result, const TArray<FGatherPointLotResult>& LotResults);
    void OnResult(ESBGatherPointLotResult Result, FString GetObjectId, const TArray<FGatherPointLotResult>& LotResults);
    void MotionEnd();
    void InteractPoint(class AActor* InOtherActor, const FRotator& ViewRotation);
    ESBGatherPointType GetType();
    TEnumAsByte<EPhysicalSurface> GetGatherSoundSurface();
    EGatherHeight GetGatherPosition();
    void Disappear();
    void ClearInteractIcon();
    void Appear();
}; // Size: 0x2E0

class ASBFieldActorPoint : public AActor
{
    class USceneComponent* RootComp;                                                  // 0x0230 (size: 0x8)
    class USBGroundComponent* GroundComp;                                             // 0x0238 (size: 0x8)

    bool IsEnable();
    bool IsDiscovery();
    bool IsActive();
    int32 GetAreaID();
    void EnableSearchPoint();
    void DisableSearchPoint();
    void DeactiveSearchPoint();
    void ActiveSearchPoint();
}; // Size: 0x258

class ASBFieldActorTreasureBox : public ASBFieldActorPoint
{
    class USBInteractionTargetComponent* InteractionTargetComponent;                  // 0x0260 (size: 0x8)
    char padding_0[0x27];                                                             // 0x0268 (size: 0x27)
    ESBTreasureBoxRarity Rarity;                                                      // 0x028F (size: 0x1)
    char padding_1[0x18];                                                             // 0x0290 (size: 0x18)
    class AActor* TreasureSpawner;                                                    // 0x02A8 (size: 0x8)

    void PreOpenBox(class AActor* InOtherActor, const FRotator& ViewRotation);
    void PostOpenBox(ESBTreasureBoxLotResult Result, const TArray<FSBTreasureBoxLotResult>& LotResults);
    void PostGetDropTreasure(ESBTreasureBoxLotResult Result, const TArray<FSBTreasureBoxLotResult>& LotResults);
    void PostBuffActivate(class AActor* InOtherActor);
    void InteractDeactivate();
    FString GetTag();
    ESBTreasureBoxRewardType GetDropTreasureBoxRewardType();
    void DropTreasure(class AActor* InOtherActor, int32 MinMoney, int32 MaxMoney, ESBTreasureBoxRewardType InDropTreasureReward);
    void Disappear();
    void Appear(bool IsDropPlaySE);
}; // Size: 0x2B0

class ASBFieldActorWarpPoint : public ASBFieldActorPoint
{
    FVector RestartAjustLocation;                                                     // 0x0260 (size: 0xC)
    FRotator ArrivalAtRotation;                                                       // 0x026C (size: 0xC)
    FRotator ArrivalAtCameraRotation;                                                 // 0x0278 (size: 0xC)
    bool bIsAvailableForSearchStartPoint;                                             // 0x0284 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0285 (size: 0x3)
    TArray<FSBWarpPointInfo> WarpPointList;                                           // 0x0288 (size: 0x10)
    FName WarpPointId;                                                                // 0x0298 (size: 0x8)
    float WarpApperRandomDistanceX;                                                   // 0x02A0 (size: 0x4)
    float WarpApperRandomDistanceY;                                                   // 0x02A4 (size: 0x4)
    class UParticleSystemComponent* ParticleComp;                                     // 0x02A8 (size: 0x8)
    class USBInteractionTargetComponent* InteractionTargetComponent;                  // 0x02B0 (size: 0x8)

    void SetupWarp();
    void ReceiveActivate(class ASBPlayerState* Player, bool bIsNewActivattion);
    void OnFinishedWarpPointActivated();
    bool IsWarpActivattion();
    int32 GetWarpPointInfoNum();
    TArray<FSBWarpPointInfo> GetWarpPointInfoList();
    FSBWarpPointInfo GetWarpPointInfo(const int32 Index);
}; // Size: 0x2B8

class ASBFieldGimmickProjectileSpawnerBase : public AActor
{
    char padding_0[0x230];                                                            // 0x0000 (size: 0x0)

    void RegisterSpawnerMesh(class USkeletalMeshComponent* InSpawnerMesh);
}; // Size: 0x230

class ASBFieldSplineActor : public AActor
{
    class USceneComponent* SceneRoot;                                                 // 0x0228 (size: 0x8)
    class USplineComponent* Spline;                                                   // 0x0230 (size: 0x8)

    class USplineComponent* GetSplineComponent();
}; // Size: 0x238

class ASBFieldTravelTrigger : public ATriggerBase
{
    class UBoxComponent* PreloadCollisionComponent;                                   // 0x0230 (size: 0x8)
    FName TravelFieldId;                                                              // 0x0238 (size: 0x8)
    FString TravelFieldMapName;                                                       // 0x0240 (size: 0x10)
    FString SpawnPortal;                                                              // 0x0250 (size: 0x10)
    bool IsSpawnEffect;                                                               // 0x0260 (size: 0x1)
    bool KeepLocation;                                                                // 0x0261 (size: 0x1)
    bool IsCityEntrance;                                                              // 0x0262 (size: 0x1)
    char padding_0[0x5];                                                              // 0x0263 (size: 0x5)
    class ATargetPoint* DemoTargetPoint;                                              // 0x0268 (size: 0x8)
    class ASBFieldSplineActor* ReturnPointSpline;                                     // 0x0270 (size: 0x8)
    FDataTableRowHandle EventTrigger;                                                 // 0x0278 (size: 0x10)

    void OnPreloadCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    void OnMatchmakingConfirmed(class USBMatchingGameState* MO, bool bConfirmed);
    void OnCollisionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    void OnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    void MulticastFieldTravel(class ASBPlayerCharacter* PlayerCharacter);
    void FieldTravel_Impl(class ASBPlayerCharacter* PlayerCharacter);
}; // Size: 0x298

class ASBFishingFish : public AActor
{
    class UBoxComponent* BoundsComponent;                                             // 0x0228 (size: 0x8)
    class USBSkeletalMeshComponent* SkeletalMeshComponent;                            // 0x0230 (size: 0x8)

}; // Size: 0x238

class ASBFishingGame : public ASBInteractionSwBase
{
    class USceneComponent* SceneRoot;                                                 // 0x0228 (size: 0x8)
    class USBInteractionTargetComponent* InteractionTargetComponent;                  // 0x0230 (size: 0x8)
    class UDataTable* FishDataTable;                                                  // 0x0238 (size: 0x8)
    FDataTableRowHandle FishLotDataHandle;                                            // 0x0240 (size: 0x10)
    FDataTableRowHandle ItemLotDataHandle;                                            // 0x0250 (size: 0x10)
    FName FishId;                                                                     // 0x0260 (size: 0x8)
    float FishScale;                                                                  // 0x0268 (size: 0x4)
    float FishMaxStamina;                                                             // 0x026C (size: 0x4)
    float FishSpeed;                                                                  // 0x0270 (size: 0x4)
    float BreakTimeMin;                                                               // 0x0274 (size: 0x4)
    float BreakTimeMax;                                                               // 0x0278 (size: 0x4)
    float TiredTimeMin;                                                               // 0x027C (size: 0x4)
    float TiredTimeMax;                                                               // 0x0280 (size: 0x4)
    float WiggleStrength;                                                             // 0x0284 (size: 0x4)
    float WiggleSpeed;                                                                // 0x0288 (size: 0x4)
    float WiggleSpeedTired;                                                           // 0x028C (size: 0x4)
    float TiredRate;                                                                  // 0x0290 (size: 0x4)
    float BigFishLimitLength;                                                         // 0x0294 (size: 0x4)
    float TmpFishLength;                                                              // 0x0298 (size: 0x4)
    char padding_0[0x4];                                                              // 0x029C (size: 0x4)
    TMap<class ASBPlayerCharacter*, class FSBFishGameInfoPerPlayer> FishInfoPerPlayer; // 0x02A0 (size: 0x50)
    ESBFishRarityClassId FishResultRarityClassId;                                     // 0x02F0 (size: 0x1)
    ESBFishScaleClassId FishResultScaleClassId;                                       // 0x02F1 (size: 0x1)
    bool FishResultIsHugeItem;                                                        // 0x02F2 (size: 0x1)
    char padding_1[0x1];                                                              // 0x02F3 (size: 0x1)
    int32 FishResultItemId;                                                           // 0x02F4 (size: 0x4)
    int32 FishResultItemAmount;                                                       // 0x02F8 (size: 0x4)
    char padding_2[0x139C];                                                           // 0x02FC (size: 0x139C)
    class USBInteractionMoveComponent* InteractionMoveComponent;                      // 0x1698 (size: 0x8)

    void UploadFishingResult(const class ASBPlayerCharacter* InPlayerCharacter, const FName InFishId, const int32 InItemID, const float InLength, const int32 InItemAmount);
    float UpdateFishStamina(bool IsSamePosition, bool IsReelLine, ESBFishMoveState InFishMoveState, float InCurrentStamina, float InMaxStamina);
    void UpdateDebugFishingParam();
    void SetTmpFishingFishInfo(const class ASBPlayerCharacter* InPlayerCharacter, FName InFishId, int32 InItemID, float InLength);
    void SetFishingLineVisibility(bool bIsVisible);
    void SetFishingLineBaseLocation(FVector BaseLocation);
    void ServerSetFishDebugParam(class ASBPlayerCharacter* Player, const FSBFishDebugParam& FishDebugParam);
    void ServerChangeState(class ASBPlayerCharacter* Player, const ESBFishingGameState NewState, FString InOption);
    void PushLog(FString LogText);
    void OnUploadFishingResultCompleted(const class ASBPlayerCharacter* InPlayerCharacter, bool Success, const FName InFishId, const int32 InItemID, const float InFishLength, const int32 InItemAmount);
    float LotFishScaleRarityWithRareItemRate(const FName FishId, int32 RarityItemId, float RareItemRate, float ave, float dev);
    float LotFishScaleRarity(float ave, float dev);
    FString LotFishId();
    bool IsFishingPointCapacityFullTest();
    bool IsFadeEnable();
    bool IsDebugNoLineBreak();
    bool IsDebugHookNoTimeout();
    bool IsDebugFishStaminaLow();
    bool IsDebugFishStaminaInfinite();
    void InitFishLotTable();
    class USBPlayerFishingComponent* GetPlayerFishingComponent(class AActor* Actor);
    float GetMaxFishScleTest(float& OverMaxRate, float MaxScale, int32 tryNum, float ave, float dev);
    class USBInteractionMoveComponent* GetInteractionMoveComponent();
    int32 GetFishRarityItem(const TArray<FSBFishRarityItem>& ItemArray, float Rarity);
    bool GetFishingResultItemId(FName InFishId, float InRarity, int32& OutItemId, float& OutLength, int32& OutAmount);
    class ASBFishingGame* GetFishingGame(class AActor* Actor);
    bool GetFishingFishScaleParam(const FName InFishId, const float InRarity, float& OutScale, float& OutStamina, float& OutSpeed, float& OutLength);
    bool GetFishingFishName(const FName InFishId, const float InRarity, FString& OutFishName, FString& OutFishDesc);
    bool GetFishingFishLength(const FName InFishId, const float InRarity, float& OutLength);
    void FishingBattleFishTick();
    void ClientStartFishing(int32 InPositionId);
    void ClientNoVacantEnd();
    void ClientNotifyPlayerReady(class ASBPlayerCharacter* PlayerCharacter);
    void ClientInitFish(const FName InFishId, float InRarity);
    void ClentShowResult(bool Success, FName ResultFishId, int32 ResultItemId, float ResultFishLength, int32 ResultItemAmount, bool NewFish, bool NewRecord, int32 RetCode);
    float CalcMinimumTimeForFishFight(float InMaxStamina);
}; // Size: 0x16A0

class ASBFoliageReactionWave : public AActor
{
    float Radius;                                                                     // 0x0228 (size: 0x4)
    float Strength;                                                                   // 0x022C (size: 0x4)
    float CurrentTime;                                                                // 0x0230 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0234 (size: 0x4)
    class USBFoliageReactionCollisionComp* ReactionCollisionComponent;                // 0x0238 (size: 0x8)

    class USBFoliageReactionCollisionComp* GetFoliageReactionCollisionComponent();
}; // Size: 0x240

class ASBFoliageReactions : public AActor
{
    bool Available;                                                                   // 0x0228 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0229 (size: 0x3)
    FVector CurrentCameraLocation;                                                    // 0x022C (size: 0xC)
    FVector CurrentCameraVector;                                                      // 0x0238 (size: 0xC)
    float CurrentCameraCullingFOV;                                                    // 0x0244 (size: 0x4)
    char padding_1[0x3C];                                                             // 0x0248 (size: 0x3C)
    int32 ReactionDrawCharacterMaxNum;                                                // 0x0284 (size: 0x4)
    float ReactionDrawCharacterCullingFOVOfst;                                        // 0x0288 (size: 0x4)
    float BrushSizeMinDist;                                                           // 0x028C (size: 0x4)
    float BrushSizeMaxDist;                                                           // 0x0290 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0294 (size: 0x4)
    TArray<FSBFoliageReactionData> FoliageReactionDatas;                              // 0x0298 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> MaterialInstancesRadial;                  // 0x02A8 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> MaterialInstancesSpeed;                   // 0x02B8 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> MaterialInstancesHeight;                  // 0x02C8 (size: 0x10)

    void UpdateBoxInfo(class UBoxComponent* Box);
    void SelectCharacters(TArray<class AActor*>& OverlappingActors);
    float GetBrushSizeScale(FVector Location);
    void DrawFoliageReactionMaterial(class UObject* WorldContextObject, class UTextureRenderTarget2D* TargetRT, class UMaterialInterface* Material, ESBFoliageReactions Mode);
    void DrawFoliageReactionDebug();
    bool CreateFoliageReactionDatas();
    void CalcDrawLocations(const FSBFoliageReactionData& InReactionData, FVector2D CanvasScreenSize, float ScaleParam, FVector2D& ScreenPosition, FVector2D& SizeOnScreen, FVector2D& HeightInfo, float& Strength, float& SpeedScalar);
}; // Size: 0x2E0

class ASBFoliageSoundActor : public AActor
{
    float FoliageSoundPlayDistance;                                                   // 0x0228 (size: 0x4)
    char padding_0[0x4];                                                              // 0x022C (size: 0x4)
    TArray<FSBFoliageSoundType> FoliageSoundTypes;                                    // 0x0230 (size: 0x10)
    float ParticleWindDirectionPower;                                                 // 0x0240 (size: 0x4)
    float ParticleWindNumPower;                                                       // 0x0244 (size: 0x4)
    TArray<FSBFoliageParticleType> FoliageParticleTypes;                              // 0x0248 (size: 0x10)
    TArray<FSBFoliageSoundInstance> FoliageSoundInstances;                            // 0x0258 (size: 0x10)
    char padding_1[0x10];                                                             // 0x0268 (size: 0x10)
    TArray<FSBFoliageParticleInstance> FoliageParticleInstances;                      // 0x0278 (size: 0x10)
    TArray<int32> PlayingSoundNumPerType;                                             // 0x0288 (size: 0x10)
    char padding_2[0x4];                                                              // 0x0298 (size: 0x4)
    bool bGrassSoundAvailable;                                                        // 0x029C (size: 0x1)
    bool bDrawGrassSoundDebug;                                                        // 0x029D (size: 0x1)
    char padding_3[0x2];                                                              // 0x029E (size: 0x2)
    int32 GrassSoundDivision;                                                         // 0x02A0 (size: 0x4)
    float GrassSoundUnitSize;                                                         // 0x02A4 (size: 0x4)
    int32 GrassSoundCheckInstanceCountThreshold;                                      // 0x02A8 (size: 0x4)
    char padding_4[0x4];                                                              // 0x02AC (size: 0x4)
    TArray<FSBGrassSoundEventList> GrassSoundEvents;                                  // 0x02B0 (size: 0x10)
    TArray<FSBGrassSoundMeshList> GrassSoundMeshes;                                   // 0x02C0 (size: 0x10)
    TMap<class UStaticMesh*, class FSBGrassSoundMeshList> GrassSoundMeshesMap;        // 0x02D0 (size: 0x50)
    TMap<class FVector2D, class UAkComponent*> GrassSoundInstances;                   // 0x0320 (size: 0x50)
    TArray<class UFoliageInstancedStaticMeshComponent*> GrassFoliageMeshComponents;   // 0x0370 (size: 0x10)

    void UpdateWindSpeedRTPC();
    void InitFoliageSoundTick();
    void InitFoliageParticleTick();
    void GrassSoundInitialize(FVector2D basePoint);
    class UParticleSystem* GetFoliageParticleSystem(int32 ID);
    class UAkAudioEvent* GetAudioStartEvent(int32 ID);
    void FoliageSoundUpdate();
    void FoliageSoundTypesOrganize();
    void FoliageSoundTick(FVector Center);
    void FoliageParticleUpdate();
    void FoliageParticleTypesOrganize();
    void FoliageParticleTick(FVector Center);
    void FoliageParticleEditorDebugDisplay();
    void AddFoliageSoundType(class UStaticMesh* Mesh, class UAkAudioEvent* AkAudio, FVector Offset);
    bool AddFoliageParticleType(class UStaticMesh* Mesh, TSoftObjectPtr<UMaterialInterface> MaterialOverride, class UParticleSystem* Particle, FVector Offset, bool bRotation, float Distance);
}; // Size: 0x390

class ASBFrameGrabberActor : public AActor
{
    TArray<uint8> CaptureFrameData;                                                   // 0x0228 (size: 0x10)
    class UTexture2D* CaptureFrameTexture;                                            // 0x0238 (size: 0x8)
    bool bEveryFrame;                                                                 // 0x0240 (size: 0x1)

    void StopFrameGrab();
    bool StartFrameGrab(bool bEveryFrame);
}; // Size: 0x258

class ASBFreeArrangeActor : public AASCharacter
{
    FSBFreeArrangeActorOnSetFreeArrangingPlayerDelegate OnSetFreeArrangingPlayerDelegate; // 0x0580 (size: 0x10)
    void OnSetFreeArrangingPlayer();
    class ASBPlayerCharacter* FreeArrangingPlayer;                                    // 0x0590 (size: 0x8)
    bool IsFreeArranging;                                                             // 0x0598 (size: 0x1)

    void UpdateServerTmpLocationAndRotation(FVector InVector, FRotator InRotator);
    void SetIsFreeArranging(bool InFlag);
    void ServerUpdateFreeArrangeActorLocationAndRotation(FVector InVector, FRotator InRotator);
    void RequestUpdateFreeArrangeActorLocationAndRotation(FVector InVector, FRotator InRotator);
    void OnSetupParameters(int32 ActorID);
    void OnSetFreeArrangingPlayer__DelegateSignature();
    void OnRep_FreeArrangingPlayer();
    void GetServerTmpLocationAndRotation(FVector& OutVector, FRotator& OutRotator);
    void GetHitPointReticleSphereTrace(class ASBPlayerCharacter* PlayerCharacter, float Radius, FVector& OutVector);
    void ClientUpdateFreeArrangeActorLocationAndRotation(FVector InVector, FRotator InRotator);
}; // Size: 0x5C0

class ASBFreeBuffNpcSpawnPoint : public AActor
{
    int32 ParamIndex;                                                                 // 0x0234 (size: 0x4)
    TArray<FSBFreeBuffNpcSpawnParameter> Parameters;                                  // 0x0238 (size: 0x10)
    ESBNpcSpawnPriority SpawnPriority;                                                // 0x0248 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0249 (size: 0x3)
    FSBNpcInteractionSettings InteractionSettings;                                    // 0x024C (size: 0x40)
    char padding_1[0x4];                                                              // 0x028C (size: 0x4)
    FDataTableRowHandle FieldStatusSettingHandle;                                     // 0x0290 (size: 0x10)
    FString Animation;                                                                // 0x02A0 (size: 0x10)
    FString AnimationSubCommand;                                                      // 0x02B0 (size: 0x10)
    class UDataTable* OverrideWaitParamTable;                                         // 0x02C0 (size: 0x8)

}; // Size: 0x2C8

class ASBFreeBuffSpot : public ATargetPoint
{
    class USBInteractionTargetAuthorComponent* InteractionTargetAuthorComponent;      // 0x0228 (size: 0x8)
    TSubclassOf<class ASBFieldActorFreeBuffPoint> TargetClass;                        // 0x0230 (size: 0x8)
    int32 FreeBuffPointId;                                                            // 0x0238 (size: 0x4)
    char padding_0[0x4];                                                              // 0x023C (size: 0x4)
    FString FreeBuffPointTag;                                                         // 0x0240 (size: 0x10)
    ESBFreeBuffPointType FreeBuffPointType;                                           // 0x0250 (size: 0x1)
    ESBFreeBuffPointView FreeBuffPointView;                                           // 0x0251 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0252 (size: 0x2)
    FName NpcSpawnerTag;                                                              // 0x0254 (size: 0x8)

    bool IsValidFreeBuffPoint();
    bool IsNpcBuffPoint();
}; // Size: 0x260

class ASBGameMode : public ASBGameModeBase
{
    FString GameModeShortName;                                                        // 0x0328 (size: 0x10)
    float StartPointRandomX;                                                          // 0x0338 (size: 0x4)
    float StartPointRandomY;                                                          // 0x033C (size: 0x4)
    FSBGameModeOnRestartPlayer OnRestartPlayer;                                       // 0x0340 (size: 0x10)
    void OnRestartPlayer(class ASBPlayerCharacter* PlayerCharacter);
    char padding_0[0x4];                                                              // 0x0350 (size: 0x4)
    float PlayerDiedCountDown;                                                        // 0x0354 (size: 0x4)
    int32 MinutesPerDay;                                                              // 0x0358 (size: 0x4)
    int32 MinutesPerDaytime;                                                          // 0x035C (size: 0x4)
    bool EnableTimeProgression;                                                       // 0x0360 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0361 (size: 0x3)
    int32 GameTime_Hour;                                                              // 0x0364 (size: 0x4)
    int32 GameTime_Minute;                                                            // 0x0368 (size: 0x4)
    uint8 bPvP;                                                                       // 0x036C (size: 0x1)
    char padding_2[0x3];                                                              // 0x036D (size: 0x3)
    ESBLocationType LocationType;                                                     // 0x0370 (size: 0x1)
    ESBPartyChainSettingType PartyChainSettingType;                                   // 0x0371 (size: 0x1)
    bool bEnableReplicationGraph;                                                     // 0x0372 (size: 0x1)
    char padding_3[0x5];                                                              // 0x0373 (size: 0x5)
    TSubclassOf<class USBReplicationGraph> ReplicationGraphClass;                     // 0x0378 (size: 0x8)

    void SeamlessTravelTimer(FString TravelURL);
    void OnRestartPlayer__DelegateSignature(class ASBPlayerCharacter* PlayerCharacter);
    void OnBeginPlayerCharacter(class UObject* Sender, class UObject* Param);
    void NotifyPlayerTeleportedWithDelay(class ASBPlayerCharacter* Player);
    void InitGameModeInfoOnMasterDataAvailable();
    void DefaultTimer();
    void CharacterDelayJoin(class USBNetConnection* Connection);
}; // Size: 0x3F8

class ASBGameModeBase : public AGameMode
{
    int32 NumGmJumpers;                                                               // 0x0310 (size: 0x4)

}; // Size: 0x318

class ASBGameMode_BattleArena : public ASBGameMode_DungeonNormal
{
    char padding_0[0x608];                                                            // 0x0000 (size: 0x0)

    void SetBattleArenaClearTime();
    void EventOnRushTime();
}; // Size: 0x608

class ASBGameMode_DemoCapture : public ASBGameMode
{
    char padding_0[0x3F8];                                                            // 0x0000 (size: 0x0)

    void TimerTick();
}; // Size: 0x3F8

class ASBGameMode_Dungeon : public ASBGameMode
{
    FSBGameMode_DungeonOnSpawnEnemyDelegate OnSpawnEnemyDelegate;                     // 0x03F8 (size: 0x10)
    void OnSpawnEnemyDelegate(const class ASBEnemyCharacter* Character);
    FSBGameMode_DungeonOnDeathEnemyDelegate OnDeathEnemyDelegate;                     // 0x0408 (size: 0x10)
    void OnDeathEnemyDelegate(const class ASBEnemyCharacter* Character, const class AActor* DamageCauser);
    FSBGameMode_DungeonOnDeathPlayerDelegate OnDeathPlayerDelegate;                   // 0x0418 (size: 0x10)
    void OnDeathPlayerDelegate(const class ASBPlayerCharacter* Character, const class AActor* DamageCauser);
    FSBGameMode_DungeonOnWipedOutPlayersDelegate OnWipedOutPlayersDelegate;           // 0x0428 (size: 0x10)
    void OnWipedOutPlayersDelegate();
    FSBGameMode_DungeonOnResurrectPlayerDelegate OnResurrectPlayerDelegate;           // 0x0438 (size: 0x10)
    void OnResurrectPlayerDelegate(const class ASBPlayerCharacter* Character);
    class USBMatchingRescueRequester* MatchingRescueRequester;                        // 0x0448 (size: 0x8)
    FSBGameMode_DungeonOnDungeonProcessMessage OnDungeonProcessMessage;               // 0x0450 (size: 0x10)
    void OnDungeonProcessMessage(const FString Message);
    FSBGameMode_DungeonOnDungeonScriptRequested OnDungeonScriptRequested;             // 0x0460 (size: 0x10)
    void OnDungeonScriptRequested(const FString ScriptId);
    FSBGameMode_DungeonOnAllPlayerLoadedDelegete OnAllPlayerLoadedDelegete;           // 0x0470 (size: 0x10)
    void OnAllPlayerLoaded();
    FSBGameMode_DungeonOnStartGameDelegate OnStartGameDelegate;                       // 0x0480 (size: 0x10)
    void OnStartGame();
    FSBGameMode_DungeonOnPostPlayerLoginDelegate OnPostPlayerLoginDelegate;           // 0x0490 (size: 0x10)
    void PostPlayerLogin();
    int32 RoundTime;                                                                  // 0x04A0 (size: 0x4)
    int32 LeaveTime;                                                                  // 0x04A4 (size: 0x4)
    int32 InstanceLifeTime;                                                           // 0x04A8 (size: 0x4)
    float ReadyLimit;                                                                 // 0x04AC (size: 0x4)
    float ReadyCount;                                                                 // 0x04B0 (size: 0x4)
    float StartCountDownTime;                                                         // 0x04B4 (size: 0x4)
    char padding_0[0x10];                                                             // 0x04B8 (size: 0x10)
    FDateTime DungeonStartDateTimeUTC;                                                // 0x04C8 (size: 0x8)
    FDateTime DungeonClearDateTimeUTC;                                                // 0x04D0 (size: 0x8)
    char padding_1[0x38];                                                             // 0x04D8 (size: 0x38)
    TSubclassOf<class ASBGameReadyBase> GameReadyClass;                               // 0x0510 (size: 0x8)

    void TeleportAllPlayersAndBattleNpc(FVector Location, FRotator Rotation, float PosOffset, bool bTeleportNpc, bool bWithFade, float DelayTime);
    void TeleportAllBattleNpc();
    void SetGodModeAllPlayerAndBuddy(bool sw);
    void SetDungeonEnemyAIStop(bool sw);
    void SetAllEnemysInvincibleMode(bool sw);
    void ResurrectAllPlayers();
    void RespawnAllPlayers(bool bDeadOnly);
    void PostPlayerLogin__DelegateSignature();
    void OnWipedOutPlayersDelegate__DelegateSignature();
    void OnStartGame__DelegateSignature();
    void OnSpawnEnemyDelegate__DelegateSignature(const class ASBEnemyCharacter* Character);
    void OnResurrectPlayerDelegate__DelegateSignature(const class ASBPlayerCharacter* Character);
    void OnDungeonScriptRequested__DelegateSignature(const FString ScriptId);
    void OnDungeonProcessMessage__DelegateSignature(const FString Message);
    void OnDeathPlayerDelegate__DelegateSignature(const class ASBPlayerCharacter* Character, const class AActor* DamageCauser);
    void OnDeathEnemyDelegate__DelegateSignature(const class ASBEnemyCharacter* Character, const class AActor* DamageCauser);
    void OnAllPlayerLoaded__DelegateSignature();
    bool KillDestructibleObject(class ASBDestructible* DestructibleObject);
    void KillAllEnemys();
    void InitGameContentInfoOnMaplevelInfoInitialized();
    void FinishMatch();
    void DungeonStartGame();
}; // Size: 0x598

class ASBGameMode_DungeonNormal : public ASBGameMode_Dungeon
{
    TArray<FSBDungeonScriptQueue> DungeonScriptQueue;                                 // 0x0598 (size: 0x10)
    int32 ScriptRequestId;                                                            // 0x05A8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x05AC (size: 0x4)
    FSBGameMode_DungeonNormalOnClearDungeonDelegate OnClearDungeonDelegate;           // 0x05B0 (size: 0x10)
    void OnClearDungeon();
    FSBGameMode_DungeonNormalOnRespawnFrontlineUpdated OnRespawnFrontlineUpdated;     // 0x05C0 (size: 0x10)
    void OnRespawnFrontlineUpdated();
    char padding_1[0x10];                                                             // 0x05D0 (size: 0x10)
    FName RespawnFrontline;                                                           // 0x05E0 (size: 0x8)

}; // Size: 0x5F8

class ASBGameMode_DungeonOffline : public ASBGameMode_DungeonNormal
{
    bool bUseNetData;                                                                 // 0x05F8 (size: 0x1)

}; // Size: 0x600

class ASBGameMode_DungeonScenario : public ASBGameMode_DungeonNormal
{
    char padding_0[0x5F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x5F8

class ASBGameMode_DungeonScoreAttack : public ASBGameMode_DungeonNormal
{
    char padding_0[0x600];                                                            // 0x0000 (size: 0x0)

    void InteractScoreSupplier(const class AActor* Supplier, class ASBPlayerController* PlayerController);
    void ExtendGameLimitTime(float ExtraTime, FVector ActorLocation);
}; // Size: 0x600

class ASBGameMode_DungeonTimeAttack : public ASBGameMode_DungeonNormal
{
    char padding_0[0x600];                                                            // 0x0000 (size: 0x0)

    void SetClearTimeAndLapTime();
}; // Size: 0x600

class ASBGameMode_DxBattle : public ASBGameMode_DungeonNormal
{
    class ASBDxBattleGameInstance* m_pDxBattleGameInstance;                           // 0x05F8 (size: 0x8)

    class ASBDxBattleGameInstance* GetDxBattleGameInstance();
}; // Size: 0x608

class ASBGameMode_InstanceArea : public ASBGameMode_DungeonNormal
{
    char padding_0[0x5F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x5F8

class ASBGameMode_KwmBattle : public ASBGameMode_DungeonNormal
{
    char padding_0[0x5F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x5F8

class ASBGameMode_Lobby : public ASBGameMode
{
    char padding_0[0x448];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x448

class ASBGameMode_PublicDungeon : public ASBGameMode
{
    char padding_0[0x3F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x3F8

class ASBGameMode_RaidBattle : public ASBGameMode_DungeonNormal
{
    class ASBRaidBattleGameInstance* m_pRaidBattleGameInstance;                       // 0x0600 (size: 0x8)

}; // Size: 0x608

class ASBGameMode_RankUpExam : public ASBGameMode_DungeonNormal
{
    char padding_0[0x5F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x5F8

class ASBGameMode_SksBattle : public ASBGameMode_BattleArena
{
    char padding_0[0x608];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x608

class ASBGameMode_Theater : public ASBGameMode_DungeonOffline
{
    char padding_0[0x610];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x610

class ASBGameMode_TowerSurvival : public ASBGameMode_DungeonNormal
{
    bool CurrentFloorCleared;                                                         // 0x0600 (size: 0x1)

    void SetRespawnPointActor(class AActor* InRespawnPointActor);
    void DebugSetNextFloor(int32 InFloor);
}; // Size: 0x608

class ASBGameMode_Tutorial : public ASBGameMode_Dungeon
{
    bool bUseNetData;                                                                 // 0x0598 (size: 0x1)

}; // Size: 0x5A0

class ASBGameReadyBase : public AActor
{
    class UStaticMeshComponent* StaticMeshComponent;                                  // 0x0228 (size: 0x8)

}; // Size: 0x230

class ASBGameSession : public AGameSession
{
    int32 MaxGMJumpers;                                                               // 0x0240 (size: 0x4)

}; // Size: 0x338

class ASBGameState : public AGameState
{
    FString GameModeStr;                                                              // 0x0298 (size: 0x10)
    int64 NetId;                                                                      // 0x02A8 (size: 0x8)
    char padding_0[0x18];                                                             // 0x02B0 (size: 0x18)
    int32 MinutesPerDay;                                                              // 0x02C8 (size: 0x4)
    int32 MinutesPerDaytime;                                                          // 0x02CC (size: 0x4)
    bool EnableTimeProgression;                                                       // 0x02D0 (size: 0x1)
    char padding_1[0x3];                                                              // 0x02D1 (size: 0x3)
    int32 GameTime_Hour;                                                              // 0x02D4 (size: 0x4)
    int32 GameTime_Minute;                                                            // 0x02D8 (size: 0x4)
    char padding_2[0x4];                                                              // 0x02DC (size: 0x4)
    int64 ServerTime;                                                                 // 0x02E0 (size: 0x8)
    float PlayerDiedCountDown;                                                        // 0x02E8 (size: 0x4)
    char padding_3[0x34];                                                             // 0x02EC (size: 0x34)
    FDateTime ModeStartTimeUTC;                                                       // 0x0320 (size: 0x8)
    char padding_4[0x8];                                                              // 0x0328 (size: 0x8)
    uint8 bPvP;                                                                       // 0x0330 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0331 (size: 0x3)
    bool bInfiniteRespawnable;                                                        // 0x0334 (size: 0x1)
    char padding_6[0x3];                                                              // 0x0335 (size: 0x3)
    int64 ServerGameTime;                                                             // 0x0338 (size: 0x8)
    char padding_7[0x60];                                                             // 0x0340 (size: 0x60)
    TArray<class ASBPlayerState*> SimplicityOnPlayers;                                // 0x03A0 (size: 0x10)
    bool bActivateShutDownServer;                                                     // 0x03B0 (size: 0x1)
    char padding_8[0x7];                                                              // 0x03B1 (size: 0x7)
    FDateTime ActivateShutDownServerDateTime;                                         // 0x03B8 (size: 0x8)
    ESBServerShutDownReason ServerShutDownReason;                                     // 0x03C0 (size: 0x1)
    char padding_9[0x7];                                                              // 0x03C1 (size: 0x7)
    int64 MonitorTime_Server;                                                         // 0x03C8 (size: 0x8)

    void SublevelInitialLoaded();
    void SetOverrideGameTime(bool bInOverrideGameTime, FDateTime InOverrideGameTime, bool bDebug);
    void SetGameTimeSettings(bool InEnableTimeProgression, int32 InGameTime_Hour, int32 InGameTime_Minute);
    void OnRep_ServerTime();
    void LoadSublevels();
    bool IsSublevelInitialLoaded();
    bool IsPvP();
    bool IsNoWaitSelfRespawnInput();
    bool GetTimeProgression();
    FDateTime GetServerTime();
    FDateTime GetServerGameTime();
    FDateTime GetModeStartTimeUTC();
    int32 GetMinutesPerDaytime();
    int32 GetMinutesPerDay();
    FDateTime GetLocalTime();
    FDateTime GetGameTime(bool IngoreOverride);
    bool GameTimeIsOverridden();
}; // Size: 0x3F8

class ASBGameState_BattleArena : public ASBGameState_DungeonNormal
{
    char padding_0[0x1168];                                                           // 0x0000 (size: 0x0)

    void SetTotalWaveNo(int32 WaveNo);
    void SetCurrentWaveNo(int32 WaveNo);
    int32 GetTotalWaveNo();
    int32 GetCurrentWaveNo();
}; // Size: 0x1168

class ASBGameState_Dungeon : public ASBGameState
{
    float ReadyCount;                                                                 // 0x0400 (size: 0x4)
    int32 PlayerNumAtStart;                                                           // 0x0404 (size: 0x4)
    int32 RespawnableNum;                                                             // 0x0408 (size: 0x4)
    int32 MissionStartType;                                                           // 0x040C (size: 0x4)
    char padding_0[0x1];                                                              // 0x0410 (size: 0x1)
    bool bIsGameStarted;                                                              // 0x0411 (size: 0x1)
    bool bFromBattleMode;                                                             // 0x0412 (size: 0x1)
    ESBGameOver GameOverState;                                                        // 0x0413 (size: 0x1)
    bool bIsDungeonCanEntry;                                                          // 0x0414 (size: 0x1)
    bool bIsTimerPause;                                                               // 0x0415 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0416 (size: 0x2)
    float GameLimitTime;                                                              // 0x0418 (size: 0x4)
    char padding_2[0x4];                                                              // 0x041C (size: 0x4)
    FDateTime DungeonNowDateTimeUTC;                                                  // 0x0420 (size: 0x8)
    char padding_3[0x8];                                                              // 0x0428 (size: 0x8)
    FDateTime DungeonLimitDateTimeUTC;                                                // 0x0430 (size: 0x8)
    float DungeonLossTimeSec;                                                         // 0x0438 (size: 0x4)
    float DungeonClearTime;                                                           // 0x043C (size: 0x4)
    class USBLevelBuddyVoiceComponent* LevelConditionVoiceComponent;                  // 0x0440 (size: 0x8)
    FSBGameState_DungeonOnDeathDelegete OnDeathDelegete;                              // 0x0448 (size: 0x10)
    void SBOnDeathDelegete(const class ASBPlayerState_Dungeon* Killer, const class ASBPlayerState_Dungeon* Victim, int32 Count, int32 KillersTotalKills, int32 VictimsTotalDeaths);
    FSBGameState_DungeonOnGameStartDelegate OnGameStartDelegate;                      // 0x0458 (size: 0x10)
    void SBOnGameStartDelegate();
    FSBGameState_DungeonOnSubtractGameLimitTimeDelegete OnSubtractGameLimitTimeDelegete; // 0x0468 (size: 0x10)
    void SBOnSubtractGameLimitTimeDelegate(int32 SubtractTime);
    FSBGameState_DungeonOnFromRespawnPointDelegete OnFromRespawnPointDelegete;        // 0x0478 (size: 0x10)
    void SBOnFromRespawnPointDelegate(bool IsFieldDead);
    FSBGameState_DungeonOnGameOverDelegate OnGameOverDelegate;                        // 0x0488 (size: 0x10)
    void SBOnGameOverDelegate();
    FSBGameState_DungeonOnTimeOverDelegate OnTimeOverDelegate;                        // 0x0498 (size: 0x10)
    void SBOnTimeOverDelegate();
    FSBGameState_DungeonOnDungeonClearAPIDelegate OnDungeonClearAPIDelegate;          // 0x04A8 (size: 0x10)
    void OnDungeonClearAPIDelegate();
    FSBGameState_DungeonOnSetDungeonClearTimeDelegate OnSetDungeonClearTimeDelegate;  // 0x04B8 (size: 0x10)
    void OnDungeonClearTimeDelegate();
    FSBGameState_DungeonOnStartDungeonResult OnStartDungeonResult;                    // 0x04C8 (size: 0x10)
    void OnStartDungeonResult();
    FName PlayingDungeonId;                                                           // 0x04D8 (size: 0x8)
    class USBDungeonClearConditionWatcher* ClearConditionWatcher;                     // 0x04E0 (size: 0x8)
    char padding_4[0x18];                                                             // 0x04E8 (size: 0x18)
    int32 PlayScriptNumber;                                                           // 0x0500 (size: 0x4)
    ESBDungeonScriptType PlayScriptType;                                              // 0x0504 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0505 (size: 0x3)
    class ASBDungeonCameraDemo* DungeonDemoBossDead;                                  // 0x0508 (size: 0x8)
    class ASBDungeonCameraDemo* DungeonDemoResult;                                    // 0x0510 (size: 0x8)
    char padding_6[0x2];                                                              // 0x0518 (size: 0x2)
    bool bDungeonEntryClosed;                                                         // 0x051A (size: 0x1)
    char padding_7[0xD];                                                              // 0x051B (size: 0xD)
    class USBArenaMissionWatcher* ArenaMissionWatcher;                                // 0x0528 (size: 0x8)
    class USBTowerChallengeWatcher* TowerChallengeWatcher;                            // 0x0530 (size: 0x8)

    void UpdateDungeonPlayerNum();
    void SkipGameLimitTime(float Time);
    void SetResultStartDelay(float Time);
    void SetResultLimitTime(float Time);
    void SetPlayingDungeonId(const FName& InPlayingId);
    void SetGameLimitTime(float Time);
    void SetGameLimitEnterTime(float LimitEnterTime);
    bool SetEnableLocalPlayerInput(bool sw);
    void SetBossSpawnEncounterVolume(class ASBEncounterVolume* EncounterVolume);
    void SBOnTimeOverDelegate__DelegateSignature();
    void SBOnSubtractGameLimitTimeDelegate__DelegateSignature(int32 SubtractTime);
    void SBOnGameStartDelegate__DelegateSignature();
    void SBOnGameOverDelegate__DelegateSignature();
    void SBOnFromRespawnPointDelegate__DelegateSignature(bool IsFieldDead);
    void SBOnDeathDelegete__DelegateSignature(const class ASBPlayerState_Dungeon* Killer, const class ASBPlayerState_Dungeon* Victim, int32 Count, int32 KillersTotalKills, int32 VictimsTotalDeaths);
    void RequestSkipGameLimitTime(float Time);
    void PushNewLoginLog(FString InCharacterName, bool Comeback);
    void OnStartDungeonResult__DelegateSignature();
    void OnRep_RespawnableNum();
    void OnRep_ReadyCount();
    void OnRep_PlayingDungeonId();
    void OnRep_IsGameStarted();
    void OnRep_GameOverState();
    void OnRep_GameLimitTime();
    void OnRep_DungeonNowTime();
    void OnRep_DungeonLimitDataTimeUTC();
    void OnRep_DungeonClearTime();
    void OnDungeonClearTimeDelegate__DelegateSignature();
    void OnDungeonClearAPIDelegate__DelegateSignature();
    bool IsTimerPaused();
    bool IsTimeOver();
    bool IsGameStarted();
    bool IsGameOver();
    bool IsFromBattleMode();
    bool IsDungeonEntryClosed();
    bool IsAlwaysShowBossHPGauge();
    class USBTowerChallengeWatcher* GetTowerChallengeWatcher();
    float GetResultLimitTime();
    float GetReadyCount();
    FName GetPlayingDungeonId();
    int32 GetPlayerNumAtStart();
    float GetGameLimitTimeBase();
    float GetGameLimitTime();
    float GetDungeonLossTime();
    int32 GetDungeonClearTimeMSec();
    FSBDungeonClearRewardInfo GetDungeonClearRewardPlusInfo();
    FSBDungeonClearRewardInfo GetDungeonClearRewardInfo();
    class USBDungeonClearConditionWatcher* GetClearConditionWatcher();
    class ASBEncounterVolume* GetBossSpawnEncounterVolume();
    class USBArenaMissionWatcher* GetArenaMissionWatcher();
    int32 GetAlivePlayersNum();
    void ClientSubtractGameLimitTime(const int32 SubtractTime);
    void BP_ReadyCount();
}; // Size: 0x10E8

class ASBGameState_DungeonNormal : public ASBGameState_Dungeon
{
    int32 PlayerNum;                                                                  // 0x10E8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x10EC (size: 0x4)
    TArray<FName> DungeonScriptQueue;                                                 // 0x10F0 (size: 0x10)
    int32 DungeonScriptIdAllPlayerStarted;                                            // 0x1100 (size: 0x4)
    int32 DungeonScriptIdAllPlayerEnded;                                              // 0x1104 (size: 0x4)
    char padding_1[0x8];                                                              // 0x1108 (size: 0x8)
    FSBGameState_DungeonNormalOnStartClearConditionScriptAllPlayers OnStartClearConditionScriptAllPlayers; // 0x1110 (size: 0x10)
    void OnStartClearConditionScriptAllPlayers(const int32 StartScriptId, const FString ScriptName);
    FSBGameState_DungeonNormalOnEndClearConditionScriptAllPlayers OnEndClearConditionScriptAllPlayers; // 0x1120 (size: 0x10)
    void OnEndClearConditionScriptAllPlayers(const int32 EndScriptId, const FString ScriptName);
    FSBGameState_DungeonNormalOnEndClearConditionScriptOnePlayer OnEndClearConditionScriptOnePlayer; // 0x1130 (size: 0x10)
    void OnEndClearConditionScriptOnePlayer(const int32 EndScriptId, const FString ScriptName);
    FName DungeonFrontline;                                                           // 0x1140 (size: 0x8)
    ESBDungeonNormalProgress DungeonProgress;                                         // 0x1148 (size: 0x1)
    char padding_2[0x7];                                                              // 0x1149 (size: 0x7)
    FSBGameState_DungeonNormalOnDungeonProgressChangeDelegate OnDungeonProgressChangeDelegate; // 0x1150 (size: 0x10)
    void OnDungeonProgressChangeDelegate(ESBDungeonNormalProgress NewDungeonProgress);

    void UpdateDungeonProcessCondition(ESBDungeonClearCondition ClearType, const FString ClearParameter);
    void SetupDungeonProcessCondition(const TArray<FSBDungeonProcess> Processes);
    void OnStartClearConditionScriptAllPlayers__DelegateSignature(const int32 StartScriptId, const FString ScriptName);
    void OnRep_DungeonProgressChange();
    void OnRep_DungeonFrontline();
    void OnRep_AddNewDungeonScript();
    void OnEndClearConditionScriptOnePlayer__DelegateSignature(const int32 EndScriptId, const FString ScriptName);
    void OnEndClearConditionScriptAllPlayers__DelegateSignature(const int32 EndScriptId, const FString ScriptName);
    void OnDungeonProgressChangeDelegate__DelegateSignature(ESBDungeonNormalProgress NewDungeonProgress);
    void NotifyPlayerScriptStart(class ASBPlayerState* PS, int32 StartId);
    void NotifyPlayerScriptEnd(class ASBPlayerState* PS, int32 StartId);
    void GetScriptPlayInfo(int32& AllStarted, int32& AllEnded);
    FName GetDungeonScriptName(int32 ID);
    void ExecOnePlayerScriptEnd(int32 EndId);
    bool ExecAllPlayerScriptStart(int32 EndId);
    bool ExecAllPlayerScriptEnd(int32 EndId);
    bool CheckAllPlayerScriptStart(int32 StartId);
    bool CheckAllPlayerScriptEnd(int32 EndId);
}; // Size: 0x1160

class ASBGameState_DungeonOffline : public ASBGameState_DungeonNormal
{
    char padding_0[0x1160];                                                           // 0x0000 (size: 0x0)
}; // Size: 0x1160

class ASBGameState_DungeonScenario : public ASBGameState_DungeonNormal
{
    char padding_0[0x1160];                                                           // 0x0000 (size: 0x0)
}; // Size: 0x1160

class ASBGameState_DungeonScoreAttack : public ASBGameState_DungeonNormal
{
    FSBScoreAttackSettings ScoreAttackSettings;                                       // 0x1160 (size: 0x160)
    bool SettingsInitialized;                                                         // 0x12C0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x12C1 (size: 0x3)
    int32 Score;                                                                      // 0x12C4 (size: 0x4)
    int32 ComboCount;                                                                 // 0x12C8 (size: 0x4)
    int32 MaxComboCount;                                                              // 0x12CC (size: 0x4)
    float ComboTimer;                                                                 // 0x12D0 (size: 0x4)
    int32 KillCount;                                                                  // 0x12D4 (size: 0x4)
    float ScoreBuffTimer;                                                             // 0x12D8 (size: 0x4)
    bool ResultFixed;                                                                 // 0x12DC (size: 0x1)
    char padding_1[0x3];                                                              // 0x12DD (size: 0x3)
    int32 TotalScore;                                                                 // 0x12E0 (size: 0x4)
    int32 BestScore;                                                                  // 0x12E4 (size: 0x4)
    ESBScoreAttackRemainTime RemainTimeType;                                          // 0x12E8 (size: 0x1)
    char padding_2[0x3];                                                              // 0x12E9 (size: 0x3)
    int32 SpawnedEnemyNum;                                                            // 0x12EC (size: 0x4)
    int32 AliveEnemyNum;                                                              // 0x12F0 (size: 0x4)

    void OnTimeOver();
    void OnScoreUp(int32 InScore);
    void OnRep_ScoreAttackRemainTime();
    void OnExtendGameLimitTime(float Time, FVector ActorLocation);
    void NotifyInteractScoreSupplier(const class AActor* Supplier, const class ASBPlayerController* PlayerController);
    void NotifyExtendGameLimitTime(float Time, FVector ActorLocation);
    void InitScoreAttackState(const FSBScoreAttackSettings& Settings);
    bool GetScoreAttackResult(FSBScoreAttackResult& ScoreAttackResult);
    int32 GetScore();
    int32 GetMaxComboCount();
    int32 GetKillCount();
    float GetCurrentScoreRate();
    float GetCurrentScoreBuffRate();
    float GetCurrentComboScoreRate();
    float GetCurrentBuffTimer();
    float GetComboTimer();
    int32 GetComboCount();
    float GetBuffTimer();
    int32 GetBestScore();
}; // Size: 0x1310

class ASBGameState_DungeonTimeAttack : public ASBGameState_DungeonNormal
{
    char padding_0[0x1198];                                                           // 0x0000 (size: 0x0)

    void SetTimeAttackResult(const TArray<FDateTime>& Time);
    void SetBestClearTimeAndLapTime(const int64 Clear, TArray<int32> Lap);
    int32 GetResultTimeMSec();
    TArray<int32> GetResultLapTimeMSec();
    TArray<int32> GetBestLapTime();
    FTimespan GetBestClearTime();
}; // Size: 0x1198

class ASBGameState_DxBattle : public ASBGameState_DungeonNormal
{
    FSBGameState_DxBattleStartInfoDelegete StartInfoDelegete;                         // 0x1160 (size: 0x10)
    void OnDxBattleDelegete();
    int32 BattleSequenceCount;                                                        // 0x1170 (size: 0x4)
    float BattleCurrentSequenceTimeLimit;                                             // 0x1174 (size: 0x4)

    void SetBattleCurrentSequenceTimeLimit(float NextCurrentSequenceTimeLimit);
    void OnTimeOver();
    int32 IncBattleSequenceCount();
    int32 GetBattleSequenceCount();
    float GetBattleCurrentSequenceTimeLimit();
    void CallStartInfo();
    void BattleFailed();
}; // Size: 0x1180

class ASBGameState_InstanceArea : public ASBGameState_DungeonNormal
{
    char padding_0[0x1160];                                                           // 0x0000 (size: 0x0)
}; // Size: 0x1160

class ASBGameState_Lobby : public ASBGameState
{
    FSBGameState_LobbyOnChangedLobbyDelegete OnChangedLobbyDelegete;                  // 0x03F8 (size: 0x10)
    void OnChangedLobbyDelegete(ESBLobbyChangedType LobbyChangedType);
    FName DungeonId;                                                                  // 0x0408 (size: 0x8)
    char padding_0[0x10];                                                             // 0x0410 (size: 0x10)
    int32 MaxPlayers;                                                                 // 0x0420 (size: 0x4)
    int32 NumPlayers;                                                                 // 0x0424 (size: 0x4)

    void OnRep_DungeonId();
    void OnChangedLobbyDelegete__DelegateSignature(ESBLobbyChangedType LobbyChangedType);
    class ASBPlayerState_Lobby* GetRoomOwnerPlayer();
    int32 GetNumPlayers();
    int32 GetMaxPlayers();
    FName GetDungeonId();
}; // Size: 0x428

class ASBGameState_PublicDungeon : public ASBGameState
{
    char padding_0[0x3F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x3F8

class ASBGameState_RaidBattle : public ASBGameState_DungeonNormal
{
    FSBGameState_RaidBattleStartInfoDelegete StartInfoDelegete;                       // 0x1160 (size: 0x10)
    void OnRaidBattleStartInfoDelegete();

    void CallStartInfo();
}; // Size: 0x1178

class ASBGameState_RankUpExam : public ASBGameState_DungeonNormal
{
    char padding_0[0x1160];                                                           // 0x0000 (size: 0x0)
}; // Size: 0x1160

class ASBGameState_SksBattle : public ASBGameState_BattleArena
{
    char padding_0[0x1168];                                                           // 0x0000 (size: 0x0)
}; // Size: 0x1168

class ASBGameState_Theater : public ASBGameState_DungeonOffline
{
    char padding_0[0x1160];                                                           // 0x0000 (size: 0x0)

    void UnloadSubLevels();
    void UnloadSublevelCB();
}; // Size: 0x1160

class ASBGameState_TowerSurvival : public ASBGameState_DungeonNormal
{
    int32 NowFloorNum;                                                                // 0x1160 (size: 0x4)

}; // Size: 0x1168

class ASBGashaDemoActor : public AActor
{
    class UDataTable* RankUpDemoLotteryTable;                                         // 0x0228 (size: 0x8)
    class UDataTable* ExpectDemoLotteryTable;                                         // 0x0230 (size: 0x8)
    class UDataTable* GreetingVoiceGroupTable;                                        // 0x0238 (size: 0x8)
    class UDataTable* GreetingVoiceTable;                                             // 0x0240 (size: 0x8)
    class UAkAudioEvent* GreetingVoiceEvent;                                          // 0x0248 (size: 0x8)
    FSBGashaResultData GashaResult;                                                   // 0x0250 (size: 0x18)
    bool bIsMainFlow;                                                                 // 0x0268 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0269 (size: 0x7)
    FSBGashaDemoActorOnShowResultDelegate OnShowResultDelegate;                       // 0x0270 (size: 0x10)
    void OnShowResultDelegate();

    void SetActorHiddenDemo(const bool bInHidden);
    void PlaySpecialCut(const ESBRarity InDemoRarity, const ESBRarity InActualRarity);
    void Play(const bool bInSkip);
    void OnShowResultDelegate__DelegateSignature();
    float GetPlayRate();
    FSBGashaVoiceData DecideGreetingVoice();
    void DecideDemo();
}; // Size: 0x280

class ASBGatherPointSpot : public ATargetPoint
{
    class USBInteractionTargetAuthorComponent* InteractionTargetAuthorComponent;      // 0x0228 (size: 0x8)
    TSubclassOf<class ASBFieldActorGatherPoint> TargetClass;                          // 0x0230 (size: 0x8)
    int32 GatherPointId;                                                              // 0x0238 (size: 0x4)
    char padding_0[0x4];                                                              // 0x023C (size: 0x4)
    FString GatherPointTag;                                                           // 0x0240 (size: 0x10)
    EGatherHeight GatherPosition;                                                     // 0x0250 (size: 0x1)
    TEnumAsByte<EPhysicalSurface> GatherSoundSurface;                                 // 0x0251 (size: 0x1)
    ESBTreasureBoxRarity GatherRarity;                                                // 0x0252 (size: 0x1)
    char padding_1[0x1];                                                              // 0x0253 (size: 0x1)
    bool IsSpawnRandom;                                                               // 0x0254 (size: 0x1)
    char padding_2[0x13];                                                             // 0x0255 (size: 0x13)
    class UBoxComponent* CollisionComponent;                                          // 0x0268 (size: 0x8)

}; // Size: 0x270

class ASBGimmickBase : public ASBInteractionSwBase
{
    class USBInteractionTargetComponent* InteractionTargetComponent;                  // 0x0228 (size: 0x8)
    int32 MinimapIconParam;                                                           // 0x0230 (size: 0x4)

}; // Size: 0x238

class ASBIndoorLightSchedule : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    void UpdateEditorPreview(float TimeRate, bool sw);
    void ResetToDefaultEditorPreview();
    void InitEditorPreview(bool sw);
}; // Size: 0x228

class ASBInitialiCheatCommandActor : public AActor
{
    TArray<FSBInitialiCheatCommandData> CommandList;                                  // 0x0228 (size: 0x10)

}; // Size: 0x238

class ASBInstanceBattleProvider : public AActor
{
    FName InstanceBattleId;                                                           // 0x0228 (size: 0x8)
    TMap<class ESBDungeonCompleteType, class FSBInstanceBattleProviderSpawnInfo> ProviderAgents; // 0x0230 (size: 0x50)

    FName GetInstanceBattleId();
}; // Size: 0x288

class ASBInteractionSwBase : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    void OnInteractionSw(class AActor* OtherActor, FRotator Rotator);
    void NotifyPlayerInteraction(class ASBPlayerCharacter* Player);
    void InteractionMulticast(class AActor* OtherActor, FRotator Rotator);
}; // Size: 0x228

class ASBInterruptQuestGimmickActor : public ASBInterruptQuestGimmickActorBase
{
    char padding_0[0x240];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x240

class ASBInterruptQuestGimmickActorBase : public AActor
{
    FName NameId;                                                                     // 0x0228 (size: 0x8)
    FName ProfileDataId;                                                              // 0x0230 (size: 0x8)
    bool bAppear;                                                                     // 0x0238 (size: 0x1)

    void SetAppear(bool InAppear);
    bool isAppear();
    void Disappear();
    void Appear();
}; // Size: 0x240

class ASBInterruptQuestInstance : public AActor
{
    class USphereComponent* QuestAreaCollisionComponent;                              // 0x0230 (size: 0x8)
    char padding_0[0x8];                                                              // 0x0238 (size: 0x8)
    FName QuestID;                                                                    // 0x0240 (size: 0x8)
    uint64 EndTime;                                                                   // 0x0248 (size: 0x8)
    FSBInterruptQuestProgressInfo ProgressInfo;                                       // 0x0250 (size: 0x10)
    FSBInterruptQuestMasterData MasterData;                                           // 0x0260 (size: 0xB8)
    FVector Location;                                                                 // 0x0318 (size: 0xC)
    FRotator Rotation;                                                                // 0x0324 (size: 0xC)
    EInterruptQuestStatus Status;                                                     // 0x0330 (size: 0x1)
    char padding_1[0x1];                                                              // 0x0331 (size: 0x1)
    EInterruptQuestResult Result;                                                     // 0x0332 (size: 0x1)

    void StartQuest();
    void SetResult(const EInterruptQuestResult InResult);
    void OnPlayerActorEndPlay(class AActor* InActor, TEnumAsByte<EEndPlayReason::Type> InEndPlayReason);
    void OnEnemyDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void OnEnemyAssetLoaded();
    void OnClearTargetEnemyDead(class ASBEnemyCharacter* pClearTargetEnemy);
    void HandleQuestAreaCollisionComponentEndOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
    void HandleQuestAreaCollisionComponentBeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& OverlapInfo);
    float GetQuestAreaSize();
    FDateTime GetEndTime();
    void BP_GetQuestName(FString& OutQuestName);
}; // Size: 0x4C0

class ASBInterruptQuestInteractionGimmickActor : public ASBInterruptQuestGimmickActorBase
{
    char padding_0[0x240];                                                            // 0x0000 (size: 0x0)

    void Request_SetInteractionActiveAll(class USBInteractionTargetComponent* InTarget, class UPrimitiveComponent* InMesh, bool InFlag);
    void Request_SetInteractionActive(class USBInteractionTargetComponent* InTarget, class UPrimitiveComponent* InMesh, class ASBPlayerCharacter* InPlayer, bool InFlag);
    void InteractionCheck(class ASBPlayerCharacter* InPlayer, FString InProfileId);
    void InitAppearedCheck();
}; // Size: 0x240

class ASBInterruptQuestPoint : public AActor
{
    TArray<FName> QuestIdList;                                                        // 0x0228 (size: 0x10)
    class USphereComponent* SensorComponent;                                          // 0x0238 (size: 0x8)
    class USphereComponent* GimmickAreaCollisionComponent;                            // 0x0240 (size: 0x8)
    int32 CurStep;                                                                    // 0x0248 (size: 0x4)
    char padding_0[0x2C];                                                             // 0x024C (size: 0x2C)
    class ASBInterruptQuestInstance* QuestInstance;                                   // 0x0278 (size: 0x8)
    float RemainCoolTime;                                                             // 0x0280 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0284 (size: 0x4)
    class ASBInterruptQuestGimmickActor* pGimmickActor;                               // 0x0288 (size: 0x8)
    class ASBInterruptQuestInteractionGimmickActor* pInteractionGimmickActor;         // 0x0290 (size: 0x8)
    class ASBBhtSignalManager* pSignalDoorActor;                                      // 0x0298 (size: 0x8)
    FSBInterruptQuestMasterData MasterData;                                           // 0x02A0 (size: 0xB8)
    bool SetMasterFlag;                                                               // 0x0358 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0359 (size: 0x3)
    FSBInterruptQuestFieldObjectVisible FieldObjectQuestConditionFlag;                // 0x035C (size: 0x14)
    char padding_3[0x28];                                                             // 0x0370 (size: 0x28)
    bool DestructibleObjectSpawnFlag;                                                 // 0x0398 (size: 0x1)
    char padding_4[0x7];                                                              // 0x0399 (size: 0x7)
    TSubclassOf<class ASBTreasureSpot> DropTreasureClass;                             // 0x03A0 (size: 0x8)
    TSubclassOf<class ASBGatherPointSpot> DropGatherSpotClass;                        // 0x03A8 (size: 0x8)

    void OnQuestInstanceEndPlay(class AActor* InActor, TEnumAsByte<EEndPlayReason::Type> InEndPlayReason);
    void OnConditionEnemyDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void HandleSensorComponentEndOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
    void HandleSensorComponentBeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& OverlapInfo);
    void HandleGimmickAreaCollisionComponentEndOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex);
    void HandleGimmickAreaCollisionComponentBeginOverlapEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& OverlapInfo);
    TSubclassOf<class ASBTreasureSpot> GetTreasureSpot();
    TSubclassOf<class ASBGatherPointSpot> GetGatherSpot();
    void DestructibleObjectDestruct(class ASBDestructible* InDestructibleObject);
    void DeleteDestructibleObject(class ASBDestructible* InDestructibleObject);
    void CreateDestructibleObject(FString SpawnId);
    bool CheckInteractionObjectAppeared(const FName& InProfileDataId);
    void AddDestructibleObject(class ASBDestructible* InDestructibleObject, const EInterruptQuestDestructibleType& InProfileId, const FName& InInDataId);
}; // Size: 0x3B0

class ASBLevelSequenceActor : public ALevelSequenceActor
{
    bool bAutoDestroy;                                                                // 0x02B0 (size: 0x1)
    ESBLevelSequenceType LevelSequenceType;                                           // 0x02B1 (size: 0x1)
    char padding_0[0x26];                                                             // 0x02B2 (size: 0x26)
    TArray<class UTexture2D*> StreamingTextures;                                      // 0x02D8 (size: 0x10)

    void ReceiveOnStop();
    void ReceiveOnPrePlay();
    void ReceiveOnPlay();
    void OnStop();
    void OnPlay();
    void OnChoiceDialogSelectItem(const int32 nSelectItemIndex);
    void OnCameraCut(class UCameraComponent* CameraComponent);
}; // Size: 0x2F8

class ASBLevelStreamingManager : public AActor
{
    TArray<FEditorStreamingDependencies> LevelDependencies;                           // 0x0278 (size: 0x10)

}; // Size: 0x2D8

class ASBLibraryEnemyLoadCheck : public AActor
{
    FSBLibraryEnemyLoadCheckLoadCompleteDelegate LoadCompleteDelegate;                // 0x0228 (size: 0x10)
    void SBLibraryEnemyModelLoadCompleteDelegate();
    FSBLibraryEnemyLoadCheckWeaponSpawnDelegate WeaponSpawnDelegate;                  // 0x0238 (size: 0x10)
    void SBLibraryEnemyWeaponDelegate(class ASBEnemyCharacter* EnemyCharacter);
    class ASBEnemyCharacter* TargetEnemy;                                             // 0x0248 (size: 0x8)
    TArray<FName> WeaponName;                                                         // 0x0250 (size: 0x10)
    ESBLibraryEnemyViewSetting StandType;                                             // 0x0260 (size: 0x1)
    ESBLibraryEnemyWeaponSetting WeaponType;                                          // 0x0261 (size: 0x1)

    void UnbindDelegate();
}; // Size: 0x270

class ASBLightSchedule : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    void InitEditorPreview(bool sw);
}; // Size: 0x228

class ASBLocationAnchor : public AActor
{
    int32 LocationId;                                                                 // 0x0228 (size: 0x4)
    bool bForceOnGround;                                                              // 0x022C (size: 0x1)
    char padding_0[0x3];                                                              // 0x022D (size: 0x3)
    class USBTargetableComponent* TargetableComp;                                     // 0x0230 (size: 0x8)

}; // Size: 0x238

class ASBLocationAnchorManager : public AActor
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    bool IsValidLocationID(int32 InLocationID);
    class ASBLocationAnchor* GetAnchor(int32 InLocationID);
    void Client_PrintLocationLog(int32 LocationId, FString AnchorName, FVector AnchorLocation, FString WorldName);
}; // Size: 0x278

class ASBMiniMapChangeVolume : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    void OnEndOverlap(class AActor* InActor);
    void OnBeginOverlap(class AActor* InActor);
    void GetConfigName(FName& InVolume, FName& OutVolume);
}; // Size: 0x228

class ASBMobCharacter : public AASCharacterBase
{
    class USBAnimationControlComponent* AnimationControlComp;                         // 0x0528 (size: 0x8)
    class USBNamePlateComponent2D* NamePlateComp;                                     // 0x0530 (size: 0x8)
    class USBInteractionTargetComponent* InteractionTargetComp;                       // 0x0538 (size: 0x8)
    class USBInfluenceSourceComponent* WandererDensitySourceComp;                     // 0x0540 (size: 0x8)
    class USBNpcPerformanceOptimizationComponent* PerfOptComp;                        // 0x0548 (size: 0x8)
    class UGameplayTasksComponent* GameplayTasksComp;                                 // 0x0550 (size: 0x8)
    class USBFootprintComponent* FootprintComponent;                                  // 0x0558 (size: 0x8)
    class USBActorVisibilityComponent* ActorVisibilityComponent;                      // 0x0560 (size: 0x8)
    class USBFieldStatusComponent* FieldStatusComponent;                              // 0x0568 (size: 0x8)
    char padding_0[0x4C];                                                             // 0x0570 (size: 0x4C)
    FName ProfileDataId;                                                              // 0x05BC (size: 0x8)
    char padding_1[0x2C];                                                             // 0x05C4 (size: 0x2C)
    FString CharacterName;                                                            // 0x05F0 (size: 0x10)
    FSBNpcScriptInfo ScriptInfo;                                                      // 0x0600 (size: 0x28)
    uint8 bCanWander;                                                                 // 0x0628 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0629 (size: 0x7)
    FSBMobCharacterWanderingModeChangedDelegate WanderingModeChangedDelegate;         // 0x0630 (size: 0x10)
    void SBNpcWanderingModeChangedSignature(bool bCanWander);
    char padding_3[0x8];                                                              // 0x0640 (size: 0x8)
    FString Animation;                                                                // 0x0648 (size: 0x10)
    FString AnimationSubCommand;                                                      // 0x0658 (size: 0x10)
    char padding_4[0x8];                                                              // 0x0668 (size: 0x8)
    FSBMobCharacterOnMobPostSpawnDelegate OnMobPostSpawnDelegate;                     // 0x0670 (size: 0x10)
    void SBOnMobPostSpawnDelegate(class ASBMobCharacter* InMobCharacter);
    FSBMobCharacterOnMobDeactivateDelegate OnMobDeactivateDelegate;                   // 0x0680 (size: 0x10)
    void SBOnMobDeactivateDelegate(class ASBMobCharacter* InMobCharacter);
    char padding_5[0x28];                                                             // 0x0690 (size: 0x28)
    class USBNpcWaitParamComponent* WaitParamComp;                                    // 0x06B8 (size: 0x8)
    char padding_6[0x8];                                                              // 0x06C0 (size: 0x8)
    class USBNpcTalkActionComponent* TalkActionComp;                                  // 0x06C8 (size: 0x8)
    TMap<class FName, class FString> ScriptParameters;                                // 0x06D0 (size: 0x50)
    float CameraTransparentComponentEnableLength;                                     // 0x0720 (size: 0x4)

    void ReceivePostSpawnBySpawner();
    FName GetProfileDataId();
    FSBCharacterProfileData GetProfileData();
    FString GetCharacterName();
}; // Size: 0x730

class ASBMount : public ASBMountCharacter
{
    class USBNetworkSmoothMoveComponent* m_NetworkSmoothMoveComponent;                // 0x0628 (size: 0x8)
    char padding_0[0x8];                                                              // 0x0630 (size: 0x8)
    float OwnerCharacterScale;                                                        // 0x0638 (size: 0x4)
    char padding_1[0x8C];                                                             // 0x063C (size: 0x8C)
    class UAkAudioEvent* StartAkEvent;                                                // 0x06C8 (size: 0x8)
    class UAkAudioEvent* EndAkEvent;                                                  // 0x06D0 (size: 0x8)
    class UAkAudioEvent* MoveOnAkEvent;                                               // 0x06D8 (size: 0x8)
    class UAkAudioEvent* MoveOffAkEvent;                                              // 0x06E0 (size: 0x8)
    char padding_2[0x10];                                                             // 0x06E8 (size: 0x10)
    class USBMountPlayerCliffComponent* MountPlayerCliffComponent;                    // 0x06F8 (size: 0x8)
    char padding_3[0x8];                                                              // 0x0700 (size: 0x8)
    class UAkComponent* AkComponent;                                                  // 0x0708 (size: 0x8)

    void ResetDashStartEffectRequested();
    void RequestFinishSequenceToBP();
    void PostEvent(class UAkAudioEvent* Event);
    bool IsWarp();
    bool IsMovingOnGround();
    bool IsFinishMotion();
    bool IsEnableDashEffect();
    bool IsDashStartEffectRequested();
    bool IsDash();
    bool IsAutoRunCameraControl();
    bool IsAttach();
    float GetWalkBSSampleValueX();
    float GetWaitBSSampleValueX();
    float GetSpeedRate();
    float GetRunBSSampleValueX();
    FSBMountIKParam GetIKParam();
    FVector GetCliffJumpVelocity();
    bool CheckWallHitBeforeGettingOff();
    void CalcuMaxWalkRunBlendSample(const class UASAnimationSet* AnimationSet);
}; // Size: 0x710

class ASBMountCharacter : public AASCharacter
{
    float BlendValueX;                                                                // 0x05B0 (size: 0x4)
    float BlendValueXlerped;                                                          // 0x05B4 (size: 0x4)
    float BlendValueY;                                                                // 0x05B8 (size: 0x4)
    float MountAnimPlayRate;                                                          // 0x05BC (size: 0x4)
    char padding_0[0x10];                                                             // 0x05C0 (size: 0x10)
    class USBActorVisibilityComponent* ActorVisibilityComponent;                      // 0x05D0 (size: 0x8)
    char padding_1[0x8];                                                              // 0x05D8 (size: 0x8)
    TSubclassOf<class USBSurfaceFootprintSetting> DashStartFootprint;                 // 0x05E0 (size: 0x8)

    class USBPlayerMovementComponent* GetOwnerPlayerMovement();
    class ASBPlayerController* GetOwnerPlayerController();
    class ASBPlayerCharacter* GetOwnerPlayerCharacter();
}; // Size: 0x610

class ASBNavLinkProxy : public ANavLinkProxy
{
    class USBNavLinkJumpComponent* NavLinkJumpComp;                                   // 0x0278 (size: 0x8)

    void OnJumpStart(class AActor* PathOwner, const FVector& Destination);
}; // Size: 0x280

class ASBNavLinkProxy_APClimbing : public ASBNavLinkProxy_AutoPlay
{
    FName ClimbingActorName;                                                          // 0x0288 (size: 0x8)
    FVector TopEdge;                                                                  // 0x0290 (size: 0xC)
    FVector BottomEdge;                                                               // 0x029C (size: 0xC)

}; // Size: 0x2B0

class ASBNavLinkProxy_AutoPlay : public ANavLinkProxy
{
    TSubclassOf<class UAutoPlayTask> TaskClass;                                       // 0x0278 (size: 0x8)

    void ResumeMoveTask(class UAutoPlayTask* Task);
    class UAutoPlayTask* ReceiveNewAutoPlayTask(class USBAutoPlayTask_MoveTo* OwnerTask, const FVector& DestPoint);
    void ReceiveInitAutoPlayTask(class UAutoPlayTask* AutoPlayTask, const FVector& DestPoint);
    void OnNavigationGenerationFinished(class ANavigationData* NavData);
}; // Size: 0x288

class ASBNavMesh : public ARecastNavMesh
{
    int32 VolatileNavMeshVersion;                                                     // 0x04E0 (size: 0x4)
    int32 NumPolys;                                                                   // 0x04E4 (size: 0x4)
    int32 NumActivatedPolys;                                                          // 0x04E8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x04EC (size: 0x4)
    class USBAutoLinkCreaterComponent* AutoLinkCreaterComp;                           // 0x04F0 (size: 0x8)

}; // Size: 0x528

class ASBNavMeshAutoLinkVolume : public AVolume
{
    char padding_0[0x260];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x260

class ASBNavVolumeObstructer : public AVolume
{
    char padding_0[0x260];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x260

class ASBNavigationTestingActor : public ANavigationTestingActor
{
    NavigationTestingType NavTestType;                                                // 0x0318 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0319 (size: 0x3)
    float RunAwayDistance;                                                            // 0x031C (size: 0x4)
    TArray<class ANavigationTestingActor*> OtherActors;                               // 0x0320 (size: 0x10)

}; // Size: 0x330

class ASBNoMapDisplayVolume : public AVolume
{
    char padding_0[0x260];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x260

class ASBNoRepCharaCreateCharacter : public ASBCharaCreateCharacter
{
    char padding_0[0x1480];                                                           // 0x0000 (size: 0x0)
}; // Size: 0x1480

class ASBNoticeBoard : public AStaticMeshActor
{
    class UShapeComponent* SensorVolume;                                              // 0x0238 (size: 0x8)
    class UShapeComponent* CachedSensorVolume;                                        // 0x0240 (size: 0x8)

}; // Size: 0x248

class ASBNpcCharacter : public ASBMobCharacter
{
    int32 Job;                                                                        // 0x0870 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0874 (size: 0x4)
    uint8 bIsEnableStagger;                                                           // 0x0878 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0879 (size: 0x3)
    bool bRandomCharacter;                                                            // 0x087C (size: 0x1)
    char padding_2[0x3];                                                              // 0x087D (size: 0x3)
    class USBCharaCreateComponent* CharaCreateComponent;                              // 0x0880 (size: 0x8)
    FSBNpcAppearanceType RandomAppearanceType;                                        // 0x0888 (size: 0x3)
    char padding_3[0x5];                                                              // 0x088B (size: 0x5)
    class USBCharaPartsFaceComponent* FaceComp;                                       // 0x0890 (size: 0x8)
    class UASAnimationSet* AnimationSet;                                              // 0x0898 (size: 0x8)
    class USBDemoParameterComponent* DemoParameterComp;                               // 0x08A0 (size: 0x8)
    class UDataTable* F100WaitParamTable;                                             // 0x08A8 (size: 0x8)
    class UDataTable* F200WaitParamTable;                                             // 0x08B0 (size: 0x8)
    class UDataTable* F300WaitParamTable;                                             // 0x08B8 (size: 0x8)
    class UDataTable* F400WaitParamTable;                                             // 0x08C0 (size: 0x8)
    class UDataTable* F500WaitParamTable;                                             // 0x08C8 (size: 0x8)
    class UDataTable* M100WaitParamTable;                                             // 0x08D0 (size: 0x8)
    class UDataTable* M200WaitParamTable;                                             // 0x08D8 (size: 0x8)
    class UDataTable* M300WaitParamTable;                                             // 0x08E0 (size: 0x8)
    class UDataTable* M400WaitParamTable;                                             // 0x08E8 (size: 0x8)
    class UDataTable* M500WaitParamTable;                                             // 0x08F0 (size: 0x8)
    class USBCameraTransparentCapsuleComponent* CameraTransparentComponent;           // 0x08F8 (size: 0x8)
    class UCurveFloat* FadeInCurve;                                                   // 0x0900 (size: 0x8)

    void SetStaggerState(class AActor* HitActor);
    void SetShadowMeshCastShadow(bool bSw);
    void SetNpcState(ENpcState State);
    void SetDemoAnimationSet(const class UASAnimationSet* NewAnimationSet);
    void SetCharaCreateData(class USBCharaCreateData* InCharaCreateData);
    void SetAnimationSet(class UASAnimationSet* InAnimationSet);
    bool IsEnableStagger();
    ENpcState GetNpcState();
    TSoftObjectPtr<UASAnimationSet> GetDemoAnimationSet();
    void AddSubTrigger(const FName& InId);
    void AddMainTrigger(const FName& InId);
}; // Size: 0x910

class ASBNpcLaneBase : public AActor
{
    TArray<FSBNpcLaneSpawnSettings> SpawnSettings;                                    // 0x0228 (size: 0x10)
    float Density;                                                                    // 0x0238 (size: 0x4)
    ESBNpcLaneDirection Direction;                                                    // 0x023C (size: 0x4)
    class USBNpcLaneGraph* OwnerGraph;                                                // 0x0240 (size: 0x8)
    TArray<FSBNpcLanePoint> SpawnPoints;                                              // 0x0248 (size: 0x10)
    char padding_0[0x8];                                                              // 0x0258 (size: 0x8)
    TArray<class AController*> WalkingControllers;                                    // 0x0260 (size: 0x10)

}; // Size: 0x270

class ASBNpcNavPathProxy : public AActor
{
    TArray<FNpcNavPathData> PointList;                                                // 0x0238 (size: 0x10)
    FName PathName;                                                                   // 0x0248 (size: 0x8)
    FPathConfig PathConfig;                                                           // 0x0250 (size: 0xC)

    FName GetPathName();
    int32 GetPathDataNum();
    TArray<FNpcNavPathData> GetPathData();
    FPathConfig GetPathConfig();
}; // Size: 0x260

class ASBNpcPath : public AActor
{
    class USBNpcPathComponent* NpcPathComponent;                                      // 0x0228 (size: 0x8)
    FName PathName;                                                                   // 0x0230 (size: 0x8)

    FName GetPathName();
    class USBNpcPathComponent* GetNpcPathComponent();
}; // Size: 0x238

class ASBNpcSpawnArea : public AVolume
{
    TArray<FSBNpcSpawnAreaSettings> SpawnSettings;                                    // 0x0268 (size: 0x10)
    float Density;                                                                    // 0x0278 (size: 0x4)
    bool bUseFaceLocation;                                                            // 0x027C (size: 0x1)
    char padding_0[0x3];                                                              // 0x027D (size: 0x3)
    FVector FaceLocation;                                                             // 0x0280 (size: 0xC)
    bool bUseFaceDirection;                                                           // 0x028C (size: 0x1)
    char padding_1[0x3];                                                              // 0x028D (size: 0x3)
    float FaceDirection;                                                              // 0x0290 (size: 0x4)
    bool bFlipped;                                                                    // 0x0294 (size: 0x1)

}; // Size: 0x298

class ASBNpcSpawnPoint : public AActor
{
    FName ProfileDataId;                                                              // 0x0230 (size: 0x8)
    ESBNpcSpawnPriority SpawnPriority;                                                // 0x0238 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0239 (size: 0x3)
    FSBNpcDisableOutRangeInfo OutRangeInfo;                                           // 0x023C (size: 0x8)
    char padding_1[0x4];                                                              // 0x0244 (size: 0x4)
    FSBNpcSpawnPointSettings SpawnSettings;                                           // 0x0248 (size: 0x110)
    FSBNpcScriptInfo ScriptInfo;                                                      // 0x0358 (size: 0x28)
    FSBNpcInteractionSettings InteractionSettings;                                    // 0x0380 (size: 0x40)
    FDataTableRowHandle FieldStatusSettingHandle;                                     // 0x03C0 (size: 0x10)
    FString Animation;                                                                // 0x03D0 (size: 0x10)
    FString AnimationSubCommand;                                                      // 0x03E0 (size: 0x10)
    class UDataTable* OverrideWaitParamTable;                                         // 0x03F0 (size: 0x8)

    FName GetProfileDataId();
}; // Size: 0x3F8

class ASBNpcSpawnPointNappo : public ASBNpcSpawnPoint
{
    char padding_0[0x3F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x3F8

class ASBNpcSpawner : public AActor
{
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0228 (size: 0x8)
    class UAIFwHierarchyComponent* HierarchyComponent;                                // 0x0230 (size: 0x8)
    TSubclassOf<class ASBNpcCharacter> NpcClass;                                      // 0x0238 (size: 0x8)
    TSubclassOf<class ASBAnimalCharacter> AnimalClass;                                // 0x0240 (size: 0x8)
    char padding_0[0xB8];                                                             // 0x0248 (size: 0xB8)
    class USBNpcPool* NpcPool;                                                        // 0x0300 (size: 0x8)
    class USBPawnPool* AnimalPool;                                                    // 0x0308 (size: 0x8)

    void NotifyNeedToUpdateFieldStatus();
    void InitNpcSpawn();
    void DeactivateWanderingNpc(class ASBMobCharacter* InMobCharacter);
}; // Size: 0x310

class ASBNpcStraightLane : public ASBNpcLaneBase
{
    FVector Left;                                                                     // 0x0270 (size: 0xC)
    float LeftPointRate;                                                              // 0x027C (size: 0x4)
    FVector LeftPoint;                                                                // 0x0280 (size: 0xC)
    FVector Right;                                                                    // 0x028C (size: 0xC)
    float RightPointRate;                                                             // 0x0298 (size: 0x4)
    FVector RightPoint;                                                               // 0x029C (size: 0xC)
    float Width;                                                                      // 0x02A8 (size: 0x4)
    bool bAutoAdjustWidth;                                                            // 0x02AC (size: 0x1)
    bool bIsDrawPoint;                                                                // 0x02AD (size: 0x1)
    char padding_0[0x2];                                                              // 0x02AE (size: 0x2)
    float NumWalking;                                                                 // 0x02B0 (size: 0x4)
    float DensityPerLength;                                                           // 0x02B4 (size: 0x4)

    void ChangeDrawPoint();
    void AdjustWidthToNavMesh();
}; // Size: 0x2B8

class ASBOceanGrid : public AOceanGrid
{
    class USBOceanRippleCaptureComponent* RippleCapture;                              // 0x0308 (size: 0x8)

    void SwitchOceanCollision(bool sw);
    void EndActorOverlap(class AActor* OverlappingActor, class AActor* OtherActor);
    void BeginActorOverlap(class AActor* OverlappingActor, class AActor* OtherActor);
}; // Size: 0x310

class ASBPainCausingVolume : public APainCausingVolume
{
    FName SocketNameForImpactPoint;                                                   // 0x0298 (size: 0x8)
    float PlayerDamage;                                                               // 0x02A0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02A4 (size: 0x4)
    TSubclassOf<class UDamageType> PlayerDamageType;                                  // 0x02A8 (size: 0x8)
    float EnemyDamage;                                                                // 0x02B0 (size: 0x4)
    char padding_1[0x4];                                                              // 0x02B4 (size: 0x4)
    TSubclassOf<class UDamageType> EnemyDamageType;                                   // 0x02B8 (size: 0x8)
    bool DamageToCenterDirection;                                                     // 0x02C0 (size: 0x1)
    bool IgnoreUpDirection;                                                           // 0x02C1 (size: 0x1)
    char padding_2[0x6];                                                              // 0x02C2 (size: 0x6)
    class UParticleSystem* HitParticle;                                               // 0x02C8 (size: 0x8)

}; // Size: 0x2D0

class ASBPerformanceCamera : public ASBAimCamera
{
    class USphereComponent* m_SphereCollision;                                        // 0x0A48 (size: 0x8)
    class USBSkeletalMeshComponent* MeshComp;                                         // 0x0A50 (size: 0x8)

    void SetupULTPerformance(bool bEnable);
    void SetupSceneCapture();
    void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    void OnAttachActorEndPlay(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    bool IsPlayULT();
    bool IsApplyULT();
    bool IsApplySceneCapture();
    bool IsApplyCameraMotion();
    float GetBodyDifferenceCorrection();
}; // Size: 0xA70

class ASBPhotoModeController : public APlayerController
{
    TSubclassOf<class ASBPhotoModePawn> PhotoModePawnClassAsset;                      // 0x0578 (size: 0x8)
    TSubclassOf<class USBPhotoModePlayerControlData> PlayerControlDatanClassAsset;    // 0x0580 (size: 0x8)
    class ASBPlayerController* OriginalControllerRef;                                 // 0x0588 (size: 0x8)
    class UPlayer* OriginalPlayer;                                                    // 0x0590 (size: 0x8)
    class AActor* OriginalPlayerCharacter;                                            // 0x0598 (size: 0x8)
    class ASBPlayerState* OriginalPlayerState;                                        // 0x05A0 (size: 0x8)
    class APlayerCameraManager* OriginalPlayerCameraManager;                          // 0x05A8 (size: 0x8)
    char padding_0[0x8];                                                              // 0x05B0 (size: 0x8)
    class UWidget* BgWidget;                                                          // 0x05B8 (size: 0x8)
    bool bIgnoreQuitPhotoModeByDisableInput;                                          // 0x05C0 (size: 0x1)
    char padding_1[0x37];                                                             // 0x05C1 (size: 0x37)
    class ASBPlayerState* SelectedPlayer;                                             // 0x05F8 (size: 0x8)
    FName SelectedCharacterId;                                                        // 0x0600 (size: 0x8)
    TMap<class FName, class USBPhotoModePlayerControlData*> PlayerControlDataMap;     // 0x0608 (size: 0x50)
    TArray<class USBPhotoModePlayerControlData*> PlayerControlDataList;               // 0x0658 (size: 0x10)
    TArray<class USBPhotoModePlayerControlData*> PlayerControlInvalidDataList;        // 0x0668 (size: 0x10)
    TArray<class USBPhotoModePlayerControlData*> PlayerControlValidDataList;          // 0x0678 (size: 0x10)
    int32 CloneCountMax;                                                              // 0x0688 (size: 0x4)
    bool bIsCloneCountMax;                                                            // 0x068C (size: 0x1)
    char padding_2[0x13];                                                             // 0x068D (size: 0x13)
    TArray<uint8> Image_PNGData;                                                      // 0x06A0 (size: 0x10)
    class UTexture2DDynamic* TextureDynamic;                                          // 0x06B0 (size: 0x8)
    char padding_3[0x18];                                                             // 0x06B8 (size: 0x18)
    FKey MoveUpKey;                                                                   // 0x06D0 (size: 0x18)
    FKey MoveDownKey;                                                                 // 0x06E8 (size: 0x18)

    void UpdatePlayerControlDataList();
    float UiYawToCameraYaw(float UiYaw);
    void ToggleUiVisible();
    void ToggleTalkMode();
    void TogglePlayerControlView();
    void ToggleMotionStop();
    void ToggleControlMode();
    void ToggleCameraControlView();
    void ToggleAllLookAtEyeActive();
    void ToggleAllLookAtActive();
    void ToggleAllFixHead();
    void ToggleAllFixEye();
    void SetOverrideTime(float Value);
    void SetOtherPlayerVisibility(bool bValue);
    void SetLookAtPlayer(bool bValue);
    void SetFOV(float Value, bool bByUi);
    void SetEnableOverrideTime(bool bValue);
    void SetDebugValidAllPlayer(bool bValue);
    void SetAllWeaponVisibility(bool bValue);
    void SetAllVisibility(bool bValue);
    void SetAllMotionStop(bool bValue);
    void SetAllLookAtEyeActive(bool bValue);
    void SetAllLookAtActive(bool bValue);
    void SetAllFixHead(bool bValue);
    void SetAllFixEye(bool bValue);
    void SetAllClone(bool bValue);
    class USBPhotoModePlayerControlData* SelectPlayer(class ASBPlayerState* Target, FName CharacterId);
    void ResetCamera();
    void ResetAllLookAt();
    void RequestQuitPhotoModeMain();
    void RequestQuitPhotoMode();
    void ReceiveOnPreDeactivate(class APlayerController* OriginalPC);
    void ReceiveOnPostActivate(class APlayerController* OriginalPC);
    void ReceiveOnDeactivate(class APlayerController* RestoredPC);
    void ReceiveOnActivate(class APlayerController* OriginalPC);
    void QuitPhotoModeMain();
    void QuitPhotoMode();
    void OnUpdatePlayerControlData();
    void OnScreenshotCaptured();
    void OnRequestScreenShot(class UObject* Sender, class UObject* Param);
    void OnReplicatedPlayerState(class UObject* Sender, class UObject* Param);
    void OnEndPlayerCharacter(class UObject* Sender, class UObject* Param);
    void OnCloseChatWindow(class UObject* Sender, class UObject* Param);
    void OnChangeTalkMode(bool bInTalkMode, bool bPreChange);
    void OnChangeLookAtPlayer(bool bValue);
    void OnChangeLastEmoteStateName(class UObject* Sender, class UObject* Param);
    void OnChangeFov(float Value, bool bByUi);
    void OnChangeControlMode(bool bInPlayerControlMode, bool bPreChange);
    void OnBeginPlayerCharacter(class UObject* Sender, class UObject* Param);
    bool IsShowDebugUi();
    bool IsShowConfirmQuitDialog();
    bool IsOtherPlayerVisibility();
    bool IsLookAtPlayer();
    bool IsEnableOverrideTime();
    bool IsDebugValidAllPlayer();
    bool IsAllVisible();
    bool IsAllMotionStop();
    bool IsAllLookAtEyeActive();
    bool IsAllLookAtActive();
    bool IsAllFixHead();
    bool IsAllFixEye();
    bool IsAllEnabledLookAtEyeActive();
    bool IsAllEnabledLookActive();
    bool IsAllClone();
    void InputSkillAction(const ESkillActionPosition Position, bool bPressed);
    class USBPhotoModePlayerControlData* GetSelectedPlayerControlData();
    class USBPhotoModePlayerControlData* GetPlayerControlDataByCloneCharacter(const class ASBCreationCharacter* Target);
    class USBPhotoModePlayerControlData* GetPlayerControlData(class ASBPlayerState* Target, FName CharacterId, bool bMakeIfNotFound);
    float GetOverrideTime();
    FVector GetOriginLocation();
    void GetOriginalPlayerViewPoint(FVector& OutLocation, FRotator& OutRotation);
    class USBPhotoModePlayerControlData* GetOriginalPlayerControlData();
    float GetFOV();
    int32 GetCloneCount();
    void GetCameraResetViewPoint(float SphereRadius, FVector& OutLocation, FRotator& OutRotation);
    FVector GetCameraLocation();
    bool GetAllWeaponVisibility();
    void EnableScreenShotCapturedCallback();
    void DisableScreenShotCapturedCallback();
    bool CanControlAllVisibility();
    bool CanControlAllMotionStop();
    bool CanControlAllClone();
    void CancelPhotoModePadPressed();
    void CancelPhotoMode();
    float CameraYawToUiYaw(float CameraYaw);
    void BP_TogglePlayerControlView();
    void BP_ToggleCameraControlView();
    void BP_ResetCamera();
    void BP_OnUpdatePlayerControlData();
    void BP_OnRequestQuitPhotoMode();
}; // Size: 0x700

class ASBPhotoModePawn : public ASpectatorPawn
{
    bool bLookAtPlayer;                                                               // 0x02B0 (size: 0x1)
    bool bPadFunc1Pressed;                                                            // 0x02B1 (size: 0x1)
    bool bPadFunc2Pressed;                                                            // 0x02B2 (size: 0x1)
    bool bHideCursor;                                                                 // 0x02B3 (size: 0x1)
    char padding_0[0x4];                                                              // 0x02B4 (size: 0x4)
    TArray<class AActor*> HiddenActors;                                               // 0x02B8 (size: 0x10)

    void SetLookAtPlayer(bool bValue);
    void MoveUp_Local(float Val);
    void BP_ResetCamera();
}; // Size: 0x2C8

class ASBPhysicsWaterVolume : public APhysicsVolume
{
    TArray<class USplineMeshComponent*> PhyTrackSplineMeshComponents;                 // 0x0270 (size: 0x10)
    class ASBWaterMeshActor* WaterMesh;                                               // 0x0280 (size: 0x8)

    void ResetBrushSetting();
}; // Size: 0x288

class ASBPlayerAnimationSamplingLevelScriptActor : public ASBAnimationSamplingLevelScriptActor
{
    char padding_0[0x240];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x240

class ASBPlayerCharacter : public ASBCreationCharacter
{
    class USBPlayerMovementComponent* PlayerMovement;                                 // 0x1548 (size: 0x8)
    class ASBPlayerController* SBPlayerController;                                    // 0x1550 (size: 0x8)
    class USBCharacterAnimationSamplingComponent* AnimationSamplingComp;              // 0x1558 (size: 0x8)
    class USBCharacterTrackingComponent* CharacterTrackingComponent;                  // 0x1560 (size: 0x8)
    char padding_0[0x28];                                                             // 0x1568 (size: 0x28)
    FSBPlayerCharacterOnPlayerTakeAnyDamage OnPlayerTakeAnyDamage;                    // 0x1590 (size: 0x10)
    void PlayerTakeAnyDamageSignature(class ASBPlayerCharacter* DamagedActor, float Damage, const FSBDamageEvent& DamageEvent, class AController* InstigatedBy, class AActor* DamageCauser);
    char padding_1[0x10];                                                             // 0x15A0 (size: 0x10)
    FSBCharacterStatus m_ReplicateStatusParameter;                                    // 0x15B0 (size: 0x40)
    char padding_2[0x760];                                                            // 0x15F0 (size: 0x760)
    FSBPlayerCharacterOnCalcEquipStatusDiffDelegate OnCalcEquipStatusDiffDelegate;    // 0x1D50 (size: 0x10)
    void OnCalcEquipStatusDiffDelegate();
    FSBPlayerCharacterOnStatusDiffAtRecalc2ndStatusDelegate OnStatusDiffAtRecalc2ndStatusDelegate; // 0x1D60 (size: 0x10)
    void OnStatusDiffAtRecalc2ndStatusDelegate();
    TSoftClassPtr<USBSurfaceFootprintSetting> DashStartFootprint;                     // 0x1D70 (size: 0x28)
    class USBDhcBattleComponent* m_pDhcBattleComponent;                               // 0x1D98 (size: 0x8)
    class USBPlayerPresetEquipComponent* m_pPresetEquipComponent;                     // 0x1DA0 (size: 0x8)
    class USBNetworkSmoothMoveComponent* m_NetworkSmoothMoveComponent;                // 0x1DA8 (size: 0x8)
    char padding_3[0x20];                                                             // 0x1DB0 (size: 0x20)
    bool TurnYawFlag;                                                                 // 0x1DD0 (size: 0x1)
    char padding_4[0x3];                                                              // 0x1DD1 (size: 0x3)
    float AcceleratorSpeedStart;                                                      // 0x1DD4 (size: 0x4)
    float AcceleratorSpeedEnd;                                                        // 0x1DD8 (size: 0x4)
    float AcceleratorInputRun;                                                        // 0x1DDC (size: 0x4)
    float AcceleratorSlopeSpeedStart;                                                 // 0x1DE0 (size: 0x4)
    float AcceleratorSlopeSpeedEnd;                                                   // 0x1DE4 (size: 0x4)
    char padding_5[0x10];                                                             // 0x1DE8 (size: 0x10)
    float MarkerAutoRunEndDistance;                                                   // 0x1DF8 (size: 0x4)
    char padding_6[0xD0];                                                             // 0x1DFC (size: 0xD0)
    float FollowingDistance;                                                          // 0x1ECC (size: 0x4)
    TWeakObjectPtr<class AActor> FollowingActor;                                      // 0x1ED0 (size: 0x8)
    FString FollowingCharacterId;                                                     // 0x1ED8 (size: 0x10)
    class USBPlayerCameraComponent* m_pPlayerCameraComponent;                         // 0x1EE8 (size: 0x8)
    char padding_7[0x20];                                                             // 0x1EF0 (size: 0x20)
    FVector_NetRoughDirection m_ReplicatedAimDirection;                               // 0x1F10 (size: 0xC)
    char padding_8[0x1C];                                                             // 0x1F1C (size: 0x1C)
    class USBMeshClimbingComponent* m_pMeshClimbingComponent;                         // 0x1F38 (size: 0x8)
    class USBPlayerTargetingComponent* m_pPlayerTargetingComponent;                   // 0x1F40 (size: 0x8)
    char padding_9[0x8];                                                              // 0x1F48 (size: 0x8)
    class USBPlayerInteractionComponent* m_pPlayerInteractionComponent;               // 0x1F50 (size: 0x8)
    char padding_10[0x8];                                                             // 0x1F58 (size: 0x8)
    FSBPlayerCharacterOnJankenUIDelegate OnJankenUIDelegate;                          // 0x1F60 (size: 0x10)
    void OnJankenUIDelegate();
    class USBPlayerHoldHandComponent* m_HoldHandComponent;                            // 0x1F70 (size: 0x8)
    class USBAutoWordComponent* AutoWordComponent;                                    // 0x1F78 (size: 0x8)
    ESBRoleType RoleType;                                                             // 0x1F80 (size: 0x1)
    char padding_11[0x37];                                                            // 0x1F81 (size: 0x37)
    FSBPlayerCharacterOnStaminaConsumeDelegate OnStaminaConsumeDelegate;              // 0x1FB8 (size: 0x10)
    void OnStaminaConsumeDelegate();
    FSBPlayerCharacterOnStaminaRecoveredDelegate OnStaminaRecoveredDelegate;          // 0x1FC8 (size: 0x10)
    void OnStaminaRecoveredDelegate();
    FSBStaminaSettings StaminaSettings;                                               // 0x1FD8 (size: 0x28)
    FSBStaminaSettings m_UnsheatheStaminaSetting;                                     // 0x2000 (size: 0x28)
    float CarryingDecreaseStamina;                                                    // 0x2028 (size: 0x4)
    float CarryingRunConsumeStamina;                                                  // 0x202C (size: 0x4)
    float CarryingIncreaseStamina;                                                    // 0x2030 (size: 0x4)
    float CarryingStaminaDelay;                                                       // 0x2034 (size: 0x4)
    char padding_12[0x90];                                                            // 0x2038 (size: 0x90)
    FSBPlayerCharacterOnServerReplicateStateInfoDelegate OnServerReplicateStateInfoDelegate; // 0x20C8 (size: 0x10)
    void OnServerReplicateStateInfoDelegate(class AActor* Actor, const FVector& Location);
    char padding_13[0x50];                                                            // 0x20D8 (size: 0x50)
    uint8 bUnsheathe;                                                                 // 0x2128 (size: 0x1)
    char padding_14[0x7];                                                             // 0x2129 (size: 0x7)
    class USBPlayerCliffComponent* CliffComponent;                                    // 0x2130 (size: 0x8)
    FSBPlayerCharacterOnGiveDamageBattleLogDelegate OnGiveDamageBattleLogDelegate;    // 0x2138 (size: 0x10)
    void OnGiveDamageBattleLogDelegate(float Damage, const FSBDamageEvent& DamageEvent, class ASBPlayerCharacter* CauserPlayer, class ASBCharacter* DstCharacter);
    FSBPlayerCharacterOnDeathDelegate OnDeathDelegate;                                // 0x2148 (size: 0x10)
    void OnDeathDelegate();
    float CurrentDiedCountDown;                                                       // 0x2158 (size: 0x4)
    float TickDeadDelay;                                                              // 0x215C (size: 0x4)
    TArray<ESBAbilityFlags> ChangeRespawnPointAbilityFlagList;                        // 0x2160 (size: 0x10)
    TArray<FString> ChangeRespawnPointGameContentIdList;                              // 0x2170 (size: 0x10)
    char padding_15[0x200];                                                           // 0x2180 (size: 0x200)
    float FieldDeadDiedCountDown;                                                     // 0x2380 (size: 0x4)
    char padding_16[0x4];                                                             // 0x2384 (size: 0x4)
    class USBPlayerAppearEffectComponent* m_pPlayerAppearEffectComponent;             // 0x2388 (size: 0x8)
    class USBPlayerResurrectionComponent* m_pPlayerResurrectionComponent;             // 0x2390 (size: 0x8)
    FSBPlayerCharacterOnResurrectionDelegate OnResurrectionDelegate;                  // 0x2398 (size: 0x10)
    void OnResurrectionDelegate();
    class USBPlayerSkillActionComponent* SkillActionComponent;                        // 0x23A8 (size: 0x8)
    FSBSkillAction SkillAction;                                                       // 0x23B0 (size: 0x4A0)
    TArray<FCharaSkillMasteryInfo> m_ReplicatedSkillMasteryList;                      // 0x2850 (size: 0x10)
    char padding_17[0x18];                                                            // 0x2860 (size: 0x18)
    FSBPlayerSkillIDForReplicate m_SkillIDForReplication;                             // 0x2878 (size: 0x68)
    char padding_18[0x80];                                                            // 0x28E0 (size: 0x80)
    ESkillActionPosition m_LastSetupSkillPosition;                                    // 0x2960 (size: 0x1)
    char padding_19[0xA7];                                                            // 0x2961 (size: 0xA7)
    TArray<FSBPlayerAttackHitRecastSetting> AttackHitRecastSettingList;               // 0x2A08 (size: 0x10)
    char padding_20[0x14];                                                            // 0x2A18 (size: 0x14)
    int32 HiddenSkillPaletteRecastModifyPercent;                                      // 0x2A2C (size: 0x4)
    char padding_21[0x54];                                                            // 0x2A30 (size: 0x54)
    FSBAttackSettings AttackLight;                                                    // 0x2A84 (size: 0xC)
    FSBAttackSettings AttackLightSpecial;                                             // 0x2A90 (size: 0xC)
    FSBAttackSettings AttackHigh;                                                     // 0x2A9C (size: 0xC)
    FSBAttackSettings AttackHighSpecial;                                              // 0x2AA8 (size: 0xC)
    char padding_22[0x4];                                                             // 0x2AB4 (size: 0x4)
    FSBPlayerCharacterOnSkillAnimationStartDelegate OnSkillAnimationStartDelegate;    // 0x2AB8 (size: 0x10)
    void OnSkillAnimationStartDelegate(const ESkillActionPosition SkillPosition);
    FSBPlayerCharacterOnSkillChangedDelegate OnSkillChangedDelegate;                  // 0x2AC8 (size: 0x10)
    void OnSkillChangedDelegate(const ESkillActionPosition ChangedSAP);
    FSBPlayerCharacterOnImagineArtsChangedDelegate OnImagineArtsChangedDelegate;      // 0x2AD8 (size: 0x10)
    void OnImagineArtsChangedDelegate(const ESkillActionPosition ChangedSAP, FString UniqueId);
    char padding_23[0x20];                                                            // 0x2AE8 (size: 0x20)
    class USBPlayerSpecialSkill* m_pPlayerSpecialSkillComponent;                      // 0x2B08 (size: 0x8)
    TArray<FSBEffectAsset> m_SpecialSkillEffectList;                                  // 0x2B10 (size: 0x10)
    char padding_24[0x8];                                                             // 0x2B20 (size: 0x8)
    TArray<FSBPlayingEffect> m_PlayingSpecialSkillEffectList;                         // 0x2B28 (size: 0x10)
    char padding_25[0x878];                                                           // 0x2B38 (size: 0x878)
    TArray<FSBInventoryWeapon> AdditionalInventoryWeapons;                            // 0x33B0 (size: 0x10)
    FSBPlayerCharacterOnSpawnInventoryWeaponDelegate OnSpawnInventoryWeaponDelegate;  // 0x33C0 (size: 0x10)
    void OnSpawnInventoryWeaponDelegate(const int32 InventoryIndex, const TEnumAsByte<ESBWeaponEquipType> WeaponEquipType);
    FSBPlayerEquipWeaponParameterCache EquipWeaponParamCache;                         // 0x33D0 (size: 0x18)
    char padding_26[0x8];                                                             // 0x33E8 (size: 0x8)
    TArray<class ASBEnemyCharacter*> FindByEnemyList;                                 // 0x33F0 (size: 0x10)
    char padding_27[0x38];                                                            // 0x3400 (size: 0x38)
    int32 TrainingAreaOverlapNum;                                                     // 0x3438 (size: 0x4)
    char padding_28[0x4];                                                             // 0x343C (size: 0x4)
    TArray<class ASBEnemyCharacter*> BuddyList;                                       // 0x3440 (size: 0x10)
    char padding_29[0x1];                                                             // 0x3450 (size: 0x1)
    bool bCountCombo;                                                                 // 0x3451 (size: 0x1)
    char padding_30[0x2];                                                             // 0x3452 (size: 0x2)
    int32 m_ComboCount;                                                               // 0x3454 (size: 0x4)
    char padding_31[0x20];                                                            // 0x3458 (size: 0x20)
    int32 m_PartyChainComboCount;                                                     // 0x3478 (size: 0x4)
    float m_PartyChainComboKeepTimer;                                                 // 0x347C (size: 0x4)
    float m_PartyChainComboCoolTimer;                                                 // 0x3480 (size: 0x4)
    bool m_bInPartyChainComboDistance;                                                // 0x3484 (size: 0x1)
    ESBPartyChainSettingType m_PartyChainSettingType;                                 // 0x3485 (size: 0x1)
    char padding_32[0xA];                                                             // 0x3486 (size: 0xA)
    TSoftObjectPtr<UASAnimationSet> AnimationSetMale;                                 // 0x3490 (size: 0x28)
    TSoftObjectPtr<UASAnimationSet> AnimationSetFemale;                               // 0x34B8 (size: 0x28)
    TSoftObjectPtr<UASAnimationSet> AnimationSetMaleNoBattle;                         // 0x34E0 (size: 0x28)
    TSoftObjectPtr<UASAnimationSet> AnimationSetFemaleNoBattle;                       // 0x3508 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> StateMachine;                                     // 0x3530 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> UpperBodyStateMachine;                            // 0x3558 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> AimOffsetStateMachine;                            // 0x3580 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> AdditiveLandingStateMachine;                      // 0x35A8 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> AdditiveMeshSpaceStateMachine;                    // 0x35D0 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> AdditiveLocalSpaceStateMachine;                   // 0x35F8 (size: 0x28)
    char padding_33[0x28];                                                            // 0x3620 (size: 0x28)
    TArray<FSBAimBodyBlendRateSetting> m_AimBodyBlendRateAdjustSettingList;           // 0x3648 (size: 0x10)
    char padding_34[0xB6];                                                            // 0x3658 (size: 0xB6)
    uint8 m_TrainAnimationStep;                                                       // 0x370E (size: 0x1)
    char padding_35[0x26];                                                            // 0x370F (size: 0x26)
    FSBPlayerLoadCompleteParam m_LoadCompleteParam;                                   // 0x3735 (size: 0x1)
    char padding_36[0x2];                                                             // 0x3736 (size: 0x2)
    FSBPlayerCharacterOnLoadCompletePlayerDelegate OnLoadCompletePlayerDelegate;      // 0x3738 (size: 0x10)
    void OnLoadCompletePlayerDelegate(class ASBPlayerCharacter* PlayerCharacter);
    char padding_37[0x2];                                                             // 0x3748 (size: 0x2)
    bool bPlayerInitialParametersLoadCompleted;                                       // 0x374A (size: 0x1)
    char padding_38[0x25];                                                            // 0x374B (size: 0x25)
    class USBPlayerWarpComponent* m_pWarpComponent;                                   // 0x3770 (size: 0x8)
    class AActor* WarpPointActor;                                                     // 0x3778 (size: 0x8)
    class USBPlayerFishingComponent* m_pPlayerFishingComponent;                       // 0x3780 (size: 0x8)
    FSBPlayerCharacterOnActivateBuffToPlayerDelegate OnActivateBuffToPlayerDelegate;  // 0x3788 (size: 0x10)
    void OnActivateBuffToPlayerDelegate(class ASBPlayerCharacter* PlayerCharacter);
    char padding_39[0x8];                                                             // 0x3798 (size: 0x8)
    float m_DefaultPlayerNetCullHiddenTimer;                                          // 0x37A0 (size: 0x4)
    char padding_40[0x5C];                                                            // 0x37A4 (size: 0x5C)
    float m_DefaultPlayerDisableUpdateProcessTimer;                                   // 0x3800 (size: 0x4)
    char padding_41[0x8];                                                             // 0x3804 (size: 0x8)
    float m_SpecifyReasonHiddenPlayerWarpThreshold;                                   // 0x380C (size: 0x4)
    char padding_42[0x30];                                                            // 0x3810 (size: 0x30)
    class USBProjectileHitTargetLimitComponent* ProjectileHitTargetLimitComponent;    // 0x3840 (size: 0x8)
    char padding_43[0x2C];                                                            // 0x3848 (size: 0x2C)
    int32 NowSummoningMountIndex;                                                     // 0x3874 (size: 0x4)
    char padding_44[0x118];                                                           // 0x3878 (size: 0x118)
    int32 MountingImagineMountIndex;                                                  // 0x3990 (size: 0x4)
    char padding_45[0x34];                                                            // 0x3994 (size: 0x34)
    bool bIsAttachMountConditionRequest;                                              // 0x39C8 (size: 0x1)
    char padding_46[0x5B];                                                            // 0x39C9 (size: 0x5B)
    int32 MountDisableAreaOverlapNum;                                                 // 0x3A24 (size: 0x4)
    char padding_47[0x88];                                                            // 0x3A28 (size: 0x88)
    TArray<FSBPlayerEquipPassiveImagine> EquipPassiveImagineList;                     // 0x3AB0 (size: 0x10)
    FSBPlayingEffect m_PlayingLevelUpEffect;                                          // 0x3AC0 (size: 0xC8)
    FSBPlayingEffect m_PlayingAdventurerRankUpEffect;                                 // 0x3B88 (size: 0xC8)
    FSBPlayerPassiveArtsReplication m_PassiveArtsReplication;                         // 0x3C50 (size: 0x10)
    ESBClassType ClassType;                                                           // 0x3C60 (size: 0x1)
    uint8 Level;                                                                      // 0x3C61 (size: 0x1)
    char padding_48[0x6];                                                             // 0x3C62 (size: 0x6)
    class USBPCClassComponentBase* PlayerCharacterClassComponent;                     // 0x3C68 (size: 0x8)
    class USBPlayerCharacterLevelSyncComponent* LevelSyncComponent;                   // 0x3C70 (size: 0x8)
    ESBStackBEnableType StackBEnableType;                                             // 0x3C78 (size: 0x1)
    char padding_49[0x17];                                                            // 0x3C79 (size: 0x17)
    FSBPlayerCharacterOnAtGatheringPopupDelegate OnAtGatheringPopupDelegate;          // 0x3C90 (size: 0x10)
    void OnAtGatheringPopupDelegate(bool bIsVisible);
    char padding_50[0x40];                                                            // 0x3CA0 (size: 0x40)
    bool m_bIsCarrying;                                                               // 0x3CE0 (size: 0x1)
    bool m_bIsFreeArranging;                                                          // 0x3CE1 (size: 0x1)
    char padding_51[0x6];                                                             // 0x3CE2 (size: 0x6)
    class USBPlayerAttachableObjectComponent* AttachableObjectComponent;              // 0x3CE8 (size: 0x8)
    char padding_52[0x14];                                                            // 0x3CF0 (size: 0x14)
    FSBPlayerMiniMapInfo MiniMapInfo;                                                 // 0x3D04 (size: 0xC)
    char padding_53[0x39];                                                            // 0x3D10 (size: 0x39)
    bool bCountdownUIActive;                                                          // 0x3D49 (size: 0x1)
    char padding_54[0x6];                                                             // 0x3D4A (size: 0x6)
    FSBPlayerCharacterOnCountdownCancelDelegate OnCountdownCancelDelegate;            // 0x3D50 (size: 0x10)
    void OnCountdownCancelDelegate();
    FSBPlayerCharacterOnCountdownInteractionDelegate OnCountdownInteractionDelegate;  // 0x3D60 (size: 0x10)
    void OnCountdownInteractionDelegate(bool bPress);
    char padding_55[0x20];                                                            // 0x3D70 (size: 0x20)
    TSoftObjectPtr<UAkAudioEvent> LocalHitSE;                                         // 0x3D90 (size: 0x28)
    TSoftObjectPtr<UAkAudioEvent> EnemyDeadAttackSE;                                  // 0x3DB8 (size: 0x28)
    TSoftObjectPtr<UAkAudioEvent> ResourceShortageSE;                                 // 0x3DE0 (size: 0x28)
    class UAkComponent* VoiceComponent;                                               // 0x3E08 (size: 0x8)
    char padding_56[0x10];                                                            // 0x3E10 (size: 0x10)
    class USBPlayerBuddyVoiceComponent* m_pPlayerBuddyVoiceComponent;                 // 0x3E20 (size: 0x8)
    class UStaticMeshComponent* FaceLODComp;                                          // 0x3E28 (size: 0x8)
    int32 FaceLODLevel;                                                               // 0x3E30 (size: 0x4)
    char padding_57[0x4];                                                             // 0x3E34 (size: 0x4)
    class UStaticMesh* FaceStaticMeshMale;                                            // 0x3E38 (size: 0x8)
    class UStaticMesh* FaceStaticMeshFemale;                                          // 0x3E40 (size: 0x8)
    char padding_58[0x8];                                                             // 0x3E48 (size: 0x8)
    class USBPlayerAdminFuncComponent* AdminFuncComp;                                 // 0x3E50 (size: 0x8)
    TMap<class FName, class FSBPlayerAttackInfoForEnemy> PlayerAttackInfoForEnemy;    // 0x3E58 (size: 0x50)
    int32 CampCollisionCount;                                                         // 0x3EA8 (size: 0x4)
    bool IsCampFireUsed;                                                              // 0x3EAC (size: 0x1)
    char padding_59[0x3];                                                             // 0x3EAD (size: 0x3)
    float StatusAlimentByDelayTime;                                                   // 0x3EB0 (size: 0x4)
    char padding_60[0x6C];                                                            // 0x3EB4 (size: 0x6C)
    class USBPlayerEngramCannonComponent* m_pPlayerEngramCannonComponent;             // 0x3F20 (size: 0x8)
    class USBPlayerCheerfulItemComponent* m_pPlayerCheerfulItemComponent;             // 0x3F28 (size: 0x8)
    FSBPlayerCharacterOnRequestTermCommandMenuDelegate OnRequestTermCommandMenuDelegate; // 0x3F30 (size: 0x10)
    void OnRequestTermCommandMenuDelegate(bool bForce);
    char padding_61[0x10];                                                            // 0x3F40 (size: 0x10)
    class USBPlayerBehaviorHistoryLogComponent* m_pPlayerBehaviorHistoryLogComponent; // 0x3F50 (size: 0x8)
    char padding_62[0xE8];                                                            // 0x3F58 (size: 0xE8)
    class USBPlayerDebugComponent* DebugComponent;                                    // 0x4040 (size: 0x8)

    bool WillClassChangeByEquipChange(FString AddEquipUniqueID, bool InUseStorage);
    bool WasHitAttack();
    void TurnActorToAimDirectionConstant(const float DeltaTime, const float InterpSpeed, bool bIgnoreRange);
    void TurnActorToAimDirection(bool bIgnoreRange);
    void TrainingAreaOverlapStart();
    void TrainingAreaOverlapEnd();
    void TickMovingNoise(float DeltaTime);
    void TeleportWithDelay(FVector Location, FRotator Rotation, bool bWithFade, float DelayTime);
    bool TeleportTo(const FVector& DestLocation, const FRotator& DestRotation, bool bIsATest, bool bNoCheck);
    void StopMountEnergyRecoverOnServer();
    void StopMountEnergyRecover();
    void StartMountInterval();
    void StartMountGettingOff();
    void StartMountEnergyRecoverOnServer(const class AActor* InCauserActor);
    void StartMountEnergyRecover(const class AActor* InCauserActor);
    void SpawnWeapon(TArray<FSBSpawnWeaponLoadParam> RequestSpawnWeapons);
    void ShowHitIndicator(const FVector& InHitPosition, class AActor* InDamageCauser);
    void SetupSkillPreInputNextAttack();
    void SetupSkillAtPosition(ESkillActionPosition Position);
    void SetupLimitedKeyBind(const TArray<TEnumAsByte<ESBKeyConfigAction::Type>>& ActionList);
    void SetupKeyBind();
    void SetUnsheathed();
    void SetThrowObject(class AActor* Gimmick);
    void SetThrowFlag(bool IsThrow);
    void SetSpecialGauge(float Value);
    void SetSheathed();
    void SetPlayerRespawnLocationInfo(FVector NewLocation, float NewYaw);
    void SetMountStartDashRate(float Rate);
    void SetMountLocomotionNotify(bool isNotify);
    void SetMountEnergyTimeDamageScale(float InMountEnergyTimeDamageScale);
    void SetMiniMapRouteVisibility(const bool Visibility);
    void SetMiniMapId(const FName& MiniMapId);
    void SetLevel(int32 InLevel);
    void SetLastEmoteStateName(FString Value);
    void SetIsRunMountImagine(bool IsRun);
    void SetIsHandIkActiveForThrow(bool IsThrow);
    void SetIsHandIkActiveForMount(bool Active);
    void SetIsHandIkActiveForCarry(bool carry);
    void SetInCoinPubPrivateRoom(FString TriggerName, bool bIsIn);
    void SetFreeArrangeFlag(bool InFlag);
    void SetFastRecoveryEmote(bool Flag);
    void SetFailedSummonMount();
    void SetEnableAvatarRandomWaitFlag(bool InFlag);
    void SetEditWholeMap(bool Flag);
    void SetDamageCollisionTransformType(ESBPlayerDamageCollisionTransformType TransformType);
    void SetChangePassiveImagineRequestFlag(const bool bInIsFlagOn);
    void SetCarryFlag(bool carry);
    void SetCannotInput(ESBCannotInputType Type, bool bOn);
    void SetAimParam(ESBAimDirection DirectionType, FName StateMachineName, float AimBodyPitchRangeMin, float AimBodyPitchRangeMax, float AimBodyYawRangeMin, float AimBodyYawRangeMax, bool bInterpolation, float AimBodyPitchSpeed, float AimBodyYawSpeed, bool bAutoEndInterpolation);
    void SetAcceleratorSlope(float Slope);
    void SetAbnormalRemoteMountState(bool isAbnormal);
    void ServerUpdateFreeArrangeLocation(class AActor* InActor, FVector InVector, FRotator InRotator);
    void ServerUpdateFreeArrangeFlag(bool InFlag);
    void ServerUpdateCarryLocation(class AActor* CarryObj, FVector Location, FRotator Rotation);
    void ServerUpdateCarryFlag(bool carry);
    void ServerStartMountDirect(int32 InMountingImagineMountIndex);
    void ServerStartGather(float GatherMotionLoopTime);
    void ServerSpawnImagineCharacterInstance(UClass* AssetClass, int32 ImagineIndex, const FTransform& InMountSpawnTransform);
    void ServerSpawnEffect(FName SocketName, const TSoftObjectPtr<UParticleSystem>& ParticleSoftPtr, const TSoftObjectPtr<UAkAudioEvent>& SoundSoftPtr);
    void ServerShowLogIsPushModelEnabled();
    void ServerSetupPlayerOnMount(bool InIsPlayerOnMount, float InTargetableCompHeightOffset, float InCapsuleCollisionHeightOffset);
    void ServerSetUnsheathed(bool which);
    void ServerSetTrainAnimationStep(int32 TrainAnimationStep);
    void ServerSetSpecialGauge(float Value);
    void ServerSetReplicateMovement(bool bNewFlag);
    void ServerSetMountingImagineMountIndex(int32 InMountingImagineMountIndex);
    void ServerSetMiniMapInfo(const FSBPlayerMiniMapInfo& Info);
    void ServerSetLoadCompleteParam(const FSBPlayerLoadCompleteParam& Param);
    void ServerSetLastSetupSkillID(ESkillActionPosition Position);
    void ServerSetIsRunMountImagine(bool IsRun);
    void ServerSetDebugMoveFlag(bool EnableDebugMove);
    void ServerSetDamageState(bool bEnable);
    void ServerSetCurrentMountEnergy(float SetMountEnergy);
    void ServerSetCurrentFightingStyle(int32 FightingStyle);
    void ServerSetAimDirection(const FVector_NetRoughDirection& AimDirection);
    void ServerResetSkillSound();
    void ServerResetComboCount();
    void ServerResetCheatCheck_MoveOnServer_FlyingHistory();
    void ServerResetBattleStatus();
    void ServerRequestUnequipImagineData(const ESBCharaEquipType ImagineCharaEquipType);
    void ServerRequestResetMountDirect(int32 ImagineMountIndex);
    void ServerRequestLoadImagineMount(int32 ImagineTableIndex);
    void ServerRequestLoadAsset();
    void ServerRequestChangePassiveImagine(ESBPlayerPassiveImagineSlotType Slot, FString UniqueId);
    void ServerRequestChangeImagineData(const ESBCharaEquipType ImagineCharaEquipType, FString UniqueId);
    void ServerReplicateStateInfo_Unreliable(const FRepMovement& InReplicatedMovement, const FASReplicateStateInfo& InReplicateStateInfo, int8 InMovementMode, const FSBPlayerRepStateCheatInfo& InCheatInfo);
    void ServerReplicateStateInfo_Reliable(const FRepMovement& InReplicatedMovement, const FASReplicateStateInfo& InReplicateStateInfo, int8 InMovementMode, const FSBPlayerRepStateCheatInfo& InCheatInfo);
    void ServerReplicateStateInfo(bool bReliable);
    void ServerReplicateMovementInfo_Reliable(const FRepMovement& InReplicatedMovement, int8 InMovementMode, bool bMulticast, bool bWarp);
    void ServerReplicateMovementInfo(bool bMulticast, bool bWarp);
    void ServerRemoveOverlapEmemy(class ASBEnemyCharacter* OverlapEnemy);
    void ServerRegisterMountingPlayerAttachTransform(FVector attachPlayerPos, FRotator attachPlayerRot);
    void ServerOutputLogMountRideAction(bool bIsStartMount, int32 SummonMountID);
    void ServerOutputLogMountAttachState(bool bIsStartMount);
    void ServerNotifySkillAnimationStart(const ESkillActionPosition Position, const FVector& AttackDir, const uint16 SamplingId);
    void ServerNotifySkillAnimationEnd(const ESkillActionPosition Position);
    void ServerNotifyProjectileHit(ESkillActionPosition Position, class AActor* OtherActor, FName OtherCompName, const FHitResult& HitResult);
    void ServerNotifyMountAttachState(bool bIsAttach);
    void ServerNotifyDodgeAttackStart(bool bDodgeSucceeded);
    void ServerNotifyAerialAttackBonus(bool bBonus);
    void ServerMountAttachTiming();
    void ServerIntentionalDisconnection(FString InReasonMessage, const ESBCheatOshiokiType InCheatOshiokiType);
    void ServerExecMountJumpOnLaunch(FVector LaunchVelocity);
    void ServerExecMountFailedLaunch(FVector LaunchVelocity);
    void ServerEndGather(bool bSuccess);
    void ServerDetachMount(bool bIsDirect);
    void ServerDestroyImagineCharacterInstance(ESBImagineSummonCharacter ImagineType);
    void ServerDebugEnergyTireless(bool TirelessEnable);
    void ServerDebugEnergyRecovery(float EnergyRecoveryValue);
    void ServerCheckMountEnergyIsIllegalValue(float ClientEnergy);
    void ServerChangeSkill(const ESkillActionPosition Position, const int32 SkillId);
    void ServerChangeImagineArtsByName(int32 ImagineArtsSlotIndex, const FName& ImagineArtsName);
    void ServerCastSkill(ESkillActionPosition Position, const FSBPlayerCastSkillCheatInfo& CastSkillInfo, const FSBCheatCheckSendData_OnCastSkill& CheatCheckSendData);
    void ServerCalcEquipStatusDiff_PresetEquip(const TArray<FSBPlayerPresetEquipItem>& InEquipItemList);
    void ServerCalcEquipStatusDiff(FString CurrentUniqueID, FString NextUniqueID, bool InUseStorage);
    void ServerAddOverlapEmemy(class ASBEnemyCharacter* OverlapEnemy);
    void Server_SyncEnemyHitPoint(class ASBEnemyCharacter* InEnemy);
    void Server_SetFollow(class AActor* Followee, FString CharacterId);
    void Server_RequestServerGiveDeactivateStatusGroupByInteraction(class ASBPlayerCharacter* DstPlayerCharacter);
    void Server_RequestNotifyHatedTargetTakeAction(float HateValue);
    void Server_ReqEnemyImportantBattleEffective(class ASBEnemyCharacter* InEnemy);
    void Server_OnSavePresetEquipment(const int32 InListIndex, const FSBPlayerPresetEquipList& InPresetEquipList, const TArray<FSBPlayerPresetEquipItem>& InPresetEquipItems, const int32 InRetCode);
    void Server_OnPlayerLevelUp();
    void Server_OnPlayerAdventurerRankUp();
    void Server_OnLoadPresetEquipmentList(const TArray<FSBPlayerPresetEquipList>& InPresetEquipLists, const TArray<FSBPlayerPresetEquipItem>& InPresetEquipItems, const int32 InRetCode);
    void Server_LoadPresetEquipmentParam(const int32 RetCode);
    void SelfRespawn_Server(bool Force);
    void SelfRespawn_Multicast(bool Success);
    void ResetRecastTime();
    void ResetMountLocalDirect(bool bIsAutoCallToRemote);
    void ResetImagineArtsRecastTime();
    void ResetForDemo();
    void ResetDodgeSucceededFlag();
    void RequestServerGiveDeactivateStatusGroupByInteraction(class ASBPlayerCharacter* DstPlayerCharacter);
    void RequestSelfRespawn(bool Force);
    void RequestNotifyHatedTargetTakeAction(float HateValue);
    void RequestJointGesture(bool bRequest);
    void RequestFinishMountDirect();
    void RequestFinishMount();
    void RequestChangePassiveImagine(ESBPlayerPassiveImagineSlotType Slot, FString UniqueId);
    void RequestChangeImagineArts(int32 ImagineArtsSlotIndex, FString UniqueId);
    void RequestCalcEquipStatusDiff_BattleSet(const TArray<FSBPlayerPresetEquipItem>& InEquipItemList, const bool InUseStorage);
    void RequestCalcEquipStatusDiff(FString CurrentUniqueID, FString NextUniqueID, const bool InUseStorage);
    void Request_SwapPresetEquipmentList(const int32 InSrcListIndex, const int32 InDstListIndex);
    void Request_SavePresetEquipment(const int32 InListIndex, const FSBPlayerPresetEquipList& InPresetEquipList, const TArray<FSBPlayerPresetEquipItem>& InPresetEquipItems);
    void Request_SaveCharaCostumePresetEquip(const int32 listIndex, const ESBClassType InClassType, const TArray<FSBPlayerPresetEquipItem>& EquipItem);
    void Request_SaveCharaBattlePresetEquip(const int32 InListIndex, const bool bInIsClassChange);
    void Request_RenamePresetEquipmentList(const int32 InListIndex, FString InName);
    void Request_LoadPresetEquipmentParam(int32 listIndex);
    void Request_LoadPresetEquipmentList();
    void Request_DeletePresetEquipmentList(const int32 InListIndex);
    void RemoveAimParam(ESBAimDirection DirectionType, FName StateMachineName);
    void ReceiveUnsheatheByEquipType(TEnumAsByte<ESBWeaponEquipType> EquipType);
    void ReceiveUnsheathe();
    void ReceiveSheathe();
    void Recalc2ndStatus();
    int32 PlayVoice(class UAkAudioEvent* Event, ESBAkEventLOD LOD);
    int32 PlaySkillVoice(ESBAkEventLOD LOD);
    void PlayResourceShortageSE();
    void PlayerTakeAnyDamageSignature__DelegateSignature(class ASBPlayerCharacter* DamagedActor, float Damage, const FSBDamageEvent& DamageEvent, class AController* InstigatedBy, class AActor* DamageCauser);
    void OnStatusDiffAtRecalc2ndStatusDelegate__DelegateSignature();
    void OnStaminaRecoveredDelegate__DelegateSignature();
    void OnStaminaConsumeDelegate__DelegateSignature();
    void OnSpawnInventoryWeaponDelegate__DelegateSignature(const int32 InventoryIndex, const TEnumAsByte<ESBWeaponEquipType> WeaponEquipType);
    void OnSkillDataAvailable();
    void OnSkillChangedDelegate__DelegateSignature(const ESkillActionPosition ChangedSAP);
    void OnSkillAnimationStartDelegate__DelegateSignature(const ESkillActionPosition SkillPosition);
    void OnSetInitialMiniMapInfo(const FSBPlayerMiniMapInfo& Info);
    void OnServerReplicateStateInfoDelegate__DelegateSignature(class AActor* Actor, const FVector& Location);
    void OnResurrectionDelegate__DelegateSignature();
    void OnRequestTermCommandMenuDelegate__DelegateSignature(bool bForce);
    void OnRep_SkillActionForLoad();
    void OnRep_ReplicateStatusParameter();
    void OnRep_ReplicatedAimDirection();
    void OnRep_PassiveArtsReplication();
    void OnRep_MountingImagineMountIndex();
    void OnRep_Level();
    void OnRep_LastSetupSkillActionPosition();
    void OnRep_ComboCount();
    void OnRayHitForPlayerReticle(bool bHit, bool bProperDistance);
    void OnLossByEnemyLast();
    void OnLoadCompletePlayerDelegate__DelegateSignature(class ASBPlayerCharacter* PlayerCharacter);
    void OnLastHitActorInfo(class AActor* HitActor);
    void OnJankenUIDelegate__DelegateSignature();
    void OnJankenUI(class ASBPlayerCharacter* TargetPlayer);
    void OnInitialSkillDataFromNetworkDataCache(bool Result);
    void OnImagineArtsChangedDelegate__DelegateSignature(const ESkillActionPosition ChangedSAP, FString UniqueId);
    void OnHitForPlayerReticle(float Damage, bool bWeakHit);
    void OnGiveDamageBattleLogDelegate__DelegateSignature(float Damage, const FSBDamageEvent& DamageEvent, class ASBPlayerCharacter* CauserPlayer, class ASBCharacter* DstCharacter);
    void OnGetUserItemCompleted();
    void OnFindByEnemyFirst();
    void OnEndStartParticleOfPlayerTransform(class UParticleSystemComponent* ParticleSystemComponent);
    void OnDeathDelegate__DelegateSignature();
    void OnDeadNotifyMessage(const FText& Name);
    void OnCountdownInteractionDelegate__DelegateSignature(bool bPress);
    void OnCountdownCancelDelegate__DelegateSignature();
    void OnClassLevelUp(class UObject* Sender, class UObject* Param);
    void OnCastSkill(const ESkillActionPosition Position);
    void OnCapsuleComponentHitCallback(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const FVector& NormalInpulse, const FHitResult& SweepResult);
    void OnCalcEquipStatusDiffDelegate__DelegateSignature();
    void OnAtGatheringPopupDelegate__DelegateSignature(bool bIsVisible);
    void OnAdventurerRankUp(class UObject* Sender, class UObject* Param);
    void OnActivateBuffToPlayerDelegate__DelegateSignature(class ASBPlayerCharacter* PlayerCharacter);
    void NotifyTrainAnimationStart(float AnimLength, const float BasePlayRate, const float PlayRateAdjustMax, const float PlayRateAdjustMin, const float EasingTimeRange, const int32 TrainStepNum);
    void NotifyTrainAnimationSetup(float SearchDistance, float SearchDegree);
    void NotifySyncAnimationStart(float AnimLength, const float BasePlayRate, const float PlayRateAdjustMax, const float PlayRateAdjustMin, const float EasingTimeRange, const float SyncAnimTimeShiftTime, class UCurveFloat* SyncRateCurve);
    void NotifySyncAnimationEnd();
    void NotifySkillNextAnimationStart(class UObject* InstigatorObject);
    void NotifyReloadEnd();
    void NotifyMountAttachTiming();
    void NotifyLaunchEnemyStepJump();
    void NotifyEndDashByOutOfStamina();
    void NotifyCastLastSetupSkill(int32 CastIndex, const class UAnimSequenceBase* AnimSequence, const class UAnimNotify* AnimNotify);
    void NotifyCastImagineSkill();
    void NotifyBattleAreaClear();
    void MulticastStartMountDirect(int32 InMountingImagineMountIndex);
    void MulticastSpawnImagineCharacterInstance(UClass* AssetClass, int32 ImagineIndex, const FTransform& InMountSpawnTransform);
    void MulticastSpawnEffect(FName SocketName, const TSoftObjectPtr<UParticleSystem>& ParticleSoftPtr, const TSoftObjectPtr<UAkAudioEvent>& SoundSoftPtr);
    void MulticastSkillMastery(const TArray<FCharaSkillMasteryInfo>& SkillMasteryList);
    void MulticastSetTrainAnimationStep(int32 TrainAnimationStep);
    void MulticastSetLoadCompleteParam(const FSBPlayerLoadCompleteParam& Param);
    void MulticastSetInitialSkill1To4();
    void MulticastSetInitialCachedProperty(const FSBPlayerCachedProperty& PlayerCachedProperty, const bool bResurrection);
    void MulticastResetSkillSound();
    void MulticastRequestResetMountDirect(int32 ImagineMountIndex);
    void MulticastRequestLoadImagineMount(int32 ImagineTableIndex);
    void MulticastRequestLoadAsset();
    void MulticastRequestFinishMountDirect();
    void MulticastRequestChangePassiveImagine(ESBPlayerPassiveImagineSlotType Slot, FString UniqueId);
    void MulticastReplicateMovementInfo(const FRepMovement& InReplicatedMovement, int8 InMovementMode, bool bWarp);
    void MulticastRegisterMountingPlayerAttachTransform(FVector attachPlayerPos, FRotator attachPlayerRot);
    void MulticastRecalcStatus();
    void MulticastRecalc2ndStatus(const FSBCharacterStatus& Status);
    void MulticastOnUnequipImagineCommon(const ESBCharaEquipType ImagineCharaEquipType);
    void MulticastOnChangeImagineCommon(const ESBCharaEquipType ImagineCharaEquipType, FString UniqueId, const FName& ImagineName);
    void MulticastNotifyProjectileHit(ESkillActionPosition Position, class AActor* OtherActor, FName OtherCompName, const FHitResult& HitResult);
    void MulticastNotifyBattleAreaClear();
    void MulticastMountInterrupted();
    void MulticastMountAttachTiming();
    void MulticastIntentionalDisconnection(FString InReasonMessage, const ESBCheatOshiokiType InCheatOshiokiType);
    void MulticastExecMountJumpOnLaunch(FVector LaunchVelocity);
    void MulticastExecMountFailedLaunch(FVector LaunchVelocity);
    void MulticastEquipWeaponParamCache(const FSBPlayerEquipWeaponParameterCache& ParamCache);
    void MulticastEndPlayerInitialParameters();
    void MulticastDetachMount(bool bIsDirect);
    void MulticastDestroyImagineCharacterInstance(ESBImagineSummonCharacter ImagineType);
    void MulticastChangeImagineArtsByName(int32 ImagineArtsSlotIndex, const FName& ImagineArtsName);
    void MulticastCastSkill(ESkillActionPosition Position);
    void MulticastAerialAttackBonus(bool bBonus);
    void Multicast_UseItem(const int32 InItemID);
    void Multicast_SetRateHitPoint(float Percent);
    void Multicast_SetFullHitPoint();
    void Multicast_SetFollow(class AActor* Followee, FString CharacterId);
    void Multicast_SetCurrentHitPoint();
    void Multicast_OnPlayerLevelUp();
    void Multicast_OnPlayerAdventurerRankUp();
    void MountDisableAreaOverlapStart();
    void MountDisableAreaOverlapEnd();
    void MakeMovingNoise(float Loudness, FVector NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker);
    bool IsValidSpawningCacheImagineMount();
    bool IsValidMountIndex();
    bool IsUnsheathe();
    bool IsTrainingBattleState();
    bool IsThrowing(class AActor* Gimmick);
    bool IsSkillPressedTriggered(const TSoftClassPtr<USBSkillInfoClass>& SkillAsset);
    bool IsSkillPressed(const TSoftClassPtr<USBSkillInfoClass>& SkillAsset);
    bool IsSkillActive(const ESkillActionPosition Position);
    bool IsSheathe();
    bool IsSetupImagineSkillArts2();
    bool IsRespawn();
    bool IsRequestedDirectMountStart();
    bool IsRequestedDirectMountEnd();
    bool IsRemoteMountSummonInst();
    bool IsQuestEventMode();
    bool IsPlayerInteraction();
    bool IsPlayerInitialParametersLoadCompleted();
    bool IsPlayerExtraFootHoldValid();
    bool IsPlayerBot();
    bool IsPassiveImagineEquipped(FString UniqueId, ESBPlayerPassiveImagineSlotType& OutEquippedSlot);
    bool IsMovingByWarpAroundEffect();
    bool IsMountDash();
    bool IsMountAttachStartHeight(const float InPlayerAttachSocketHeight);
    bool IsMountAssetLoaded();
    bool IsMasterySkill(const int32 SkillId);
    bool IsLevelSyncApplied();
    bool isLevelLimit();
    bool IsInvincible();
    bool IsInPartyChainComboDistance();
    bool IsInheritDeathFromPreviousMap();
    bool IsImagineArtsEquipped(FString UniqueId, ESkillActionPosition& OutEquippedPosition);
    bool IsHiddenBuddyNpc();
    bool IsGathering();
    bool IsGameInputReleaseTriggered(EGameInput inputLabel);
    bool IsGameInputPressTriggered(EGameInput inputLabel);
    bool IsGameInputPressed(EGameInput inputLabel);
    bool IsFreeArranging();
    bool IsFishingMode();
    bool IsFindByEnemy();
    bool IsFieldDead();
    bool IsFastRecoveryEmote();
    bool IsFallingByMountGetoffJump();
    bool IsFallingByEnemyStepJump();
    bool IsFailedSummonMount();
    bool IsExistImagineMount();
    bool IsEngramCannonAction();
    bool IsEnableSummonMount(bool IsDebugErrorPrintPut, bool IsEquipedCheck);
    bool IsEnableAvatarRandomWait();
    bool isEditWholeMap();
    bool IsDebugMoveMode();
    bool IsDamageState();
    bool IsClimbing();
    bool IsCheerfulItemActive();
    bool IsCarrying();
    bool IsCampCollisionCount();
    bool IsAutoRunWalk();
    bool IsAutoRunDash();
    bool IsAutoRunActive();
    bool IsAimBlend();
    bool IsAdminHide();
    bool IsActionGameInputPressTriggered();
    void InitEquipWeaponStatus(TArray<int32>& OutEquipWeaponStatus);
    void IncrementPlaySkillSoundCount();
    void IncrementCampCollisionCount();
    bool HasForecastLocation();
    void GiveDamageBattleLogEvent(float fDamage, const FSBDamageEvent& DamageEvent, class ASBPlayerCharacter* InCauserPlayer, class ASBCharacter* InDstCharacter);
    FVector GetWorldMoveInput();
    float GetWalkSpeedTypeSpeedRate(ESBPlayerWalkSpeedType SpeedType);
    ESBPlayerWalkSpeedType GetWalkSpeedType();
    float GetWalkBSSampleValueXOnMount();
    float GetWaitBSSampleValueXOnMount();
    class UAkComponent* GetVoiceComponent();
    class ASBPlayerState* GetValidPlayerState();
    class AActor* GetThrowObject();
    int32 GetTeamNumber();
    FRotator GetTargetComponentDirection(bool bNeedLockon);
    class USBTargetableComponent* GetTargetableComponent();
    class AActor* GetTargetableActor();
    class UASStateMachine* GetStateMachine();
    ESBStackBEnableType GetStackBEnableType();
    class ASBMount* GetSpawningCacheImagineMount();
    int32 GetSkillRemainingCount(ESkillActionPosition Position);
    float GetSkillRecastTime(const ESkillActionPosition Position);
    FVector GetSkillPreInputMoveWorldDirection();
    FVector2D GetSkillPreInputMoveDirection();
    class USBPlayerSkillMarker* GetSkillMarkerComponent();
    class USBSkillInfoClass* GetSkillInfo(ESkillActionPosition Position);
    int32 GetSkillID(const ESkillActionPosition Position);
    class USBPlayerSkillActionComponent* GetSkillActionComponent();
    class USBImagineSkillInfo* GetSetupImagineSkill();
    class USBRaidBattleComponent* GetSBRaidBattleComponent();
    float GetRunBSSampleValueXOnMount();
    FRotator GetReticleWorldRotation();
    class USBPlayerPresetEquipComponent* GetPresetEquipComponent();
    void GetPresetEquipBattleSetElementResistanceBP(const TArray<FSBPlayerPresetEquipItem>& InEquipItemList, const TArray<ESBAttribute>& InAttributeOrderList, TArray<float>& OutElementResistanceList);
    float GetPlayRateForAnimationSync(const float AnimTime);
    class USBPlayerWarpComponent* GetPlayerWarpComponent();
    class USBPlayerTargetingComponent* GetPlayerTargetingComponent();
    class USBPlayerSpecialSkill* GetPlayerSpecialSkillComponent();
    class USBPlayerResurrectionComponent* GetPlayerResurrectionComponent();
    class USBPlayerMovementComponent* GetPlayerMovement();
    class USBPlayerInteractionComponent* GetPlayerInteractionComponent();
    class USBPlayerHoldHandComponent* GetPlayerHoldHandComponent();
    class USBPlayerFishingComponent* GetPlayerFishingComponent();
    class USBPlayerEngramCannonComponent* GetPlayerEngramCannonComponent();
    class USBPlayerCheerfulItemComponent* GetPlayerCheerfulItemComponent();
    class USBPlayerCameraComponent* GetPlayerCameraComponent();
    class USBPlayerBuddyVoiceComponent* GetPlayerBuddyVoiceComponent();
    class USBPlayerAppearEffectComponent* GetPlayerAppearEffectComponent();
    FString GetPassiveImagineUniqueID(ESBPlayerPassiveImagineSlotType Slot);
    FString GetPartyId();
    float GetPartyChainComboKeepTimerRate();
    float GetPartyChainComboKeepTimer();
    int32 GetPartyChainComboCount();
    float GetPartyChainComboCoolTimerRate();
    float GetPartyChainComboCoolTimer();
    float GetPartyChainBonusDamageModifyRate();
    FSBCharacterStatus GetOriginalStatus();
    int32 GetOriginalLevel();
    FVector GetMoveInput3D();
    FVector2D GetMoveInput2D();
    FVector GetMoveDestinationByWarpAroundEffect();
    float GetMountSummonPosOffsetFront();
    float GetMountStartDashRate();
    float GetMountSpeedRate();
    float GetMountPlayerAttachShiftZ();
    float GetMountPlayerAttachShiftY();
    bool GetMountLocomotionNotify();
    FVector GetMountJumpOnVelocity();
    FVector GetMountJumpOnStartFallVelocity(const FVector AttachSocketLocation);
    FVector GetMountJumpOnLaunchVelocity();
    FVector GetMountJumpOffVelocity();
    float GetMountIntervalMax();
    float GetMountInterval();
    float GetMountEndLaunchRate();
    int32 GetMountDisableAreaOverlapNum();
    class USBMeshClimbingComponent* GetMeshClimbingComponent();
    float GetMaxHitPointWithoutResurrectionAdjust();
    int32 GetLevelSyncTarget();
    int32 GetLevelLimit();
    int32 GetLevel();
    FVector GetLastSkillPositionInputMoveWorldDirection(const ESkillActionPosition Position);
    FVector2D GetLastSkillPositionInputMoveDirection(const ESkillActionPosition Position);
    ESkillActionPosition GetLastSetupSkillPosition();
    FVector GetLastMoveInput3D();
    FVector2D GetLastMoveInput2D();
    FVector GetLastForecastLocation();
    FString GetLastEmoteStateName();
    bool GetIsHandIkActiveForMount();
    FString GetImagineUniqueID(const ESkillActionPosition Position);
    FName GetImagineName(const ESkillActionPosition Position);
    class ASBMount* GetImagineMount();
    ESBHostility GetHostilityAt(const class ASBPlayerCharacter* OtherPlayerCharacter);
    FVector GetGroundAssumeLocation();
    float GetGameInputPressTime(EGameInput inputLabel);
    int32 GetExp(const class UObject* WorldContextObject);
    int32 GetEquipStatusDiffRequestResult(FString FromUniqueID, FString ToUniqueID);
    FSBCharacterStatus GetEquipStatusDiffBattleSet(const TArray<FSBPlayerPresetEquipItem>& InEquipItem, const bool InUseStorage);
    FSBCharacterStatus GetEquipStatusDiff(FString CurrentUniqueID, FString NextUniqueID);
    class USphereComponent* GetEnemyStepJumpCollisionComponent();
    float GetEnableHealMaxHitPoint();
    bool GetEnableAvatarRandomWaitFlag();
    class USBDhcBattleComponent* GetDhcBattleComponent();
    float GetCurrentWalkSpeedTypeSpeedRate();
    ESBPlayerSkillPaletteSide GetCurrentSkillPaletteSide();
    float GetCurrentSkillChargeRatio();
    int32 GetCurrentSkillChargeLevelMax();
    int32 GetCurrentSkillChargeLevel();
    float GetCurrentMountEnergy();
    int32 GetCurrentFightingStyle();
    float GetCurrentDiedCountDown();
    int32 GetComboCount();
    FVector GetCliffJumpVelocity();
    int32 GetCampCollisionCount();
    class UASAnimationSet* GetAnimationSet();
    class UASStateMachine* GetAimStateMachine();
    FRotator GetAimRotation();
    class UASStateMachine* GetAimOffsetStateMachine();
    class UASStateMachine* GetAdditiveMeshSpaceStateMachine();
    class UASStateMachine* GetAdditiveLocalSpaceStateMachine();
    float GetAcceleratorVector();
    float GetAcceleratorSlopeReverse();
    float GetAcceleratorSlope();
    bool GetAbnormalRemoteMountState();
    void FollowWithCharaId(class AActor* Followee, FString CharacterId);
    void Follow(class AActor* Followee);
    void FieldDead_Server(ESBFieldDamageType FieldDamageType);
    void FieldDead_Multicast(ESBFieldDamageType FieldDamageType);
    void EndMountGettingOff();
    void EndClimbingDamage();
    void DebugServerStartMountToAllPlayer(FName MountName);
    void DebugServerSendAnimCommandToSimulated(FName Command);
    void DebugServerResetMountRemoteDirectToAllPlayer();
    void DebugServerBurdeningDummyRPC(int32 dummySendMulticastNum, int32 dummySendRepeatNum, float dummySendIntervalMsec);
    void DebugMulticastStartMountToAllPlayer(FName MountName);
    void DebugMulticastSendAnimCommandToSimulated(FName Command);
    void DebugMulticastResetMountRemoteDirect();
    void DebugMulticastBurdeningDummyRPC(const FSBBurderingDummyData& dummySendData);
    void DebugMenu();
    void ClientStartGather();
    void ClientSkillProjectilePlayer(const ESkillActionPosition Position, FDataTableRowHandle Handle);
    void ClientShowPartyChainComboCountLog(ESBPartyChainComboCountLogType ShowLogType);
    void ClientShowLogIsPushModelEnabled(bool IsPushModelEnabled);
    void ClientSetMountEnergy(float MountEnergy);
    void ClientSetInitialMiniMapInfo(const FSBPlayerMiniMapInfo& Info);
    void ClientReturnEquipStatusDiff_PresetEquip(const TArray<FSBPlayerPresetEquipItem>& InEquipItemList, const TArray<FSBCharacterStatus>& InEquipStatusDiff);
    void ClientReturnEquipStatusDiff(FString CurrentUniqueID, FString NextUniqueID, const FSBCharacterStatus& EquipStatusDiff, bool InUseStorage);
    void ClientNotifyOtherPlayerOutToNetCullDistance(class ASBPlayerCharacter* OtherPlayerCharacter);
    void ClientNotifyOtherPlayerIntoNetCullDistance(class ASBPlayerCharacter* OtherPlayerCharacter);
    void ClientEndGather(bool bSuccess);
    void ClientAttackHitRecastChange(const int32 Index, const ESkillActionPosition Position);
    void Client_AnsEnemyImportantBattleEffective(class ASBEnemyCharacter* InEnemy, const FSBEffectiveImpotantStatusParam& Param);
    void ClearSkillAction();
    void ClearMountState_OnInstanceDelete();
    void ClearEquipStatusDiffCache();
    bool ClearEnemyDropTreasureBox();
    void ClearCampCollisionCount();
    void ClearActionForDemo();
    bool CheckWallHitBeforeGettingOffMount();
    bool CheckStamina(float BaseConsumeAmountStamina, bool bNotifyFew, int32 CorrectValue, bool bApplyStatusValue);
    void CheatCommand_OverrideEnemyDropRatio(ESBEnemyDropItemType DropItemType, float DropRatio);
    bool ChangeSkill(const int32 SkillIndex, const int32 SkillId);
    bool CanWalk();
    bool CanStartSkillAtPosition(ESkillActionPosition Position, bool bNotification, bool bForUI);
    bool CanStartImagineArts();
    bool CanPlayEmoteStatusByEmoteName(const FName& EmoteName, bool bIsDebugRequest);
    bool CanPlayEmoteStatusByEmoteId(const FName& EmoteId, bool bIsDebugRequest);
    bool CanPlayEmoteStatus(bool bIsDebugRequest);
    bool CanPartyChainCombo();
    bool CanChangeSkillPosition(const ESkillActionPosition Position);
    void CancelWarp();
    bool CanAutoSheathe();
    FVector CalcMountJumpOnBallisticLaunchVelocity(const FVector AttachSocketLocation);
    void CacheStatusMasterData();
    void BP_OnStopDemo();
    void BP_OnPlayDemo();
    void AdjustCurrentStamina(const float AddValue, bool bNotify, int32 CorrectValue, bool bApplyStatusValue);
    void AddSkillRecastTime(const TSoftClassPtr<USBSkillInfoClass> SkillAsset, float AddTime);
    void AddLastSetupSkillRecastTime();
}; // Size: 0x4050

class ASBPlayerController : public ASBPlayerControllerBase
{
    class ASBPlayerCharacter* SBPlayerCharacter;                                      // 0x0668 (size: 0x8)
    char padding_0[0x18];                                                             // 0x0670 (size: 0x18)
    int32 ClassId;                                                                    // 0x0688 (size: 0x4)
    char padding_1[0xB8];                                                             // 0x068C (size: 0xB8)
    float m_GamePadCameraZoomInOutScale;                                              // 0x0744 (size: 0x4)
    char padding_2[0x740];                                                            // 0x0748 (size: 0x740)
    TSubclassOf<class ASBPerformanceCamera> PerformanceCameraActor;                   // 0x0E88 (size: 0x8)
    char padding_3[0x8];                                                              // 0x0E90 (size: 0x8)
    class USBReticleComponent* ReticleComponent;                                      // 0x0E98 (size: 0x8)
    FDataTableRowHandle GodModeGameModeHandle;                                        // 0x0EA0 (size: 0x10)
    FDataTableRowHandle GodModeUserHandle;                                            // 0x0EB0 (size: 0x10)
    FDataTableRowHandle GodModeAdminHandle;                                           // 0x0EC0 (size: 0x10)
    FDataTableRowHandle ReverberationGodModeHandle;                                   // 0x0ED0 (size: 0x10)
    FDataTableRowHandle SksBattleGodModeHandle;                                       // 0x0EE0 (size: 0x10)
    FSBPlayerControllerOnPlayerActivateGodModeResultDelegate OnPlayerActivateGodModeResultDelegate; // 0x0EF0 (size: 0x10)
    void OnPlayerActivateGodModeResultDelegate(bool Result);
    FSBPlayerControllerOnPlayerDeactivateGodModeResultDelegate OnPlayerDeactivateGodModeResultDelegate; // 0x0F00 (size: 0x10)
    void OnPlayerDeactivateGodModeResultDelegate(bool Result);
    FSBPlayerControllerOnPlayerDeactivateReverberationGodModeResultDelegate OnPlayerDeactivateReverberationGodModeResultDelegate; // 0x0F10 (size: 0x10)
    void OnPlayerDeactivateReverberationGodModeResultDelegate(bool Result);
    char padding_4[0x28];                                                             // 0x0F20 (size: 0x28)
    class USBPlayerGatherPointComponent* PlayerGatherPointComponent;                  // 0x0F48 (size: 0x8)
    class USBPlayerFieldActorPickupComponent* PlayerFieldActorPickupComponent;        // 0x0F50 (size: 0x8)
    class USBPlayerAutoDeliveryQuestComponent* PlayerAutoDeliveryQuestComponent;      // 0x0F58 (size: 0x8)
    char padding_5[0x8];                                                              // 0x0F60 (size: 0x8)
    FSBPlayerControllerOnGetUserItemCompletedDelegate OnGetUserItemCompletedDelegate; // 0x0F68 (size: 0x10)
    void OnGetUserItemCompletedDelegate();
    class USBQuestComponent* QuestComponent;                                          // 0x0F78 (size: 0x8)
    FSBPlayerControllerOnWeaponEquipDelegate OnWeaponEquipDelegate;                   // 0x0F80 (size: 0x10)
    void OnWeaponEquipDelegate(int32 RetCode, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const FSBExpiredEquipmentData& InExpiredEquipmentData);
    TArray<FSBStatusAilmentWhenRespawnIfAbilityFlagWhenDead> StatusAilmentWhenRespawnIfAbilityFlagWhenDead; // 0x0F90 (size: 0x10)
    FSBPlayerControllerOnGetMyCharacterInfoDelegate OnGetMyCharacterInfoDelegate;     // 0x0FA0 (size: 0x10)
    void OnGetMyCharacterInfoDelegate(bool Result);
    char padding_6[0x3C8];                                                            // 0x0FB0 (size: 0x3C8)
    FSBPlayerControllerOnSaveCharaCostumeEquipDelegate OnSaveCharaCostumeEquipDelegate; // 0x1378 (size: 0x10)
    void OnSaveCharaCostumeEquipDelegate(int32 RetCode, const FSBExpiredEquipmentData& InExpiredEquipmentData);
    FSBPlayerControllerOnSaveCharaImagineEquipsDelegate OnSaveCharaImagineEquipsDelegate; // 0x1388 (size: 0x10)
    void OnSaveCharaImagineEquipsDelegate(int32 RetCode, const ESBCharaEquipType EquipType, FString UniqueId, const bool IsEquip, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const FSBExpiredEquipmentData& InExpiredEquipmentData);
    FSBPlayerControllerOnCharaEquipPassiveImagineChangedDelegate OnCharaEquipPassiveImagineChangedDelegate; // 0x1398 (size: 0x10)
    void OnCharaEquipPassiveImagineChangedDelegate();
    FSBPlayerControllerOnSaveCharaConfigDelegate OnSaveCharaConfigDelegate;           // 0x13A8 (size: 0x10)
    void OnSaveCharaConfigDelegate(bool Result);
    char padding_7[0x68];                                                             // 0x13B8 (size: 0x68)
    class USBNetworkDataCache* NetworkDataCache;                                      // 0x1420 (size: 0x8)
    bool bIsMainMenuOpen;                                                             // 0x1428 (size: 0x1)
    bool bIsShopMenuOpen;                                                             // 0x1429 (size: 0x1)
    bool bIsTextWindowOpen;                                                           // 0x142A (size: 0x1)
    bool bIsQuestMenuOpen;                                                            // 0x142B (size: 0x1)
    char padding_8[0x15];                                                             // 0x142C (size: 0x15)
    bool bIsLockQuickAccess;                                                          // 0x1441 (size: 0x1)
    char padding_9[0x6];                                                              // 0x1442 (size: 0x6)
    class USBPlayerUIComponent* UIComponent;                                          // 0x1448 (size: 0x8)
    bool IsWarpMoveStart;                                                             // 0x1450 (size: 0x1)
    char padding_10[0x7];                                                             // 0x1451 (size: 0x7)
    class USBCheatCommandPlayerComponent* PlayerCheatComponent;                       // 0x1458 (size: 0x8)
    class USBCheatCommandProjectileComponent* ProjectileCheatComponent;               // 0x1460 (size: 0x8)
    class USBCheatCommandUtilityComponent* UtilityCheatComponent;                     // 0x1468 (size: 0x8)
    char padding_11[0x10];                                                            // 0x1470 (size: 0x10)
    FSBPlayerControllerOnClientRestart OnClientRestart;                               // 0x1480 (size: 0x10)
    void OnCompleteClientRestart();
    FSBTravelOption TravelRetryOption;                                                // 0x1490 (size: 0x90)
    int32 TravelRetryCnt;                                                             // 0x1520 (size: 0x4)
    bool TravelRetryWait;                                                             // 0x1524 (size: 0x1)
    char padding_12[0x3];                                                             // 0x1525 (size: 0x3)
    float TravelRetryTimer;                                                           // 0x1528 (size: 0x4)
    float TravelRetryInterval;                                                        // 0x152C (size: 0x4)
    FSBPlayerControllerClassChangeNotify ClassChangeNotify;                           // 0x1530 (size: 0x10)
    void OnClassChangeNotify(const int32 InRetCode, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    FSBPlayerControllerOnAttachedClientPlayerStateDelegate OnAttachedClientPlayerStateDelegate; // 0x1540 (size: 0x10)
    void OnAttachedClientPlayerState(class ASBPlayerController* PlayerController);
    char padding_13[0x8];                                                             // 0x1550 (size: 0x8)
    class USBPlayerConcernedList* PlayerConcernedList;                                // 0x1558 (size: 0x8)
    FSBPlayerControllerOnSaveMapPinInfosDelegate OnSaveMapPinInfosDelegate;           // 0x1560 (size: 0x10)
    void OnSaveMapPinInfosDelegate(const bool Result, const ESBMapErrorCode ErrorCode);
    FSBPlayerControllerOnRecoverRewardPlusCountDelegate OnRecoverRewardPlusCountDelegate; // 0x1570 (size: 0x10)
    void OnRecoverRewardPlusCountDelegate(ESBRecoverRewardPlusCountResult Result);
    class USBPlayerCharacterCommonComponent* PlayerCharacterCommonComponent;          // 0x1580 (size: 0x8)
    FSBPlayerControllerOnChangePlayerCharacterDelegate OnChangePlayerCharacterDelegate; // 0x1588 (size: 0x10)
    void OnChangePlayerCharacterDelegate(class APawn* InPawn);
    char padding_14[0x8];                                                             // 0x1598 (size: 0x8)
    class USBPlayerMailComponent* MailComponent;                                      // 0x15A0 (size: 0x8)
    char padding_15[0x20];                                                            // 0x15A8 (size: 0x20)
    class USBCharactersLogComponent* CharacterLogComponent;                           // 0x15C8 (size: 0x8)
    class USBPlayerAchievementComponent* PlayerAchievementComponent;                  // 0x15D0 (size: 0x8)
    class USBPlayerAwardComponent* PlayerAwardComponent;                              // 0x15D8 (size: 0x8)
    class USBPlayerCraftComponent* PlayerCraftComponent;                              // 0x15E0 (size: 0x8)
    class USBImagineLabComponent* ImaginLabComp;                                      // 0x15E8 (size: 0x8)
    class USBPlayerWeaponEnhancementComponent* PlayerWeaponEnhanceComp;               // 0x15F0 (size: 0x8)
    class USBPlayerTreasureBoxComponent* PlayerTreasureBoxComponent;                  // 0x15F8 (size: 0x8)
    class USBPlayerArtsComponent* PlayerArtsComponent;                                // 0x1600 (size: 0x8)
    class USBPlayerLiquidMemoryComponent* PlayerLiquidMemoryComponent;                // 0x1608 (size: 0x8)
    class USBTheaterComponent* TheaterComponent;                                      // 0x1610 (size: 0x8)
    class USBPartyRecruitComponent* PartyRecruitComponent;                            // 0x1618 (size: 0x8)
    class USBPlayerAcEventComponent* AcEventComponent;                                // 0x1620 (size: 0x8)
    class USBPlayerNaEventComponent* NaEventComponent;                                // 0x1628 (size: 0x8)
    class USBPlayerSeasonPassComponent* SeasonPassComponent;                          // 0x1630 (size: 0x8)
    class USBPlayerFmComponent* FmComponent;                                          // 0x1638 (size: 0x8)
    class USBPlayerRewardBoostComponent* RewardBoostComponent;                        // 0x1640 (size: 0x8)
    class USBReportComponent* ReportComponent;                                        // 0x1648 (size: 0x8)
    class USBOutGameBuffComponent* OutGameBuffComponent;                              // 0x1650 (size: 0x8)
    class USBPlayerAdventureBoardComponent* AdventureBoardComponent;                  // 0x1658 (size: 0x8)
    class USBCharacterCampFireComponent* CharacterCampFireComponent;                  // 0x1660 (size: 0x8)
    char padding_16[0x8];                                                             // 0x1668 (size: 0x8)
    FSBPlayerControllerOnRenameCompleteDelegate OnRenameCompleteDelegate;             // 0x1670 (size: 0x10)
    void OnCompletedCharacterName(const int32 RetCode);
    char padding_17[0x4];                                                             // 0x1680 (size: 0x4)
    float MouseCursorAreaMargin;                                                      // 0x1684 (size: 0x4)
    char padding_18[0x8];                                                             // 0x1688 (size: 0x8)
    FSBPlayerControllerOnUseSupplyDelegate OnUseSupplyDelegate;                       // 0x1690 (size: 0x10)
    void OnUseSupplyDelegate(const bool Result);
    FDateTime LevelInDate;                                                            // 0x16A0 (size: 0x8)
    int32 LevelInDateStatus;                                                          // 0x16A8 (size: 0x4)
    char padding_19[0x4];                                                             // 0x16AC (size: 0x4)
    TArray<FSBDungeonSupply> SupplyList;                                              // 0x16B0 (size: 0x10)
    char padding_20[0x8];                                                             // 0x16C0 (size: 0x8)
    class USBPlayerFreeBuffPointComponent* PlayerFreeBuffPointComponent;              // 0x16C8 (size: 0x8)
    class USBWarehouseAbilityComponent* WarehouseAbilityComponent;                    // 0x16D0 (size: 0x8)
    class USBResearchTeamComponent* ResearchTeamComponent;                            // 0x16D8 (size: 0x8)
    class USBPlayerLoginBonusComponent* LoginBonusComponent;                          // 0x16E0 (size: 0x8)
    class USBHappyNappoComponent* HappyNappoComponent;                                // 0x16E8 (size: 0x8)
    class USBStackBComponent* StackBComponent;                                        // 0x16F0 (size: 0x8)
    char padding_21[0x8];                                                             // 0x16F8 (size: 0x8)
    class USBPlayerDxBattleComponent* PlayerDxBattleComponent;                        // 0x1700 (size: 0x8)
    char padding_22[0x20];                                                            // 0x1708 (size: 0x20)
    FSBPlayerControllerOnDebugCustomInputToServerDelegate OnDebugCustomInputToServerDelegate; // 0x1728 (size: 0x10)
    void OnDebugCustomInputToServerDelegate(FName ActionName);
    FSBPlayerControllerOnEndActionBindingsDelegate OnEndActionBindingsDelegate;       // 0x1738 (size: 0x10)
    void OnEndActionBindings();
    bool bSimplycityPartyKeyPress;                                                    // 0x1748 (size: 0x1)
    char padding_23[0x7];                                                             // 0x1749 (size: 0x7)
    FDateTime SimplycityPartyKeyPressStartTime;                                       // 0x1750 (size: 0x8)
    float SimplycityPartyKeyPressTime;                                                // 0x1758 (size: 0x4)

    void WaitNeedInitialParameterLoadAsset();
    void Try_DirectOpen_Theater();
    void TravelToSessionsWithPartyMemberParticipatingInMission(const FName& GameContentId);
    void TravelToOnlinePlayerSessionForPartyMigration(TScriptInterface<class ISBOnlinePlayerState> TargetPlayer);
    void TravelToOnlinePlayerSessionByFriendCharacterId(FString FriendCharacterId);
    void TravelToOnlinePlayerSession(TScriptInterface<class ISBOnlinePlayerState> TargetPlayer);
    void TravelToAnyMap(const FSBTravelOption& InTravelOption);
    void ToggleLookUpRelease();
    void ToggleLookUp();
    void ToggleLookRightRelease();
    void ToggleLookRight();
    void ToggleLookLeftRelease();
    void ToggleLookLeft();
    void ToggleLookDownRelease();
    void ToggleLookDown();
    void StopPlayingPerformanceCamera();
    void StartPlayerInitialParameters();
    void StartGather(class ASBFieldActorGatherPoint* GatherPoint, float GatherMotionLoopTime);
    void ShowRetCode(int32 RetCode, FString Desc);
    void ShowMatchingMenu(const FName& InitDungeonId, bool bInteract);
    void ShowCommandMenu(const ESBCommandMenuType& InType, FString BookmarkType, const FName ParamName);
    void SetupLogout(bool bReserveLogout, float TimeToLogout, bool bEnableReversion, EClientExitStatus ClientExitStatus);
    void SetupActionBindings(ESBClassType ClassType);
    void SetTextWindowStatus(bool bIsOpen);
    void SetSimplycityPartyKeyPress(bool bFlag);
    void SetShowMouseCursor(bool bShow);
    void SetShopMenuMode(bool bIsOpen);
    void SetQuickAccessLock(bool bIsLock);
    void SetQuestMenuMode(bool bIsOpen);
    void SetNotificationPartyStatus(ENotificationDialogStatus eStatus);
    void SetNotificationGuildStatus(ENotificationDialogStatus eStatus);
    void SetMainMenuMode(bool bIsOpen);
    void SetHudVisible(bool bIsVisible);
    void SetCursorMode(bool Flag);
    void SetConnectToServerFailureDebugCode(int32 InDebugCode);
    void SetChatWindowVisible(bool bIsVisible);
    void ServerSetPingCheckMode(bool bIsEnable);
    void ServerSeamlessTravel(FString MapName, FString GameMode);
    void ServerRestart(FVector LastLocation);
    void ServerRequestClassChange(ESBClassType InClassType, FString InNewWeaponUniqueId, int32 InPresetListIndex);
    void ServerPreSeamlessTravel();
    void ServerPreLogout(bool bEnableReversion, EClientExitStatus ClientExitStatus);
    void ServerPreClientTravel(const FSBTravelOption& Option);
    void ServerPingCheck(float sendIntervalFromBefore);
    void ServerNotifyMapLoadedAtRestart();
    void ServerNotifyMapLoaded();
    void ServerDebugOutputDispPingCheckData();
    void ServerChangeClass(ESBClassType Type);
    void Server_WeaponRemove(FString InWeaponUniqueId, bool IsUpdateDB);
    void Server_WeaponEquip(FString InNewWeaponUniqueId, FString InOldWeaponUniqueId, bool IsUpdateDB);
    void Server_UseSupply(int32 ItemIndex, int32 ListNum);
    void Server_SaveMapPinInfos(const TArray<FMapPinInfo>& MapPinInfoList);
    void Server_SaveKeyConfig(const TArray<FSBPlayerClassKeyConfigDataDiff>& KeyConfigDiffList);
    void Server_SaveCharaCostumeEquip(const FCharaEquipItemInfo& EquipItemInfo, const FCharaEquipItemCharaCreateInfo& EquipItemCharaCreateInfo, const ESBCharaEquipType EquipType);
    void Server_SaveCharaConfig(const FCharaConfigInfo& ConfigInfo);
    void Server_RequestSpawnAsBuddy(const int32 BuddyIndex, const FVector& OffsetLocation);
    void Server_RequestKickedLog();
    void Server_RequestCharacterRename(class ASBPlayerController* InPlayerController, FString NewName);
    void Server_RecoverRewardPlusCount();
    void Server_PlayerEnterBattleArea(class ASBBattleArea* Area);
    void Server_PlayerDeactivateReverberationGodMode();
    void Server_PlayerDeactivateGodMode(ESBGodModeType GodModeType, bool bReverberation);
    void Server_PlayerCountdownBattleArea(class ASBBattleArea* Area, float Time);
    void Server_PlayerActivateGodMode(ESBGodModeType GodModeType, bool bIsRequestPermitEternalGodMode);
    void Server_OnWeaponEquip(int32 RetCode, FString InNewWeaponUniqueId, FString InOldWeaponUniqueId, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void Server_OnSaveMapPinInfos(bool Result, const TArray<FMapPinInfo>& MapPinInfoList, const ESBMapErrorCode ErrorCode);
    void Server_OnSaveKeyConfig(bool Result);
    void Server_OnSaveCharaImagineEquips(int32 RetCode, const FCharaEquipItemInfo& InEquipItemInfo, const ESBCharaEquipType InEquipType, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void Server_OnSaveCharaCostumeEquip(int32 RetCode, const TArray<ESBCharaEquipType>& DirtyEquipTypes, const TArray<FCharaEquipItemInfo>& DirtyEquipItemInfos, const ESBCharaEquipType EquipType, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void Server_OnSaveCharaConfig(bool Result);
    void Server_OnRecoverRewardPlusCount(int32 RetCode, int32 Count, int32 Ticket);
    void Server_OnCharaEquipPassiveImagineChanged();
    void Server_KickThis();
    void Server_InitSupplyList();
    void Server_GetMyCharacterInfo();
    void Server_EraseSpawnedBuddy(const int32 BuddyIndex);
    void Server_DefaultWeaponEquip(class ASBPlayerCharacter* PlayerCharacter);
    void Server_DebugCallCustomInputEvent(const FName ActionName);
    void Server_AnswerCheckBuildInitialWeapon(bool bRet);
    void Server_AnswerCheckBuildInitialParameter(bool bRet);
    void Server_AddSupply(int32 ItemIndex, int32 Amount);
    void SendCommand(FName Command, bool Force);
    void ReturnToPreviousMap();
    void RequestSeamlessTravel(FString MapName, FString GameMode);
    void RequestRestart();
    void RequestPerformanceCamera(FDataTableRowHandle RowHandle, class AActor* WatchTarget, float InputCancelTimer);
    bool RequestLocalWarpMoveToPortal(FString Portal);
    bool RequestLocalWarpMoveToLocation(FSBWarpDestinationLocationInfo WarpDestination);
    void RequestClassChange(ESBClassType Type, FString InWeaponUniqueId, int32 InEquipSetId);
    void Request_WeaponRemove();
    void Request_WeaponEquip(FString InNewWeaponUniqueId, FString InOldWeaponUniqueId);
    void Request_UseSupply(int32 ItemIndex);
    bool Request_SaveMapPinInfos(const TArray<FMapPinInfo>& MapPinInfoList);
    void Request_SaveCharaCostumeEquip(const FCharaEquipItemInfo& EquipItemInfo, const FCharaEquipItemCharaCreateInfo& EquipItemCharaCreateInfo, const ESBCharaEquipType EquipType);
    bool Request_SaveCharaConfig(const FCharaConfigInfo& ConfigInfo);
    bool Request_RecoverRewardPlusCount();
    bool Request_GetMyCharacterInfo();
    void Request_CharacterRename(FString NewName);
    void ReceiveJoinAchievement(const TArray<int32>& recvAchievement);
    void QuitPhotoMode();
    void QuickAccess_SeasonPass();
    void QuickAccess_RmShop();
    void QuickAccess_QuestAdventureBoard();
    void QuickAccess_Quest();
    void QuickAccess_Photo();
    void QuickAccess_Party();
    void QuickAccess_Option();
    void QuickAccess_MyCharacter();
    void QuickAccess_Map();
    void QuickAccess_Mail();
    void QuickAccess_Library();
    void QuickAccess_Inventory();
    void QuickAccess_HudPad();
    void QuickAccess_Hud();
    void QuickAccess_Guild();
    void QuickAccess_Gacha();
    void QuickAccess_Contents();
    void QuickAccess_CommunicateFriend();
    void QuickAccess_Communicate();
    void PushSupplyEmptyLog();
    void PushInitSupplyLog();
    void OnWeaponEquipDelegate__DelegateSignature(int32 RetCode, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const FSBExpiredEquipmentData& InExpiredEquipmentData);
    void OnUseSupplyDelegate__DelegateSignature(const bool Result);
    void OnSubPaletteRelease();
    void OnShortcutRightRepeat();
    void OnShortcutRightPressed();
    void OnShortcutLeftRepeat();
    void OnShortcutLeftPressed();
    void OnShortcutExecPressed();
    void OnSCRUp(const int32 InCurrentRank, const int32 InCurrentRankMax);
    void OnSaveMapPinInfosDelegate__DelegateSignature(const bool Result, const ESBMapErrorCode ErrorCode);
    void OnSaveCharaImagineEquipsDelegate__DelegateSignature(int32 RetCode, const ESBCharaEquipType EquipType, FString UniqueId, const bool IsEquip, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const FSBExpiredEquipmentData& InExpiredEquipmentData);
    void OnSaveCharaCostumeEquipDelegate__DelegateSignature(int32 RetCode, const FSBExpiredEquipmentData& InExpiredEquipmentData);
    void OnSaveCharaConfigDelegate__DelegateSignature(bool Result);
    void OnReleasedShortcutRing_Normal_Pad();
    void OnReleasedShortcutRing_Normal_Keyboard();
    void OnReleasedMiniMap();
    void OnReleased_Pushpin();
    void OnReleased_NowPartyPadReleased();
    void OnReleased_NowPartyKbReleased();
    void OnRecoverRewardPlusCountDelegate__DelegateSignature(ESBRecoverRewardPlusCountResult Result);
    void OnPressMainMenu();
    void OnPressedShortcutRingExecuteF12();
    void OnPressedShortcutRingExecuteF11();
    void OnPressedShortcutRingExecuteF10();
    void OnPressedShortcutRingExecuteF09();
    void OnPressedShortcutRingExecuteF08();
    void OnPressedShortcutRingExecuteF07();
    void OnPressedShortcutRingExecuteF06();
    void OnPressedShortcutRingExecuteF05();
    void OnPressedShortcutRing_Normal_Pad();
    void OnPressedShortcutRing_Normal_Keyboard();
    void OnPressedQuestHUDChange();
    void OnPressedMiniMap();
    void OnPressed_QuickAccess_SeasonPass();
    void OnPressed_QuickAccess_RmShop();
    void OnPressed_QuickAccess_QuestAdventureBoard();
    void OnPressed_QuickAccess_Quest();
    void OnPressed_QuickAccess_Photo();
    void OnPressed_QuickAccess_Party();
    void OnPressed_QuickAccess_Option();
    void OnPressed_QuickAccess_MyCharacter();
    void OnPressed_QuickAccess_Map();
    void OnPressed_QuickAccess_Mail();
    void OnPressed_QuickAccess_Library();
    void OnPressed_QuickAccess_Inventory();
    void OnPressed_QuickAccess_Guild();
    void OnPressed_QuickAccess_Gacha();
    void OnPressed_QuickAccess_Contents();
    void OnPressed_QuickAccess_CommunicateFriend();
    void OnPressed_QuickAccess_Communicate();
    void OnPressed_Pushpin();
    void OnPressed_NowPartyPad();
    void OnPressed_NowPartyKb();
    void OnPressed_BookMarkRegist();
    void OnPressed_BookMark9();
    void OnPressed_BookMark8();
    void OnPressed_BookMark7();
    void OnPressed_BookMark6();
    void OnPressed_BookMark5();
    void OnPressed_BookMark4();
    void OnPressed_BookMark3();
    void OnPressed_BookMark24();
    void OnPressed_BookMark23();
    void OnPressed_BookMark22();
    void OnPressed_BookMark21();
    void OnPressed_BookMark20();
    void OnPressed_BookMark2();
    void OnPressed_BookMark19();
    void OnPressed_BookMark18();
    void OnPressed_BookMark17();
    void OnPressed_BookMark16();
    void OnPressed_BookMark15();
    void OnPressed_BookMark14();
    void OnPressed_BookMark13();
    void OnPressed_BookMark12();
    void OnPressed_BookMark11();
    void OnPressed_BookMark10();
    void OnPressed_BookMark1();
    void OnPressDebugMenu();
    void OnPressDebugLevelDesignMenu();
    void OnPressChatWindow();
    void OnPlayerDeactivateReverberationGodModeResultDelegate__DelegateSignature(bool Result);
    void OnPlayerDeactivateGodModeResultDelegate__DelegateSignature(bool Result);
    void OnPlayerActivateGodModeResultDelegate__DelegateSignature(bool Result);
    void OnLevelLoadedAtRestart();
    void OnLevelLoaded();
    void OnLearningSkill(const TArray<FCharaSkillMasteryInfo>& SkillList);
    void OnGetUserItemCompletedDelegate__DelegateSignature();
    void OnGetUserItemCompleted();
    void OnGetMyCharacterInfoDelegate__DelegateSignature(bool Result);
    void OnExec_DirectOpen_Theater();
    void OnEndActionBindings__DelegateSignature();
    void OnDebugCustomInputToServerDelegate__DelegateSignature(FName ActionName);
    void OnCompletedCharacterName__DelegateSignature(const int32 RetCode);
    void OnCompleteClientRestart__DelegateSignature();
    void OnClassLevelUp(const int32 InPrevLevel, const int32 InCurrentLevel, const FSBExtraExpParse& InExtraExpParse);
    void OnClassChangeNotify__DelegateSignature(const int32 InRetCode, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void OnChatWindowClose();
    void OnCharaEquipPassiveImagineChangedDelegate__DelegateSignature();
    void OnChangePlayerCharacterDelegate__DelegateSignature(class APawn* InPawn);
    void OnChangedSessionOwner(class ASBPlayerState* NewOwnerPlayer);
    void OnAttachedClientPlayerState__DelegateSignature(class ASBPlayerController* PlayerController);
    void MulticastSetPingCheckMode(bool bIsEnable);
    void MulticastDebugNotifyClientMessage(FString InMessage);
    void Multicast_DefaultWeaponEquip(class ASBPlayerCharacter* PlayerCharacter);
    void MouseInteractionTargetVisible(bool InVisible);
    void MouseInteractionRelease();
    void MouseInteraction();
    bool IsToggleDash();
    bool IsTextWindowOpen();
    bool IsSupplyList();
    bool IsSimplycityPartyKeyPress();
    bool IsShopMenuOpen();
    bool IsQuestMenuOpen();
    bool IsPhotoMode();
    bool IsPhotoCameraControlMode();
    bool IsOpenDebugMenu();
    bool IsMoveByKeyboard();
    bool IsMainMenuOpen();
    bool IskQuickAccessLocked();
    bool IsInitSupplyList();
    bool IsInitializeClientMyCharacterInfo();
    bool IsHudVisible();
    bool IsEnableShortcutKey();
    bool IsEnableInput();
    bool IsDeleteSupplyList();
    bool IsCursorMode();
    bool IsChatWindowVisible();
    bool IsCameraInputByMouse();
    void InitSupplyList();
    class USBPlayerWeaponEnhancementComponent* GetWeaponEnhancementComponent();
    class USBWarehouseAbilityComponent* GetWarehouseAbilityComponent();
    class USBUserImageComponent* GetUserImageComponent();
    class USBPlayerUIComponent* GetUIComponent();
    class USBTheaterComponent* GetTheaterComponent();
    TArray<FSBDungeonSupply> GetSupplyList();
    class USBStackBComponent* GetStackBComponent();
    float GetSimplycityPartyKeyPressTime();
    class USBSerialCodeComponent* GetSerialCodeComponent();
    class USBPlayerSeasonPassComponent* GetSeasonPassComponent();
    class USBRmShopComponent* GetRmShopComponent();
    class USBPlayerRewardBoostComponent* GetRewardBoostComponent();
    class USBResearchTeamComponent* GetResearchTeamComponent();
    class USBReportComponent* GetReportComponent();
    class USBQuestComponent* GetQuestComponent();
    class USBPlayerTreasureBoxComponent* GetPlayerTreasureBoxComponent();
    class USBPlayerShopComponent* GetPlayerShopComponent();
    class USBPlayerLiquidMemoryComponent* GetPlayerLiquidMemoryComponent();
    class USBPlayerGatherPointComponent* GetPlayerGatherPointComponent();
    class USBPlayerFreeBuffPointComponent* GetPlayerFreeBuffPointComponent();
    class USBPlayerFieldActorPickupComponent* GetPlayerFieldActorPickupComponent();
    class USBPlayerDxBattleComponent* GetPlayerDxBattleComponent();
    class USBPlayerCharacterCommonComponent* GetPlayerCharacterCommonComponent();
    class ASBPlayerCharacter* GetPlayerCharacter();
    class USBPlayerAwardComponent* GetPlayerAwardComponent();
    class USBPlayerAutoDeliveryQuestComponent* GetPlayerAutoDeliveryQuestComponent();
    class USBPlayerArtsComponent* GetPlayerArtsComponent();
    class USBPlayerAchievementComponent* GetPlayerAchievementComponent();
    class USBPineVillageComponent* GetPineVillageComponent();
    class USBPhotoModeImageComponent* GetPhotoModeImageComponent();
    class USBPlayerPhotoModeComponent* GetPhotoModeComponent();
    class USBPartyRecruitComponent* GetPartyRecruitComponent();
    class USBOutGameBuffComponent* GetOutGameBuffComponent();
    ENotificationDialogStatus GetNotificationPartyStatus();
    ENotificationDialogStatus GetNotificationGuildStatus();
    class USBNetworkDataCache* GetNetworkDataCache();
    class USBPlayerNaEventComponent* GetNaEventComponent();
    class USBPlayerMailComponent* GetMailComponent();
    class USBPlayerLoginBonusComponent* GetLoginBonusComponent();
    class USBImagineLabComponent* GetImaginLabComp();
    class USBHappyNappoComponent* GetHappyNappoComponent();
    class USBPlayerGuildComponent* GetGuildComponent();
    class USBGashaComponent* GetGashaComponent();
    class USBPlayerFmComponent* GetFmComponent();
    class USBPlayerExpeditionComponent* GetFang_expeditionComponent();
    class USBExchangeItemComponent* GetExchangeItemComponent();
    class USBEventShopComponent* GetEventShopComponent();
    class USBPlayerCraftComponent* GetCraftComponent();
    class USBPlayerConcernedList* GetConcernedList();
    class USBCharactersLogComponent* GetCharacterLogComponent();
    class USBCharacterCampFireComponent* GetCharacterCampFireComponent();
    class USBCashExchangeShopComponent* GetCashExchangeShopComponent();
    class USBPlayerAdventureBoardComponent* GetAdventureBoardComponent();
    class USBPlayerAcEventComponent* GetAcEventComponent();
    void DeleteSupply();
    void DebugServerSkillButtonPressAtSame(const EGameInput gameInput, float DelayTime, uint8 LimitType);
    void DebugMulticastSkillButtonPressAtSame(const EGameInput gameInput);
    void DebugBindCustomInputToServer(const FName ActionName);
    void ClientTravelToSession(FString SessionId, FString MapName, FString GameType, const FSBTravelOption& InTravelOption);
    void ClientTravelToAnyMap(FString MapName, FString GameType, const FSBTravelOption& InTravelOption);
    void ClientStartInstanceContent(const FSBMapInfo& ContentInfo);
    void ClientShowMatchingMenu(const FName& InitDungeonId, bool bInteract);
    void ClientSetControlRotation(FRotator NewRotation);
    void ClientReturnToPreviousMap();
    void ClientReturnDisconnectedParty(FString CharacterId);
    void ClientPreSeamlessTravel();
    void ClientPreClientTravelRetryMessage(int32 RetCode);
    void ClientPreClientTravelOpt(bool bWasSuccessful, const FSBTravelOption& InTravelOption, int32 RetCode);
    void ClientPreClientTravel(bool bWasSuccessful, FString InSessionId, int32 RetCode);
    void ClientOnCompleteChangeClass(int32 RetCode, FSBClassChangeSyncData InData, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void ClientNotifySessionOwnerChanged(class ASBPlayerState* NewOwnerPlayer);
    void ClientGmJumper(bool bJumper);
    void ClientCheckMapLoadedAtRestart(FVector NewLocation, FRotator NewRotation);
    void ClientApprovedJoinInstantParty(FString PartyJoinInfoJson);
    void Client_WeaponRemove(int32 RetCode, int32 ClientLogRetCode, FString InWeaponUniqueId);
    void Client_WeaponEquip(int32 RetCode, int32 ClientLogRetCode, FString InNewWeaponUniqueId, FString InOldWeaponUniqueId, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void Client_UseSupply(bool bResult, int32 ListNum, const FSBRecastTimeInfo& NewRecastTime);
    void Client_SendShowSpawnedEnemyNum(int32 SpawnedEnemyNum, int32 EmptySlotNum);
    void Client_SendEnemyStateMachineLog(FString DumpFileName, int32 Cursor, const TArray<FString>& DumpStates);
    void Client_SendEnemySpawnInfo(const FSBEnemySpawnInfo SpawnInfo);
    void Client_SaveMapPinInfos(bool Result, const TArray<FMapPinInfo>& MapPinInfoList, const ESBMapErrorCode ErrorCode);
    void Client_SaveCharaImagineEquips(int32 RetCode, const FCharaEquipItemInfo& InEquipItemInfo, const ESBCharaEquipType InEquipType, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void Client_SaveCharaCostumeEquip(int32 RetCode, const TArray<ESBCharaEquipType>& DirtyEquipTypes, const TArray<FCharaEquipItemInfo>& DirtyEquipItemInfos, const ESBCharaEquipType EquipType, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void Client_SaveCharaConfig(bool Result);
    void Client_RecoverRewardPlusCount(int32 RetCode, int32 Count, int32 Ticket);
    void Client_PlayerDeactivateReverberationGodModeResult(bool bResult);
    void Client_PlayerDeactivateGodModeResult(bool bResult);
    void Client_PlayerActivateGodModeResult(bool bResult);
    void Client_OnSpawnedBuddy(const int32 BuddyIndex, const ESpawnedBuddyResult Result);
    void Client_OnSaveKeyConfig(bool Result);
    void Client_OnErasedSpawnedBuddy(const int32 BuddyIndex, const ESpawnedBuddyResult Result);
    void Client_OnCompletedRename(bool bWasSuccessful, FString NewName, int32 RetCode);
    void Client_InitSupplyList(const TArray<FSBDungeonSupply>& MasterSupplyList);
    void Client_GetMyCharacterInfo(bool Result, const FSBCharacterMisc& CharacterMisc);
    void Client_EndPlayerInitialParameters(bool bResult);
    void Client_ConsumeItem_SkillRecastReset();
    void Client_CheckBuildInitialWeapon();
    void Client_CheckBuildInitialParameter();
    void Client_CharaEquipPassiveImagineChanged();
    void ClearEnemyDropTreasureBox();
    void CheatCommand_SwitchEnemyTacticalSkillDebugMode(class ASBEnemyCharacter* Enemy, int32 Mode);
    void CheatCommand_SwitchEnemyTacticalSkillActivation(class ASBEnemyCharacter* Enemy, FString Command, bool bEnable);
    void CheatCommand_SpawnEnemy(FString EnemyId, int32 Level, const FVector& Location, const FRotator& Rotation);
    void CheatCommand_ShowSpawnedEnemyNum();
    void CheatCommand_ServerGatherEnemyParam();
    void CheatCommand_ServerDumpGameSessionState();
    void CheatCommand_ReviveSelf();
    void CheatCommand_RestartGame(uint32 ConnectWait);
    void CheatCommand_RequestSendEnemySpawnInfo();
    void CheatCommand_PauseEnemyBehavior(class ASBEnemyCharacter* Enemy);
    void CheatCommand_PartsBreak(FName PartsName, bool bSoon);
    void CheatCommand_KillSelf();
    void CheatCommand_KillAllEnemyInBattleArea();
    void CheatCommand_KillAllEnemyAndPlayerInBattleArea(bool bKillPlayerFirst);
    void CheatCommand_GiveAllEnemyParalyze();
    void CheatCommand_EnemyPhaseProgress(int8 AddPhaseProgress);
    void CheatCommand_EnemyHitPointForceSync();
    void CheatCommand_DumpEnemyStateMachineLog(class ASBEnemyCharacter* Enemy);
    void CheatCommand_ClientGatherEnemyParam(FString OutputStr);
    void CheatCommand_ClientDumpGameSessionState(FString OutputStr);
    void CheatCommand_ChangePlayerFaction(const FName& NewFaction);
    bool CanOpenNotificationPartyDialog();
    bool CanOpenNotificationGuildDialog();
    void CancelCursorMode();
    void BookMark9();
    void BookMark8();
    void BookMark7();
    void BookMark6();
    void BookMark5();
    void BookMark4();
    void BookMark3();
    void BookMark24();
    void BookMark23();
    void BookMark22();
    void BookMark21();
    void BookMark20();
    void BookMark2();
    void BookMark19();
    void BookMark18();
    void BookMark17();
    void BookMark16();
    void BookMark15();
    void BookMark14();
    void BookMark13();
    void BookMark12();
    void BookMark11();
    void BookMark10();
    void BookMark1();
    FString AFKDataToString();
    void AddSupply(int32 ItemIndex, int32 Amount);
}; // Size: 0x1760

class ASBPlayerControllerBase : public APlayerController
{
    FSBPlayerControllerBaseOnSaveKeyConfigDelegate OnSaveKeyConfigDelegate;           // 0x0630 (size: 0x10)
    void OnSaveKeyConfigDelegate(bool Result);
    char padding_0[0x18];                                                             // 0x0640 (size: 0x18)
    class USBNgWordComponent* NgWordComponent;                                        // 0x0658 (size: 0x8)
    class ASBUIController* UIController;                                              // 0x0660 (size: 0x8)

    void SetReturnLocation_Server(FVector Location, float Yaw);
    void SetReturnLocation(FVector Location, float Yaw);
    bool Request_SaveKeyConfig();
    bool Request_ClientTravel(FString URL, const FSBTravelOption& InTravelOption);
    void OnUpdateDecideButton__DelegateSignature();
    void OnSaveKeyConfigDelegate__DelegateSignature(bool Result);
    bool GetReturnLocation(FVector& Location, float& Yaw);
    class USBNgWordComponent* GetNGWordComponent();
    void ClientGameStarted();
    void ClearReturnLocation_Server();
    void ClearReturnLocation();
}; // Size: 0x668

class ASBPlayerController_PawnControl : public APlayerController
{
    class USBPawnControlSettings* ControlSettings;                                    // 0x0578 (size: 0x8)

}; // Size: 0x580

class ASBPlayerStart : public APlayerStart
{
    bool bIsAvailableForSearchStartPoint;                                             // 0x0258 (size: 0x1)
    ESBPlayerStartType Type;                                                          // 0x0259 (size: 0x1)
    char padding_0[0xE];                                                              // 0x025A (size: 0xE)
    class UShapeComponent* CollisionComponent;                                        // 0x0268 (size: 0x8)

    void SetPlayerRespawnPoint(class ASBPlayerCharacter* PlayerCharacter);
    void SetOwnerWarpPoint(class ASBFieldActorWarpPoint* NewOwner);
    ESBPlayerStartType GetPlayerStartType();
    class ASBFieldActorWarpPoint* GetOwnerWarpPoint();
}; // Size: 0x270

class ASBPlayerState : public APlayerState
{
    bool bIsClientReady;                                                              // 0x0330 (size: 0x1)
    bool bHasAnnouncedAdd;                                                            // 0x0331 (size: 0x1)
    bool bSimplycityPartyJoinRequested;                                               // 0x0332 (size: 0x1)
    char padding_0[0x65];                                                             // 0x0333 (size: 0x65)
    FSBPlayerStateOnCharacterNameChangeDelegate OnCharacterNameChangeDelegate;        // 0x0398 (size: 0x10)
    void OnCharacterNameChangeDelegate(FString InName);
    FSBPlayerStateOnAchievementSelectedChangeDelegate OnAchievementSelectedChangeDelegate; // 0x03A8 (size: 0x10)
    void OnAchievementSelectedChangeDelegate();
    int32 ClassIndex;                                                                 // 0x03B8 (size: 0x4)
    int32 ClassLevel;                                                                 // 0x03BC (size: 0x4)
    int32 TotalPower;                                                                 // 0x03C0 (size: 0x4)
    char padding_1[0x4];                                                              // 0x03C4 (size: 0x4)
    FString CharacterName;                                                            // 0x03C8 (size: 0x10)
    char padding_2[0x18];                                                             // 0x03D8 (size: 0x18)
    FString CharacterId;                                                              // 0x03F0 (size: 0x10)
    int32 AchievementSelected;                                                        // 0x0400 (size: 0x4)
    char padding_3[0x2A];                                                             // 0x0404 (size: 0x2A)
    bool bSimplycityPartyOn;                                                          // 0x042E (size: 0x1)
    char padding_4[0x1];                                                              // 0x042F (size: 0x1)
    float SimplycityPartyMatchingRange;                                               // 0x0430 (size: 0x4)
    char padding_5[0x4];                                                              // 0x0434 (size: 0x4)
    TArray<class ASBPlayerState*> SimplicityInRangePlayers;                           // 0x0438 (size: 0x10)
    int32 Birthday;                                                                   // 0x0448 (size: 0x4)
    int32 Birthday_CertCount;                                                         // 0x044C (size: 0x4)
    bool bIsMainMenuOpen;                                                             // 0x0450 (size: 0x1)
    char padding_6[0x3];                                                              // 0x0451 (size: 0x3)
    int32 OnlineStatus;                                                               // 0x0454 (size: 0x4)
    FString PartyIdString;                                                            // 0x0458 (size: 0x10)
    char padding_7[0x40];                                                             // 0x0468 (size: 0x40)
    TMap<class FString, class FSBGameServerPartyInfo> PartyInfoMap;                   // 0x04A8 (size: 0x50)
    char padding_8[0x68];                                                             // 0x04F8 (size: 0x68)
    FSBPlatformInfo PlatformInfo;                                                     // 0x0560 (size: 0x20)
    FName PlayingDungeonId;                                                           // 0x0580 (size: 0x8)
    int32 DeadCount;                                                                  // 0x0588 (size: 0x4)
    char padding_9[0x1C];                                                             // 0x058C (size: 0x1C)
    float m_ImagineArtsRecastTimePast;                                                // 0x05A8 (size: 0x4)
    float m_ImagineArtsRecastTimePast2;                                               // 0x05AC (size: 0x4)
    char padding_10[0x4];                                                             // 0x05B0 (size: 0x4)
    uint8 bInvalidPlayerStart;                                                        // 0x05B4 (size: 0x1)
    char padding_11[0x3];                                                             // 0x05B5 (size: 0x3)
    int32 NoMapDisplayCnt;                                                            // 0x05B8 (size: 0x4)
    char padding_12[0x4];                                                             // 0x05BC (size: 0x4)
    class USBPlayerWarpPointComponent* WarpPointPropertyComponent;                    // 0x05C0 (size: 0x8)
    class USBPlayerDungeonComponent* DungeonComponent;                                // 0x05C8 (size: 0x8)
    class USBPlayerCacheComponent* CachedPropertyComponent;                           // 0x05D0 (size: 0x8)
    class USBPlayerGatherPointComponent* GatherPointPropertyComponent;                // 0x05D8 (size: 0x8)
    class USBPlayerCharacterParameterComponent* CharacterParameterComponent;          // 0x05E0 (size: 0x8)
    class USBPlayerInterruptQuestComponent* InterruptQuestComponent;                  // 0x05E8 (size: 0x8)
    class USBPlayerFriendComponent* FriendComponent;                                  // 0x05F0 (size: 0x8)
    class USBPlayerActivityComponent* ActivityComponent;                              // 0x05F8 (size: 0x8)
    class USBPlayerCommunicateSettingsComponent* PlayerCommunicateSettingsComponent;  // 0x0600 (size: 0x8)
    class USBPlayerStampComponent* PlayerStampComponent;                              // 0x0608 (size: 0x8)
    class USBPlayerEmoteComponent* PlayerEmoteComponent;                              // 0x0610 (size: 0x8)
    class USBPlayerAdventurerComponent* PlayerAdventurerComponent;                    // 0x0618 (size: 0x8)
    class USBPlayerStorageComponent* PlayerStorageComponent;                          // 0x0620 (size: 0x8)
    class USBPlayerMissionQuestComponent* PlayerMissionQuestComponent;                // 0x0628 (size: 0x8)
    class USBPlayerDefeatEnemyComponent* DefeatEnemyComponent;                        // 0x0630 (size: 0x8)
    class USBPlayerGuildComponent* GuildComponent;                                    // 0x0638 (size: 0x8)
    class USBPlayerFieldActorPickupComponent* FieldActorPickupComponent;              // 0x0640 (size: 0x8)
    class USBBlackListComponent* BlackListComponent;                                  // 0x0648 (size: 0x8)
    class USBPlayerVirtualDateTimeComponent* VirtualDateTimeComponent;                // 0x0650 (size: 0x8)
    class USBJointGestureComponent* JointGestureComponent;                            // 0x0658 (size: 0x8)
    class USBPlayerWeaponComponent* PlayerWeaponComponent;                            // 0x0660 (size: 0x8)
    class USBPlayerShortPinComponent* PlayerShortPinComponent;                        // 0x0668 (size: 0x8)
    class USBGeneralPurposeCounterComponent* GeneralPurposeCounterComponent;          // 0x0670 (size: 0x8)
    class USBPlayerChatComponent* PlayerChatComponent;                                // 0x0678 (size: 0x8)
    class USBPlayerExpeditionComponent* PlayerExpeditionComponent;                    // 0x0680 (size: 0x8)
    class USBUncheaterComponent* UncheaterComponent;                                  // 0x0688 (size: 0x8)
    class USBPlayerAwardComponent* PlayerAwardComponent;                              // 0x0690 (size: 0x8)
    class USBPlayerDecorationComponent* PlayerDecorationComponent;                    // 0x0698 (size: 0x8)
    FString PlayerLevelStartLog;                                                      // 0x06A0 (size: 0x10)

    void SetSimplycityPartyOn(bool InSimplycityPartyOn, bool bResetWaitTime);
    void SetCharacterId(FString InCharacterId);
    void ServerUpdateSimplycityPartyOnPlayerState(bool InSimplycityPartyOn);
    void ServerUpdateSimplycityPartyMatchingRange(float InSimplycityPartyMatchingRange);
    void ServerUpdateShowPrintServerString(bool sw);
    void ServerUpdatePartyInfo(const FSBGameServerPartyInfo& InPartyInfo);
    void ServerSimplycityPartyJoinRequestRejected(class ASBPlayerState* SBPlayerState);
    void ServerSimplycityPartyJoinRequest(int32 existPartyLeaderIndex);
    void ServerSetMainMenuOpen(bool InMainMenuOpen);
    void ServerSetImagineArtsRecastTimePast(ESkillActionPosition Position, float Value);
    void ServerSetCurrentMapInitialSpawnedInfo(FVector NewLocation, float NewYaw);
    void ServerSetClientReady(bool bReady);
    void ServerSetAppearEffectType(ESBAppearEffectType Type);
    void ServerResetPartyInfo();
    void ServerRemoveOnlineStatus(ESBOnlineStatus InOnlineStatus);
    void ServerRemoveMultiOnlineStatus(const TArray<ESBOnlineStatus>& InOnlineStatus);
    void ServerLeaveParty(FString TargetPartyId);
    void ServerAddOnlineStatus(ESBOnlineStatus InOnlineStatus);
    void ServerAddMultiOnlineStatus(const TArray<ESBOnlineStatus>& InOnlineStatus);
    void ServerAddDeadCount();
    void ResetNoMapDisplay();
    void PrintServerMsgToClient(FString Msg, FLinearColor Col, float Timer, bool ToScreen);
    void OnRep_PlayerLevelStartLog();
    void OnRep_OnlineStatus();
    void OnRep_ImagineArtsRecastTimePast2();
    void OnRep_ImagineArtsRecastTimePast();
    void OnRep_CharacterName();
    void OnRep_CharacterId();
    void OnRep_AchievementSelected();
    void OnDebugParamChanged(TEnumAsByte<ESBDebugMenuType> MenuType, FName DataName);
    void MulticastSetClientReady(bool bReady);
    void MulticastSetAppearEffectType(ESBAppearEffectType Type);
    bool IsPartyPlay();
    bool IsPartyLeader();
    bool IsPartyBuilding();
    bool IsOnline();
    bool IsNoMapDisplay();
    bool IsMainMenuOpen();
    bool IsClientReady();
    bool IsActive();
    void InOutNoMapDisplayArea(bool bIsIn);
    bool HasOnlineStatus(ESBOnlineStatus InOnlineStatus);
    int32 GetTotalPower();
    bool GetSimplycityPartyOn();
    bool GetSelfRespawnFromDeath();
    int32 GetRealPartySize();
    FName GetPlayingDungeonId(bool& IsExists);
    class USBPlayerWeaponComponent* GetPlayerWeaponComponent();
    class USBPlayerStorageComponent* GetPlayerStorageComponent();
    class USBPlayerStampComponent* GetPlayerStampComponent();
    class USBPlayerShortPinComponent* GetPlayerShortPinComponent();
    class USBPlayerDecorationComponent* GetPlayerDecorationComponent();
    class USBPlayerCommunicateSettingsComponent* GetPlayerCommunicateComponent();
    class USBPlayerAwardComponent* GetPlayerAwardComponent();
    FSBPlatformInfo GetPlatformInfo();
    int32 GetPartySize();
    FString GetPartyId();
    class ASBPlayerController* GetOwnerPlayerController();
    class USBPlayerInterruptQuestComponent* GetInterruptQuestComponent();
    ESBHostility GetHostilityAt(const class ASBPlayerState* OtherPlayer);
    class USBPlayerGuildComponent* GetGuildComponent();
    class USBGeneralPurposeCounterComponent* GetGeneralPurposeCounterComponent();
    class USBPlayerGatherPointComponent* GetGatherPointPropertyComponent();
    bool GetGameServerPartyInfoByType(const ESBPartyType Type, FSBGameServerPartyInfo& OutInfo);
    bool GetGameServerPartyInfo(FSBGameServerPartyInfo& OutInfo);
    int32 GetDeadCount();
    ESBClassType GetClassType();
    int32 GetClassLevel();
    int32 GetClassIndex();
    class USBPlayerCharacterParameterComponent* GetCharacterParameterComponent();
    FString GetCharacterId();
    int32 GetBirthdayCertCount();
    int32 GetBirthday();
    void CountNoMapDisplay(bool bIsIn);
    void ClientSimplycityPartyMatchingStop();
    void ClientSimplycityPartyMatchingSend(class ASBPlayerState* TargetPlayerState);
    void ClientSimplycityPartyMatchingInfoReset();
    void ClientSimplycityPartyMatching();
    void ClientSetImagineArtsRecastTimePast(ESkillActionPosition Position, float Value);
    void ClientSetFieldRespawnPointTag(const FName& NewTag, const FName& OldTag);
    void BP_SetBirthdayInfo(int32 birth, int32 Count);
}; // Size: 0x6B8

class ASBPlayerState_BattleArena : public ASBPlayerState_DungeonNormal
{
    char padding_0[0x848];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x848

class ASBPlayerState_Dungeon : public ASBPlayerState
{
    FSBPlayerState_DungeonOnRequestEndResultMenuDelegate OnRequestEndResultMenuDelegate; // 0x06C8 (size: 0x10)
    void OnRequestEndResultMenu();
    char padding_0[0x18];                                                             // 0x06D8 (size: 0x18)
    int32 SpawnCount;                                                                 // 0x06F0 (size: 0x4)
    int32 DeadRespawnCount;                                                           // 0x06F4 (size: 0x4)
    class ASBDungeonStandbyArea* StandbyArea;                                         // 0x06F8 (size: 0x8)
    bool bRetireDungeon;                                                              // 0x0700 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0701 (size: 0x3)
    int32 DungeonPID;                                                                 // 0x0704 (size: 0x4)
    bool bInitialLoaded;                                                              // 0x0708 (size: 0x1)
    char padding_2[0x17];                                                             // 0x0709 (size: 0x17)
    FSBPlayerState_DungeonOnFavoriteCountDelegate OnFavoriteCountDelegate;            // 0x0720 (size: 0x10)
    void OnFavoriteCountDelegate(FString InCharacterId);

    void SetDungeonStandbyArea(class ASBDungeonStandbyArea* Area);
    void ServerRequestRescue();
    void ServerNotifyRetireDungeon();
    void ServerFavoriteCount(FString InCharacterId);
    void Server_EndInitialLoad();
    void Server_EndDungeonScript();
    void Server_EndCheckPlayDungeonScript(const int32 ScriptNumber);
    void RequestEndSkipResultMenu();
    void ReceiveEndDungeon();
    void OnRequestEndResultMenu__DelegateSignature();
    void OnRep_RetireDungeon();
    void OnFavoriteCountDelegate__DelegateSignature(FString InCharacterId);
    void OnEndInitialLoad();
    void OnEndGameOverMenu__DelegateSignature();
    void MulticastFavoriteCount(FString InCharacterId);
    bool IsStartResultMenu();
    bool IsSkipResultMenu();
    bool IsRetireDungeon();
    bool IsEndResultMenu();
    bool IsEndGameOverMenu();
    bool IsDungeonResultFixed();
    int32 GetRewardMoney();
    TArray<FSBDungeonRewardItem> GetRewardItems();
    void GetRewardItemAndMoney(FSBDungeonRewardInfo& DungeonRewardInfo);
    int32 GetResurrectCount();
    int32 GetRescueCount();
    ESBDungeonEvaluation GetPlayerEvaluation();
    bool GetFirstSpawn();
    class ASBDungeonStandbyArea* GetDungeonStandbyArea();
    int32 GetDungeonResultScore();
    bool GetDungeonResultCleared();
    int32 GetDungeonPID();
    int32 GetDeadRespawnCount();
    void GetClearTimeAndLapTime(int64& ClearTime, TArray<int32>& LapTime);
    float GetClearRaidRatio();
    int32 GetClassExp();
    int32 GetBravePoint();
    void EndResultMenu();
    void EndGameOverMenu();
    void DemoEndWaitFadeInWaitDemoStart();
    void DemoEndWaitFadeInWaitDemoEnd();
    void DemoEndWaitFadeInStart();
    void ClientDemoEndWaitFadeIn(FName DemoName, float FadeTime, float DelayTime, int32 LimitCount);
    void Client_StartDungeonScript(ESBDungeonScriptType ScriptType, const int32 ScriptNumber);
    void Client_SetLockLoadingScreen(bool LockScreen);
    void Client_SetFadeScreen(bool FadeOut, float Duration);
    void Client_CoolDownPlayerSkill(FString Mode);
    void Client_CheckPlayDungeonScript(ESBDungeonScriptType ScriptType, bool SkipScript);
    void AddFavoriteCount(FString InCharacterId);
}; // Size: 0x798

class ASBPlayerState_DungeonNormal : public ASBPlayerState_Dungeon
{
    TArray<FName> DungeonScriptQueue;                                                 // 0x0798 (size: 0x10)
    int32 RequestedDungeonScriptId;                                                   // 0x07A8 (size: 0x4)
    int32 EndDungeonScriptId;                                                         // 0x07AC (size: 0x4)

    void StartExitDungeon();
    void SpawnExitPortal(FName Tag);
    void SetDeadLocation(FVector Location);
    void Server_NotifyDungeonScriptStart(int32 SatrtId);
    void Server_NotifyDungeonScriptEnd(int32 EndId);
    void OnGameOverEnd();
    void OnDungeonActivated(FName DungeonId);
    void OnAllActivatedMessageShown();
    void MulticastSetRewardInfo(const FSBDungeonRewardInfo& RewardInfo);
    void MulticastClearTimeAndLapTime(const int64 ClearTime, const TArray<int32>& LapTime);
    bool IsStartScriptOnClient(FName ScriptId);
    bool IsEndScriptOnClient(FName ScriptId);
    void ExitDungeonCore();
}; // Size: 0x848

class ASBPlayerState_DungeonOffline : public ASBPlayerState_DungeonNormal
{
    char padding_0[0x848];                                                            // 0x0000 (size: 0x0)

    void RetireOfflineDungeon();
}; // Size: 0x848

class ASBPlayerState_DungeonScenario : public ASBPlayerState_DungeonNormal
{
    char padding_0[0x848];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x848

class ASBPlayerState_DungeonScoreAttack : public ASBPlayerState_DungeonNormal
{
    char padding_0[0x848];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x848

class ASBPlayerState_DungeonTimeAttack : public ASBPlayerState_DungeonNormal
{
    char padding_0[0x848];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x848

class ASBPlayerState_DxBattle : public ASBPlayerState_DungeonNormal
{
    FSBDxBattleResult m_DxBattleResult;                                               // 0x0850 (size: 0x70)
    int32 m_PlayerCount;                                                              // 0x08C0 (size: 0x4)

    void SetDxBattleResult(const FSBDxBattleResult& InDxBattleResult, int32 InPlayerCount);
    bool IsAwarded(ESBDxBattleScore Index);
    FSBDxBattleResult GetDxBattleResult();
    void Client_SetDxBattleResult(const FSBDxBattleResult& InDxBattleResult, int32 InPlayerCount);
    void Client_DebugPrintMasterDataErrorLog(FString DefenseName, FString ContentId);
    void Client_DebugPlayerRewardLog(FString InRaidId);
}; // Size: 0x8E8

class ASBPlayerState_InstanceArea : public ASBPlayerState_DungeonNormal
{
    char padding_0[0x848];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x848

class ASBPlayerState_Lobby : public ASBPlayerState
{
    int32 TeamNumber;                                                                 // 0x06B8 (size: 0x4)
    bool bIsRoomOwner;                                                                // 0x06BC (size: 0x1)

    void SetTeamNumber(int32 InTeamNumber);
    void SetDungeonId(FName InDungeonId);
    void ServerSetTeamNumber(int32 InTeamNumber);
    void ServerSetDungeonId(FName InDungeonId);
    void ServerSetCharacter(int32 InClassIndex, FString InCharacterId, FString InCharacterName);
    void RequestSetDefaultPlayCharacter(FString InCharacterId);
    void OnRep_TeamNumber();
    bool IsRoomOwner();
    int32 GetTeamNumber();
}; // Size: 0x6C0

class ASBPlayerState_PublicDungeon : public ASBPlayerState
{
    char padding_0[0x6B8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x6B8

class ASBPlayerState_RaidBattle : public ASBPlayerState_DungeonNormal
{
    FSBRaidBattleResult m_RaidBattleResult;                                           // 0x0848 (size: 0x58)
    int32 m_PlayerCount;                                                              // 0x08A0 (size: 0x4)
    char padding_0[0x15];                                                             // 0x08A4 (size: 0x15)
    bool DebugViewContributionValue;                                                  // 0x08B9 (size: 0x1)
    char padding_1[0x6];                                                              // 0x08BA (size: 0x6)
    TArray<FSBRaidBattleGameScore> OutScoreList;                                      // 0x08C0 (size: 0x10)

    void SetRaidBattleResult(const FSBRaidBattleResult& InRaidBattleResult, int32 InPlayerCount);
    void Server_SetDebugViewContributionValue(bool Value);
    void MulticastRaidName(FString Name);
    bool IsAwarded(RAID_BATTLE_SCORE Index);
    FString GetRaidName();
    FSBRaidBattleResult GetRaidBattleResult();
    void Client_SetRaidBattleResult(const FSBRaidBattleResult& InRaidBattleResult, int32 InPlayerCount);
    void Client_DebugStackLogPrint(const TArray<FString>& InLogList);
    void Client_DebugScreenPrint(FString InPrintLog);
    void Client_DebugPrintMasterDataErrorLog(FString RaidName, FString ContentId);
    void Client_DebugPlayerRewardLog(FString InGameContentId);
}; // Size: 0x8D0

class ASBPlayerState_RankUpExam : public ASBPlayerState_DungeonNormal
{
    char padding_0[0x850];                                                            // 0x0000 (size: 0x0)

    void OnRankUpExamStart();
}; // Size: 0x850

class ASBPlayerState_Theater : public ASBPlayerState_DungeonOffline
{
    char padding_0[0x850];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x850

class ASBPlayerState_TowerSurvival : public ASBPlayerState_DungeonNormal
{
    char padding_0[0x848];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x848

class ASBPlayerState_Tutorial : public ASBPlayerState_Dungeon
{
    char padding_0[0x7A0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x7A0

class ASBPlayerTransformCharacter : public AASCharacter
{
    float BlendValueX;                                                                // 0x05A8 (size: 0x4)
    float BlendValueY;                                                                // 0x05AC (size: 0x4)
    bool bOverrideJumpConsumeStamina;                                                 // 0x05B0 (size: 0x1)
    bool bCalcJumpConsumeStaminaByMaxStaminaRate;                                     // 0x05B1 (size: 0x1)
    char padding_0[0x2];                                                              // 0x05B2 (size: 0x2)
    float OverrideJumpConsumeStamina;                                                 // 0x05B4 (size: 0x4)
    class USBActorVisibilityComponent* ActorVisibilityComponent;                      // 0x05B8 (size: 0x8)
    class USBFootprintComponent* FootprintComponent;                                  // 0x05C0 (size: 0x8)

    class USBPlayerMovementComponent* GetOwnerPlayerMovement();
    class ASBPlayerController* GetOwnerPlayerController();
    class ASBPlayerCharacter* GetOwnerPlayerCharacter();
    class UCharacterMovementComponent* GetOwnerCharacterMovement();
    class ASBCharacter* GetOwnerCharacter();
}; // Size: 0x5F0

class ASBPostProcessChecker : public AActor
{
    TArray<class APostProcessVolume*> PostProcessVolumes;                             // 0x0228 (size: 0x10)

    void InitPostProcessVolumeList();
    class UTexture* GetPostProcessColorGradingLUT(const FPostProcessSettings& Settings, float& ColorGradingIntensity);
}; // Size: 0x238

class ASBProjectileBase : public AActor
{
    class USBProjectileParamComponent* ParamComp;                                     // 0x02B0 (size: 0x8)
    class USBProjectileDestroyConditionComponent* DestroyCondComp;                    // 0x02B8 (size: 0x8)
    class USBProjectileAttachToActorComponent* AttachToActorComp;                     // 0x02C0 (size: 0x8)
    class USBProjectileHitChainComponent* HitChainComp;                               // 0x02C8 (size: 0x8)
    class USBTargetableComponent* TargetableComp;                                     // 0x02D0 (size: 0x8)
    class USBNamePlateComponent2D* NamePlateComp;                                     // 0x02D8 (size: 0x8)
    class USBProjectileHealthConditionComponent* HealthCondComp;                      // 0x02E0 (size: 0x8)

    void SetTargetableMode(bool InIsTargetable);
    void RequestSpawnProjectileAsChainLaunch(const FDataTableRowHandle SpawnProjectileHandle, const FTransform& SpawnTrans, const class USceneComponent* OverrideTargetComp, const class AActor* IgnoreHitActor);
    void PlaySound(class UAkAudioEvent* Event);
    void OnProjectileEndPlay(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    void NotifyOrderedChainHit();
}; // Size: 0x2E8

class ASBProjectileEffect : public AActor
{
    class USBProjectileEffectComponent* EffectComp;                                   // 0x0298 (size: 0x8)
    class USBEffectValueComponent* EffectValueComp;                                   // 0x02A0 (size: 0x8)
    FAkEventVariables AkEvent;                                                        // 0x02A8 (size: 0x40)
    TArray<float> RequestSoundDelayTimeList;                                          // 0x02E8 (size: 0x10)
    ESBEffectVisibleType VisibleTypeParamOnSpawnBP;                                   // 0x02F8 (size: 0x1)

    void SetEffectVisibleType(ESBEffectVisibleType VisibleType);
    void RequestPlaySound(float Delay);
    void ReflectEffectVisibleTypeOnSpawnBP();
    ESBEffectVisibleType GetEffectVisibleType();
}; // Size: 0x300

class ASBProjectileImagineCharacter : public AASCharacterBase
{
    bool bOverrideCameraDistanceTransparent;                                          // 0x05A8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x05A9 (size: 0x3)
    float CameraDistanceTransparent;                                                  // 0x05AC (size: 0x4)
    bool bOverrideCameraShieldingTransparentParam;                                    // 0x05B0 (size: 0x1)
    char padding_1[0x3];                                                              // 0x05B1 (size: 0x3)
    FSBCameraShieldingTransparentParam CameraShieldingTransparentParam;               // 0x05B4 (size: 0x8)
    char padding_2[0x24];                                                             // 0x05BC (size: 0x24)
    class USBProjectileSummonImagineComponent* SummonImagineComp;                     // 0x05E0 (size: 0x8)
    class USBProjectileSpawnComponent* SpawnComp;                                     // 0x05E8 (size: 0x8)
    class USBFootprintComponent* FootprintComp;                                       // 0x05F0 (size: 0x8)
    class USBCheckSwimmingAreaBImagine* CheckSwimmingAreaComp;                        // 0x05F8 (size: 0x8)
    class UASStateMachine* StateMachine;                                              // 0x0600 (size: 0x8)
    class UASAnimationSet* AnimationSet;                                              // 0x0608 (size: 0x8)
    FSBElementDamageSetting DefaultAttackElement;                                     // 0x0610 (size: 0x10)
    float TransitionLoopTime;                                                         // 0x0620 (size: 0x4)
    float AuraEffectScale;                                                            // 0x0624 (size: 0x4)

    void SetRequestSpawnProjectileAsInstigatorSpawn();
    void ResetExecutedTime();
    void RequestFinishCutIn();
    void NotifyImagineArtsMotionEnd();
    void NotifyCapturedEndPoseSnapShot();
    bool IsTransitionLoopOut();
    bool IsNotifiedImagineArtsMotionEnd();
    bool IsEnableDisappearSummonEffect();
    bool IsDispCutInDemo();
    bool IsCanDispCutInDemo();
    class USBCheckSwimmingAreaBImagine* GetCheckSwimmingAreaComp();
    void AddnExecutedTime(const float InDeltaTime);
}; // Size: 0x630

class ASBProjectileImagineCreationCharacter : public ASBProjectileImagineCharacter
{
    class USBCharaCreateComponent* CharaCreateComponent;                              // 0x0640 (size: 0x8)
    class USBCharaPartsFaceComponent* FaceComp;                                       // 0x0648 (size: 0x8)

    void StartSummonEffect();
}; // Size: 0x650

class ASBProjectilePath : public AActor
{
    int32 MaxSplineMeshComponent;                                                     // 0x0228 (size: 0x4)
    char padding_0[0x4];                                                              // 0x022C (size: 0x4)
    class UStaticMesh* ProjectilePathMesh;                                            // 0x0230 (size: 0x8)
    class UMaterial* ProjectilePathMaterial;                                          // 0x0238 (size: 0x8)
    class USceneComponent* RootSceneComp;                                             // 0x0240 (size: 0x8)
    class USplineComponent* SplineComp;                                               // 0x0248 (size: 0x8)
    TArray<class USplineMeshComponent*> SplineMeshCompList;                           // 0x0250 (size: 0x10)
    char padding_1[0x10];                                                             // 0x0260 (size: 0x10)
    TArray<FVector> SplineDirectionList;                                              // 0x0270 (size: 0x10)

    void SetAllSplineMeshVisible(bool bVisible);
    void ResetSplineMeshComponent();
    void RegisterSplineMeshComponent(class USplineMeshComponent* SplineMesh);
    void RecalcSplinePath();
    void InitBuildSplineMesh();
    class USplineMeshComponent* GetSplineMeshComponentIndex(int32 Index);
    FVector GetSplineDirection(int32 Index);
    class USplineComponent* GetSplineComponent();
    int32 GetRegisterSplineMeshComponentNum();
    void GetRegisterSplineMeshComponent(TArray<class USplineMeshComponent*>& OutArray);
    class UStaticMesh* GetProjectilePathMesh();
    class UMaterial* GetProjectilePathMaterial();
}; // Size: 0x280

class ASBProjectileSequencer : public ASBProjectileBase
{
    class USceneComponent* SceneComp;                                                 // 0x02E8 (size: 0x8)
    class USBProjectileEffectComponent* EffectComp;                                   // 0x02F0 (size: 0x8)
    class USBProjectileAttackParamComponent* AttackParamComp;                         // 0x02F8 (size: 0x8)

}; // Size: 0x300

class ASBProjectileSequencerLauncherArea : public ASBProjectileSequencer
{
    char padding_0[0x300];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x300

class ASBProjectileSequencerLauncherForecast : public ASBProjectileSequencer
{
    char padding_0[0x300];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x300

class ASBProjectileSequencerLauncherParty : public ASBProjectileSequencer
{
    char padding_0[0x300];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x300

class ASBProjectileSequencerLauncherRapid : public ASBProjectileSequencer
{
    char padding_0[0x300];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x300

class ASBProjectileSequencerLauncherWide : public ASBProjectileSequencer
{
    char padding_0[0x300];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x300

class ASBProjectile_AlongGround : public ASBRangedProjectile
{
    class USBProjectileMovementBaseComponent* MoveComp;                               // 0x04E8 (size: 0x8)

}; // Size: 0x4F0

class ASBProjectile_Beam : public ASBRangedProjectile
{
    class USBProjectileBeamComponent* BeamComp;                                       // 0x04E8 (size: 0x8)
    class USBProjectileTrailImpactComponent* TrailImpactComp;                         // 0x04F0 (size: 0x8)
    class USBProjectileBeamImpactComponent* BeamImpactComp;                           // 0x04F8 (size: 0x8)
    class USBLineSoundComponent* LineSoundComp;                                       // 0x0500 (size: 0x8)

    void OnSbProjectileConfigRep();
    FVector GetBeamStartPos();
    FVector GetBeamEndPos();
}; // Size: 0x518

class ASBProjectile_Fix : public ASBRangedProjectile
{
    char padding_0[0x4E8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x4E8

class ASBProjectile_Parabola : public ASBRangedProjectile
{
    class USBProjectileMovementBaseComponent* MoveComp;                               // 0x04E8 (size: 0x8)

}; // Size: 0x4F0

class ASBProjectile_Straight : public ASBRangedProjectile
{
    class USBProjectileMovementBaseComponent* MoveComp;                               // 0x04E8 (size: 0x8)

}; // Size: 0x4F0

class ASBProjectile_StraightBox : public ASBProjectile_Straight
{
    char padding_0[0x4F0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x4F0

class ASBRaidBattleDungeonEntranceBase : public AActor
{
    FString GateId;                                                                   // 0x0228 (size: 0x10)

    void EntranceOpen();
    void EntranceClose();
}; // Size: 0x238

class ASBRaidBattleGameInstance : public AActor
{
    ERaidBattleGameStatus m_Status;                                                   // 0x0230 (size: 0x1)
    ERaidBattleGameResult m_Result;                                                   // 0x0231 (size: 0x1)

    void SetResult(const ERaidBattleGameResult InResult);
    void Server_SetScore(RAID_BATTLE_SCORE ScoreType, const class ASBPlayerCharacter* pPlayer, const float InPoint);
    void Server_LeavePlayer(class ASBPlayerCharacter* InLeaveMember);
    void Server_JoinPlayer(class ASBPlayerCharacter* InJoinMember);
    void Server_AddScore(RAID_BATTLE_SCORE ScoreType, const class ASBPlayerCharacter* pPlayer, const float InPoint);
    FString GetRewardId();
}; // Size: 0x368

class ASBRandomDungeonFieldMeshActor : public AStaticMeshActor
{
    FSBDungeonRect RoomByRect;                                                        // 0x0238 (size: 0x1C)

}; // Size: 0x258

class ASBRandomDungeonGenerator : public AActor
{
    float MapCellSizeX;                                                               // 0x0228 (size: 0x4)
    float MapCellSizeY;                                                               // 0x022C (size: 0x4)
    TSubclassOf<class AActor> EntranceActorClass;                                     // 0x0230 (size: 0x8)
    FRandomStream RandomDungeonGeneratorStream;                                       // 0x0238 (size: 0x8)
    int32 MapCellNumMaxX;                                                             // 0x0240 (size: 0x4)
    int32 MapCellNumMaxY;                                                             // 0x0244 (size: 0x4)
    TArray<FSBRandomDungeonMakeParamTable> RandomDungeonMakeParamTable;               // 0x0248 (size: 0x10)
    class UDataTable* RandomDungeonMakeParamSetTable;                                 // 0x0258 (size: 0x8)
    FName LoadMapTableRowName;                                                        // 0x0260 (size: 0x8)
    char padding_0[0x10];                                                             // 0x0268 (size: 0x10)
    TArray<FSBRandomDungeonAriaConnectInfo> RandomDungeonRouteInfoParam;              // 0x0278 (size: 0x10)
    TArray<FSBDungeonRect> DungeonRectList;                                           // 0x0288 (size: 0x10)
    bool DebugDrawMapBox;                                                             // 0x0298 (size: 0x1)
    bool DebugViewImpossibleAria;                                                     // 0x0299 (size: 0x1)

    bool BuildRandomDungeon();
}; // Size: 0x2A0

class ASBRangedProjectile : public ASBProjectileBase
{
    int32 ChainMovementIndex;                                                         // 0x0494 (size: 0x4)
    char padding_0[0xC];                                                              // 0x0498 (size: 0xC)
    uint8 bIsInstigatorPlayer;                                                        // 0x04A4 (size: 0x1)
    char padding_1[0xB];                                                              // 0x04A5 (size: 0xB)
    class UShapeComponent* GroundCollisionComp;                                       // 0x04B0 (size: 0x8)
    class USBProjectileCollisionComponent* CollisionComp;                             // 0x04B8 (size: 0x8)
    class USBProjectileAttackParamComponent* AttackParamComp;                         // 0x04C0 (size: 0x8)
    class USBProjectileEffectComponent* EffectComp;                                   // 0x04C8 (size: 0x8)
    class USBProjectileMeshControllComponent* MeshControllComp;                       // 0x04D0 (size: 0x8)
    class USBProjectileAttachToActorOnHitComponent* AttachHitComp;                    // 0x04D8 (size: 0x8)
    class USBProjectileSummonImagineComponent* SummonImagineComp;                     // 0x04E0 (size: 0x8)

    void ServerTakeDamage(const FSBDamageEvent& SBDamageEvent, class AController* EventInstigator, class AActor* DamageSrc);
    void ProjectileNotifySendTakeDamageOnServer(const FSBDamageEvent& InDamageEvent, const class AActor* InOtherActor);
    void ProjectileNotifyOnGroundtHit(const class USceneComponent* InHitSelfComponent, const class AActor* InOtherActor, const class UPrimitiveComponent* InOtherComponent, FVector InNormalImpulse);
    void ProjectileNotifyOnAttackHit(const class USceneComponent* InHitSelfComponent, const class AActor* InOtherActor, const class UPrimitiveComponent* InOtherComponent, FVector InImpactPoint);
    void MulticastTakeDamage(float Damage, const FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageSrc);
    FVector GetTargetPosition();
    class USceneComponent* GetTargetComp();
    FName GetNowMovementLabel();
    class USBProjectileMeshControllComponent* GetMeshControllComponent();
    FVector GetAttackCollisionScale();
    FVector GetAttackCollision(FVector& Center, FVector& CenterOffset);
    bool ChangeMovementToNext();
    bool ChangeMovementByLabel(FName InChangeLabel);
}; // Size: 0x4E8

class ASBReplicateTestActor : public ACharacter
{
    FSBReplicateTestActorOnPostNetReceiveSignature OnPostNetReceiveSignature;         // 0x04B8 (size: 0x10)
    void OnPostNetReceiveSignature();
    class USBReplicationTestComponent* TestComp;                                      // 0x04C8 (size: 0x8)

}; // Size: 0x4D0

class ASBReplicatedAlwaysGimmick : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x228

class ASBReplicatedGimmick : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x228

class ASBRespawnPoint : public ASBRespawnPointBase
{
    class UShapeComponent* CollisionComponent;                                        // 0x0270 (size: 0x8)

    void OnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
}; // Size: 0x278

class ASBRespawnPointBase : public ANavigationObjectBase
{
    FName RespawnPointTag;                                                            // 0x0250 (size: 0x8)
    float RespawnAreaRadius;                                                          // 0x0258 (size: 0x4)
    bool RespawnPointPTCheckAll;                                                      // 0x025C (size: 0x1)
    bool RespawnPointPTCheckOnce;                                                     // 0x025D (size: 0x1)
    char padding_0[0x2];                                                              // 0x025E (size: 0x2)
    FName MiniMapId;                                                                  // 0x0260 (size: 0x8)
    bool MiniMapRouteVisibility;                                                      // 0x0268 (size: 0x1)

}; // Size: 0x270

class ASBRespawnPointField : public ASBRespawnPointBase
{
    class UParticleSystem* ActivatedEffect;                                           // 0x0278 (size: 0x8)
    class UStaticMeshComponent* StaticMeshComponent;                                  // 0x0280 (size: 0x8)
    class UParticleSystemComponent* ActivatedEffectComponent;                         // 0x0288 (size: 0x8)
    class USBInteractionTargetComponent* InteractionTargetComponent;                  // 0x0290 (size: 0x8)

    void ServerRegisterRespawnPoint(class ASBPlayerCharacter* PlayerCharacter);
}; // Size: 0x298

class ASBRootCoordinator : public ASBSquadAI
{
    TSubclassOf<class ASBSquadAI> FactionSquadClass;                                  // 0x0240 (size: 0x8)
    TMap<class FName, class ASBSquadAI*> FactionSquads;                               // 0x0248 (size: 0x50)
    TArray<class USBSquadMemberComponent*> Members;                                   // 0x0298 (size: 0x10)

}; // Size: 0x2A8

class ASBRouteGuide : public AActor
{
    bool Available;                                                                   // 0x0228 (size: 0x1)
    bool DebugDraw;                                                                   // 0x0229 (size: 0x1)
    bool GuideUpdateFlag;                                                             // 0x022A (size: 0x1)
    char padding_0[0x1];                                                              // 0x022B (size: 0x1)
    FName CurrentDestination;                                                         // 0x022C (size: 0x8)
    char padding_1[0x24];                                                             // 0x0234 (size: 0x24)
    ESBRouteGuideArea PlayersArea;                                                    // 0x0258 (size: 0x1)
    char padding_2[0x13];                                                             // 0x0259 (size: 0x13)
    bool bUseRouteFindPatch;                                                          // 0x026C (size: 0x1)
    char padding_3[0x3];                                                              // 0x026D (size: 0x3)
    FSBRouteGuideDebugInfo DebugInfo;                                                 // 0x0270 (size: 0x20)

    ESBRouteGuideArea UpdatePlayersArea(FVector Location, float Scale);
    void SetRouteMapData(class UTexture2D* Texture);
    bool SetDestination(FName DestinationId, const ESBRouteGuideDestIdType IdType);
    void Set2DArea(FVector Root, float Size);
    bool SearchNearestRoutePt(ESBRouteGuideArea Area, int32 Range, float PosX, float PosY, int32& OutX, int32& OutY, int32& OutZ, int32& Cntr);
    void OverridePlayersArea(ESBRouteGuideArea Area, bool Overlapping);
    void OnChangeAvailability();
    int32 MemAccessTest(int32 Count);
    void LineCheck(int32 DX, int32 DY, TArray<FVector2D>& Points);
    bool IsDebugDraw();
    void InnerCulling(TArray<FVector2D> CurrentPts, TArray<FVector2D> InnerPts, TArray<FVector2D>& Points);
    void InitRouteLevelLink(TArray<FSBRouteGuideDestinationLevelLink> LinkData, TMap<class FName, class FVector4>& OutData);
    void GetTexelColorInfo(class UTexture2D* Texture, TArray<FSBTexelColorInfo>& Out);
    int32 GetRoutePtValue(ESBRouteGuideArea Area, int32 X, int32 Y);
    ESBRouteGuideArea FindRoutePtAreaValue(ESBRouteGuideArea Area, int32 X, int32 Y, int32& Z);
    class UNavigationPath* FindPath(FVector PathStart, FVector PathGoal, class AActor* PathfindingContext, int32 MaxSearchNode, TArray<FVector>& NavPathPoints);
    void CircleCheck(int32 Radius, TArray<FVector2D>& Points);
    void ChangePlayersArea(ESBRouteGuideArea Area);
}; // Size: 0x290

class ASBRouteGuideMarker : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    bool IsMarkerVisible();
    FVector GetMarkerLocation();
}; // Size: 0x228

class ASBRouteGuideShape : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    void UpdateRouteGuideShapeInstances(const TArray<FSBTexelColorInfo>& ShapeInfo, int32 MaxLevel);
    void AddRouteGuideShapeInstance(int32 X, int32 Y, int32 Z, int32 Type);
}; // Size: 0x228

class ASBRouteGuideTool : public AActor
{
    TArray<FIntPoint> FillBuff;                                                       // 0x0228 (size: 0x10)

    void GetRouteFill(class UTextureRenderTarget2D* RenderTarget, const FIntPoint Seed, TArray<FIntPoint>& DrawPts);
    bool GetNavPolysInBox(const FBox& Box, FVector RoutePt, FVector2D Scale, TArray<FSBRouteGuideAreaPoly>& Polys);
    bool FillRoute(class UCanvas* Canvas, ESBRouteGuideArea RouteGuideArea, float Height, const TArray<FIntPoint>& Points);
    void DrawRouteSplines(class UCanvas* Canvas, ESBRouteGuideArea RouteGuideArea, FVector RootPoint, FVector2D Scale, class UInstancedStaticMeshComponent* Instances, float Thickness, int32 LinkLength, float BaseHeight, float StartHeight, float EndHeight);
    void DrawRouteAreas(class UCanvas* Canvas, ESBRouteGuideArea RouteGuideArea, const TArray<FSBRouteGuideAreaPoly>& Polys);
}; // Size: 0x250

class ASBRouteGuideToolArea : public AActor
{
    ESBRouteGuideArea AreaColor;                                                      // 0x0228 (size: 0x1)

}; // Size: 0x230

class ASBScriptActor : public AActor
{
    TArray<class UDataTable*> DefineTableList;                                        // 0x0228 (size: 0x10)
    FSBScriptActorCreateDesc CreateDesc;                                              // 0x0238 (size: 0x98)
    FSBScriptActorOnPlayEnd OnPlayEnd;                                                // 0x02D0 (size: 0x10)
    void OnPlayEnd();
    char padding_0[0xD0];                                                             // 0x02E0 (size: 0xD0)
    TMap<class FName, class AActor*> SubActors;                                       // 0x03B0 (size: 0x50)
    TArray<class AActor*> ReferenceActor;                                             // 0x0400 (size: 0x10)
    char padding_1[0x8];                                                              // 0x0410 (size: 0x8)
    class AActor* LastSpeaker;                                                        // 0x0418 (size: 0x8)

    void ShowQuestJingle();
    void ShowQuestCompleteJingle(const int32 InQuestIndex);
    void ShowClassLevelUpEffect();
    void SetTalkModeFilterEnable(bool bInEnable);
    void SetFastForwardInfoDisplayFlag(const bool bInFlag);
    void SetFastForwardFlag(const bool bInFlag);
    void RetryConnectToServer();
    void OnYesNoPopupSelected(const int32 SelectItem);
    void OnYesNoDialogSelected(const int32 SelectItem);
    void OnWeaponSyntheMenuFinish(const bool bDoSynthe);
    void OnWeaponAbilityRemoverFinish(const bool bInDoRemoved);
    void OnWeaponAbilityReconditionFinish(const bool bInDoRecondition);
    void OnWeaponAbilityExtenderFinish(const bool bInDoExtended);
    void OnWarpMenuFinish();
    void OnWaitToIdlePlayerFinish();
    void OnWaitMusicCueFinished();
    void OnUpdateQuestProgressByTalkNpc(bool Result, const int32 RetCode);
    void OnUpdateQuestProgress(bool Result, const int32 RetCode, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void OnUnlockImagineRecipesFinished(const int32 RetCode);
    void OnUnlockCraftRecipesFinished(const int32 ErrorCode, const TArray<FCharacterCraftRecepi>& InUpdatedRecipe);
    void OnTitle2ndUIFinish();
    void OnTextWindowTurnText();
    void OnStoragePresetEquipSetMenuFinish();
    void OnStorageMenuFinish();
    void OnStorageAbilityShopFinish();
    void OnStartInstanceBattleFailed(class USBMatchingGameState* InMatchedGame, const ESBMatchingFailureType InFailureType);
    void OnSpawnSubActorFinished(const FName InProfileId, class AActor* InActor);
    void OnShowTutorialHelpFinished();
    void OnShowRankingBoardFinish();
    void OnShowDhcUIMenuFinish(int32 Select);
    void OnShowColosseumMenu(FString InMapName);
    void OnShopMenuFinish();
    void OnSetViewTargetFinish();
    void OnSetUserData(bool Result);
    void OnSetTalkModeFinished();
    void OnSetQuestEventModeFinished();
    void OnSetHiddenBuddyNpcFinished();
    void OnSetFieldShopModeFinished();
    void OnSetDemoModeFinish();
    void OnSetContentLockFinish(const bool bInResult);
    void OnSendMailFinish(const bool bInResult);
    void OnSelectMenu_SelectItem(const int32 SelectItem);
    void OnSaveDemoBrowsedFlagFinish(const bool bSuccess);
    void OnRmShopMenuFinish();
    void OnResetViewTargetFinish();
    void OnResearchTeamMenuFinish();
    void OnRequestFreeBuffEffectActivationFinished();
    void OnReportQuest(bool Result, int32 QuestIndex);
    void OnQuestRequestMenuFinish(const bool bInAccepted);
    void OnQuestConfirmFinish();
    void OnQuestCancelMenuFinish();
    void OnQuestBoardFinish();
    void OnQuestAccept(bool Result, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void OnPlaySubTitleFinish();
    void OnPlayerCraftMenuFinish(const bool bInDoCraft);
    void OnPlayEnd__DelegateSignature();
    void OnPickQuestFinish(const int32 InQuestIndex);
    void OnMessageDialogFinished();
    void OnMediaPlayerFinish();
    void OnMatchingFinished(bool IsCanceled);
    void OnLookAtLocationFinished();
    void OnLookAtActorForPlayerFinished();
    void OnLoginBonusCheckFinish();
    void OnLiquidMemoryShopFinish(const bool bIsLiquidMemoryUsed);
    void OnLayoutSelected(int32 Layout);
    void OnInteractNappoFinish(bool retlua);
    void OnImaginLevelingFinish();
    void OnImagineStackBFinish();
    void OnImagineCraftFinish();
    void OnGuildMenuFinish();
    void OnGuildJoinMenuFinish();
    void OnGetValidSubEventFinished(FName InEventId);
    void OnGetEmoteFinish(bool bResult);
    void OnFmMenuFinish();
    void OnFang_expeditionFinish();
    void OnFadeFinish();
    void OnExecChildProcessFinished(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    void OnEventShopFinish();
    void OnEstheMenuFinish();
    void OnEnhanceMenuFinish(const bool bInDoEnhance);
    void OnDemoFinishBP(const bool bSuccess);
    void OnDelayFinish();
    void OnDebugSetAdventurerRankFinished(const int32 InRetCode);
    void OnCompleteQuestStep(bool bResult, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void OnCommandMenuAdventureBoardFinish();
    void OnColoringShopMenuFinish();
    void OnColorFilterFinish();
    void OnCloseNappoUIAndCheckCompleteFinish();
    void OnClassChangeMenuFinish(const bool bInResult);
    void OnChoiceDialogFinish(const int32 SelectItem);
    void OnCashExchangeShopFinish();
    void OnCancelQuest(bool bResult, int32 QuestIndex);
    void OnApplyDofSettingsFinish();
    void OnAdventurerRankUpFinish(const bool bSuccess);
    void OnAdventurerRankShopMenuFinish();
    void OnActivateWarpPointFinish();
    void OnActivateContent(bool bInResult);
    bool GetFastForwardInfoDisplayFlag();
    bool GetFastForwardFlag();
    void BP_WaitToIdlePlayer();
    void BP_WaitMusicCue();
    void BP_UpdateQuestProgressByTalkNpc(const int32 InQuestIndex, const FName NpcId);
    void BP_StopCameraShake(const FName& InId);
    void BP_StartActorLipSyncAnim(class USBCharaPartsFaceComponent* FaceComponent, float Speed, float Duration);
    void BP_SpawnSubActor(const FName& InCharacterId, const FVector& Location);
    void BP_ShowYesNoPopup();
    void BP_ShowYesNoDialog(const FText& MessageText);
    void BP_ShowWeaponSyntheMenu();
    void BP_ShowWeaponAbilityRemover();
    void BP_ShowWeaponAbilityReconditioner();
    void BP_ShowWeaponAbilityExtender();
    void BP_ShowWarpMenu();
    void BP_ShowTutorialHelp(const FName& InId);
    void BP_ShowTitle2ndUI();
    void BP_ShowTextWindow(const FText& InText, const bool bWaitUserInput);
    void BP_ShowTAbilityShopMenu(EShopType InShopType);
    void BP_ShowStoragePresetEquipSetMenu();
    void BP_ShowStorageMenu();
    void BP_ShowStorageAbilityShop();
    void BP_ShowShopMenu(const EShopType InShopType, const FName& InProductListId);
    void BP_ShowSelectMenu(const TArray<FText>& InItems);
    void BP_ShowRmShopMenu();
    void BP_ShowResearchTeamMenu();
    void BP_ShowRankingBoard();
    void BP_ShowQuestRequestMenu(const int32 InQuestIndex);
    void BP_ShowQuestJingle();
    void BP_ShowQuestConfirm(const int32 InQuestIndex);
    void BP_ShowQuestCompleteJingle(const int32 InQuestIndex);
    void BP_ShowQuestCancelMenu();
    void BP_ShowQuestBoard(const FName& InQuestBoardId);
    void BP_ShowPlayerCraftMenu();
    void BP_ShowMoneyUI();
    void BP_ShowMessageDialog(const FText& MessageText);
    void BP_ShowMediaPlayerUI(const FName& SourceId);
    void BP_ShowLiquidMemoryShopMenu();
    void BP_ShowImaginLeveling();
    void BP_ShowImagineStackB();
    void BP_ShowImaginCraft(bool bIsBattleImagine);
    void BP_ShowHudLayoutSelectPreset();
    void BP_ShowGuildMenu();
    void BP_ShowGuildJoinMenu();
    void BP_ShowFmMenu();
    void BP_ShowFang_expedition();
    void BP_ShowEventShopMenu(EShopType InShopType);
    void BP_ShowEstheMenu();
    void BP_ShowEnhanceMenu();
    void BP_ShowEngramUI();
    void BP_ShowDhcUIMenu(bool IsDhcMapMode);
    void BP_ShowConnectToServerError(int32 RetCode);
    void BP_ShowCommandMenuAdventureBoard();
    void BP_ShowColosseumMenu();
    void BP_ShowColoringShop(const bool InIsCostumeChange, const bool InIsColorSVEnabled);
    void BP_ShowChoiceDialog(const FText& InQuestion, const TArray<FText>& InItems);
    void BP_ShowCashExchangeShopMenu();
    void BP_ShowBalloonWindow(class ACharacter* InAttachCharacter, const FText& InText);
    void BP_ShowAdventurerRankUp();
    void BP_ShowAdventurerRankShopMenu();
    void BP_SetViewTargetPreset(const FName& InCameraId, const FVector& InOffsetLocation, const float InBlendTime);
    void BP_SetViewTargetActor(class AActor* InNewTarget, const bool bInRelative);
    void BP_SetViewTarget(const FVector InTargetLocation, const FRotator InTargetRotation, const float InBlendTime);
    void BP_SetUserData(const FName& InKey, FString InValue);
    void BP_SetTalkModeFixed(class AActor* InOtherActor, const FName ViewParamId, const bool bIsNoCheckAtTeleportPlayer, const float InCameraZOffset);
    void BP_SetTalkMode(class AActor* InOtherActor, const float InDistancePlayer, const bool bIsNoCheckAtTeleportPlayer, const float InCameraZOffset);
    void BP_SetSpeaker(const FName& InName);
    void BP_SetQuestEventMode();
    void BP_SetHiddenBuddyNpc();
    void BP_SetEnvironmentMeshShadow(const FName& RowName, const bool bCastShadow);
    void BP_SetDemoModeWait();
    void BP_SetContentLock(const ESBContentLockType InContentLockType, const bool bInLock);
    void BP_SetColorFilter(const FLinearColor& InColor, const float InDuration);
    void BP_SendMail(const FName& InMailId);
    void BP_SaveDemoBrowsedFlag(const FName& InDemoName);
    void BP_ResumeChange();
    void BP_ResetViewTarget();
    void BP_ResetColorFilter(const float InDuration);
    void BP_RequestFreeBuffEffectActivation(const class ASBFieldActorFreeBuffPoint* BuffPoint, const class AActor* PlayerCharacter);
    void BP_ReportQuest(const int32 QuestIndex);
    void BP_QuestAccept(const int32 QuestIndex);
    void BP_PlaySubTitle(const FName& InId);
    void BP_PlayParticleFromActor(const class AActor* InTargetActor, const FName& InParticleId, const FName& InAttachSocketId, const FVector& InOffsetLocation);
    void BP_PlayDemo_SkipSave(const FName& InDemoName);
    void BP_PlayDemo(const FName& InDemoName);
    void BP_PlayCameraShake(const FName& InId);
    void BP_PickQuest(const FName& InClientId);
    void BP_OnStart();
    void BP_LookAtLocation(class AActor* InActor, const FVector& InTargetLocation);
    void BP_LookAtActorForPlayer(class AActor* SourceActor, class AActor* DestinationActor, bool bIsMount);
    void BP_LoginBonusCheck();
    void BP_IsMatchingCanselMenu();
    void BP_InteractNappo(FString NappoId);
    void BP_HideMoneyUI();
    void BP_HideEngramUI();
    void BP_GetValidSubEvent(const TArray<FName>& InSubEvents);
    void BP_GetEmote(const FName& InEmoteId);
    void BP_FadeOut(const float InDuration, const bool bInWait);
    void BP_FadeIn(const float InDuration, const bool bInWait);
    void BP_Delay(const float InDelayTime);
    void BP_CompleteQuestStep(const int32 InQuestIndex, const int32 InStepIndex, const int32 InConditionDataId);
    void BP_CloseNappoUIAndCheckComplete();
    void BP_ClassChangeMenu();
    void BP_ApplyDofSettings(const FName& InSettingId, const float InTransitionTime);
    void BP_ActivateWarpPoint(const FName& InWarpPointId);
    void BP_ActivateContentsOnComplete(const bool bAll);
    void BP_ActivateContent(const FName& InContentId, const bool bIsStartMatching);
}; // Size: 0x9E0

class ASBSegmentNavLinkProxy : public AActor
{
    TArray<FNavigationSegmentLink> SegmentLinks;                                      // 0x0238 (size: 0x10)
    class USBSegmentNavLinkComponent* SmartSegmentLinkComp;                           // 0x0248 (size: 0x8)
    bool bSmartLinkIsRelevant;                                                        // 0x0250 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0251 (size: 0x7)
    FSBSegmentNavLinkProxyOnSmartLinkReached OnSmartLinkReached;                      // 0x0258 (size: 0x10)
    void SmartSegmentLinkReachedSignature(class AActor* MovingActor, const FVector& DestinationPoint);
    class USBNavLinkJumpComponent* NavLinkJumpComp;                                   // 0x0268 (size: 0x8)

    void SetSmartLinkEnabled(bool bEnabled);
    void SetbSmartLinkIsRelevant(bool bRelevant);
    void ResumePathFollowing(class AActor* Agent);
    void ReceiveSmartLinkReached(class AActor* Agent, const FVector& Destination);
    void OnJumpStart(class AActor* PathOwner, const FVector& Destination);
    bool IsSmartLinkEnabled();
    bool HasMovingAgents();
}; // Size: 0x270

class ASBSegmentNavLinkProxyWithAnchor : public ASBSegmentNavLinkProxy
{
    char padding_0[0x270];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x270

class ASBSimpleBattleTester : public AActor
{
    TArray<class USBUtilityDataProvider_BlueprintBase*> Conditions;                   // 0x0228 (size: 0x10)
    bool bIsTestStarted;                                                              // 0x0238 (size: 0x1)

    void StartTest();
    void EndTest();
}; // Size: 0x240

class ASBSkeletalMeshActor : public ASkeletalMeshActor
{
    char padding_0[0x2B0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2B0

class ASBSkillForecast : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x228

class ASBSkillMarker : public AActor
{
    class UCurveFloat* SizeChangeCurve;                                               // 0x0240 (size: 0x8)

    void SetShowDecal(bool bShowDecal);
    void SetRadius(float Radius);
}; // Size: 0x248

class ASBSkySphere : public AActor
{
    class USBSkyMeshComponent* Mesh;                                                  // 0x0228 (size: 0x8)
    class UStaticMeshComponent* OcclusionQuerySun;                                    // 0x0230 (size: 0x8)
    class ADirectionalLight* DirectionalLightActor;                                   // 0x0238 (size: 0x8)
    float SunDiskPitch;                                                               // 0x0240 (size: 0x4)
    float SunDiskYaw;                                                                 // 0x0244 (size: 0x4)
    float LightVectorZMax;                                                            // 0x0248 (size: 0x4)
    float RoundSpeed;                                                                 // 0x024C (size: 0x4)
    float RoundOffset;                                                                // 0x0250 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0254 (size: 0x4)
    class UCurveLinearColor* LightColor;                                              // 0x0258 (size: 0x8)
    class UCurveFloat* LightIntensity;                                                // 0x0260 (size: 0x8)
    class UCurveFloat* ToonIntensityScale;                                            // 0x0268 (size: 0x8)
    char padding_1[0x24];                                                             // 0x0270 (size: 0x24)
    float ElapsedTime;                                                                // 0x0294 (size: 0x4)
    char padding_2[0x8];                                                              // 0x0298 (size: 0x8)
    int32 PreviewHour;                                                                // 0x02A0 (size: 0x4)
    int32 PreviewMinute;                                                              // 0x02A4 (size: 0x4)
    float TimeRate;                                                                   // 0x02A8 (size: 0x4)
    bool EnableTimeProgression;                                                       // 0x02AC (size: 0x1)
    char padding_3[0x3];                                                              // 0x02AD (size: 0x3)
    int32 Morning;                                                                    // 0x02B0 (size: 0x4)
    int32 DayTime;                                                                    // 0x02B4 (size: 0x4)
    int32 Dusk;                                                                       // 0x02B8 (size: 0x4)
    int32 Night;                                                                      // 0x02BC (size: 0x4)
    char padding_4[0x22];                                                             // 0x02C0 (size: 0x22)
    bool bLightPreviewInitialized;                                                    // 0x02E2 (size: 0x1)

    void UpdateSkySphere();
    void UpdateScheduleLightPreview(float PreviewTimeRate, bool Switch);
    void UpdateLightsImmidiate();
    bool SetSkyTime(FDateTime GameTime, FDateTime ServerTime, bool InEnableTimeProgression, bool Overridden);
    bool SetPreviewTime(int32 InHour, int32 InMinute);
    int32 SetMinutesPerDaytime(int32 InMinutesPerDaytime);
    int32 SetMinutesPerDay(int32 InMinutesPerDay);
    void ScheduleLightPreviewInit(bool sw);
    bool IsLightDirectionLimited();
    FVector2D GetSunScreenPosition();
    FVector GetSunLocation();
    float GetSunLastPixelsPercentage();
    FRotator GetSunDiskRotation(int32 Index);
    FString GetStringServerTime();
    FString GetStringPreviewTime();
    FString GetStringGameTime();
    bool GetPrevTimeUpdated();
    FDateTime GetPreviewTime();
    int32 GetActiveLightIndex();
    float CalcPreviewTime(float DeltaSeconds);
}; // Size: 0x368

class ASBSpawnArea : public AActor
{
    FSBSpawnAreaOnFirstSpawnDelegate OnFirstSpawnDelegate;                            // 0x0228 (size: 0x10)
    void SBOnFirstSpawnInSpawnAreaDelegate(class ASBSpawnArea* SpawnArea);
    FAIFwParameterizedBTRequest SubSpawnQuery;                                        // 0x0238 (size: 0x18)
    FAIFwParameterizedBTRequest FindSpawnPointQuery;                                  // 0x0250 (size: 0x18)
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0268 (size: 0x8)
    uint8 bEnabled;                                                                   // 0x0270 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0271 (size: 0x7)
    class USBSpawnSourceComponent* SpawnSourceComponent;                              // 0x0278 (size: 0x8)
    uint8 bGenerateSpawnPoint;                                                        // 0x0280 (size: 0x1)
    uint8 bProjectOnNavMesh;                                                          // 0x0280 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0281 (size: 0x3)
    FVector Extent;                                                                   // 0x0284 (size: 0xC)
    float StepSize;                                                                   // 0x0290 (size: 0x4)

    bool SetSpawnQueryArgument(FString ArgName, bool BoolValue, int32 IntValue, float FloatValue, FString StringValue);
    EAIFwBTParamType GetSpawnQueryArgument(FString ArgName, bool& BoolValue, int32& IntValue, float& FloatValue, FString& StringValue);
}; // Size: 0x2B0

class ASBSpawnAreaDungeon : public ASBSpawnArea
{
    TArray<TWeakObjectPtr<ASBEnemySenseChanger>> EnemySenseChangers;                  // 0x02B0 (size: 0x10)
    FName SpawnedEnemyTag;                                                            // 0x02C0 (size: 0x8)

    void LoadEnemyAssets();
}; // Size: 0x2C8

class ASBSpawnWaveArea : public ASBSpawnArea
{
    FSBSpawnWaveAreaOnWaveStarted OnWaveStarted;                                      // 0x02B0 (size: 0x10)
    void OnWaveStartedSignature(int32 WaveNo);
    FSBSpawnWaveAreaOnAssetLoadBegan OnAssetLoadBegan;                                // 0x02C0 (size: 0x10)
    void OnAssetLoadCompletedSignature();
    FSBSpawnWaveAreaOnAssetLoadCompleted OnAssetLoadCompleted;                        // 0x02D0 (size: 0x10)
    void OnAssetLoadCompletedSignature();
    FSBSpawnWaveAreaOnSettingWaveDataEnd OnSettingWaveDataEnd;                        // 0x02E0 (size: 0x10)
    void OnSettingWaveDataEndSignature();
    class USBSpawnWaveConditionComponent* SpawnWaveConditionComponent;                // 0x02F0 (size: 0x8)
    FName SpawnedEnemyTag;                                                            // 0x02F8 (size: 0x8)
    char padding_0[0x4C];                                                             // 0x0300 (size: 0x4C)
    FName EnemyWaveId;                                                                // 0x034C (size: 0x8)
    char padding_1[0x4];                                                              // 0x0354 (size: 0x4)
    TArray<TWeakObjectPtr<ASBEnemySenseChanger>> EnemySenseChangers;                  // 0x0358 (size: 0x10)

    void StartWave();
    void OnWaveStartedSignature__DelegateSignature(int32 WaveNo);
    void OnSettingWaveDataEndSignature__DelegateSignature();
    void OnAssetLoadCompletedSignature__DelegateSignature();
    void OnAssetLoadBeganSignature__DelegateSignature();
    void OnActorDamaged(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst);
    bool NextWave();
    void LoadEnemyAssets();
    bool IsAssetLoading();
    bool IsAssetLoaded();
    int32 GetTotalEnemyCount();
    int32 GetMaxStepIndex();
    int32 GetCurrentStepIndex();
}; // Size: 0x368

class ASBSplineMeshActor : public ASplineMeshActor
{
    bool ForceAdjustAverageSplinePoint;                                               // 0x0230 (size: 0x1)
    bool LockAdjustAverageSplinePoint;                                                // 0x0231 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0232 (size: 0x2)
    int32 RoadMeshNumMax;                                                             // 0x0234 (size: 0x4)
    bool ForceAdjustAverageSplinePointTM;                                             // 0x0238 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0239 (size: 0x3)
    int32 RoadTrackMeshNumMax;                                                        // 0x023C (size: 0x4)

    void SetStaticMeshParam(class UStaticMeshComponent* StaticMeshComponent, float DesiredMaxDrawDistance, bool SetAllowCullDistanceVolume);
}; // Size: 0x240

class ASBSquadAI : public AActor
{
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0228 (size: 0x8)
    class UAIFwHierarchyComponent* HierarchyComponent;                                // 0x0230 (size: 0x8)
    class USBAIMessageDispatchingComponent* MessageDispatchingComponent;              // 0x0238 (size: 0x8)

    class ASBSquadAI* NewSubSquad(TSubclassOf<class ASBSquadAI> SquadClass);
}; // Size: 0x240

class ASBSquadAI_Battle : public ASBSquadAI
{
    class USBAIRoleDistributionComponent* RoleDistributionComponent;                  // 0x0240 (size: 0x8)

    void SetTarget(FName TargetFaction, int32 TargetClusterNo);
}; // Size: 0x248

class ASBSquadAI_BlueprintBase : public ASBSquadAI
{
    char padding_0[0x240];                                                            // 0x0000 (size: 0x0)

    class ASBSquadAI* ReceiveFindSubSquad(const FSBSquadMemberContext& Context);
}; // Size: 0x240

class ASBStreamingVolume : public AVolume
{
    FName LevelToLoad;                                                                // 0x0260 (size: 0x8)

}; // Size: 0x270

class ASBSwitchManager : public AActor
{
    TArray<float> PanelLamp;                                                          // 0x0228 (size: 0x10)
    bool bSwitchGateOpen;                                                             // 0x0238 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0239 (size: 0x3)
    FSBRandomSwitchs SetRandomPattern;                                                // 0x023C (size: 0x10)
    char padding_1[0x4];                                                              // 0x024C (size: 0x4)
    TArray<FString> IconNames;                                                        // 0x0250 (size: 0x10)
    FSBSwitchManagerOnInitRandomSwitchPattern OnInitRandomSwitchPattern;              // 0x0260 (size: 0x10)
    void OnInitRandomSwitchPattern();

    void ServerUpdateRandomPattern(FSBRandomSwitchs InSetRandomPattern, bool RetryUpdateNotify);
    void RequestUpdateRandomPatternMC(FSBRandomSwitchs InSetRandomPattern, bool RetryUpdateNotify);
    void RequestUpdateRandomPattern(FSBRandomSwitchs InSetRandomPattern, bool RetryUpdateNotify);
    void OnUpdateRandomPattern();
    void OnRep_SwitchGateOpen();
    void OnRep_RandomPattern();
    void OnRep_PanelLamp();
    void OnInitRandomSwitchPattern__DelegateSignature();
    void MultiCastUpdateRandomPattern(FSBRandomSwitchs InSetRandomPattern, bool RetryUpdateNotify);
    void ClientUpdateRandomPattern(FSBRandomSwitchs InSetRandomPattern, bool RetryUpdateNotify);
}; // Size: 0x270

class ASBSwitchableNavModifierVolume : public ANavModifierVolume
{
    TSubclassOf<class UNavArea> CurrentAreaClass;                                     // 0x0278 (size: 0x8)
    TArray<FVector2D> ConvexPolygon;                                                  // 0x0280 (size: 0x10)
    float Height;                                                                     // 0x0290 (size: 0x4)
    float BrushRadius;                                                                // 0x0294 (size: 0x4)
    TArray<uint64> PolysInVolume;                                                     // 0x0298 (size: 0x10)
    TArray<FNavDataInfo> PolyNumOfNavMeshes;                                          // 0x02A8 (size: 0x10)

    void SetNavAreaInGameplay_Client(TSubclassOf<class UNavArea> NewAreaClass);
    void SetNavAreaInGameplay(TSubclassOf<class UNavArea> NewAreaClass);
    void OnRep_CurrentAreaClass();
}; // Size: 0x2C0

class ASBTidalAreaVolume : public AActor
{
    class UFont* FontObject;                                                          // 0x0228 (size: 0x8)
    char padding_0[0x8];                                                              // 0x0230 (size: 0x8)
    float TideRate;                                                                   // 0x0238 (size: 0x4)
    char padding_1[0x4];                                                              // 0x023C (size: 0x4)
    FString TideDirection;                                                            // 0x0240 (size: 0x10)
    TSubclassOf<class UNavArea> LowTideNavArea;                                       // 0x0250 (size: 0x8)
    TSubclassOf<class UNavArea> HighTideNavArea;                                      // 0x0258 (size: 0x8)

}; // Size: 0x260

class ASBTidalOceanGrid : public ASBOceanGrid
{
    class UBoxComponent* TideBox;                                                     // 0x0310 (size: 0x8)
    class UCurveFloat* TideCurve;                                                     // 0x0318 (size: 0x8)
    float WaterHeight;                                                                // 0x0320 (size: 0x4)
    float MaxTideHeight;                                                              // 0x0324 (size: 0x4)
    float MinTideHeight;                                                              // 0x0328 (size: 0x4)
    float MaxTideMoveSpeed;                                                           // 0x032C (size: 0x4)
    float TidePreview;                                                                // 0x0330 (size: 0x4)
    ESBTidalOceanGridPlayInEditor PlayInEditorPreview;                                // 0x0334 (size: 0x1)

    float GetCurrentTideOffsetHeight();
}; // Size: 0x348

class ASBTideManager : public AActor
{
    FSBTideManagerOnHighTideDelegate OnHighTideDelegate;                              // 0x0228 (size: 0x10)
    void OnHighTideDelegate();
    FSBTideManagerOnLowTideDelegate OnLowTideDelegate;                                // 0x0238 (size: 0x10)
    void OnLowTideDelegate();
    FSBTideManagerOnStartHighTideDelegate OnStartHighTideDelegate;                    // 0x0248 (size: 0x10)
    void OnStartHighTideDelegate();
    FSBTideManagerOnStartLowTideDelegate OnStartLowTideDelegate;                      // 0x0258 (size: 0x10)
    void OnStartLowTideDelegate();

    void PlayTide(bool sw, float Time);
    void OnStartLowTideDelegate__DelegateSignature();
    void OnStartHighTideDelegate__DelegateSignature();
    void OnLowTideDelegate__DelegateSignature();
    void OnHighTideDelegate__DelegateSignature();
    bool IsSublevelInitialLoaded();
}; // Size: 0x268

class ASBTitleHUD : public AHUD
{
    char padding_0[0x320];                                                            // 0x0000 (size: 0x0)

    void TryRequestTitleToCharacterSelectLog();
    void SetFirstTime();
    void RequestTermsOfUseRead(TArray<int32> InIds);
    void RequestTermsOfUseGet();
    void OnTermsOfUse(const TArray<FSBTermsOfUseInfo>& TermsOfUseList);
    void OnTermsOfRead(int32 RetCode);
}; // Size: 0x320

class ASBTraverseVolume : public ATriggerVolume
{
    FString TraverseName;                                                             // 0x0260 (size: 0x10)
    int32 Floor;                                                                      // 0x0270 (size: 0x4)

    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnDemoPlayStart();
    void OnDemoPlayEnd();
    void OnCompleatTraverse(const int32 RetCode);
    FString GetTraverseName();
    int32 GetFloor();
}; // Size: 0x298

class ASBTreasureSpot : public ATargetPoint
{
    class USBInteractionTargetAuthorComponent* InteractionTargetAuthorComponent;      // 0x0228 (size: 0x8)
    TSubclassOf<class ASBFieldActorTreasureBox> TargetClass;                          // 0x0230 (size: 0x8)
    TSubclassOf<class ASBFieldActorTreasureBox> DestructibleObjectDropTargetClass;    // 0x0238 (size: 0x8)
    int32 TreasureBoxId;                                                              // 0x0240 (size: 0x4)
    int32 TreasureBoxHardId;                                                          // 0x0244 (size: 0x4)
    int32 TreasureBoxSceId;                                                           // 0x0248 (size: 0x4)
    int32 CalcTreasureBoxId;                                                          // 0x024C (size: 0x4)
    FString TreasureBoxTag;                                                           // 0x0250 (size: 0x10)
    bool bTimeLimited;                                                                // 0x0260 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0261 (size: 0x3)
    float EffectiveTime;                                                              // 0x0264 (size: 0x4)
    ESBTreasureBoxRarity Rarity;                                                      // 0x0268 (size: 0x1)
    char padding_1[0x17];                                                             // 0x0269 (size: 0x17)
    bool IsSpawnRandom;                                                               // 0x0280 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0281 (size: 0x7)
    class UBoxComponent* CollisionComponent;                                          // 0x0288 (size: 0x8)

}; // Size: 0x290

class ASBTriggerBox : public ATriggerBox
{
    bool bSpriteHiddenInGame;                                                         // 0x0230 (size: 0x1)

}; // Size: 0x238

class ASBTriggerVolume : public ATriggerVolume
{
    char padding_0[0x260];                                                            // 0x0000 (size: 0x0)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x260

class ASBUIController : public AActor
{
    class UWidget* CommandMenuCommonCheckWidgetUi;                                    // 0x0228 (size: 0x8)
    class UWidget* CommandMenuCommonWidgetUi;                                         // 0x0230 (size: 0x8)
    char padding_0[0x8];                                                              // 0x0238 (size: 0x8)
    class UWidget* SelectWidgetUi;                                                    // 0x0240 (size: 0x8)

    void SetSelectWidgetToMousePoint(class UWidget* Widget);
    void SetCommandMenuCommonSubButtonListButton(class UWidget* Widget);
    bool GetCommandMenuCommonTouchCheckEnd();
    bool GetCommandMenuCommonSubOn();
    void CheckCommandMenuCommonSubButtonListButtonStart();
    void CheckCommandMenuCommonSubButtonListButton(class UWidget* Widget);
}; // Size: 0x248

class ASBUpdraft : public AActor
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)

    void RemoveOverlappingToPlayer(class AActor* OverlapActor);
    void AddOverlappingToPlayer(class AActor* OverlapActor);
}; // Size: 0x228

class ASBWaterAreaVolume : public AVolume
{
    class USBChildWaterNavModifierVolumeComponent* ChildVolume_Default;               // 0x0260 (size: 0x8)
    class USBChildWaterNavModifierVolumeComponent* ChildVolume_Medium;                // 0x0268 (size: 0x8)
    class USBChildWaterNavModifierVolumeComponent* ChildVolume_Large;                 // 0x0270 (size: 0x8)

}; // Size: 0x278

class ASBWaterDepthSoundVolume : public AVolume
{
    bool DebugDisplayAkComponent;                                                     // 0x0260 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0261 (size: 0x7)
    class UAkAudioEvent* PlayAudioEvent;                                              // 0x0268 (size: 0x8)
    class UAkAudioEvent* StopAudioEvent;                                              // 0x0270 (size: 0x8)
    float DistanceInterval;                                                           // 0x0278 (size: 0x4)
    int32 MaxNumberOfSearches;                                                        // 0x027C (size: 0x4)
    class USBWaterDepthSoundComponent* WaterDepthSoundComponent;                      // 0x0280 (size: 0x8)

    void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x298

class ASBWaterFlowActor : public AActor
{
    char padding_0[0x230];                                                            // 0x0000 (size: 0x0)

    bool GetWaterFlowParam(const FVector& Location, FVector& Direction, float& power);
}; // Size: 0x230

class ASBWaterFlowTick : public AActor
{
    TMap<class AActor*, class USBWaterFlowListForActor*> WaterFlowDataList;           // 0x0228 (size: 0x50)

    void OnTargetDestroyed(class AActor* Target);
}; // Size: 0x278

class ASBWaterMeshActor : public AStaticMeshActor
{
    int32 Priority;                                                                   // 0x0240 (size: 0x4)
    float FluidFriction;                                                              // 0x0244 (size: 0x4)
    bool bShallowWater;                                                               // 0x0248 (size: 0x1)
    bool bTraceComplex;                                                               // 0x0249 (size: 0x1)
    char padding_0[0x6];                                                              // 0x024A (size: 0x6)
    class UPhysicalMaterial* PhysMaterialDeepOverride;                                // 0x0250 (size: 0x8)
    class UStaticMeshComponent* DebugDrawMeshComponent;                               // 0x0258 (size: 0x8)
    class USplineMeshComponent* TrackSplineMeshComponent;                             // 0x0260 (size: 0x8)
    bool IsUseWaterSetting;                                                           // 0x0268 (size: 0x1)
    bool bPlayerOverlap;                                                              // 0x0269 (size: 0x1)
    char padding_1[0x6];                                                              // 0x026A (size: 0x6)
    class ASBPhysicsWaterVolume* WaterVolume;                                         // 0x0270 (size: 0x8)
    bool bSkipConstructAfterLoad;                                                     // 0x0278 (size: 0x1)

    void UpdateWaterVolume();
    void SetWaterVolumeParam();
    class ASBPhysicsWaterVolume* GetWaterVolume();
    void CheckWorld();
}; // Size: 0x280

class ASBWaterNavModifierVolume : public ANavModifierVolume
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x280

class ASBWeapon : public AActor
{
    class UASCollisionGroupComponent* Collision;                                      // 0x0238 (size: 0x8)
    class USBCharaPartsComponent* Mesh;                                               // 0x0240 (size: 0x8)
    char padding_0[0xE];                                                              // 0x0248 (size: 0xE)
    TEnumAsByte<ESBWeaponType> WeaponType;                                            // 0x0256 (size: 0x1)
    TEnumAsByte<ESBWeaponShapeType> WeaponShapeType;                                  // 0x0257 (size: 0x1)
    char padding_1[0x10];                                                             // 0x0258 (size: 0x10)
    class UCharaPartsColorWeaponList* ColorList;                                      // 0x0268 (size: 0x8)
    TArray<class UCharaPartsMaterialSet*> CharaPartsMaterialSetList;                  // 0x0270 (size: 0x10)
    char padding_2[0x48];                                                             // 0x0280 (size: 0x48)
    TArray<FSBEnvironmentWeaponEffect> EnvironmentEffectList;                         // 0x02C8 (size: 0x10)
    TArray<FSBUnsheatheWeaponEffect> UnsheatheEffectList;                             // 0x02D8 (size: 0x10)
    TArray<FSBWeaponAnimationSetting> AnimationList;                                  // 0x02E8 (size: 0x10)
    char padding_3[0x94];                                                             // 0x02F8 (size: 0x94)
    float FadeSpeed;                                                                  // 0x038C (size: 0x4)
    bool bPropagateVisibilityToAdditionalMesh;                                        // 0x0390 (size: 0x1)
    char padding_4[0x17];                                                             // 0x0391 (size: 0x17)
    class USBWeaponBowComponent* m_pBowComponent;                                     // 0x03A8 (size: 0x8)
    class USBWeaponBallHammerComponent* m_pBallHammerComponent;                       // 0x03B0 (size: 0x8)

    void SetMaterialParamToParticle(class UParticleSystemComponent* Particle);
    void SetMaterialIndex(int32 Index);
    void SetColorData(const FSBCharaCreateColorHSV& ColorHSV);
    void ResetAnimation(class USBCharaPartsComponent* TargetMesh);
    void ReceivePlayWeaponAnimation(int32 Anim);
    class USBWeaponBaseComponent* GetWeaponTypeComponent(TEnumAsByte<ESBWeaponComponentType> Type);
    TEnumAsByte<ESBWeaponType> GetWeaponType();
    TEnumAsByte<ESBWeaponShapeType> GetWeaponShapeType();
    FName GetWeaponAssetName();
    FVector GetSocketLocation(const FName& SocketName);
    class USBSkeletalMeshComponent* GetSkeletalMeshComponent();
    bool GetMaterialParam(FSBWeaponMaterialParam& OutWeaponMaterialParam);
    FCharaPartsColorDataWeapon GetDefaultColor();
    class USBCharaPartsComponent* GetCharaPartsComponent();
    void CopyAnimation(class USBCharaPartsComponent* TargetMesh);
}; // Size: 0x420

class ASBWorldSettings : public AWorldSettings
{
    FName GameContentId;                                                              // 0x04E0 (size: 0x8)
    FName SublevelId;                                                                 // 0x04E8 (size: 0x8)
    int32 GameTime_Hour;                                                              // 0x04F0 (size: 0x4)
    int32 GameTime_Minute;                                                            // 0x04F4 (size: 0x4)
    char padding_0[0x18];                                                             // 0x04F8 (size: 0x18)
    FSBMapLevelInfo MapLevelInfo;                                                     // 0x0510 (size: 0x80)
    char padding_1[0x1];                                                              // 0x0590 (size: 0x1)
    bool bBlockEdit;                                                                  // 0x0591 (size: 0x1)

    void OverrideSublevelId(FName ID);
    void OnRep_MapLevelInfo();
    void OnMapLevelInfoInitialized__DelegateSignature();
    FSBMapLevelInfo GetMapLevelInfo();
    FName GetCurrentSublevelId();
    FName GetCurrentGameContentId();
}; // Size: 0x5A0

class INpcNavPathInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBAICommanderInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBActorParallelTickInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBActorTransparentInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBActorVisibilityInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBActorVisibilityComponent* GetActorVisibilityComponent();
}; // Size: 0x28

class ISBAnimNotifyInterface_NeedsAdjustRootMotion : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBBDFObjectProjectileInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void Detach();
    void Destroy();
    void Attach(FString SocketName);
}; // Size: 0x28

class ISBBattleAreaResetInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ResetActorForBattleArea();
}; // Size: 0x28

class ISBBattleImagineInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SelfDeath();
}; // Size: 0x28

class ISBBattleParamInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool SetBattleArea(class ASBBattleArea* BattleArea);
    bool IsDeadHitPoint();
    bool IsApplyIdentificationFriendOrFoe();
    bool IsAliveHitPoint();
    FName GetUniqueCharacterID();
    ESBEnemyRaceType GetRaceID();
    float GetMaxHitPoint();
    float GetHitPointRate();
    float GetCurrentHitPoint();
    class ASBBattleArea* GetBattleArea();
}; // Size: 0x28

class ISBBattleStatusInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void OnClientSendImportantBattleEffective(const FSBEffectiveImpotantStatusParam& PrevParam, const FSBEffectiveImpotantStatusParam& NewParam);
    void OnClientSendEffectiveBattleStatusParam(const FSBEffectiveStatusParam& StatusParam, bool bUpdateBaseStatus);
    void NotifyExtendTimeBattleStatus(FDataTableRowHandle Handle, class AActor* Invoker, class AActor* Spawner);
    void NotifyDeactiveBattleStatus(FDataTableRowHandle Handle, class AActor* Invoker, class AActor* Spawner, ESBEffectiveStatusDeactiveReason DeactiveReason);
    void NotifyActivateBattleStatus(FDataTableRowHandle Handle, class AActor* Invoker, class AActor* Spawner);
    class USBBattleStatusComponent* GetBattleStatusComponent();
}; // Size: 0x28

class ISBCameraInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharaCreateInterface : public ISBCharaCreateScaleInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetPartsName(ECharaPartsLocation PartsLocation, FName PartsName);
    void SetCreationGender(ESBCharacterGender InGender);
    void SetCharacterType(ECharaPartsCharacterType NewCharacterType);
    void SetBodyType(ECharaPartsBody BodyType);
    class UCharaPartsData* GetPartsData(ECharaPartsLocation PartsLocation);
    ESBCharacterGender GetCreationGender();
    ECharaPartsCharacterType GetCharacterType();
    class USBCharaCreateComponent* GetCharaCreateComponentForBP();
    ECharaPartsBody GetBodyType();
}; // Size: 0x28

class ISBCharaCreateScaleInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool SetBoneScaleSliderValue(ESBBoneScaleSliderIndex SliderIndex, float Value);
    float GetBoneScaleSliderValue(ESBBoneScaleSliderIndex SliderIndex);
}; // Size: 0x28

class ISBCharaPartsReplaceMaterialInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharacterAdjustRootMotionSetupInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharacterAnimNotifyProjectileCommonInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharacterAnimNotifyProjectileConfigInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharacterCheckSwimmingAreaInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharacterPlayRateModifierInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharacterProjectileRangedInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    float GetRange();
}; // Size: 0x28

class ISBCharacterPushOutInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharacterStatusInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCharacterTimeDilationInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBClassHudInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool UnregistClassHud(FString Name);
    void RegistClassHud(class UUserWidget* Widget, FString Name);
}; // Size: 0x28

class ISBCollisionInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBCommandMenuInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void RequestUpdateLibraryNewIcon();
    void RequestTransitionMenuNew(ESBCommandMenuType MenuType, FString BookmarkType, const FName InParamName);
    void OnIsCmnBackBtnVisible(const bool bInIsVisible);
    void OnCloseOptionMenu();
}; // Size: 0x28

class ISBComponentTickInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void TickComponentByActorEvent(float DeltaTime);
}; // Size: 0x28

class ISBDHCBattleInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    float GetScore(class APlayerState* InPlayerState);
    bool GetIsSoloPlay();
}; // Size: 0x28

class ISBDamageUIInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBDemoActorInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void GetUsedTextures(TArray<class UTexture*>& OutTextures);
}; // Size: 0x28

class ISBDungeonNotifier : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBEffectActorInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsDisableHidden_AttachOwnerTransparent();
}; // Size: 0x28

class ISBEffectControlInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void RouteNotifyUpdateAttackCollisionScale(FVector Scale);
    void RouteNotifyPrepareDestroy(bool bForce);
    void ReceiveNotifyUpdateAttackCollisionScale(FVector Scale);
    void ReceiveNotifyPrepareDestroy(bool bForce);
    class USBEffectValueComponent* GetEffectValueComponent();
}; // Size: 0x28

class ISBElementDamageInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBElementTypeInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetElementType(ESBAttribute ElementType);
    ESBAttribute GetElementType();
}; // Size: 0x28

class ISBEnemyChantEffectInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UpdateChantRate(float ChantRate);
    void OnEndChant();
    void OnAbortChant();
}; // Size: 0x28

class ISBFieldActorBase : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ReceiveMapAction(class AActor* ActionActor);
    void MapAction(class AActor* ActionActor);
}; // Size: 0x28

class ISBFootprintInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBFootprintComponent* GetFootprintComponent();
}; // Size: 0x28

class ISBGameModeCustomBattleInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBGameModeCustomBattleComponent* ReceiveGetBattleCustomComponent();
}; // Size: 0x28

class ISBHoldHandInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBHoldHandComponent* GetHoldHandComponent();
}; // Size: 0x28

class ISBInstanceBattleProviderAgent : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void OnEnableProvider(class ASBInstanceBattleProvider* InOwner);
    void OnDisableProvider(class ASBInstanceBattleProvider* InOwner);
}; // Size: 0x28

class ISBInteractionTargetInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void OnInteraction(class AActor* InOtherActor, FRotator ViewRotation);
    bool IsInteractionDisable(const class AActor* InOtherActor);
}; // Size: 0x28

class ISBLevelNavModifyInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ShowActorThisLevel();
    void HideActorThisLevel();
}; // Size: 0x28

class ISBLevelupBaseInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void AddLevelUpSkill(FString SkillType);
    void AddLevelUpClass(int32 Level);
}; // Size: 0x28

class ISBLibraryMenuDataInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void GetIdListCallback(bool WasSuccessful, int32 RetCode, const ESBLibraryPictureBookType Type);
}; // Size: 0x28

class ISBLineSoundInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBLoadAssetsInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBLockOnTargetInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FName GetLockOnRangeInfoID();
    FName GetLockOnCameraID();
}; // Size: 0x28

class ISBNetworkSmoothMoveInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool BP_UseSBSmoothClientPosition();
    float BP_GetSmoothMoveWalkSpeed();
    class USBPlayerMovementComponentBase* BP_GetMovementComponentForSmoothMove();
}; // Size: 0x28

class ISBNotifyMessageInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void AddTutorialHelpMessage(const FName InTutorialHelpId);
    void AddRecipeMessage(const ESBRecipeType RecipeType, const int32 RecepiId);
    void AddRankingRewardNotifyMessage();
    void AddNetworkCafeLoginTimeNotificationMessage(const int32 NetworkCafeTotalTimePlayedToday, const bool bIsLoginTimeOnly);
    void AddMailAcceptLimitNotifyMessage();
    void AddLoginBonusNotifyMessage(const FText& InMessage);
    void AddLine2NotifyMessage(const FText& InMainMessage, const FText& InSubMessage);
    void AddLine1NotifyMessage(const FText& InMessage);
    void AddLine1LNotifyMessage(const FText& InMessage);
    void AddItemExpiryNotifyMessage(int32 InItemID);
    void AddAwakeInterruptQuestMessage(const FName& InQuestId);
    void AddAutoDeliveryQuestCompleteMessage(const ESBSeasonPassQuestCycleType InCycle, FString QuestName);
    void AddAdventurerRankUpdateCompleteMessage(const ESBPlayerPassiveImagineSlotType Slot);
    void AddAdventurerRankupCompleteMessage();
    void AddAchievementGainedMessage(const int32 InAchievementId);
}; // Size: 0x28

class ISBNpcBase : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ReceiveMapAction(class AActor* ActionActor);
    void MapAction(class AActor* ActionActor);
}; // Size: 0x28

class ISBNpcSpawnSourceInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBOnlinePlayerState : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FString GetSessionId();
    FString GetPlayerIdString();
    int32 GetOnlineStatus();
    FString GetGameContentID();
    FString GetCharacterName();
    FString GetCharacterId();
    int32 GetAchievementSelected();
}; // Size: 0x28

class ISBOptionHUDInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class UUserWidget* GetOptionLayoutableHUD();
}; // Size: 0x28

class ISBPlayerAttackCollisionPassiveSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerCameraInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBPlayerCameraComponent* GetPlayerCameraComponent();
}; // Size: 0x28

class ISBPlayerChargeSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerCurveMoveSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerDodgeSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerForecastSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerGuardSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerMagicPointSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerMarkerSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerModifyAutoTargetSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerRecastTimePassiveSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerStaminaSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerStatusAilmentPassiveSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPlayerSuperArmorPassiveSkillInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBPoolableActorInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void NotifyDeactivated();
    void NotifyActivated();
}; // Size: 0x28

class ISBProjectileAttachInfoInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBProjectileAttackCollisionInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBProjectileDestoryCondCompInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBProjectileExtendCompInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBProjectileGroundCollisionCommonInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBProjectileImagineProcInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBProjectileInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBProjectileOnConstructionCompInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBProjectileSpawnInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBProjectileSpawnComponent* GetProjectileSpawnComponent();
    class USBProjectileShareHitComponent* GetProjectileShareHitComponent();
    class USBProjectileSendNetDataComponent* GetProjectileSendNetDataComponent();
}; // Size: 0x28

class ISBProjectileTickControlCompInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBServerDamageEventInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBShieldGuardInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void NotifyGuardSucceeded(const FSBDamageEvent& DamageEvent, class AActor* DamageCauser);
    void NotifyGuardFail(const FSBDamageEvent& DamageEvent, class AActor* DamageCauser);
    bool IsGuardBreak();
    bool IsGuard();
    class UPrimitiveComponent* GetHitCollision(class AActor* HitActor, class UPrimitiveComponent* HitComp);
    FVector GetGuardDirection();
    FSBDefenceGuardConfig GetDefenceGuardConfig(class UPrimitiveComponent* DamagedComp);
    bool CanUseShield();
}; // Size: 0x28

class ISBSitTargetSoundInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    ESBSitTargetSoundType GetSitTargetSoundType();
}; // Size: 0x28

class ISBSoundInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBSubMenuInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    ESubMenuTermRequestReply TermRequest(const ESubMenuTermReason InReason);
    void ResetMouseCursorTypeToDefaultRequest();
    void OnSubMenuUpdate(int32 MainPage, int32 SubPage);
    void OnSameMenuBookmarkAccessNew(FString InBookMarkType);
    void OnRMShopClosed();
    void OnParentTerm();
}; // Size: 0x28

class ISBSubMenuSubButtonInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void BookmarkUpdateRequest();
}; // Size: 0x28

class ISBTargetableInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBTickFromParentInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ParentsCallTick(float InDeltaTime);
}; // Size: 0x28

class ISBUIFocusableInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void OnPressOk();
    void OnLostFocus();
    void OnGetFocus();
}; // Size: 0x28

class ISBUIInputHandleInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool OnRepeat_Up();
    bool OnRepeat_Right();
    bool OnRepeat_Ok();
    bool OnRepeat_Left();
    bool OnRepeat_Down();
    bool OnRepeat_Cancel();
}; // Size: 0x28

class ISBWaterFlowInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    float GetWaterFlowPriority();
    bool GetWaterFlowParams(const FVector& Location, FVector& Direction, float& power);
}; // Size: 0x28

class ISBWeaponBowCommonInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class ISBWidgetChildrenInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void RequestShow();
    void RequestSetOwnerCharacter(class ASBCharacter* OwnerCharacter);
    void RequestSetIconColorName(FString ColorName);
    void RequestSetAnimationSpeed(float AnimationSpeed);
    void RequestHide();
}; // Size: 0x28

class ISBWidgetComponent2DContentsInterface : public IInterface
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetScreenPositionOffset(const FLinearColor InScreenPositionOffset);
    void SetDepth(const float InDepth);
}; // Size: 0x28

class UASAnimNotifyState_MountStartJumpValueSwitch : public UAnimNotifyState
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class UAssetReferenceExportFL : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ReadAssetName(FString Filename, TArray<FString>& FileData);
    void ExportReference(FString Filename, TArray<FName> AssetName, bool IsHard);
    void CreateExportFile(FString Filename);
    void AddReference(FString Filename, FString AssetName, TArray<FName> Reference, TArray<FName> Dependency);
}; // Size: 0x28

class UBlurBoxSlot : public UPanelSlot
{
    FMargin Padding;                                                                  // 0x0038 (size: 0x10)
    TEnumAsByte<EHorizontalAlignment> HorizontalAlignment;                            // 0x0048 (size: 0x1)
    TEnumAsByte<EVerticalAlignment> VerticalAlignment;                                // 0x0049 (size: 0x1)

    void SetVerticalAlignment(TEnumAsByte<EVerticalAlignment> InVerticalAlignment);
    void SetPadding(FMargin InPadding);
    void SetHorizontalAlignment(TEnumAsByte<EHorizontalAlignment> InHorizontalAlignment);
}; // Size: 0x60

class UChatSystem : public UObject
{
    char padding_0[0x260];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x260

class UJingleManager : public UObject
{
    float InterruptJingleLifeTime;                                                    // 0x0074 (size: 0x4)
    FJingleManagerOnJingleDelegate OnJingleDelegate;                                  // 0x0078 (size: 0x10)
    void OnPlayJingleDelegate(TEnumAsByte<EJingleType::Type> JingleType);
    FJingleManagerOnJingleSubDelegate OnJingleSubDelegate;                            // 0x0088 (size: 0x10)
    void OnPlayJingleDelegate(TEnumAsByte<EJingleType::Type> JingleType);
    FJingleManagerOnCancelJingleDelegate OnCancelJingleDelegate;                      // 0x0098 (size: 0x10)
    void OnPlayJingleDelegate(TEnumAsByte<EJingleType::Type> JingleType);
    FJingleManagerOnTutorialHelpJingleDelegate OnTutorialHelpJingleDelegate;          // 0x00A8 (size: 0x10)
    void OnPlayTutorialHelpJingleDelegate(FName TutorialHelpId);

    void Request_TutorialHelp(const FName TutorialId);
    void Request_Jingle(const TEnumAsByte<EJingleType::Type> Jingle, int32 QuestIndex);
    void Request_CancelJingle(const TEnumAsByte<EJingleType::Type> Jingle, int32 QuestIndex);
    void OnPlayTutorialHelpJingleDelegate__DelegateSignature(FName TutorialHelpId);
    void OnPlayJingleDelegate__DelegateSignature(TEnumAsByte<EJingleType::Type> JingleType);
    bool IsJinglePlaying();
    bool HasStack();
    TEnumAsByte<EJingleType::Type> GetCurrentJingleType();
    void FinishJingle(const TEnumAsByte<EJingleType::Type> Jingle);
}; // Size: 0xB8

class UKeyConfigFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FKey ToStanderdKey(const FKey& InKey);
    FKey ToPadFunctionKey(const FKey& InKey);
    FKey ToPadFunction2Key(const FKey& InKey);
    FKey ToFunction3Key(const FKey& InKey);
    void SyncBookMark(class UObject* WorldContextObject, const FSBPlayerClassKeyConfigData& Data);
    void RemoveBookmarks(FSBPlayerClassKeyConfigData& Data);
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> PadToKeyConfigKey(const FKey& InputKey);
    FSBPlayerClassKeyConfigData OverWriteKeyData(FSBPlayerClassKeyConfigData& KeyConfigData, TEnumAsByte<ESBKeyConfigAction::Type> Action, TEnumAsByte<ESBKeyConfigKeyboardKey::Type> KB_Key, TEnumAsByte<ESBKeyConfigMouseKey::Type> MS_Key, TEnumAsByte<ESBKeyConfigGamepadKey::Type> Pad_Key);
    TEnumAsByte<ESBKeyConfigMouseKey::Type> MouseToKeyConfigKey(const FKey& InputKey);
    FKey MouseKeyToKey(const TEnumAsByte<ESBKeyConfigMouseKey::Type> MouseKey);
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> KeyToKeyConfigKey(const FKey& InputKey);
    bool KeyIsActionKey(const FSBPlayerClassKeyConfigData& KeyConfigData, const FKey& InputKey, TEnumAsByte<ESBKeyConfigAction::Type> KeyConfigAction);
    FKey KeyboardKeyToKey(const TEnumAsByte<ESBKeyConfigKeyboardKey::Type> KeyboardKey);
    bool IsPadAction(TEnumAsByte<ESBKeyConfigAction::Type> Type);
    bool IsKeyRegisted(class UObject* WorldContextObject, const FKey& InKey);
    bool IsKeyboardAction(TEnumAsByte<ESBKeyConfigAction::Type> Type);
    bool IsFunctionPadKey(const FSBPlayerClassKeyConfigData& Data, const FKey& InKey);
    bool IsFunctionKey(const FKey& InKey);
    bool IsFunctionConfigKey(const TEnumAsByte<ESBKeyConfigGamepadKey::Type> InKey);
    bool IsFunction3Key(const FKey& InKey);
    bool IsFunction2PadKey(const FSBPlayerClassKeyConfigData& Data, const FKey& InKey);
    bool IsFunction2Key(const FKey& InKey);
    bool IsFunction2ConfigKey(const TEnumAsByte<ESBKeyConfigGamepadKey::Type> InKey);
    bool IsBookMarks(TEnumAsByte<ESBKeyConfigAction::Type> Type);
    void GetKeyConfigSliderMinMax(float& Min, float& Max);
    float GetKeyConfigPersentageBias();
    float GetKeyConfigMouseFixedValue();
    float GetKeyConfigMouseBias();
    TArray<FKey> GetKeyByActionFunctionPlus(const ESBUIKeyConfigAction KeyConfigAction, ESBOperateMode InMode);
    FKey GetKeyByAction(const ESBUIKeyConfigAction KeyConfigAction);
    TArray<TEnumAsByte<ESBKeyConfigGamepadKey::Type>> GetGamepadShortcutKeys(const FSBPlayerClassKeyConfigData& KeyConfigData);
    FString GetDisplayTextByAction(const ESBUIKeyConfigAction KeyConfigAction);
    FString GetDisplayShortTextByAction(const ESBUIKeyConfigAction KeyConfigAction);
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> GetActionPad(const FSBGamePadSettings& PadSetting, TEnumAsByte<ESBKeyConfigAction::Type> Action);
    TEnumAsByte<ESBKeyConfigMouseKey::Type> GetActionMouse(const FSBMouseSettings& MouseSetting, TEnumAsByte<ESBKeyConfigAction::Type> Action);
    TEnumAsByte<ESBKeyConfigGamepadKey::Type> GetActionKeyPad(const FSBPlayerClassKeyConfigData& KeyConfigData, TEnumAsByte<ESBKeyConfigAction::Type> KeyConfigAction);
    void GetActionKeyMouse(const FSBPlayerClassKeyConfigData& KeyConfigData, TEnumAsByte<ESBKeyConfigAction::Type> KeyConfigAction, TEnumAsByte<ESBKeyConfigMouseKey::Type>& MouseKey, TEnumAsByte<ESBKeyConfigKeyboardKey::Type>& KeyboardKey);
    TEnumAsByte<ESBKeyConfigKeyboardKey::Type> GetActionKB(const FSBKeyboardSettings& KeyboardSetting, TEnumAsByte<ESBKeyConfigAction::Type> Action);
    void GetActionBindNameByAction(TArray<FName>& OutActionBindNameList, const class UObject* WorldContextObject, const ESBUIKeyConfigAction KeyConfigAction);
    FKey GamepadKeyToKey(const TEnumAsByte<ESBKeyConfigGamepadKey::Type> GamepadKey);
    void ClearBookMarks(class UObject* WorldContextObject, const FSBPlayerClassKeyConfigData& Data);
}; // Size: 0x28

class UListUpDeleteEnemyAssetsCmdFunctionCommandlet : public UCommandlet
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class UMatchingSystem : public UObject
{
    char padding_0[0x178];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x178

class UNpcNavPathDef : public UObject
{
    TArray<FNpcNavPathData> PointList;                                                // 0x0028 (size: 0x10)

}; // Size: 0x38

class UPartySystem : public UObject
{
    FString PartyServerSocketScheme;                                                  // 0x0038 (size: 0x10)
    FString PartyServerScheme;                                                        // 0x0048 (size: 0x10)
    FString PartyServerHost;                                                          // 0x0058 (size: 0x10)
    int32 PartyServerPort;                                                            // 0x0068 (size: 0x4)
    char padding_0[0x4];                                                              // 0x006C (size: 0x4)
    FString PartyServerVersion;                                                       // 0x0070 (size: 0x10)

}; // Size: 0x3E8

class USBAIAttackHitComponent : public UActorComponent
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAIComboComponent : public UActorComponent
{
    class USCTGraph* SkillTreeGraph;                                                  // 0x00B8 (size: 0x8)
    class USBAIComboTree* ComboTree;                                                  // 0x00C0 (size: 0x8)

    void Initialize(class APawn* Pawn);
}; // Size: 0xE0

class USBAIComboTree : public UObject
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBAICommand : public UDataAsset
{
    FString Command;                                                                  // 0x0030 (size: 0x10)
    TArray<class TSubclassOf<USBAITacticalSkill>> TacticalSkills;                     // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBAICommanderComponent : public UActorComponent
{
    char padding_0[0x108];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x108

class USBAICustomComponent : public UActorComponent
{
    TArray<class TSubclassOf<USBAICustom_Base>> DefaultCustomClasses;                 // 0x0110 (size: 0x10)
    TArray<class TSubclassOf<USBAICustom_Base>> IgnoreResetCustomClasses;             // 0x0120 (size: 0x10)
    TArray<class USBAICustom_Base*> CustomArray;                                      // 0x0130 (size: 0x10)

    void RemoveCustomization(TSubclassOf<class USBAICustom_Base> CustomClass);
    void AddCustomization(TSubclassOf<class USBAICustom_Base> CustomClass);
}; // Size: 0x148

class USBAICustom_Base : public UObject
{
    ESBAICustomPriority Priority;                                                     // 0x0028 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0029 (size: 0x7)
    TArray<class TSubclassOf<USBAITacticalSkill>> EnableSkills;                       // 0x0030 (size: 0x10)
    TArray<class TSubclassOf<USBAITacticalSkill>> DisableSkills;                      // 0x0040 (size: 0x10)
    TArray<FName> ActivateTags;                                                       // 0x0050 (size: 0x10)
    TArray<FName> DeactivateTags;                                                     // 0x0060 (size: 0x10)
    TSubclassOf<class USBAIRoleBase> NewRoleClass;                                    // 0x0070 (size: 0x8)

}; // Size: 0x78

class USBAICustom_BlueprintBase : public USBAICustom_Base
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)

    void ReceiveTick(float DeltaTime, class USBAICustomComponent* OwnerComp, class ASBAIController_Enemy* Controller);
    void ReceiveDeactivate(class USBAICustomComponent* OwnerComp, class ASBAIController_Enemy* Controller);
    void ReceiveActivate(class USBAICustomComponent* OwnerComp, class ASBAIController_Enemy* Controller);
}; // Size: 0x78

class USBAIEmotionComponent : public UActorComponent
{
    class AAIController* AIOwner;                                                     // 0x00B8 (size: 0x8)

}; // Size: 0x130

class USBAIEnemyActionLotteryRule : public UDataAsset
{
    bool bInvertResult;                                                               // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBAIEnemyActionLotteryRule_OnAnchor : public USBAIEnemyActionLotteryRule
{
    int32 LocationAnchorID;                                                           // 0x0038 (size: 0x4)
    float Radius;                                                                     // 0x003C (size: 0x4)

}; // Size: 0x40

class USBAIEnemyActionLotteryRule_TurnTowardsAnchor : public USBAIEnemyActionLotteryRule
{
    int32 LocationAnchorID;                                                           // 0x0038 (size: 0x4)

}; // Size: 0x40

class USBAIEnemyActionOrderList : public UObject
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAIHierarchyComponent : public UAIFwHierarchyComponent
{
    char padding_0[0xF8];                                                             // 0x0000 (size: 0x0)

    void CancelOrder(bool bForce);
}; // Size: 0xF8

class USBAILookAtControlComponent : public UActorComponent
{
    class AAIController* AIOwner;                                                     // 0x00B8 (size: 0x8)
    class USBAnimationControlComponent* AnimControlComp;                              // 0x00C0 (size: 0x8)
    char padding_0[0x8];                                                              // 0x00C8 (size: 0x8)
    class AActor* LookAtActor;                                                        // 0x00D0 (size: 0x8)

}; // Size: 0xE8

class USBAIMessageDispatchingComponent : public UActorComponent
{
    char padding_0[0x108];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x108

class USBAIPerceptionComponent : public UAIFwPerceptionComponent
{
    class USBEnemySenserSetting* SenserSetting;                                       // 0x00E0 (size: 0x8)
    TArray<FAIFwParameterizedBTRequest> NonActiveSensers;                             // 0x00E8 (size: 0x10)

    void SetSensorSetting(class USBEnemySenserSetting* Setting);
    void RemoveEnabledSenseTag(FString Tag);
    void RemoveDisabledSenseTag(FString Tag);
    void AddEnabledSenseTag(FString Tag);
    void AddDisabledSenseTag(FString Tag);
}; // Size: 0x130

class USBAIQueryManager : public UWorldSubsystem
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBAIReactiveSkill_Counter : public USBAIReactiveSkill_TakeDamage
{
    FName Command;                                                                    // 0x0098 (size: 0x8)
    uint8 bUseManualAreaSettings;                                                     // 0x00A0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00A1 (size: 0x3)
    FSBAIAttackableArea AttackableArea;                                               // 0x00A4 (size: 0x24)
    uint8 Priority;                                                                   // 0x00C8 (size: 0x1)
    uint8 bIncludeZeroDamage;                                                         // 0x00C9 (size: 0x1)
    char padding_1[0x2];                                                              // 0x00CA (size: 0x2)
    ESBAIReactiveSkill_GuardState GuardStateBeforeAttack;                             // 0x00CC (size: 0x4)
    class APawn* OwnerPawn;                                                           // 0x00D0 (size: 0x8)

}; // Size: 0xD8

class USBAIReactiveSkill_GuardCounter : public USBAIReactiveSkill_Counter
{
    class USBAITacticalSkill_GuardCounter* OwnerTacticalSkill;                        // 0x00D8 (size: 0x8)

}; // Size: 0xE0

class USBAIReactiveSkill_PerceiveAttack : public UAIFwReactiveSkill
{
    FSBPerceiveAttackSettings PerceiveAttackSettings;                                 // 0x007C (size: 0x8)

}; // Size: 0x88

class USBAIReactiveSkill_TakeDamage : public UAIFwReactiveSkill_TakeDamage
{
    char padding_0[0x98];                                                             // 0x0000 (size: 0x0)

    void TakeAnyDamageWithDamageEventImpl(class ASBEnemyCharacter* DamagedActor, float Damage, const FSBDamageEvent& DamageEvent, class AController* InstigatedBy, class AActor* DamageCauser);
    void ReceiveCharacterTakeDamage(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser);
    void ReceiveAnyDamageWithDamageEvent(float Damage, const FSBEnemyDamageEventInfo DamageEventInfo, class AController* InstigatedBy, class AActor* DamageCauser);
    void CharacterTakeDamageImpl(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
}; // Size: 0x98

class USBAIResource_StateMachine : public UGameplayTaskResource
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAIRoleAttackerBase : public USBAIRoleBase
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBAIRoleBase : public UObject
{
    TArray<class TSubclassOf<USBAITacticalSkill>> TacticalSkills;                     // 0x0028 (size: 0x10)
    float BattleRange;                                                                // 0x0038 (size: 0x4)
    float DefensePriority;                                                            // 0x003C (size: 0x4)
    float LineAreaRestriction;                                                        // 0x0040 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0044 (size: 0x4)
    class AActor* Owner;                                                              // 0x0048 (size: 0x8)
    class AAIController* OwnerAI;                                                     // 0x0050 (size: 0x8)

    void ReceivePrepareForPlanning();
    void ReceiveDeactivate();
    float ReceiveCalcAttackUtility();
    void ReceiveActivate();
}; // Size: 0x60

class USBAIRoleComponent : public UActorComponent
{
    TSubclassOf<class USBAIRoleBase> DefaultRoleClass;                                // 0x00B8 (size: 0x8)
    TSubclassOf<class USBAIRoleAttackerBase> AttackerRoleClass;                       // 0x00C0 (size: 0x8)
    float DefaultRolePriority;                                                        // 0x00C8 (size: 0x4)
    float Aggression;                                                                 // 0x00CC (size: 0x4)
    ESBAIPositioningType DesiredPositioningType;                                      // 0x00D0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00D1 (size: 0x3)
    float DesiredPositioningIntensity;                                                // 0x00D4 (size: 0x4)
    float VanguardRange;                                                              // 0x00D8 (size: 0x4)
    float RearguardRange;                                                             // 0x00DC (size: 0x4)
    float SupporterBattleRange;                                                       // 0x00E0 (size: 0x4)
    float SupporterDefensePriority;                                                   // 0x00E4 (size: 0x4)
    class USBAIRoleBase* DefaultRole;                                                 // 0x00E8 (size: 0x8)
    class USBAIRoleAttackerBase* AttackerRole;                                        // 0x00F0 (size: 0x8)
    class USBAIRoleBase* CurrentRole;                                                 // 0x00F8 (size: 0x8)
    ESBAIPositioningType PositioningType;                                             // 0x0100 (size: 0x1)

    void ResetDefaultRole();
    void ReleaseCurrentRole();
    void OverrideDefaultRole(TSubclassOf<class USBAIRoleBase> NewRoleClass);
}; // Size: 0x108

class USBAIRoleDistributionComponent : public UActorComponent
{
    float MinAttackerRatio;                                                           // 0x00B8 (size: 0x4)
    float AttackRequestRatioToPlayerNum;                                              // 0x00BC (size: 0x4)
    float AttackRequestRatioToEnemyNum;                                               // 0x00C0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00C4 (size: 0x4)
    class USBAIWorldProfilerComponent* WorldProfilerComponent;                        // 0x00C8 (size: 0x8)
    class ASBSquadAI* SquadAI;                                                        // 0x00D0 (size: 0x8)
    TArray<class USBAIRoleComponent*> Members;                                        // 0x00D8 (size: 0x10)
    class USBAIRoleComponent* Leader;                                                 // 0x00E8 (size: 0x8)

}; // Size: 0x100

class USBAIRoleLeaderBase : public USBAIRoleAttackerBase
{
    class USBUtilityOption* Strategy;                                                 // 0x0068 (size: 0x8)

}; // Size: 0x70

class USBAIRoleSupporterBase : public USBAIRoleBase
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBAISharedInfoComponent : public UActorComponent
{
    TArray<class AAIController*> TargetedList;                                        // 0x00B8 (size: 0x10)

}; // Size: 0xC8

class USBAISkillAssets_ReactiveSkill : public UDataAsset
{
    TMap<class FName, class TSubclassOf<UAIFwReactiveSkill>> ReactiveSkills;          // 0x0030 (size: 0x50)

}; // Size: 0x80

class USBAISkillAssets_TacticalSkill : public UDataAsset
{
    TMap<class FName, class TSubclassOf<USBAITacticalSkill>> TacticalSkills;          // 0x0030 (size: 0x50)

}; // Size: 0x80

class USBAITacticalComponent : public UActorComponent
{
    TArray<class TSubclassOf<USBAITacticalSkill>> SkillClasses;                       // 0x00B8 (size: 0x10)
    TArray<class USBAITacticalSkill*> Skills;                                         // 0x00C8 (size: 0x10)

    TArray<class USBAITacticalSkill*> GetSkills();
    class USBAITacticalSkill* FindSkill(FString SkillName);
    void EnableSkill(TSubclassOf<class USBAITacticalSkill> SkillClass, bool bAllowAdd);
    void DisableSkill(TSubclassOf<class USBAITacticalSkill> SkillClass);
    void AddSkill(TSubclassOf<class USBAITacticalSkill> SkillClass);
}; // Size: 0xD8

class USBAITacticalSkill : public UObject
{
    class USBAITacticalComponent* OwnerComp;                                          // 0x0028 (size: 0x8)
    class AActor* OwnerActor;                                                         // 0x0030 (size: 0x8)
    class AAIController* OwnerAI;                                                     // 0x0038 (size: 0x8)
    TArray<class TSubclassOf<USBAITacticalSkill>> DependentSkills;                    // 0x0040 (size: 0x10)
    TArray<class TSubclassOf<USBAITacticalSkill>> CoordinatorSkills;                  // 0x0050 (size: 0x10)
    TArray<class USBSquadMessageListener*> MessageListeners;                          // 0x0060 (size: 0x10)
    class USBSquadMemberComponent* SquadMemberComp;                                   // 0x0070 (size: 0x8)
    TArray<int32> UseLocationAnchorIDs;                                               // 0x0078 (size: 0x10)
    TSubclassOf<class USBAITacticalSkill> NoAnchorSkill;                              // 0x0088 (size: 0x8)

    void ReceiveInitializeForPawn(class APawn* Pawn);
    void ReceiveInitialize();
    void ReceiveDeactivate();
    void ReceiveActivate();
    void Deactivate();
    void AddMessageListener(class USBSquadMessageListener* MessageListener);
    void Activate();
}; // Size: 0x98

class USBAITacticalSkill_AttackBase : public USBAITacticalSkill_CommandAction
{
    ESBAITacticalSkill_GuardState GuardStateBeforeAttack;                             // 0x0258 (size: 0x4)
    ESBAITacticalSkill_GuardState GuardStateAfterAttack;                              // 0x025C (size: 0x4)
    bool bInstantly;                                                                  // 0x0260 (size: 0x1)
    bool bNeedOnNavMesh;                                                              // 0x0261 (size: 0x1)
    bool bUseTargetLocationPrediction;                                                // 0x0262 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0263 (size: 0x1)
    float UsabilityForOutOfAreaTarget;                                                // 0x0264 (size: 0x4)
    char padding_1[0x28];                                                             // 0x0268 (size: 0x28)
    class USBHTNOperator_PartyStrategy* PartyStrategy;                                // 0x0290 (size: 0x8)
    class USBHTNOperator_Constant* Noise;                                             // 0x0298 (size: 0x8)
    class USBHTNOperator_ActionLottery* ActionLottery;                                // 0x02A0 (size: 0x8)

    void SetAttackRange(float MinRange, float MaxRange, float LeftAngle, float RightAngle, float UpperAngle, float LowerAngle);
    void ReceiveGetSummonEnemyIds(TArray<FString>& InEnemyIds);
    void ReceiveAddDefaultPreference();
}; // Size: 0x2B8

class USBAITacticalSkill_CommandAction : public USBAITacticalSkill_TemplateBase
{
    bool bEnableServerRefreshBones;                                                   // 0x01B8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x01B9 (size: 0x7)
    FString Command;                                                                  // 0x01C0 (size: 0x10)
    FString SubCommand;                                                               // 0x01D0 (size: 0x10)
    FString Category;                                                                 // 0x01E0 (size: 0x10)
    TArray<FSBAITacticalSkill_AdditionalPrecondition> AdditionalPreconditions;        // 0x01F0 (size: 0x10)
    TArray<FSBAITacticalSkill_AdditionalEffect> AdditionalEffects;                    // 0x0200 (size: 0x10)
    FString ActionName;                                                               // 0x0210 (size: 0x10)

}; // Size: 0x258

class USBAITacticalSkill_CoopAction : public USBAITacticalSkill_CommandAction
{
    char padding_0[0x258];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x258

class USBAITacticalSkill_GuardCounter : public USBAITacticalSkill_CommandAction
{
    FName CounterCommand;                                                             // 0x0258 (size: 0x8)
    class USBAIReactiveSkill_GuardCounter* ReactiveSkill;                             // 0x0260 (size: 0x8)

    bool IsGuardSucceeded(const FSBDamageEvent& DamageEvent);
}; // Size: 0x290

class USBAITacticalSkill_HTNBase : public USBAITacticalSkill
{
    FAIFwParameterizedHTNDomain ParameterizedDomain;                                  // 0x0098 (size: 0x18)
    TArray<FSBAITacticalSkillRootTask> RootTasks;                                     // 0x00B0 (size: 0x10)
    class UAIFwHTNPlanningComponent* HTNComp;                                         // 0x00C0 (size: 0x8)
    TMap<class FString, class FAIFwParameterizedBTRequest> PerceptionTreeMap;         // 0x00C8 (size: 0x50)

    void SetContextValueAsVector(FString Key, FVector Value);
    void SetContextValueAsString(FString Key, FString Value);
    void SetContextValueAsObject(FString Key, class UObject* Value);
    void SetContextValueAsInt(FString Key, int32 Value);
    void SetContextValueAsFloat(FString Key, float Value);
    void SetContextValueAsBool(FString Key, bool bValue);
    void ReceivePrepareForPlanning();
    void AddTrajectoryPreference(FString Name, class UAIFwHTNTemporalModalOperator* TemporalOperator, bool bHardConstraint);
    void AddPreconditionPreference(FString Name, FString TaskName, FString MethodName, class UAIFwHTNOperator* Operator, bool bHardConstraint);
    void AddMetricWeight(FString Name, float Weight);
    void AddGoalPreference(FString Name, class UAIFwHTNOperator* Operator, bool bHardConstraint);
}; // Size: 0x180

class USBAITacticalSkill_TemplateBase : public USBAITacticalSkill_HTNBase
{
    FAIFwParameterizedHTNDomain Template;                                             // 0x0180 (size: 0x18)
    TArray<FString> SharedTasks;                                                      // 0x0198 (size: 0x10)
    TArray<FSBAITacticalSkill_DomainOverride> Overrides;                              // 0x01A8 (size: 0x10)

}; // Size: 0x1B8

class USBAITask : public UAITask
{
    TArray<class TSubclassOf<UGameplayTaskResource>> AdditionalRequiredResources;     // 0x0070 (size: 0x10)
    TArray<class TSubclassOf<UGameplayTaskResource>> AdditionalClaimedResources;      // 0x0080 (size: 0x10)

}; // Size: 0x90

class USBAITask_BlueprintBase : public UAITask
{
    TArray<class TSubclassOf<UGameplayTaskResource>> AdditionalRequiredResources;     // 0x0070 (size: 0x10)
    TArray<class TSubclassOf<UGameplayTaskResource>> AdditionalClaimedResources;      // 0x0080 (size: 0x10)
    uint8 bIsAbortable;                                                               // 0x0090 (size: 0x1)

    void TaskTick(class AAIController* Controller, class APawn* ControlledPawn, float DeltaSeconds);
    void TaskStart(class AAIController* Controller, class APawn* ControlledPawn);
    void TaskResume(class AAIController* Controller, class APawn* ControlledPawn);
    void TaskPause(class AAIController* Controller, class APawn* ControlledPawn);
    void TaskFinish(class AAIController* Controller, class APawn* ControlledPawn, bool bInOwnerFinished);
    void SetFinishOnMessage(FName MessageName);
}; // Size: 0xA8

class USBAITask_ChangeBattleMode : public UAITask
{
    class USBEnemyBattleConditionComponent* BattleConditionComp;                      // 0x0070 (size: 0x8)

}; // Size: 0x80

class USBAITask_Dodge : public USBAITask_SendAnimCommandWithAbility
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAITask_FleeFrom : public UAITask_MoveTo
{
    char padding_0[0x1A8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x1A8

class USBAITask_FollowingWarp : public UAITask
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBAITask_Jump : public USBAITask_SendAnimCommandWithAbility
{
    char padding_0[0xE8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xE8

class USBAITask_PerceiveAttackGuard : public USBAITask_SendAnimCommandWithAbility
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAITask_PlayerDodge : public UAITask
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x78

class USBAITask_PlayerSkill : public UAITask
{
    ESkillActionPosition SkillAction;                                                 // 0x0070 (size: 0x1)

}; // Size: 0x78

class USBAITask_PrevJump : public USBAITask
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBAITask_Runaway : public UAITask
{
    class USBEnemyCharacterMovementComponent* MovementComp;                           // 0x0080 (size: 0x8)

}; // Size: 0x88

class USBAITask_SendAnimCommandWithAbility : public USBAITask
{
    uint8 bEnableAnimationWaitEnd;                                                    // 0x00A8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00A9 (size: 0x3)
    FName Command;                                                                    // 0x00AC (size: 0x8)
    FName SubCommand;                                                                 // 0x00B4 (size: 0x8)

}; // Size: 0xC0

class USBAITask_SuperFastMoveTo : public UAITask
{
    char padding_0[0xD0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xD0

class USBAITask_Turn : public UAITask
{
    FBlackboardKeySelector BlackboardKey;                                             // 0x0070 (size: 0x28)
    class AActor* TargetActor;                                                        // 0x0098 (size: 0x8)

}; // Size: 0xB0

class USBAITask_UnableAction : public UAITask
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAITask_WaitForAnimation : public UAITask
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAITask_WarpMoveTo : public UAITask
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBAIWorldProfilerComponent : public UActorComponent
{
    float ClusteringDistance;                                                         // 0x00B8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00BC (size: 0x4)
    TArray<class AActor*> UninitializedActors;                                        // 0x00C0 (size: 0x10)

    void OnActorDestroyed(class AActor* DestroyedActor);
}; // Size: 0x138

class USBAbility : public UObject
{
    class AActor* Owner;                                                              // 0x0040 (size: 0x8)
    class AActor* Causer;                                                             // 0x0048 (size: 0x8)
    char padding_0[0x20];                                                             // 0x0050 (size: 0x20)
    class USBAbilityExpiration* Expiration;                                           // 0x0070 (size: 0x8)

}; // Size: 0x80

class USBAbilityAllyAttackAttackScale : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityAllyAttackElement : public USBAbility
{
    ESBAttribute AttributeType;                                                       // 0x0080 (size: 0x1)

}; // Size: 0x88

class USBAbilityBaseStatusBoost : public USBAbilityStatusBase
{
    ESBBaseStatusBoostType BaseStatusType;                                            // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityBaseStatusRateBoost : public USBAbilityBaseStatusBoost
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBAbilityCharacterStatus : public USBAbilityStatusBase
{
    ESBAbilityCharacterStatusType StatusType;                                         // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityCondition : public UObject
{
    class AActor* Owner;                                                              // 0x0028 (size: 0x8)
    uint8 bNotEqual;                                                                  // 0x0030 (size: 0x1)

}; // Size: 0x40

class USBAbilityConditionActiveAbilityID : public USBAbilityCondition
{
    FSBAbilityID AbilityID;                                                           // 0x0040 (size: 0x8)

}; // Size: 0x48

class USBAbilityConditionActiveBattleMode : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionAnyTime : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionBattleRange : public USBAbilityCondition
{
    ESBPlayerClassBattleRange BattleRange;                                            // 0x0040 (size: 0x1)

}; // Size: 0x48

class USBAbilityConditionCharacterLevel : public USBAbilityConditionOperator
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBAbilityConditionDynamicTrigger : public USBAbilityCondition
{
    ESBAbilityDynamicTriggerType Type;                                                // 0x0040 (size: 0x1)

}; // Size: 0x48

class USBAbilityConditionEnemyHasAttackOrder : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionInBattleMap : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionInGameContentID : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionInMap : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionInParty : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionInWater : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionMapInfo : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionOperator : public USBAbilityCondition
{
    ESBAbilityConditionOperator OperatorType;                                         // 0x0040 (size: 0x1)

}; // Size: 0x48

class USBAbilityConditionPlayerClass : public USBAbilityCondition
{
    ESBClassType ClassType;                                                           // 0x0040 (size: 0x1)

}; // Size: 0x48

class USBAbilityConditionPlayerClassTotalPower : public USBAbilityConditionOperator
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBAbilityConditionPlayerResurrecting : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionPlayerSpiritRank : public USBAbilityConditionOperator
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBAbilityConditionRemainHitPointRate : public USBAbilityConditionOperator
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBAbilityConditionSheathe : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionSkillAttack : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionTimeZoneNight : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionTimeZoneNoon : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionWeaponElement : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionWeaponEnhance : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionWeaponProficiency : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityConditionWeaponTotalPower : public USBAbilityCondition
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBAbilityCurableByInteraction : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityDot : public USBAbilityDotBase
{
    int32 AttackID;                                                                   // 0x0088 (size: 0x4)
    ESBAbilityDotAmountType AmountType;                                               // 0x008C (size: 0x1)

}; // Size: 0x98

class USBAbilityDotBase : public USBAbility
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityDotHPDamage : public USBAbilityDot
{
    char padding_0[0x98];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x98

class USBAbilityDotHPHeal : public USBAbilityDot
{
    char padding_0[0x98];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x98

class USBAbilityDotMPHeal : public USBAbilityDot
{
    char padding_0[0x98];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x98

class USBAbilityDummy : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityElementAccumulation : public USBAbilityStatusBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityElementAccumulationTacticalSkillID : public USBAbilityStatusBase
{
    ESBAttribute AttributeType;                                                       // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityElementReset : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityElementStatusReinforce : public USBAbility
{
    ESBAttribute AttributeType;                                                       // 0x0080 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0081 (size: 0x7)
    TArray<FSBAbilityElementStatusReinforceLevelModifySetting> StatusAilmentLevelModifySettingList; // 0x0088 (size: 0x10)

}; // Size: 0x98

class USBAbilityEvent : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityEventAddBattleStatusWhenServerGiveDamage : public USBAbilityEventWhenServerGiveDamage
{
    FDataTableRowHandle SendBattleStatus;                                             // 0x0080 (size: 0x10)

}; // Size: 0x90

class USBAbilityEventAddBattleStatusWhenServerGiveDamageWhenBack : public USBAbilityEventWhenServerGiveDamageWhenBack
{
    FDataTableRowHandle SendBattleStatus;                                             // 0x0080 (size: 0x10)

}; // Size: 0x90

class USBAbilityEventAddSelfBattleStatusWhenServerGiveDamage : public USBAbilityEventWhenServerGiveDamage
{
    FDataTableRowHandle SendBattleStatus;                                             // 0x0080 (size: 0x10)

}; // Size: 0x90

class USBAbilityEventDarkWhenGiveDamage : public USBAbilityEventWhenTakeDamageBeforeCalcDamageAttacker
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityEventDrainWhenTakeDamageAttackHit : public USBAbilityEventWhenTakeDamageAttackHit
{
    int32 AttackID;                                                                   // 0x0080 (size: 0x4)

}; // Size: 0x88

class USBAbilityEventForceCriticalWhenGiveDamage : public USBAbilityEventWhenTakeDamageBeforeCalcDamageAttacker
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityEventHealStaminaWhenTakeDamageAttackHit : public USBAbilityEventWhenTakeDamageAttackHit
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityEventInvalidAttackWhenReceiveDamage : public USBAbilityEventWhenTakeDamageBeforeCalcDamage
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityEventRecoverAttackerWhenReceiveDamage : public USBAbilityEventWhenReceiveDamage
{
    int32 AttackID;                                                                   // 0x0080 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0084 (size: 0x4)
    TArray<FSBAttackID> ExcludeAttackIDs;                                             // 0x0088 (size: 0x10)

}; // Size: 0x98

class USBAbilityEventWhenReceiveDamage : public USBAbilityEvent
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)

    void OnEventAction(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst);
}; // Size: 0x80

class USBAbilityEventWhenServerGiveDamage : public USBAbilityEvent
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)

    void OnEventAction(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst);
}; // Size: 0x80

class USBAbilityEventWhenServerGiveDamageWhenBack : public USBAbilityEvent
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)

    void OnEventAction(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst);
}; // Size: 0x80

class USBAbilityEventWhenTakeDamageAttackHit : public USBAbilityEvent
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)

    void OnEventAction(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst);
}; // Size: 0x80

class USBAbilityEventWhenTakeDamageBeforeCalcDamage : public USBAbilityEvent
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)

    void OnEventAction(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst, bool bInvincible);
}; // Size: 0x80

class USBAbilityEventWhenTakeDamageBeforeCalcDamageAttacker : public USBAbilityEvent
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)

    void OnEventAction(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst, bool bInvincible);
}; // Size: 0x80

class USBAbilityExpiration : public UObject
{
    class AActor* Owner;                                                              // 0x0028 (size: 0x8)

}; // Size: 0x60

class USBAbilityExpirationCount : public USBAbilityExpiration
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBAbilityExpirationCountWithTime : public USBAbilityExpirationCount
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBAbilityExpirationDotTimeCount : public USBAbilityExpirationCount
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAbilityExpirationTimeLimit : public USBAbilityExpiration
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBAbilityExpirationUserAction : public USBAbilityExpiration
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBAbilityExtendNegativeStatus : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityGuardReduceSkillRecastTime : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityGuardReduceSpecialSkillRecastTime : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityGuardShieldDamageRate : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityGuardSpecialGaugeRate : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityGutsOtherDamage : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityGutsSelfDamage : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityHateCalcMagnification : public USBAbilityStatusBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityHealHPRecovery : public USBAbilityStatusBase
{
    ESBHealRecoveryType HealType;                                                     // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityInvalidStatus : public USBAbility
{
    TArray<FSBAbilityID> AbilityIDList;                                               // 0x0080 (size: 0x10)
    TArray<ESBBattleEffectiveGroup> GroupList;                                        // 0x0090 (size: 0x10)

}; // Size: 0xA0

class USBAbilityLancerMark : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityLimit : public UObject
{
    TMap<class ESBAbilityLimitParamType, class FSBAbilityLimitParam> Params;          // 0x0028 (size: 0x50)
    TMap<class ESBAbilityLimitSumParamType, class FSBAbilityLimitParam> SumParams;    // 0x0078 (size: 0x50)

}; // Size: 0xC8

class USBAbilityOnlyEnemyStatus : public USBAbility
{
    ESBAbilityOnlyEnemyStatus StatusType;                                             // 0x0080 (size: 0x1)

}; // Size: 0x88

class USBAbilityOnlyPlayerStatus : public USBAbility
{
    ESBAbilityOnlyPlayerStatus StatusType;                                            // 0x0080 (size: 0x1)

}; // Size: 0x88

class USBAbilityPointGravity : public USBAbility
{
    TArray<class UCurveFloat*> CurveValues;                                           // 0x0080 (size: 0x10)
    class UCurveFloat* ResistAbsorbCurve;                                             // 0x0090 (size: 0x8)
    char padding_0[0x18];                                                             // 0x0098 (size: 0x18)
    bool bUpdateGravityPointForCauserLocation;                                        // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class USBAbilityProjectileOnTimes : public USBAbilityDotBase
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBAbilityRecoveryHP : public USBAbility
{
    int32 AttackID;                                                                   // 0x0080 (size: 0x4)
    ESBAbilityRecoveryAmountType Type;                                                // 0x0084 (size: 0x1)

}; // Size: 0x88

class USBAbilityRecoveryHPBelowHPRate : public USBAbilityRecoveryHP
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBAbilityRecoveryShieldDurability : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityResistBadCondition : public USBAbilityStatusBase
{
    ESBBattleStatusResistType BadConditionType;                                       // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityResurrection : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilitySkillButtonChargeTime : public USBAbilityStatusTimeBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilitySkillRecoveryCoolTime : public USBAbility
{
    TArray<ESBAbilitySkillPosition> ActionTypes;                                      // 0x0080 (size: 0x10)
    ESBAbilityValueShortAndExten ValueType;                                           // 0x0090 (size: 0x1)

}; // Size: 0x98

class USBAbilitySkillReduceStaminaByAction : public USBAbilityStatusBase
{
    ESBAbilityReduceStaminaType SkillAction;                                          // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilitySkillReduceStaminaByAll : public USBAbilityStatusBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilitySkillSkillCoolTime : public USBAbilityStatusTimeBase
{
    TArray<ESBAbilitySkillPosition> SkillActions;                                     // 0x0088 (size: 0x10)

}; // Size: 0x98

class USBAbilitySpecialGaugeCharge : public USBAbilityStatusBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityStaminaRecovery : public USBAbility
{
    ESBAbilityRecoveryAmountType Type;                                                // 0x0080 (size: 0x1)

}; // Size: 0x88

class USBAbilityStatusAilmentHP : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusAttributeGiveDamage : public USBAbilityStatusBase
{
    TArray<ESBAbilityEnemyAttributeType> AttributeTypes;                              // 0x0088 (size: 0x10)

}; // Size: 0x98

class USBAbilityStatusBase : public USBAbility
{
    ESBAbilityValueUpAndDown Type;                                                    // 0x0080 (size: 0x1)

}; // Size: 0x88

class USBAbilityStatusBattleImagineElementReceiveDamage : public USBAbilityStatusBase
{
    ESBAttribute Attribute;                                                           // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityStatusDamageAttackTypeGiveDamage : public USBAbilityStatusBase
{
    ESBDamageAttackType AttackType;                                                   // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityStatusDamageAttackTypeReceiveDamage : public USBAbilityStatusBase
{
    ESBDamageAttackType AttackType;                                                   // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityStatusDungeonIDGiveDamage : public USBAbilityStatusBase
{
    TArray<FString> DungeonIds;                                                       // 0x0088 (size: 0x10)

}; // Size: 0x98

class USBAbilityStatusElementReceiveDamage : public USBAbilityStatusBase
{
    ESBAttribute Attribute;                                                           // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityStatusEnemyIDGiveDamage : public USBAbilityStatusBase
{
    TArray<FString> EnemyIDs;                                                         // 0x0088 (size: 0x10)

}; // Size: 0x98

class USBAbilityStatusFear : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusFixHate : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusFixTarget : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusFlashStun : public USBAbilityOnlyEnemyStatus
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityStatusFreeze : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusGiveDamage : public USBAbilityStatusBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityStatusInvincible : public USBAbility
{
    ESBInvincibleLevel Level;                                                         // 0x0080 (size: 0x1)

}; // Size: 0x88

class USBAbilityStatusParalyze : public USBAbility
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityStatusPoison : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusRaceGiveDamage : public USBAbilityStatusBase
{
    ESBEnemyRaceType RaceType;                                                        // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityStatusReceiveDamage : public USBAbilityStatusBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityStatusRecovery : public USBAbility
{
    TArray<ESBBattleEffectiveGroup> Groups;                                           // 0x0080 (size: 0x10)
    TArray<FSBAbilityID> AbilityIDs;                                                  // 0x0090 (size: 0x10)

}; // Size: 0xA0

class USBAbilityStatusRestraint : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusSkillActionGiveDamage : public USBAbilityStatusBase
{
    TArray<ESBAbilitySkillPosition> SkillTypes;                                       // 0x0088 (size: 0x10)

}; // Size: 0x98

class USBAbilityStatusSleep : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusStun : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusSuperArmor : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusTacticalSkillIDGiveDamage : public USBAbilityStatusBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityStatusTaunted : public USBAbility
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBAbilityStatusTimeBase : public USBAbility
{
    ESBAbilityValueShortAndExten Type;                                                // 0x0080 (size: 0x1)

}; // Size: 0x88

class USBAbilitySuccessRateControlBadCondition : public USBAbilityStatusBase
{
    ESBAbilityControlBadCondition BadConditionType;                                   // 0x0088 (size: 0x1)

}; // Size: 0x90

class USBAbilityTacticalSkillIDSkillCoolTime : public USBAbilityStatusTimeBase
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAbilityTask_EnemyPlayAnimationAndWait : public UAbilityTask
{
    FSBAbilityTask_EnemyPlayAnimationAndWaitOnCompleted OnCompleted;                  // 0x0080 (size: 0x10)
    void AnimationWaitSimpleDelegate();
    FSBAbilityTask_EnemyPlayAnimationAndWaitOnRefused OnRefused;                      // 0x0090 (size: 0x10)
    void AnimationWaitSimpleDelegate();
    FSBAbilityTask_EnemyPlayAnimationAndWaitOnCancelled OnCancelled;                  // 0x00A0 (size: 0x10)
    void AnimationWaitSimpleDelegate();

    class USBAbilityTask_EnemyPlayAnimationAndWait* CreatePlayAnimationAndWaitProxy(class UGameplayAbility* OwningAbility);
    void AnimationWaitSimpleDelegate__DelegateSignature();
}; // Size: 0xB8

class USBAbilityTask_EnemyWaitGameplayEvent : public UAbilityTask
{
    FSBAbilityTask_EnemyWaitGameplayEventEventReceived EventReceived;                 // 0x0080 (size: 0x10)
    void WaitGameplayEventDelegate(FGameplayEventData Payload);
    char padding_0[0x8];                                                              // 0x0090 (size: 0x8)
    class UAbilitySystemComponent* OptionalExternalTarget;                            // 0x0098 (size: 0x8)

    class USBAbilityTask_EnemyWaitGameplayEvent* CreateSBEnemyWaitGameplayEventProxy(class UGameplayAbility* OwningAbility, FGameplayTag EventTag, class AActor* OptionalExternalTarget, bool OnlyTriggerOnce, bool OnlyMatchExact);
}; // Size: 0xB0

class USBAcEventComponentUtility : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsAcEventValid(const class UObject* WorldContextObject);
    class USBPlayerAcEventComponent* GetAcEventComponent(const class UObject* WorldContextObject);
}; // Size: 0x28

class USBAcceptQuestEventParam : public UObject
{
    bool bResult;                                                                     // 0x0028 (size: 0x1)
    EAcceptedQuestErrorCode ErrorCode;                                                // 0x0029 (size: 0x1)
    char padding_0[0x6];                                                              // 0x002A (size: 0x6)
    FAcceptedQuestInfo AcceptedQuestInfo;                                             // 0x0030 (size: 0x60)

}; // Size: 0x90

class USBAchievementBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SortAchievementMasterDatasBySortId(TArray<FAchievementMasterData>& InAchievementMasterDatas);
    void SortAchievementList(TArray<FAchievementMasterData>& InAchievementMasterDatas, TEnumAsByte<ESBAchievementSortType::Type> SortType);
}; // Size: 0x28

class USBActivatedDungeonList : public UObject
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)

    bool IsReady();
    TArray<FSBMissionListInfo> GetActivatedDungeonList();
    void Clear();
}; // Size: 0x40

class USBActiveOutGameBuffData : public UObject
{
    FSSBActiveOutGameBuffData Data;                                                   // 0x0028 (size: 0x28)
    bool bLifetimeCheckEnable;                                                        // 0x0050 (size: 0x1)

}; // Size: 0x58

class USBActivityBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SendLogout(class UObject* WorldContextObject);
    ESBActivityCategory GetCategory(const ESBActivityType InType);
    bool ConvertToText(class UObject* WorldContextObject, FText& OutText, const FSBActivityData& InData, FString InAuthorName);
}; // Size: 0x28

class USBActorManager : public UObject
{
    class ASBActorManagerActor* m_ActorManagerActor;                                  // 0x01A8 (size: 0x8)

    void RemoveActor(class AActor* Actor);
    int32 GetTargetableProjectileNum();
    class ASBProjectileBase* GetTargetableProjectile(const int32 Index);
    int32 GetPlayerNum();
    class ASBPlayerCharacter* GetPlayer(const int32 Index);
    int32 GetEnemyNum();
    class ASBEnemyCharacter* GetEnemyForID(FString EnemyId);
    class ASBEnemyCharacter* GetEnemy(const int32 Index);
    class ASBPlayerCharacter* FindPlayerFromCharacterId(FString CharacterId);
    void AddActor(class AActor* Actor);
}; // Size: 0x1B0

class USBActorPool : public UObject
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBActorPoolManager : public UObject
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x78

class USBActorRelationRendererComponent : public UPrimitiveComponent
{
    char padding_0[0x480];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x480

class USBActorVisibilityComponent : public UActorComponent
{
    char padding_0[0xF0];                                                             // 0x0000 (size: 0x0)

    void SetActorHiddenType(ESBActorHiddenType HiddenType, bool bIsHidden);
    bool BP_IsActorHidden(ESBActorHiddenType HiddenType);
}; // Size: 0xF0

class USBActorVisibilityFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetHiddenCheck_FishingMode(const class UObject* WorldContextObject, bool bIsHidden);
}; // Size: 0x28

class USBAdditionalColorManager : public UObject
{
    FLinearColor IgnitionColor;                                                       // 0x0028 (size: 0x10)
    FLinearColor FreezeColor;                                                         // 0x0038 (size: 0x10)
    FLinearColor ShockColor;                                                          // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBAdjustRootMotionComponent : public UActorComponent
{
    char padding_0[0x120];                                                            // 0x0000 (size: 0x0)

    void MulticastReserveNewTask(uint8 SetupInterfaceIndex, const FVector_NetQuantize100 TargetLocation, const FVector_NetQuantize100 TargetVector);
}; // Size: 0x120

class USBAdminBookmarkMisc : public UObject
{
    class UUserWidget* GotoBookmarkWindow;                                            // 0x0030 (size: 0x8)
    TArray<class USBAdminGotoBookmarkItem*> GotoBookmarkList;                         // 0x0038 (size: 0x10)

    void RegisterGotoBookmark(FString MapId, FString Description, FVector Position);
    class UUserWidget* OpenGotoBookmarkWindow(class UCanvasPanel* InParentPanel);
    void OnUpdateGotoBookmarkData(class USBAdminGotoBookmarkItem* UpdateData);
    void MoveGotoBookmarkData(class USBAdminGotoBookmarkItem* Data, bool bMoveToUp);
    bool IsIdWarp();
    class USBAdminBookmarkMisc* GetSBAdminBookmarkMisc(const class UObject* WorldContextObject);
    TArray<class USBAdminGotoBookmarkItem*> GetGotoBookmarkList();
    void GetCurrentPosition(FString& OutMapId, FVector& OutPos);
    void ExecuteGotoBookmarkSub(class USBAdminGotoBookmarkItem* BookmarkData);
    void ExecuteGotoBookmarkMain(class USBAdminGotoBookmarkItem* BookmarkData);
    void ExecuteGotoBookmark(class USBAdminGotoBookmarkItem* BookmarkData);
    void DeleteGotoBookmarkData(class USBAdminGotoBookmarkItem* Data);
    void CloseGotoBookmarkWindow();
}; // Size: 0x60

class USBAdminGotoBookmarkItem : public UObject
{
    FSBAdminGotoBookmarkItemOnUpdate OnUpdate;                                        // 0x0028 (size: 0x10)
    void OnUpdateDelegate(class USBAdminGotoBookmarkItem* Sender);
    FSBAdminGotoBookmarkItemOnDataChanged OnDataChanged;                              // 0x0038 (size: 0x10)
    void OnUpdateDelegate(class USBAdminGotoBookmarkItem* Sender);
    bool bSelected;                                                                   // 0x0048 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0049 (size: 0x3)
    int32 Index;                                                                      // 0x004C (size: 0x4)
    FString MapId;                                                                    // 0x0050 (size: 0x10)
    FString MapName;                                                                  // 0x0060 (size: 0x10)
    FString Description;                                                              // 0x0070 (size: 0x10)
    FVector Position;                                                                 // 0x0080 (size: 0xC)

    void SetSelected(bool bValue);
    void SetPosition(FVector Value);
    void SetMapId(FString Value);
    void SetDescription(FString Value);
    void SetData(FString InMapId, FString InDescription, FVector InPosition);
    void OnUpdateDelegate__DelegateSignature(class USBAdminGotoBookmarkItem* Sender);
}; // Size: 0x90

class USBAdminReciever : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAdventureBoard : public UUserWidget
{
    char padding_0[0x288];                                                            // 0x0000 (size: 0x0)

    void UpdateBoardParam(const FSBAdventureBoardParam& InBoard);
    void UpdateBoardPanel(int32 InBoardId, const FSBAdventureBoardPanelParam& InPanel);
    void UpdateBoard(const FSBAdventureBoardParam& InBoard);
    void Sort();
    void SetBoardParamList(const TArray<FSBAdventureBoardParam>& InBoardParamList, bool IsSort);
    void Init();
    bool GetDebugIDDraw();
    bool GetBoardPanelMastaData(FSBAdventureBoardPanelParamMasterData& OutMasterData, int32 InBoardId, int32 InPanelId);
    bool GetBoardMastaData(FSBAdventureBoardParamMasterData& OutMasterData, int32 InBoardId);
    void GetBoardList_Filting(const class UObject* WorldContextObject, TArray<FSBAdventureBoardParam>& OutList, const TArray<FFilterGroup>& Filters, bool IsLimited, bool IsAllRewardGet);
    void GetBoardList(TArray<FSBAdventureBoardParam>& OutList);
    void GetBoard(int32 BoardId, FSBAdventureBoardParam& OutBoard);
}; // Size: 0x288

class USBAdventureBoardFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetNewClearPanelBP(const FSBAdventureBoardParam& InBoardData, FSBAdventureBoardParam& OutBoardData);
    void MargeBoardPanelParam(const FSBAdventureBoardParam& InSrcBoardData, const TArray<FSBAdventureBoardPanelParam>& InDstBoardPanelList, FSBAdventureBoardParam& OutBoardData);
    bool IsUpdateAdventureBoardPanel(class UObject* InWorldContextObject, ESBAdventureBoardType InType, ESBAdventureBoardRewardStatusType InRewardStatus);
    bool IsUpdateAdventureBoard(class UObject* InWorldContextObject, ESBAdventureBoardRewardStatusType InRewardStatus);
    bool IsUpdate(const FSBAdventureBoardParam& InBoardParam);
    bool IsTimeLimit(int32 InBoardId);
    bool IsStart(int32 InBoardId, int32 InPanelId);
    bool IsRankBoard(int32 InBoardId);
    bool IsNewAdventureBoard_BoardType(class UObject* InWorldContextObject, ESBAdventureBoardType InType, ESBAdventureBoardRewardStatusType InRewardStatus);
    bool IsNewAdventureBoard(class UObject* InWorldContextObject);
    bool IsGoalByMasterData(const FSBAdventureBoardPanelParamMasterData& InMaster);
    bool IsGoalAter(const FSBAdventureBoardParam& InBoardParam);
    bool IsGoal(int32 InBoardId, int32 InPanelId);
    bool IsFree(int32 InBoardId, int32 InPanelId);
    bool IsEnableVersion(const int32 InBoardId);
    bool IsEmphasis(int32 InBoardId, int32 InPanelId);
    bool IsCompleteRewardInGashaTicket(int32 InBoardId);
    bool IsBoardComplete(const FSBAdventureBoardParam& InBoardParam);
    bool IsBoardActive(const TArray<FSBAdventureBoardParam>& InList);
    int32 GetVersionNumber(FString InVersionId);
    int32 GetStartPanelId(const FSBAdventureBoardParam& InBoardData);
    bool GetRewardTermString(class UObject* WorldContextObject, int32 InBoardId, FString& TermDate);
    bool GetRewardTerm(class UObject* WorldContextObject, int32 InBoardId, FDateTime& OutTermDate);
    int32 GetRemainingRewardCount(const FSBAdventureBoardParam& InBoardParam);
    void GetRankupAdventureBoardIdList(const TArray<int32>& InBoardIdList, TArray<int32>& OutRankupBoardIdList, TArray<int32>& OutOtherBoardIdList);
    bool GetProjectVersion(FString& OutProjectVersion);
    int32 GetProgressCount(const FSBAdventureBoardPanelParam& InPanelParam, const FSBAdventureBoardMissionParamMasterData& InMissionMaster, const FSBAdventureBoardPanelParamMasterData& InPanelMaster);
    FVector2D GetPanelUIPosByMasterData(const FSBAdventureBoardPanelParamMasterData& InMaster);
    bool GetPanelUIPos(class UObject* WorldContextObject, int32 InBoardId, int32 InPabelId, FVector2D& OutUIPos);
    int32 GetPanelCount(const FSBAdventureBoardParam& InBoardParam);
    int32 GetPanelClearCount(const FSBAdventureBoardParam& InBoardParam);
    TArray<int32> GetNextPanelIdListByMasterData(const FSBAdventureBoardPanelParamMasterData& InMaster);
    bool GetNextPanelIdList(class UObject* WorldContextObject, int32 InBoardId, int32 InPabelId, TArray<int32>& OutPanelId);
    void GetNewOpenStartPanelBP(const FSBAdventureBoardParam& InBoardData, TArray<int32>& OutStartPaneIdList);
    bool GetMissionTermString(class UObject* WorldContextObject, int32 InBoardId, FString& TermDate);
    bool GetMissionTerm(class UObject* WorldContextObject, int32 InBoardId, FDateTime& OutTermDate);
    bool GetMissionParamMaster(const int32 InBoardId, const int32 InPanelId, FSBAdventureBoardMissionParamMasterData& OutMissionParam);
    void GetConnectPanel(const FSBAdventureBoardParam& InBoardData, const int32 InPanelId, TArray<int32>& OutConnectPanelIdList, bool CheckRoute);
    int32 GetCompleteCount(const FSBAdventureBoardPanelParam& InPanelParam, const FSBAdventureBoardMissionParamMasterData& InMissionMaster, const FSBAdventureBoardPanelParamMasterData& InPanelMaster);
    ESBAdventureBoardType GetBoardTypeByMasterData(const FSBAdventureBoardParamMasterData& InMaster);
    ESBAdventureBoardType GetBoardType(class UObject* WorldContextObject, int32 InBoardId);
    void GetBoardPanelReward_MailData(const int32 InBoardId, const int32 InPanelId, TArray<FSBMailData>& OutMailData);
    bool GetBoardPanelMaster(class UObject* WorldContextObject, int32 InBoardId, int32 InPanelId, FSBAdventureBoardPanelParamMasterData& OutPanelMaster);
    bool GetBoardMaster(class UObject* WorldContextObject, int32 InBoardId, FSBAdventureBoardParamMasterData& OutPanelMaster);
    FName GetBoardIconIdByMasterData(const FSBAdventureBoardParamMasterData& InMaster);
    FName GetBoardIconId(class UObject* WorldContextObject, int32 InBoardId);
    void GetBoardCompleteReward_MailData(const int32 InBoardId, TArray<FSBMailData>& OutMailData);
    int32 GetAdventureRank(int32 InBoardId);
    FString GetAdventureBoardStoryString(const int32 InBoardId);
    int32 GetAdventureBoardMissionTypeByMasterData(const FSBAdventureBoardMissionParamMasterData& InMaster);
    int32 GetAdventureBoardMissionType(FString InMissionId);
    FString GetAdventureBoardMissionCoundStringByMasterData(const FSBAdventureBoardMissionParamMasterData MasterData);
    FString GetAdventureBoardMissionCoundString(FString InMissionId);
    FString GetAdventureBoardBoardNameDirect(const FSBTextTableHash& InNameId);
    FString GetAdventureBoardBoardNameByMasterData(const FSBAdventureBoardParamMasterData& InMaster);
    FString GetAdventureBoardBoardName(int32 InBoardId);
    int32 GetActiveBoardMax();
    int32 GetActiveBoardCount(const TArray<FSBAdventureBoardParam>& InList);
    bool AdventureBoard_IsGetBoardCompleteReward(const FSBAdventureBoardParam& InBoard);
    bool AdventureBoard_CheckRewardAdventureBoard(const TArray<FString>& InRewardIdList);
    bool AdventureBoard_CheckMailRewardAdventureBoard(const FSBMailRewardData& InRewardData);
}; // Size: 0x28

class USBAdventureBoardManager : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAestheShopComponent : public UActorComponent
{
    FSBAestheShopComponentOnLoadAppearanceInfoDelegate OnLoadAppearanceInfoDelegate;  // 0x00B8 (size: 0x10)
    void OnLoadAppearanceInfoDelegate(const bool Result, const int32 RetCode, const TArray<FSBAestheShopAppearanceInfo>& AppearanceInfos);
    FSBAestheShopComponentOnSaveAppearanceInfoDelegate OnSaveAppearanceInfoDelegate;  // 0x00C8 (size: 0x10)
    void OnSaveAppearanceInfoDelegate(const bool Result, const int32 RetCode, const TArray<FSBAestheShopAppearanceInfo>& AppearanceInfos);
    FSBAestheShopComponentOnUploadAppearanceInfoDelegate OnUploadAppearanceInfoDelegate; // 0x00D8 (size: 0x10)
    void OnUploadAppearanceInfoDelegate(const bool Result, const int32 RetCode);
    FSBAestheShopComponentOnDownloadCharaCreateParamDelegate OnDownloadCharaCreateParamDelegate; // 0x00E8 (size: 0x10)
    void OnDownloadCharaCreateParamDelegate(const bool Result, const int32 RetCode, const FSBCharaCreateParameter& CharaCreateParam);

    bool Request_UploadAppearanceInfo(class ASBCreationCharacter* PlayerCharacter, FString InCharacterId, const ESBClassType InClassType, const FSBCharaCreateParameter& InCharaCreateParam, const FSBCharaCreatePartsIconIdData& InCharaCreatePartsIconIdData, const bool IsCharacterGenderChanged, const int32 InTicketTokenId, const int32 InTicketConsumeAmount);
    bool Request_SaveAppearanceInfo(class ASBCreationCharacter* PlayerCharacter, FString InCharacterId, const FSBAestheShopAppearanceInfo& InAppearanceInfo);
    bool Request_LoadAppearanceInfo(class ASBCreationCharacter* PlayerCharacter, FString InCharacterId);
    bool Request_DownloadCharaCreateParam(class ASBCreationCharacter* PlayerCharacter, FString InCharacterId);
    void OnUploadAppearanceInfoDelegate__DelegateSignature(const bool Result, const int32 RetCode);
    void OnSaveAppearanceInfoDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FSBAestheShopAppearanceInfo>& AppearanceInfos);
    void OnLoadAppearanceInfoDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FSBAestheShopAppearanceInfo>& AppearanceInfos);
    void OnDownloadCharaCreateParamDelegate__DelegateSignature(const bool Result, const int32 RetCode, const FSBCharaCreateParameter& CharaCreateParam);
    void MakeCharaParamRestrictionMasterDataParamValueList(const FSBAestheShopCharaParamRestrictionMasterData& InData, TArray<float>& OutParamValueList);
    float CorrectValueToCharaParamRestrictionMasterDataPatternListValue(const FSBAestheShopCharaParamRestrictionMasterData& InData, const float InValue);
    bool CheckIfValueIsInCharaParamRestrictionMasterDataPatternList(const FSBAestheShopCharaParamRestrictionMasterData& InData, const int32 InValue);
    bool CheckIfValueIsInCharaParamRestrictionMasterDataParamMinAndMaxRangeInt(const FSBAestheShopCharaParamRestrictionMasterData& InData, const int32 InValue);
    bool CheckIfValueIsInCharaParamRestrictionMasterDataParamMinAndMaxRangeFloat(const FSBAestheShopCharaParamRestrictionMasterData& InData, const float InValue);
    bool CheckIfCharaCreateParameterMakeupIsEdited(const FSBCharaCreateParameter& InBaseParam, const FSBCharaCreateParameter& InTargetParam);
    bool CheckIfCharaCreateParameterIsEdited(const FSBCharaCreateParameter& InBaseParam, const FSBCharaCreateParameter& InTargetParam);
    bool CheckIfCharaCreateParameterHairIsEdited(const FSBCharaCreateParameter& InBaseParam, const FSBCharaCreateParameter& InTargetParam);
    bool CheckIfCharaCreateParameterAppearanceIsEdited(const FSBCharaCreateParameter& InBaseParam, const FSBCharaCreateParameter& InTargetParam, bool InIgnoreHair, bool InIgnoreMakeup);
}; // Size: 0xF8

class USBAkEventLODAssetUserData : public UAssetUserData
{
    ESBAkEventLOD LOD;                                                                // 0x0028 (size: 0x1)

}; // Size: 0x30

class USBAlongGroundMovementComponent : public USBProjectileMovementHomingComponent
{
    FSBProjectileAlongGroundParameter AlongGroundParam;                               // 0x0218 (size: 0x1C)

}; // Size: 0x248

class USBAmbientAkComponent : public UAkComponent
{
    char padding_0[0x3F0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x3F0

class USBAmbientAkEventAssetUserData : public UAssetUserData
{
    class UAkAudioEvent* AkEvent;                                                     // 0x0028 (size: 0x8)
    ESBAmbientAkEventShape Shape;                                                     // 0x0030 (size: 0x1)
    bool bIsChangeActiveDistance;                                                     // 0x0031 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0032 (size: 0x2)
    float ActiveDistance;                                                             // 0x0034 (size: 0x4)

}; // Size: 0x38

class USBAnchorComponent : public USceneComponent
{
    char padding_0[0x210];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x210

class USBAnimInstance : public UASAnimInstance
{
    bool bIsPlayDemo;                                                                 // 0x0468 (size: 0x1)

}; // Size: 0x470

class USBAnimNotify : public UAnimNotify
{
    FSBNotifyRuleSetting NotifyRuleSetting;                                           // 0x0038 (size: 0x38)

}; // Size: 0x70

class USBAnimNotifyRule : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsNotifyExecutable(const class USkeletalMeshComponent* MeshComp, const class UAnimSequenceBase* Animation);
}; // Size: 0x28

class USBAnimNotifyRuleOnServer : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsNotifyExecutable(const class USkeletalMeshComponent* MeshComp, const class UAnimSequenceBase* Animation);
}; // Size: 0x28

class USBAnimNotifyRuleOnServer_EnemyFinishedElementalBurst : public USBAnimNotifyRuleOnServer
{
    uint16 Flags;                                                                     // 0x0028 (size: 0x2)

}; // Size: 0x30

class USBAnimNotifyRuleOnServer_IsElementalBurst : public USBAnimNotifyRuleOnServer
{
    uint16 Flags;                                                                     // 0x0028 (size: 0x2)

}; // Size: 0x30

class USBAnimNotifyRule_CanPlayDamageVoice : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_CanPlayDeadVoice : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_CheckStanLevel : public USBAnimNotifyRule
{
    int32 StanLevel;                                                                  // 0x0028 (size: 0x4)

}; // Size: 0x30

class USBAnimNotifyRule_HasCoopActionPower : public USBAnimNotifyRule
{
    int32 TargetPower;                                                                // 0x0028 (size: 0x4)

}; // Size: 0x30

class USBAnimNotifyRule_HasSpecifiedAppearanceID : public USBAnimNotifyRule
{
    FString TargetAppearanceID;                                                       // 0x0028 (size: 0x10)

}; // Size: 0x38

class USBAnimNotifyRule_HasSpecifiedAttribute : public USBAnimNotifyRule
{
    ESBAttribute TargetAttribute;                                                     // 0x0028 (size: 0x1)

}; // Size: 0x30

class USBAnimNotifyRule_IsAttackHit : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsBuddyRevival : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsCurrentActionSpecifiedName : public USBAnimNotifyRule
{
    FName TargetActionName;                                                           // 0x0028 (size: 0x8)

}; // Size: 0x30

class USBAnimNotifyRule_IsDodging : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsFallDamage : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsJumping : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsLocallyControlled : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsMenuOpen : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsPartsBroken : public USBAnimNotifyRule
{
    FSBPartsBreakState PartsBreakState;                                               // 0x0028 (size: 0x10)

}; // Size: 0x38

class USBAnimNotifyRule_IsPlayDemo : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsSABAttack : public USBAnimNotifyRuleOnServer
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsSABReaction : public USBAnimNotifyRuleOnServer
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsSBPlayerTransformCharacter : public USBAnimNotifyRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBAnimNotifyRule_IsSkillEquipped : public USBAnimNotifyRule
{
    int32 SkillId;                                                                    // 0x0028 (size: 0x4)

}; // Size: 0x30

class USBAnimNotifyState : public UASAnimNotifyState
{
    FName NotifyName;                                                                 // 0x0030 (size: 0x8)
    FSBNotifyRuleSetting NotifyRuleSetting;                                           // 0x0038 (size: 0x38)
    TMap<TWeakObjectPtr<AActor>, float> DeactivatedActorsWithRemainTime;              // 0x0070 (size: 0x50)

}; // Size: 0xC0

class USBAnimNotifyState_AcceptTSkillStepInput : public UAnimNotifyState
{
    uint8 CheckDirectionFlags;                                                        // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    float CheckAngle;                                                                 // 0x0034 (size: 0x4)
    bool ClearPrevInput;                                                              // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBAnimNotifyState_AdditionalInputLaunchProjectile : public UAnimNotifyState
{
    int32 NotifyStateIndex;                                                           // 0x0030 (size: 0x4)
    int32 LaunchProjectileMaxCount;                                                   // 0x0034 (size: 0x4)

}; // Size: 0x68

class USBAnimNotifyState_AdjustEnemyRootMotion : public USBAnimNotifyState
{
    FSBAdjustRootMotionSettings RootMotionSettings;                                   // 0x00C8 (size: 0xC0)
    float MinAdjustEnemyLength;                                                       // 0x0188 (size: 0x4)
    float MaxAdjustEnemyLength;                                                       // 0x018C (size: 0x4)
    float YawMaxAngle;                                                                // 0x0190 (size: 0x4)
    float PitchMaxAngle;                                                              // 0x0194 (size: 0x4)
    bool bAdjustNavMeshArea;                                                          // 0x0198 (size: 0x1)
    bool bAdjustWithZAxis;                                                            // 0x0199 (size: 0x1)
    bool bScaleMode;                                                                  // 0x019A (size: 0x1)
    char padding_0[0x1];                                                              // 0x019B (size: 0x1)
    FVector ScaleModeRatio;                                                           // 0x019C (size: 0xC)
    FVector TargetOffset;                                                             // 0x01A8 (size: 0xC)

}; // Size: 0x1B8

class USBAnimNotifyState_AllowJump : public UAnimNotifyState
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBAnimNotifyState_ArcBladeMove : public UAnimNotifyState
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBAnimNotifyState_Attack : public UASAnimNotifyState_Attack
{
    FName SBAttackName;                                                               // 0x0098 (size: 0x8)
    uint8 bApplyCustomWeaponScale;                                                    // 0x00A0 (size: 0x1)
    uint8 bApplyCustomMeshScale;                                                      // 0x00A0 (size: 0x1)
    uint8 bInventoryIndex1;                                                           // 0x00A0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00A1 (size: 0x7)
    TArray<FDataTableRowHandle> StatusAilmentHandleList;                              // 0x00A8 (size: 0x10)
    TArray<FSBAttackHitStatusAilmentCondition> StatusAilmentHandleWithConditionList;  // 0x00B8 (size: 0x10)
    float FoliageReaction;                                                            // 0x00C8 (size: 0x4)
    char padding_1[0x4];                                                              // 0x00CC (size: 0x4)
    TArray<FSBAttackCollisionAddition> SBAttackCollisionAdditions;                    // 0x00D0 (size: 0x10)
    bool bUpdateCollisionScaleWhenPlaying;                                            // 0x00E0 (size: 0x1)
    EOverlapBattleStatusTarget OverlapBattleStatusTarget;                             // 0x00E1 (size: 0x1)
    char padding_2[0x6];                                                              // 0x00E2 (size: 0x6)
    FDataTableRowHandle OverlapBattleStatus;                                          // 0x00E8 (size: 0x10)
    bool bReflectSkillPreInput;                                                       // 0x00F8 (size: 0x1)
    char padding_3[0x3];                                                              // 0x00F9 (size: 0x3)
    float ReleaseSkillCancelTime;                                                     // 0x00FC (size: 0x4)
    bool bRestrictCorrespondPassiveSkill;                                             // 0x0100 (size: 0x1)
    char padding_4[0x7];                                                              // 0x0101 (size: 0x7)
    TArray<FDataTableRowHandle> CorrespondPassiveSkillList;                           // 0x0108 (size: 0x10)
    FSBAttackID AttackID;                                                             // 0x0118 (size: 0x4)
    float OverrideTotalDuration;                                                      // 0x011C (size: 0x4)
    char padding_5[0xB0];                                                             // 0x0120 (size: 0xB0)
    FSBNotifyRuleSetting NotifyRuleSetting;                                           // 0x01D0 (size: 0x38)
    TArray<class AActor*> IgnoreActors;                                               // 0x0208 (size: 0x10)

}; // Size: 0x220

class USBAnimNotifyState_BImagineWeaponVisibilityNoManaged : public UAnimNotifyState
{
    bool bIsHidden;                                                                   // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    int32 InventoryIdentifyIndex;                                                     // 0x0034 (size: 0x4)

}; // Size: 0x38

class USBAnimNotifyState_BallVisibility : public USBAnimNotifyState
{
    int32 InventoryIndex;                                                             // 0x00C0 (size: 0x4)

}; // Size: 0xC8

class USBAnimNotifyState_CameraAnim : public UAnimNotifyState
{
    TEnumAsByte<ECameraSettingsType> CameraSettingsType;                              // 0x0030 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0031 (size: 0x7)
    FGameplayCameraSettings CustomCameraSettings;                                     // 0x0038 (size: 0x1B0)
    TEnumAsByte<ECameraPriority> CameraSettingsPriority;                              // 0x01E8 (size: 0x1)
    char padding_1[0x7];                                                              // 0x01E9 (size: 0x7)
    class UCameraAnim* CameraAnimation;                                               // 0x01F0 (size: 0x8)
    float Rate;                                                                       // 0x01F8 (size: 0x4)
    float Scale;                                                                      // 0x01FC (size: 0x4)
    float BlendInTime;                                                                // 0x0200 (size: 0x4)
    float BlendOutTime;                                                               // 0x0204 (size: 0x4)
    bool Loop;                                                                        // 0x0208 (size: 0x1)
    bool RandomStartTime;                                                             // 0x0209 (size: 0x1)
    char padding_2[0x2];                                                              // 0x020A (size: 0x2)
    float Duration;                                                                   // 0x020C (size: 0x4)
    TEnumAsByte<ECameraAnimNotifyPlaySpace> PlaySpace;                                // 0x0210 (size: 0x1)

}; // Size: 0x238

class USBAnimNotifyState_ChangeCreationCharacterMaterialParam : public USBAnimNotifyState
{
    FName MaterialParamName;                                                          // 0x00C0 (size: 0x8)
    class UCurveFloat* ScalarValueCurve;                                              // 0x00C8 (size: 0x8)

}; // Size: 0x120

class USBAnimNotifyState_ChangeEmissiveColorGradually : public UAnimNotifyState
{
    TArray<int32> TargetMaterialIndex;                                                // 0x0030 (size: 0x10)
    TArray<FNotifyStateChangeEmissiveColorTarget> TargetWeapon;                       // 0x0040 (size: 0x10)
    int32 OldColorIndex;                                                              // 0x0050 (size: 0x4)
    int32 NewColorIndex;                                                              // 0x0054 (size: 0x4)

}; // Size: 0x58

class USBAnimNotifyState_ControlRotation : public UAnimNotifyState
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBAnimNotifyState_CoopActionPowerSupply : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_CorrectWeaponDirectionForTarget : public USBAnimNotifyState
{
    int32 InventoryWeaponIndex;                                                       // 0x00C0 (size: 0x4)
    char padding_0[0xC];                                                              // 0x00C4 (size: 0xC)
    FSBCorrectTargetDirectionInfo CorrectDirectionInfo;                               // 0x00D0 (size: 0x30)

}; // Size: 0x100

class USBAnimNotifyState_EnemyAction : public USBAnimNotifyState
{
    FString CustomActionName;                                                         // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class USBAnimNotifyState_EnemyActivateDamageCollision : public USBAnimNotifyState
{
    bool bIsActivated;                                                                // 0x00C0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00C1 (size: 0x7)
    TArray<FName> TargetDamageCollisionNames;                                         // 0x00C8 (size: 0x10)

}; // Size: 0xD8

class USBAnimNotifyState_EnemyActivateModifier : public USBAnimNotifyState
{
    TArray<FName> ModifierNames;                                                      // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class USBAnimNotifyState_EnemyAttack : public USBAnimNotifyState_Attack
{
    FName CollisionGroupName;                                                         // 0x0220 (size: 0x8)
    TArray<FASAttackCollision> AttackCollisionsOnPartsBroken;                         // 0x0228 (size: 0x10)

}; // Size: 0x240

class USBAnimNotifyState_EnemyChangeMaterialParamTemporary : public USBAnimNotifyState
{
    FName MaterialParamName;                                                          // 0x00C0 (size: 0x8)
    float Value;                                                                      // 0x00C8 (size: 0x4)

}; // Size: 0x170

class USBAnimNotifyState_EnemyChangeStance : public USBAnimNotifyState
{
    FName StanceName;                                                                 // 0x00C0 (size: 0x8)

}; // Size: 0xC8

class USBAnimNotifyState_EnemyExProjectileWithTrig : public USBAnimNotifyState_ExProjectileWithTrig
{
    FSBEnemyProjectileNotifyParam EnemyProjectileNotifyParam;                         // 0x0130 (size: 0x1C)

}; // Size: 0x150

class USBAnimNotifyState_EnemyHandIKActivate : public USBAnimNotifyState
{
    bool bRightHand;                                                                  // 0x00C0 (size: 0x1)

}; // Size: 0xC8

class USBAnimNotifyState_EnemyHitBrake : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_EnemyLookAt : public USBAnimNotifyState
{
    bool LookAtActivate;                                                              // 0x00C0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00C1 (size: 0x3)
    FSBLookAtCustomParam LookAtCustomParam;                                           // 0x00C4 (size: 0x1C)

}; // Size: 0xE0

class USBAnimNotifyState_EnemyModifyAnimPlayRateWithMoveSpeedRate : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_EnemyNoActionInhibitionStatus : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_EnemyPerformanceCameraInvincible : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_EnemyPerformanceCameraStatus : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_EnemySABSection : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_EnemyShowMarker : public USBAnimNotifyState
{
    TArray<FSBEnemyChantMarkerMinimumParams> ChantMarkerMinimumParamsList;            // 0x00C8 (size: 0x10)
    bool bFixTargetLocation;                                                          // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class USBAnimNotifyState_EnemySwitchWeaponAttachment : public USBAnimNotifyState
{
    TArray<int32> TargetWeaponIndex;                                                  // 0x00C0 (size: 0x10)
    bool bIsSheathe;                                                                  // 0x00D0 (size: 0x1)

}; // Size: 0xD8

class USBAnimNotifyState_ExProjectileWithTrig : public USBAnimNotifyState
{
    TArray<FNotifyProjectileConfigPackage> ProjectileConfigPackageList;               // 0x00D0 (size: 0x10)
    int32 FixLaunchProjectileNum;                                                     // 0x00E0 (size: 0x4)
    int32 LaunchProjectileCategory;                                                   // 0x00E4 (size: 0x4)
    bool bIsAdjustTargetPositionToGround;                                             // 0x00E8 (size: 0x1)
    bool bIsUsePreMarkedTargetPos;                                                    // 0x00E9 (size: 0x1)
    char padding_0[0x6];                                                              // 0x00EA (size: 0x6)
    FNotityProjectile ForecastProjectileConfig;                                       // 0x00F0 (size: 0x20)
    bool bIsSameCalcTargetPosAsLaunchForecast;                                        // 0x0110 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0111 (size: 0x3)
    float DummyRangeFromTarget;                                                       // 0x0114 (size: 0x4)
    uint8 bIsManageProjectileHandle;                                                  // 0x0118 (size: 0x1)
    uint8 bIsSetPlayerSkillActionInfo;                                                // 0x0118 (size: 0x1)

}; // Size: 0x130

class USBAnimNotifyState_FoliageReaction : public UAnimNotifyState
{
    TArray<FSBFoliageReactionNotify> ReactionParams;                                  // 0x0030 (size: 0x10)

}; // Size: 0x40

class USBAnimNotifyState_Footprint : public USBAnimNotifyState
{
    ESBEffectVisibleType VisibleType;                                                 // 0x00C0 (size: 0x1)

    bool IsLocomotion();
    bool IsDisableSound();
    bool IsDisableEffect();
}; // Size: 0xC8

class USBAnimNotifyState_IKContact : public UAnimNotifyState
{
    int32 Index;                                                                      // 0x0030 (size: 0x4)

}; // Size: 0x38

class USBAnimNotifyState_Invincible : public USBAnimNotifyState
{
    TEnumAsByte<ESBInvincibleAnimation::Type> InvincibleType;                         // 0x00C0 (size: 0x1)
    bool UnsheatheIfSuccess;                                                          // 0x00C1 (size: 0x1)

}; // Size: 0xC8

class USBAnimNotifyState_LegIKActive : public UAnimNotifyState
{
    bool bActive;                                                                     // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBAnimNotifyState_LieOnGroundActive : public UAnimNotifyState
{
    bool bActive;                                                                     // 0x0030 (size: 0x1)
    ESBLieOnGroundSituation LieOnGroundSituation;                                     // 0x0031 (size: 0x1)
    bool bEndlessForDemo;                                                             // 0x0032 (size: 0x1)

}; // Size: 0x38

class USBAnimNotifyState_Listener : public USBAnimNotifyState
{
    ESBListenerPosition ListenerPosition;                                             // 0x00C0 (size: 0x1)

}; // Size: 0xC8

class USBAnimNotifyState_LookAtTargetingPosition : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_ParticleEffect : public USBAnimNotifyState
{
    TArray<FSBNotifyParticleEffectParams> ParamsTable;                                // 0x00C8 (size: 0x10)
    TArray<FSBEffectSetting> EffectList;                                              // 0x00D8 (size: 0x10)
    uint8 AttackEffectId;                                                             // 0x00E8 (size: 0x1)
    ESBAnimNotifyPlayType PlayType;                                                   // 0x00E9 (size: 0x1)
    bool bDetachAtEnd;                                                                // 0x00EA (size: 0x1)
    char padding_0[0x1];                                                              // 0x00EB (size: 0x1)
    ESBEColorOverride EColorOverride;                                                 // 0x00EC (size: 0x1)
    bool bIsChangeLightingChannel;                                                    // 0x00ED (size: 0x1)
    char padding_1[0x52];                                                             // 0x00EE (size: 0x52)
    TArray<FSBNotifyStatePlayingEffect> m_PlayingEffectList;                          // 0x0140 (size: 0x10)

}; // Size: 0x150

class USBAnimNotifyState_PlayerHandIK : public UAnimNotifyState
{
    bool bRightHand;                                                                  // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    FName WeaponSocketName;                                                           // 0x0034 (size: 0x8)

}; // Size: 0x40

class USBAnimNotifyState_RequestCamera : public UAnimNotifyState
{
    FDataTableRowHandle Handle;                                                       // 0x0030 (size: 0x10)

}; // Size: 0x40

class USBAnimNotifyState_SendBattleStatus : public USBAnimNotifyState
{
    FDataTableRowHandle StatusHandle;                                                 // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class USBAnimNotifyState_SendMaterialParam : public UAnimNotifyState
{
    uint8 bIsEnable;                                                                  // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    ESBSendMaterialParamCalcType CalcType;                                            // 0x0034 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0035 (size: 0x3)
    uint8 bIsReverse;                                                                 // 0x0038 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0039 (size: 0x3)
    FName MaterialParamName;                                                          // 0x003C (size: 0x8)

}; // Size: 0x58

class USBAnimNotifyState_SendMaterialScalerParam : public USBAnimNotifyState_SendMaterialParam
{
    class UCurveFloat* CurveDataScaler;                                               // 0x0058 (size: 0x8)

}; // Size: 0x68

class USBAnimNotifyState_SendMaterialVectorParam : public USBAnimNotifyState_SendMaterialParam
{
    class UCurveVector* CurveDataVector;                                              // 0x0058 (size: 0x8)

}; // Size: 0x70

class USBAnimNotifyState_SitActive : public UAnimNotifyState
{
    bool bActive;                                                                     // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBAnimNotifyState_SlashCancel : public UAnimNotifyState
{
    ESkillActionPosition SkillPosition;                                               // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBAnimNotifyState_SlashDisk : public USBAnimNotifyState
{
    int32 InventoryIndex;                                                             // 0x00C4 (size: 0x4)
    bool bEnableWeaponBend;                                                           // 0x00C8 (size: 0x1)
    bool bReverseWeaponBend;                                                          // 0x00C9 (size: 0x1)
    bool bIsULT;                                                                      // 0x00CA (size: 0x1)

    void SetReverseWeaponBend(bool bReverse);
    void SetInventoryIndex(int32 Index);
    void SetEnableWeaponBend(bool bEnable);
    bool Received_IsSlashDiskEnable();
    bool IsULT();
}; // Size: 0xD0

class USBAnimNotifyState_StepWaitEnd : public USBAnimNotifyState
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBAnimNotifyState_SuperArmor : public USBAnimNotifyState
{
    int32 DamageAdjust;                                                               // 0x00C0 (size: 0x4)

}; // Size: 0xC8

class USBAnimNotifyState_SwitchComponentVisibility : public UAnimNotifyState
{
    FNotifySwitchVisibilityTarget Target;                                             // 0x0030 (size: 0x38)

}; // Size: 0x68

class USBAnimNotifyState_SwitchWeapon : public UAnimNotifyState
{
    TEnumAsByte<ESBWeaponAttach> WeaponAttach1;                                       // 0x0030 (size: 0x1)
    TEnumAsByte<ESBWeaponAttach> WeaponAttach2;                                       // 0x0031 (size: 0x1)

}; // Size: 0x38

class USBAnimNotifyState_TimedParticleEffect : public UAnimNotifyState
{
    class UParticleSystem* PSTemplate;                                                // 0x0030 (size: 0x8)
    ESBEffectVisibleType VisibleType;                                                 // 0x0038 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0039 (size: 0x3)
    FName SocketName;                                                                 // 0x003C (size: 0x8)
    FVector LocationOffset;                                                           // 0x0044 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x0050 (size: 0xC)
    bool bDestroyAtEnd;                                                               // 0x005C (size: 0x1)

}; // Size: 0x60

class USBAnimNotifyState_Trail : public USBAnimNotifyState
{
    TArray<FSBNotifyTrailParams> ParamsTable;                                         // 0x00C0 (size: 0x10)
    int32 PlayIndex;                                                                  // 0x00D0 (size: 0x4)
    ESBEffectVisibleType VisibleType;                                                 // 0x00D4 (size: 0x1)

    class UParticleSystem* OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
}; // Size: 0xD8

class USBAnimNotifyState_TwoHandedByWeaponRotation : public UAnimNotifyState
{
    TEnumAsByte<ESBWeaponAttach> WeaponAttach;                                        // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBAnimNotifyState_WeaponVisibility : public UAnimNotifyState
{
    bool bIsHidden;                                                                   // 0x0030 (size: 0x1)
    ESBWeaponVisibilitySlot Slot;                                                     // 0x0031 (size: 0x1)

}; // Size: 0x38

class USBAnimNotifyState_WeaponVisibilityNoManaged : public UAnimNotifyState
{
    bool bIsHidden;                                                                   // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    FName TargetComponentTag;                                                         // 0x0034 (size: 0x8)

}; // Size: 0x40

class USBAnimNotify_AkEvent : public USBAnimNotify_SoundBase
{
    class UAkAudioEvent* Event;                                                       // 0x0078 (size: 0x8)
    TArray<ESBAkEventSwitchType> SwitchType;                                          // 0x0080 (size: 0x10)
    bool bIsUserFootSESocketType;                                                     // 0x0090 (size: 0x1)
    ESBFootSESocketType FootSESocketType;                                             // 0x0091 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0092 (size: 0x2)
    FName FootSESocketName;                                                           // 0x0094 (size: 0x8)
    float FootSELineLength;                                                           // 0x009C (size: 0x4)

    bool Play(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, FName AttachName, bool bStopWhenOwnerDestroyed, bool bCanReuseAkComponent);
}; // Size: 0xA0

class USBAnimNotify_AkEvent2D : public USBAnimNotify_SoundBase
{
    class UAkAudioEvent* Event;                                                       // 0x0078 (size: 0x8)

}; // Size: 0x80

class USBAnimNotify_BImagineBeginChant : public UAnimNotify
{
    float ActionChantTime;                                                            // 0x0038 (size: 0x4)

}; // Size: 0x40

class USBAnimNotify_BImagineDisableDisappearSummonEffect : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_BImagineFloat : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_BImagineProjectileWithChantEffect : public USBAnimNotify_ProjectileWithChantEffect
{
    float EffectEndTime;                                                              // 0x0108 (size: 0x4)

}; // Size: 0x110

class USBAnimNotify_BuddyRestartLogic : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_ChangeDamageBlocker : public UAnimNotify
{
    float NewValue;                                                                   // 0x0038 (size: 0x4)

}; // Size: 0x40

class USBAnimNotify_ChangeEmissiveColor : public UAnimNotify
{
    TArray<int32> TargetMaterialIndex;                                                // 0x0038 (size: 0x10)
    TArray<FNotifyStateChangeEmissiveColorTarget> TargetWeapon;                       // 0x0048 (size: 0x10)
    int32 NewColorIndex;                                                              // 0x0058 (size: 0x4)

}; // Size: 0x60

class USBAnimNotify_ClarifyAttribute : public USBAnimNotify
{
    ESBAttribute ClarifyAttribute;                                                    // 0x0070 (size: 0x1)

}; // Size: 0x78

class USBAnimNotify_EncounterSignal : public USBAnimNotify
{
    float EncounterSignalRange;                                                       // 0x0070 (size: 0x4)

}; // Size: 0x78

class USBAnimNotify_EndSkillPreInputAccept : public UAnimNotify
{
    float LaunchSkillPreInputTime;                                                    // 0x0038 (size: 0x4)

}; // Size: 0x40

class USBAnimNotify_EnemyActionWaitEnd : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_EnemyAttackHitTrigger : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_EnemyBeginChant : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_EnemyBroadcastDelegate : public UAnimNotify
{
    FName BroadcastString;                                                            // 0x0038 (size: 0x8)

}; // Size: 0x40

class USBAnimNotify_EnemyChangeBattleMode : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_EnemyChangeStance : public USBAnimNotify
{
    FName StanceName;                                                                 // 0x0070 (size: 0x8)

}; // Size: 0x78

class USBAnimNotify_EnemyCustomAction : public USBAnimNotify
{
    FString CustomActionName;                                                         // 0x0070 (size: 0x10)

}; // Size: 0x80

class USBAnimNotify_EnemyDeathEffect : public UAnimNotify
{
    bool bMulticastCall;                                                              // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBAnimNotify_EnemyEndActionAbility : public USBAnimNotify
{
    ESBEnemyAbilityType AbilityType;                                                  // 0x0070 (size: 0x1)

}; // Size: 0x78

class USBAnimNotify_EnemyExProjectile : public USBAnimNotify_ExProjectile
{
    FSBEnemyProjectileNotifyParam EnemyProjectileNotifyParam;                         // 0x00D8 (size: 0x1C)

}; // Size: 0xF8

class USBAnimNotify_EnemyExProjectileWithChant : public USBAnimNotify_EnemyExProjectile
{
    uint32 AnimNotifyID;                                                              // 0x00F8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00FC (size: 0x4)
    TArray<FSBEnemyNotifyCastMagicEffectParams> MagicParamList;                       // 0x0100 (size: 0x10)

}; // Size: 0x110

class USBAnimNotify_EnemyGiveAilment : public USBAnimNotify
{
    FAIFwParameterizedBTRequest TargetingQuery;                                       // 0x0070 (size: 0x18)
    int32 MaxCount;                                                                   // 0x0088 (size: 0x4)
    char padding_0[0x4];                                                              // 0x008C (size: 0x4)
    FString BlackboardKey;                                                            // 0x0090 (size: 0x10)
    FDataTableRowHandle StatusHandle;                                                 // 0x00A0 (size: 0x10)

}; // Size: 0xB0

class USBAnimNotify_EnemyIncreseActionUniqueCount : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_EnemyPredictTargetLocation : public USBAnimNotify
{
    ESBEnemyTargetType TargetType;                                                    // 0x0070 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0071 (size: 0x3)
    int32 TargetIndex;                                                                // 0x0074 (size: 0x4)
    float PredictSeconds;                                                             // 0x0078 (size: 0x4)
    bool bUsePredictedVelocity;                                                       // 0x007C (size: 0x1)
    char padding_1[0x3];                                                              // 0x007D (size: 0x3)
    FSBCharacterAdjustRootMotionSetupPicker AdjustRootMotionSetupPicker;              // 0x0080 (size: 0x10)
    FSBEnemyPredictTargetProjectileInfo ProjectileInfo;                               // 0x0090 (size: 0x18)

}; // Size: 0xA8

class USBAnimNotify_EnemyProjectile : public USBAnimNotify_Projectile
{
    int32 SelectTargetIndex;                                                          // 0x00D0 (size: 0x4)
    bool bUseLookAtVirtualSocket;                                                     // 0x00D4 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00D5 (size: 0x3)
    FVector LookAtVirtualSocketSpownLocation;                                         // 0x00D8 (size: 0xC)
    FVector LookAtVirtualSocketRotateLocation;                                        // 0x00E4 (size: 0xC)

}; // Size: 0xF0

class USBAnimNotify_EnemyProjectileWithChant : public USBAnimNotify_ProjectileWithChantEffect
{
    bool bAllowAddingAvailableRules;                                                  // 0x0108 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0109 (size: 0x7)
    TArray<class TSubclassOf<USBAnimNotifyRule>> AvailableRules;                      // 0x0110 (size: 0x10)
    FSBEnemyProjectileChantEffectInfo ChantEffectInfo;                                // 0x0120 (size: 0x30)
    TArray<FSBEnemyChantMarkerParams> ChantMarkerParamsList;                          // 0x0150 (size: 0x10)
    bool bFixTargetLocation;                                                          // 0x0160 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0161 (size: 0x3)
    float WaitFixTargetLocationTime;                                                  // 0x0164 (size: 0x4)

}; // Size: 0x168

class USBAnimNotify_EnemyProjectileWithNotifyID : public USBAnimNotify_EnemyProjectile
{
    uint8 NotifyID;                                                                   // 0x00F0 (size: 0x1)

}; // Size: 0xF8

class USBAnimNotify_EnemyResetCollisionHit : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_EnemyResetTakeDamageCounter : public USBAnimNotify
{
    FName AttackIDName;                                                               // 0x0070 (size: 0x8)

}; // Size: 0x78

class USBAnimNotify_EnemySamplingActionDerivation : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_EnemySelfChanceTimeDown : public USBAnimNotify
{
    FName CommandName;                                                                // 0x0070 (size: 0x8)

}; // Size: 0x78

class USBAnimNotify_EnemySelfDeath : public UAnimNotify
{
    float DestroyWaitTime;                                                            // 0x0038 (size: 0x4)

}; // Size: 0x40

class USBAnimNotify_EnemySetDownState : public UAnimNotify
{
    bool bEnable;                                                                     // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBAnimNotify_EnemySetPartsStep : public USBAnimNotify
{
    TArray<FSBPartsBreakInfo> PartsStepInfos;                                         // 0x0070 (size: 0x10)

}; // Size: 0x80

class USBAnimNotify_EnemySetSABReaction : public USBAnimNotify
{
    bool bNewReaction;                                                                // 0x0070 (size: 0x1)

}; // Size: 0x78

class USBAnimNotify_EnemySummon : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_EnemySwitchSheathe : public UAnimNotify
{
    bool bIsSheathe;                                                                  // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBAnimNotify_EnemySwitchWeaponAttachment : public UAnimNotify
{
    TArray<int32> TargetWeaponIndex;                                                  // 0x0038 (size: 0x10)
    bool bIsSheathe;                                                                  // 0x0048 (size: 0x1)

}; // Size: 0x50

class USBAnimNotify_EnemyTurnTowardsAnchor : public UAnimNotify
{
    int32 TowardsAnchorID;                                                            // 0x0038 (size: 0x4)

}; // Size: 0x40

class USBAnimNotify_EnemyWaitEndForAiming : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_EnemyWarpTiming : public USBAnimNotify
{
    int32 WarpEffectIndex;                                                            // 0x0070 (size: 0x4)

}; // Size: 0x78

class USBAnimNotify_ExProjectile : public USBAnimNotify
{
    TArray<FNotifyProjectileConfigPackage> ProjectileConfigPackageList;               // 0x0080 (size: 0x10)
    int32 FixLaunchProjectileNum;                                                     // 0x0090 (size: 0x4)
    int32 LaunchProjectileCategory;                                                   // 0x0094 (size: 0x4)
    bool bIsAdjustTargetPositionToGround;                                             // 0x0098 (size: 0x1)
    bool bIsUsePreMarkedTargetPos;                                                    // 0x0099 (size: 0x1)
    char padding_0[0x6];                                                              // 0x009A (size: 0x6)
    FNotityProjectile ForecastProjectileConfig;                                       // 0x00A0 (size: 0x20)
    bool bIsSameCalcTargetPosAsLaunchForecast;                                        // 0x00C0 (size: 0x1)
    char padding_1[0x3];                                                              // 0x00C1 (size: 0x3)
    float DummyRangeFromTarget;                                                       // 0x00C4 (size: 0x4)
    uint8 bIsManageProjectileHandle;                                                  // 0x00C8 (size: 0x1)
    uint8 bIsSetPlayerSkillActionInfo;                                                // 0x00C8 (size: 0x1)

}; // Size: 0xD8

class USBAnimNotify_FilterLOD : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_FilterServer : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_Footprint : public USBAnimNotify_FilterServer
{
    ESBEffectVisibleType VisibleType;                                                 // 0x0070 (size: 0x1)

    bool IsLocomotion();
    bool IsDisableSound();
    bool IsDisableEffect();
}; // Size: 0x78

class USBAnimNotify_HateControl : public UAnimNotify
{
    float HatedValue;                                                                 // 0x0038 (size: 0x4)

}; // Size: 0x40

class USBAnimNotify_MeshClimbingCanMove : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_MobEndTalkAction : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_MobEndTalkTurn : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_MobEndWaitAction : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_ParticleEffect : public USBAnimNotify
{
    TArray<FSBNotifyParticleEffectParams> ParamsList;                                 // 0x0078 (size: 0x10)
    TArray<FSBEffectSetting> EffectList;                                              // 0x0088 (size: 0x10)
    uint8 AttackEffectId;                                                             // 0x0098 (size: 0x1)
    ESBAnimNotifyPlayType PlayType;                                                   // 0x0099 (size: 0x1)
    char padding_0[0x2];                                                              // 0x009A (size: 0x2)
    FName CorrespondSBAttackName;                                                     // 0x009C (size: 0x8)
    ESBEColorOverride EColorOverride;                                                 // 0x00A4 (size: 0x1)
    bool bIsChangeLightingChannel;                                                    // 0x00A5 (size: 0x1)

    void AddFloatParameter(int32 EffectIndex, FName ParamName, float ParamValue);
}; // Size: 0xA8

class USBAnimNotify_PlayBuddyConditionalVoice : public UAnimNotify
{
    FName ConditionId;                                                                // 0x0038 (size: 0x8)
    bool bPlayOwnerBuddyVoice;                                                        // 0x0040 (size: 0x1)
    bool bDisablePlayForOwenerBuddy;                                                  // 0x0041 (size: 0x1)

}; // Size: 0x48

class USBAnimNotify_PlayBuddyVoice : public USBAnimNotify_SoundBase
{
    class UAkAudioEvent* Event;                                                       // 0x0078 (size: 0x8)

}; // Size: 0x80

class USBAnimNotify_PlayEnemyVoice : public USBAnimNotify_SoundBase
{
    TSoftObjectPtr<ASBEnemyCharacter> EnemyCharacter;                                 // 0x0088 (size: 0x28)

    bool PlayEventNode(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, FString InEventName);
}; // Size: 0xB0

class USBAnimNotify_PlayParticleEffect : public UAnimNotify_PlayParticleEffect
{
    ESBEffectVisibleType VisibleType;                                                 // 0x0090 (size: 0x1)
    TEnumAsByte<EEffectTarget> AttachTargetType;                                      // 0x0091 (size: 0x1)

}; // Size: 0xA0

class USBAnimNotify_PlayPlayerSkillVoice : public USBAnimNotify_SoundBase
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x78

class USBAnimNotify_PlayPlayerVoice : public USBAnimNotify_SoundBase
{
    class UAkAudioEvent* Event;                                                       // 0x0078 (size: 0x8)

}; // Size: 0x80

class USBAnimNotify_PlaySoundProjectileOnInstigator : public USBAnimNotify_SoundBase
{
    FAkEventVariables AkEventVariables;                                               // 0x0078 (size: 0x40)
    float EffectiveRange;                                                             // 0x00B8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00BC (size: 0x4)
    FDataTableRowHandle TargetProjectileHandle;                                       // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class USBAnimNotify_PrintLapTime : public UAnimNotify
{
    bool bOnlySetup;                                                                  // 0x0038 (size: 0x1)
    bool bPrintToScreen;                                                              // 0x0039 (size: 0x1)
    bool bPrintToLog;                                                                 // 0x003A (size: 0x1)
    char padding_0[0x1];                                                              // 0x003B (size: 0x1)
    FLinearColor TextColor;                                                           // 0x003C (size: 0x10)
    float Duration;                                                                   // 0x004C (size: 0x4)

}; // Size: 0x50

class USBAnimNotify_Projectile : public USBAnimNotify
{
    bool bEditableConfigCategory;                                                     // 0x0080 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0081 (size: 0x7)
    FNotityProjectile NotifyConfig;                                                   // 0x0088 (size: 0x20)
    TArray<FNotifyProjectileByTag> NotifyByTagArray;                                  // 0x00A8 (size: 0x10)
    TArray<FNotifyProjectileByCondition> NotifyByConditionArray;                      // 0x00B8 (size: 0x10)
    uint8 bIsManageProjectileHandle;                                                  // 0x00C8 (size: 0x1)
    uint8 bIsSetPlayerSkillActionInfo;                                                // 0x00C8 (size: 0x1)

}; // Size: 0xD0

class USBAnimNotify_ProjectileEnd : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_ProjectileWithChantEffect : public USBAnimNotify_EnemyProjectileWithNotifyID
{
    TArray<FSBEnemyNotifyCastMagicEffectParams> MagicParamList;                       // 0x00F8 (size: 0x10)

}; // Size: 0x108

class USBAnimNotify_RequestCamera : public UAnimNotify
{
    FDataTableRowHandle Handle;                                                       // 0x0038 (size: 0x10)
    bool IsAdd;                                                                       // 0x0048 (size: 0x1)

}; // Size: 0x50

class USBAnimNotify_ResetElementDamageAll : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_RoundBlowLoop : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_SamplingSimulateEnemyActionSetStartPoint : public USBAnimNotify
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBAnimNotify_SetCanGuard : public UAnimNotify
{
    bool CanGuardAfterCounter;                                                        // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBAnimNotify_SetCupsuleCollisionEnabled : public USBAnimNotify
{
    bool bEnabled;                                                                    // 0x0070 (size: 0x1)

}; // Size: 0x78

class USBAnimNotify_SetFishingLineVisibility : public UAnimNotify
{
    bool bIsVisible;                                                                  // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBAnimNotify_SetMovementMode : public UAnimNotify
{
    TEnumAsByte<EMovementMode> NewMovementMode;                                       // 0x0038 (size: 0x1)
    TEnumAsByte<ECustomMoveMode> NewCustomMode;                                       // 0x0039 (size: 0x1)

}; // Size: 0x40

class USBAnimNotify_ShowMarkerBeforeExProjectile : public USBAnimNotify
{
    int32 FixLaunchProjectileNum;                                                     // 0x0078 (size: 0x4)
    int32 LaunchProjectileCategory;                                                   // 0x007C (size: 0x4)
    bool bIsAdjustTargetPositionToGround;                                             // 0x0080 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0081 (size: 0x7)
    FNotityProjectile ForecastProjectileConfig;                                       // 0x0088 (size: 0x20)
    float DummyRangeFromTarget;                                                       // 0x00A8 (size: 0x4)

}; // Size: 0xC0

class USBAnimNotify_ShowMarkerBeforeExProjectileOnAnchor : public USBAnimNotify
{
    TArray<int32> TargetAnchorIDList;                                                 // 0x0078 (size: 0x10)
    int32 LaunchProjectileCategory;                                                   // 0x0088 (size: 0x4)
    bool bIsAdjustTargetPositionToGround;                                             // 0x008C (size: 0x1)
    char padding_0[0x3];                                                              // 0x008D (size: 0x3)
    FNotityProjectile ForecastProjectileConfig;                                       // 0x0090 (size: 0x20)

}; // Size: 0xC0

class USBAnimNotify_ShowSimpleAlertByType : public UAnimNotify
{
    ESimpleAlertType AlertType;                                                       // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBAnimNotify_SoundBase : public USBAnimNotify
{
    ESBAkEventLOD LOD;                                                                // 0x0070 (size: 0x1)
    bool bIsStopAnimChange;                                                           // 0x0071 (size: 0x1)
    bool bIsPlayLoopOnce;                                                             // 0x0072 (size: 0x1)
    bool bIsStopEnemyUnableActionCondition;                                           // 0x0073 (size: 0x1)

}; // Size: 0x78

class USBAnimNotify_SpawnLevelSequence : public UAnimNotify
{
    class ULevelSequence* LevelSequence;                                              // 0x0038 (size: 0x8)
    TSubclassOf<class ASBLevelSequenceActor> LevelSequenceActorClass;                 // 0x0040 (size: 0x8)

}; // Size: 0x48

class USBAnimNotify_StartSkillCancelStep : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_StartThrow : public UAnimNotify
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAnimNotify_StatusAilment : public USBAnimNotify
{
    FDataTableRowHandle StatusHandle;                                                 // 0x0070 (size: 0x10)
    uint8 bIsDeactiveStatus;                                                          // 0x0080 (size: 0x1)
    uint8 bIsForceDeactive;                                                           // 0x0080 (size: 0x1)

}; // Size: 0x88

class USBAnimNotify_SwitchComponentVisibility : public UAnimNotify
{
    FNotifySwitchVisibilityTarget Target;                                             // 0x0038 (size: 0x38)

}; // Size: 0x70

class USBAnimNotify_TrigForExProjectile : public USBAnimNotify
{
    int32 TrigRequestProjectileNum;                                                   // 0x0070 (size: 0x4)

}; // Size: 0x78

class USBAnimNotify_WeaponAnimation : public UAnimNotify
{
    int32 InventoryIndex;                                                             // 0x0038 (size: 0x4)
    int32 AnimationIndex;                                                             // 0x003C (size: 0x4)
    FName AnimationName;                                                              // 0x0040 (size: 0x8)
    bool bLooping;                                                                    // 0x0048 (size: 0x1)

}; // Size: 0x50

class USBAnimNotify_WeaponVisibility : public UAnimNotify
{
    bool bIsHidden;                                                                   // 0x0038 (size: 0x1)
    ESBWeaponVisibilitySlot Slot;                                                     // 0x0039 (size: 0x1)

}; // Size: 0x40

class USBAnimSingleNodeInstance : public UAnimSingleNodeInstance
{
    char padding_0[0x2F0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2F0

class USBAnimalCharacterAnimInstance : public USBNpcCharacterAnimInstance
{
    TArray<FSBFootprintSideSocket> FootprintSockets;                                  // 0x0FF0 (size: 0x10)
    FSBSurfaceFootprintSettingList SurfaceFootprintSettingList;                       // 0x1000 (size: 0x2B0)
    bool bOverrideCameraTransparentCheckDistance;                                     // 0x12B0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x12B1 (size: 0x3)
    FSBCameraShieldingTransparentParam CameraShieldingTransparentParam;               // 0x12B4 (size: 0x8)
    FVector CameraTransparentBoxExtent;                                               // 0x12BC (size: 0xC)

}; // Size: 0x12D0

class USBAnimationControlComponent : public UActorComponent
{
    bool bEnableIK;                                                                   // 0x00B8 (size: 0x1)
    bool bIKActive;                                                                   // 0x00B9 (size: 0x1)
    bool bEnableLookAt;                                                               // 0x00BA (size: 0x1)
    bool bLookAtActive;                                                               // 0x00BB (size: 0x1)
    FVector LookAtPosition;                                                           // 0x00BC (size: 0xC)
    class AActor* LookAtTargetActor;                                                  // 0x00C8 (size: 0x8)
    bool bLookAtCustomEyeActive;                                                      // 0x00D0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00D1 (size: 0x3)
    FVector LookAtCustomEyePosition;                                                  // 0x00D4 (size: 0xC)
    class AActor* LookAtCustomEyeTargetActor;                                         // 0x00E0 (size: 0x8)
    FSBLookAtCustomParam LookAtCustomParam;                                           // 0x00E8 (size: 0x1C)
    bool bExtraLookAtActive1;                                                         // 0x0104 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0105 (size: 0x3)
    FVector ExtraLookAtPosition1;                                                     // 0x0108 (size: 0xC)
    char padding_2[0x4];                                                              // 0x0114 (size: 0x4)
    class AActor* ExtraLookAtTargetActor1;                                            // 0x0118 (size: 0x8)
    bool bExtraLookAtActive2;                                                         // 0x0120 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0121 (size: 0x3)
    FVector ExtraLookAtPosition2;                                                     // 0x0124 (size: 0xC)
    class AActor* ExtraLookAtTargetActor2;                                            // 0x0130 (size: 0x8)
    bool bExtraLookAtActive3;                                                         // 0x0138 (size: 0x1)
    char padding_4[0x3];                                                              // 0x0139 (size: 0x3)
    FVector ExtraLookAtPosition3;                                                     // 0x013C (size: 0xC)
    class AActor* ExtraLookAtTargetActor3;                                            // 0x0148 (size: 0x8)
    bool bEnableLieOnGround;                                                          // 0x0150 (size: 0x1)
    bool bLieOnGroundActive;                                                          // 0x0151 (size: 0x1)
    bool bEnableRunningLieOnGround;                                                   // 0x0152 (size: 0x1)
    bool bRunningLieOnGroundActive;                                                   // 0x0153 (size: 0x1)
    bool bEnableLimbsRetarget;                                                        // 0x0154 (size: 0x1)
    bool bEnableBreastPhysics;                                                        // 0x0155 (size: 0x1)
    bool bBreastPhysicsActive;                                                        // 0x0156 (size: 0x1)
    char padding_5[0x1];                                                              // 0x0157 (size: 0x1)
    float BreastPhysicsScale;                                                         // 0x0158 (size: 0x4)
    bool bEnablePartsDamageShake;                                                     // 0x015C (size: 0x1)
    bool bPartsDamageShakeActive;                                                     // 0x015D (size: 0x1)
    bool bHairPhysics;                                                                // 0x015E (size: 0x1)
    bool bHairPhysicsActive;                                                          // 0x015F (size: 0x1)
    bool bHairComponentSpaceSimulation;                                               // 0x0160 (size: 0x1)
    char padding_6[0x7];                                                              // 0x0161 (size: 0x7)
    class USBAnimationControlComponent* CacheObject;                                  // 0x0168 (size: 0x8)

    void SetLookAtActive(bool Flag);
}; // Size: 0x178

class USBArenaHUD : public USBContentsHUDBase
{
    char padding_0[0x2D8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2D8

class USBArenaMissionWatcher : public USceneComponent
{
    FArenaMissionInfo MissionInfo;                                                    // 0x0218 (size: 0x48)
    FArenaMissionProgressInfo MissionProgressInfo;                                    // 0x0260 (size: 0x20)
    float MissionLimitTime;                                                           // 0x0280 (size: 0x4)
    bool bActiveMission;                                                              // 0x0284 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0285 (size: 0x3)
    TArray<FArenaMissionInfo> ArenaMissionInfoList;                                   // 0x0288 (size: 0x10)
    int32 MissionCount;                                                               // 0x0298 (size: 0x4)
    char padding_1[0x4];                                                              // 0x029C (size: 0x4)
    FSBArenaMissionWatcherOnStartDelegate_Client OnStartDelegate_Client;              // 0x02A0 (size: 0x10)
    void OnStartDelegate(const FName& InMissionName);
    FSBArenaMissionWatcherOnMissionInfoSetDelegate OnMissionInfoSetDelegate;          // 0x02B0 (size: 0x10)
    void OnMissionInfoSetDelegate(const FName& InMissionName);
    FSBArenaMissionWatcherOnUpdateDelegate OnUpdateDelegate;                          // 0x02C0 (size: 0x10)
    void OnUpdateDelegate(const FName& InMissionName);
    FSBArenaMissionWatcherOnTimeOutDelegate_Client OnTimeOutDelegate_Client;          // 0x02D0 (size: 0x10)
    void OnTimeOutDelegate(const FName& InMissionName);
    FSBArenaMissionWatcherOnClearDelegate_Client OnClearDelegate_Client;              // 0x02E0 (size: 0x10)
    void OnClearDelegate(const FName& InMissionName);

    void OnUpdateDelegate__DelegateSignature(const FName& InMissionName);
    void OnTimeOutDelegate__DelegateSignature(const FName& InMissionName);
    void OnStartDelegate__DelegateSignature(const FName& InMissionName);
    void OnRep_MissionTime();
    void OnRep_MissionProgressInfo();
    void OnRep_MissionInfo();
    void OnMissionInfoSetDelegate__DelegateSignature(const FName& InMissionName);
    void OnClearDelegate__DelegateSignature(const FName& InMissionName);
    void NotifyTimerRespawnHUDInit();
    void NotifySummonImagine(const class ASBPlayerCharacter* InPlayerCharacter);
    void NotifySkillHit(const class ASBEnemyCharacter* InEnemyCharacter);
    void NotifyEnemyTakeDamage(const class ASBEnemyCharacter* InEnemyCharacter, const class ASBPlayerController* InAttacker, const float InDamage);
    void NotifyEnemyDead(const class ASBEnemyCharacter* InEnemyCharacter);
    void NotifyCriticalHit(const class ASBEnemyCharacter* InEnemyCharacter);
    void NotifyCastSkill(const class ASBPlayerCharacter* InPlayerCharacter);
    void Multicast_NotifySucceededArenaMission(const FName& InMissionName);
    void Multicast_NotifyStartArenaMission(const FName& InMissionName);
    void Multicast_NotifyFailedArenaMission(const FName& InMissionName);
    bool IsActiveMission();
    FArenaMissionProgressInfo GetMissionProgressInfo();
    float GetMissionLimitTime();
    FArenaMissionInfo GetMissionInfo();
    int32 GetMissionCount();
    int32 GetMissionClearCount();
}; // Size: 0x300

class USBArrayBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    TArray<int32> SortRecepiId(const TArray<FCharacterCraftRecepi>& Recepi, TArray<int32>& Indexes, ESBSortType SortType);
    TArray<FOwnItemInfo> SortOwnItemsWeaponExp(TArray<FOwnItemInfo>& InOwnItemInfos, ESBSortType SortType);
    TArray<FOwnItemInfo> SortOwnItemsWeaponEnhanceLevel(TArray<FOwnItemInfo>& InOwnItemInfos, ESBSortType SortType);
    TArray<int32> SortMaxItemLevel(const TArray<FCharacterCraftRecepi>& Recepi, TArray<int32>& Indexes, ESBSortType SortType);
    TArray<int32> SortMaxImagineLevel(const TArray<FCharacterCraftRecepi>& Recepi, TArray<int32>& Indexes, ESBSortType SortType);
    TArray<FPlayerProfileSummaryData> SortCharacterSearchList(TArray<FPlayerProfileSummaryData>& PlayerList);
    TArray<int32> SortArray(TArray<int32>& Array, ESBSortType SortType);
    void SortAestheShopCharaPartsIconInfo(TArray<FSBAestheShopCharaPartsIconInfoForSort>& InInfo, TArray<FSBAestheShopCharaPartsIconInfoForSort>& Dest, ESBSortType InSortType);
    TArray<int32> SortAdventurerRankImagine(const TArray<FCharacterCraftRecepi>& Recepi, TArray<int32>& Indexes, ESBSortType SortType);
    TArray<int32> SortAdventurerRank(const TArray<FCharacterCraftRecepi>& Recepi, TArray<int32>& Indexes, ESBSortType SortType);
}; // Size: 0x28

class USBAssetDataHolder : public UObject
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBAssetManager : public UAssetManager
{
    TArray<class UObject*> LoadedLevels;                                              // 0x04A8 (size: 0x10)
    TArray<class UObject*> StoreAssets;                                               // 0x04B8 (size: 0x10)
    TSoftObjectPtr<USBBattleRegidentData> BattleRegidentData;                         // 0x04C8 (size: 0x28)
    TArray<class UObject*> BattleRegidentAssets;                                      // 0x04F0 (size: 0x10)

    bool Tick(const float InDeltaTime);
}; // Size: 0x568

class USBAttributeSlashDiskList : public UObject
{
    TArray<FSBAttributeSlashDisk> SlashDiskList;                                      // 0x0028 (size: 0x10)
    FSBEffectSetting GlitterModeSlashDisk;                                            // 0x0038 (size: 0x150)

}; // Size: 0x188

class USBAutoDeliveryQuestFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void QuestReadedCycleType(const class UObject* InWorldContextObject, ESBSeasonPassQuestCycleType InCycleType);
    void QuestReadedAll(const class UObject* InWorldContextObject);
    bool IsUpdateAutoDeliveryQuestCycleType(class UObject* InWorldContextObject, ESBSeasonPassQuestCycleType InCycleType);
    bool IsUpdateAutoDeliveryQuest(class UObject* InWorldContextObject);
    bool IsNewQuestStockCycleType(const class UObject* InWorldContextObject, ESBSeasonPassQuestCycleType InCycleType);
    bool IsNewQuestStockAll(const class UObject* InWorldContextObject);
    bool IsAutoDeliveryQuestUIQuestIdDraw();
    int32 GetProgressCount(const FSBSeasonPassQuestItemData& InItemData);
    void GetNowSeasonWeekStartDate(const class UObject* InWorldContextObject, const FDateTime& InSeasonStartDate, FDateTime& OutWeekStartDate);
    int32 GetNowSeasonWeekCount(class UObject* InWorldContextObject);
    int32 GetCompleteCount(const FSBSeasonPassQuestItemData& InItemData);
    void CreateNewMarkDataId(FString& OutMarkId, const FSBSeasonPassQuestItemData& InItem);
    bool AutoDeliveryQuest_IsOneWeekOver(const class UObject* InWorldContextObject, const FSBSeasonPassQuestItemData& InItemData);
}; // Size: 0x28

class USBAutoDeliveryQuestManager : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAutoLinkCreaterComponent : public UActorComponent
{
    char padding_0[0x148];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x148

class USBAutoPlayMap_Global : public UAutoPlayMap
{
    char padding_0[0xA0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xA0

class USBAutoPlayMap_Local : public UAutoPlayMap
{
    float CellSize;                                                                   // 0x0028 (size: 0x4)
    uint8 TileSize;                                                                   // 0x002C (size: 0x1)
    uint8 MapSize;                                                                    // 0x002D (size: 0x1)

}; // Size: 0x50

class USBAutoPlaySensor_Collision : public UAutoPlaySensor
{
    float Range;                                                                      // 0x0028 (size: 0x4)
    int32 NumLaser;                                                                   // 0x002C (size: 0x4)
    float RotationsPerSecond;                                                         // 0x0030 (size: 0x4)
    int32 NumTracePerSecond;                                                          // 0x0034 (size: 0x4)
    int32 MaxTracePerTick;                                                            // 0x0038 (size: 0x4)
    float LaserUpper;                                                                 // 0x003C (size: 0x4)
    float LaserLower;                                                                 // 0x0040 (size: 0x4)
    float HeightOffset;                                                               // 0x0044 (size: 0x4)

}; // Size: 0x90

class USBAutoPlayService_UpdateMap : public UAutoPlayService
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBAutoPlaySubsystem : public UGameInstanceSubsystem
{
    TMap<class FName, class FSoftClassPath> AgentClasses;                             // 0x0038 (size: 0x50)
    TMap<class FName, class FSoftClassPath> TaskClasses;                              // 0x0088 (size: 0x50)
    TMap<class FName, class TSubclassOf<UAutoPlayTask>> TaskClassesCache;             // 0x00D8 (size: 0x50)

    void StopAutoPlay();
    void ShowDebugAutoPlay();
    void SetAutoPlayMode(const FName& Mode);
    void APFarming(float Range);
    void APClearDungeon();
}; // Size: 0x190

class USBAutoPlayTask_BehaviorTree : public UAutoPlayTask
{
    FAIFwParameterizedBTRequest BehaviorTree;                                         // 0x0088 (size: 0x18)
    bool bLooping;                                                                    // 0x00A0 (size: 0x1)

    void SetBehaviorTree(const FAIFwParameterizedBTRequest& InBehaviorTree);
    void ReceiveTick(float DeltaTime);
    void ReceiveStop();
    void ReceiveStart(class UAIFwBlackboardComponent* BlackboardComponent);
    void OnPawnControllerChanged(class APawn* Pawn, class AController* Controller);
}; // Size: 0xB0

class USBAutoPlayTask_ClimbBase : public UAutoPlayTask_BlueprintBase
{
    FVector HighestPoint;                                                             // 0x0088 (size: 0xC)
    FVector LowestPoint;                                                              // 0x0094 (size: 0xC)

}; // Size: 0xA0

class USBAutoPlayTask_DestroyBase : public USBAutoPlayTask_BehaviorTree
{
    class AActor* Actor;                                                              // 0x00B0 (size: 0x8)

}; // Size: 0xB8

class USBAutoPlayTask_DirectMoveTo : public UAutoPlayTask
{
    char padding_0[0xB0];                                                             // 0x0000 (size: 0x0)

    void SetGoalLocation(const FVector& Location);
    void SetGoalActor(const class AActor* Actor);
    void SetAcceptanceRadius(float InAcceptanceRadius);
}; // Size: 0xB0

class USBAutoPlayTask_Explore : public UAutoPlayTask
{
    char padding_0[0x100];                                                            // 0x0000 (size: 0x0)

    void SetNavigationFilter(TSubclassOf<class UNavigationQueryFilter> Filter);
    void SetLookAt(bool bInLookAt);
    void SetGoalLocation(const FVector& Location);
    void SetGoalActor(const class AActor* Actor);
    void SetAcceptanceRadius(float InAcceptanceRadius);
    class UAutoPlayTask* RequestCustomTask(TSubclassOf<class UAutoPlayTask> TaskClass);
}; // Size: 0x100

class USBAutoPlayTask_ExploreTo : public USBAutoPlayTask_MoveTo
{
    char padding_0[0xF0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xF0

class USBAutoPlayTask_FinishTalk : public UAutoPlayTask
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAutoPlayTask_InputAction : public UAutoPlayTask
{
    char padding_0[0xA8];                                                             // 0x0000 (size: 0x0)

    void SetAction(ESBUIKeyConfigAction InAction, float InDuration);
}; // Size: 0xA8

class USBAutoPlayTask_Interact : public UAutoPlayTask
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBAutoPlayTask_LookAt : public UAutoPlayTask
{
    char padding_0[0xA8];                                                             // 0x0000 (size: 0x0)

    void SetLookAtLocation(const FVector& InLocation);
    void SetLookAtActor(const class AActor* InActor, FName InSocketName);
    void SetAcceptanceAngle(float Angle);
}; // Size: 0xA8

class USBAutoPlayTask_MoveTo : public UAutoPlayTask
{
    char padding_0[0xE8];                                                             // 0x0000 (size: 0x0)

    void SetNavigationFilter(TSubclassOf<class UNavigationQueryFilter> Filter);
    void SetLookAt(bool bInLookAt);
    void SetGoalLocation(const FVector& Location);
    void SetGoalActor(const class AActor* Actor);
    void SetAcceptanceRadius(float InAcceptanceRadius);
    class UAutoPlayTask* RequestCustomTask(TSubclassOf<class UAutoPlayTask> TaskClass);
}; // Size: 0xE8

class USBAutoPlayTask_StandbyBase : public USBAutoPlayTask_BehaviorTree
{
    FVector Center;                                                                   // 0x00B0 (size: 0xC)
    float Radius;                                                                     // 0x00BC (size: 0x4)

}; // Size: 0xC0

class USBAutoPlayTask_WarpBase : public USBAutoPlayTask_BehaviorTree
{
    FVector InteractionPoint;                                                         // 0x00B0 (size: 0xC)

}; // Size: 0xC0

class USBAutoStampData : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBAutoStampSaveData Data;                                                        // 0x0050 (size: 0x50)

}; // Size: 0xA0

class USBAutoWordComponent : public UActorComponent
{
    TArray<class AActor*> LastCauserList;                                             // 0x0118 (size: 0x10)
    char padding_0[0x10];                                                             // 0x0128 (size: 0x10)
    TSubclassOf<class USBAutoWordSetting> AutoWordSettingClass;                       // 0x0138 (size: 0x8)

    void NotifyUsedUltimateSkillPreparation();
    void NotifyUsedUltimateSkill();
    void NotifyUsableUltimateSkill();
    void NotifySpawn();
    void NotifyResurrection(TArray<class AActor*>& PlayerResurrectorList);
    void NotifyRespawn();
    void NotifyFreeze();
    void NotifyDead();
    void NotifyChangeHp(const float InCurrentHpRate, const float InAdjustValue, class AActor* InDamageCauser);
    bool IsEnableAutoWordEventType(EAutoWordEventType InEventType);
    bool IsActiveAutoWordEventType(EAutoWordEventType InEventType);
    TArray<EAutoWordEventType> GetEnableAutoWordEventTypeList();
    FSBAutoWordData GetAutoWordData(EAutoWordEventType InEventType);
}; // Size: 0x150

class USBAutoWordSetting : public UObject
{
    float PostTime;                                                                   // 0x0028 (size: 0x4)
    char padding_0[0x4];                                                              // 0x002C (size: 0x4)
    TMap<class EAutoWordEventType, class FSBAutoWordData> SBAutoWordDataMap;          // 0x0030 (size: 0x50)
    TArray<FName> FreezStatusList;                                                    // 0x0080 (size: 0x10)
    TArray<FName> ElementalLv3List;                                                   // 0x0090 (size: 0x10)
    float ElementalLv3DistanceMeter;                                                  // 0x00A0 (size: 0x4)

}; // Size: 0xA8

class USBAvaritiaOgreComponent : public USBEnemySpecializerComponent
{
    bool bIsHeadGuardMode;                                                            // 0x00B8 (size: 0x1)

    bool IsHeadGuardMode();
    void DeactivateHeadGuard();
    void ActivateHeadGuard(TSubclassOf<class ASBWeapon> AssetClass, TEnumAsByte<ESBWeaponAttach> WeaponAttach, FTransform Transform);
}; // Size: 0xC0

class USBBExportDataUtil : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsImportableVersion(int32 MajorVersionIn, int32 MinorVersionIn);
    void ImportCharaCreateJsonFromFile(FString FullFilePath, FString& CharaDataJsonOut, bool& IsSucceededOut);
    void ExportCharaCreateDataAsFile(FString FullFilePath, const FSBCharaCreateParameter& SBCharaCreateParameter);
}; // Size: 0x28

class USBBGMAkComponent : public UAkGameObject
{
    char padding_0[0x230];                                                            // 0x0000 (size: 0x0)

    void OnCallBackBGM(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
}; // Size: 0x230

class USBBGMAreaSoundComponent : public USphereComponent
{
    class UAkAudioEvent* SwitchMapIDEvent;                                            // 0x0488 (size: 0x8)

    void OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    void OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
}; // Size: 0x490

class USBBGMBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void StopUpdateInstanceAreaBGMController();
    void StopShopBGM();
    void StopFishingBGM();
    void StartWaveBattleOfInstanceAreaBGM();
    void SetOverrideBGMControllerMapType(FString BGMMapId, TEnumAsByte<ESBMapType> InMapType);
    void SetBGMRTPC(FString RTPCName, float RTPCValue);
    void SetBGMPriorityAreaID(int32 Priority, FString InAreaID);
    void SetBGMByLapOfTimeAttack(int32 LapNum);
    void SetBGMAreaID(FString InAreaID);
    void ResetBGMMapInfo(FString BGMMapId, TEnumAsByte<ESBMapType> OverrideMapType);
    void PostBGM(class UAkAudioEvent* Event);
    void PlayUpdateInstanceAreaBGMController();
    void PlayShopBGM();
    void PlayOutGameBGM();
    void PlayFishingBGM();
    void PlayArenaBGM(ESBArenaBGMType ArenaBGMType);
    bool IsBGMEventAsset(FString EventName);
    void EndWaveBattleOfInstanceAreaBGM();
    void ClearCurrentMapID();
    void ClearBGMAreaID();
}; // Size: 0x28

class USBBTAIQuery_NavRaycast : public UAIFwBTNode
{
    FAIFwBTNodePropertyString AgentName;                                              // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString StartKey;                                               // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyString EndKey;                                                 // 0x0080 (size: 0x20)
    TSubclassOf<class UNavigationQueryFilter> FilterClass;                            // 0x00A0 (size: 0x8)

}; // Size: 0xA8

class USBBTAIQuery_Trace : public UAIFwBTNode
{
    FAIFwBTNodePropertyString FromKey;                                                // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString ToKey;                                                  // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyFloat Extent;                                                  // 0x0080 (size: 0x18)

}; // Size: 0x98

class USBBTAdaptiveWalking : public UAIFwBTDecoratorNode
{
    FSBBTNodePropertyWalkingMode WalkingModeLow;                                      // 0x0038 (size: 0x18)
    FSBBTNodePropertyWalkingMode WalkingModeHigh;                                     // 0x0050 (size: 0x18)
    FAIFwBTNodePropertyFloat MaxTimeUntilArrival;                                     // 0x0068 (size: 0x18)

}; // Size: 0x80

class USBBTAdjustRootMotionFocusTarget : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString DirectionVectorBlackboardKey;                           // 0x0038 (size: 0x20)

}; // Size: 0x58

class USBBTAttackAction : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0038 (size: 0x20)

}; // Size: 0x58

class USBBTAttackOrder : public UAIFwBTNode
{
    FAIFwBTNodePropertyString OrderTargetKey;                                         // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString AttackTargetKey;                                        // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyFloat DurationTime;                                            // 0x0080 (size: 0x18)

}; // Size: 0x98

class USBBTAutoPlay_Explore : public USBBTRunAutoPlayTask
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0050 (size: 0x20)
    FAIFwBTNodePropertyFloat AcceptableRadius;                                        // 0x0070 (size: 0x18)
    FAIFwBTNodePropertyBool bAllowStrafe;                                             // 0x0088 (size: 0x18)
    FAIFwBTNodePropertyBool bAllowPartialPath;                                        // 0x00A0 (size: 0x18)

}; // Size: 0xB8

class USBBTAutoPlay_ExploreTo : public USBBTRunAutoPlayTask
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0050 (size: 0x20)
    TSubclassOf<class UNavigationQueryFilter> FilterClass;                            // 0x0070 (size: 0x8)

}; // Size: 0x78

class USBBTAutoPlay_FindPOI : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBBTAutoPlay_InputAction : public USBBTRunAutoPlayTask
{
    ESBUIKeyConfigAction Action;                                                      // 0x0050 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0051 (size: 0x7)
    FAIFwBTNodePropertyFloat DurationTime;                                            // 0x0058 (size: 0x18)

}; // Size: 0x70

class USBBTAutoPlay_LookAt : public USBBTRunAutoPlayTask
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0050 (size: 0x20)
    FAIFwBTNodePropertyFloat AcceptableAngle;                                         // 0x0070 (size: 0x18)

}; // Size: 0x88

class USBBTAutoPlay_MoveTo : public USBBTRunAutoPlayTask
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0050 (size: 0x20)
    FAIFwBTNodePropertyFloat AcceptableRadius;                                        // 0x0070 (size: 0x18)
    TSubclassOf<class UNavigationQueryFilter> FilterClass;                            // 0x0088 (size: 0x8)
    FAIFwBTNodePropertyBool bAllowStrafe;                                             // 0x0090 (size: 0x18)
    FAIFwBTNodePropertyBool bAllowPartialPath;                                        // 0x00A8 (size: 0x18)

}; // Size: 0xC0

class USBBTAutoPlay_UsePOI : public USBBTRunAutoPlayTask
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0050 (size: 0x20)

}; // Size: 0x70

class USBBTCanHitAttack : public UAIFwBTNode
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString ActionName;                                             // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyBool bDrawDebugInfo;                                           // 0x0080 (size: 0x18)

}; // Size: 0x98

class USBBTChangeBattleMode : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyBool bBattle;                                                  // 0x0068 (size: 0x18)
    FAIFwBTNodePropertyBool bInstantTransition;                                       // 0x0080 (size: 0x18)

}; // Size: 0x98

class USBBTCheckAnimTag : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString AnimTag;                                                // 0x0060 (size: 0x20)

}; // Size: 0x80

class USBBTCheckCollisionHitActor : public UAIFwBTNode
{
    FString BlackboardKey;                                                            // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBBTCheckCurrentStance : public UAIFwBTNode
{
    FAIFwBTNodePropertyString StanceName;                                             // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBBTCheckEffectiveStatusAilment : public UAIFwBTNode
{
    EAIFwBTBattleEffectiveType BattleEffectiveType;                                   // 0x0040 (size: 0x1)

}; // Size: 0x48

class USBBTCheckFrontNavigation : public UAIFwBTNode
{
    FAIFwBTNodePropertyFloat Length;                                                  // 0x0040 (size: 0x18)
    FAIFwBTNodePropertyBool Acceptance;                                               // 0x0058 (size: 0x18)
    FAIFwBTNodePropertyBool UseTrace;                                                 // 0x0070 (size: 0x18)
    FAIFwBTNodePropertyFloat Extent;                                                  // 0x0088 (size: 0x18)

}; // Size: 0xA0

class USBBTCheckGameTime : public UAIFwBTNode
{
    uint8 FromHour;                                                                   // 0x0040 (size: 0x1)
    uint8 FromMinute;                                                                 // 0x0041 (size: 0x1)
    uint8 ToHour;                                                                     // 0x0042 (size: 0x1)
    uint8 ToMinute;                                                                   // 0x0043 (size: 0x1)

}; // Size: 0x48

class USBBTCheckGameTimePeriod : public UAIFwBTNode
{
    ESBDayTime TimePeriod;                                                            // 0x0040 (size: 0x1)

}; // Size: 0x48

class USBBTCheckHPRate : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyFloat Value;                                                   // 0x0060 (size: 0x18)
    ESBBTComparison Comparison;                                                       // 0x0078 (size: 0x1)

}; // Size: 0x80

class USBBTCheckHeightDifference : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyFloat Value;                                                   // 0x0060 (size: 0x18)
    ESBBTComparison Comparison;                                                       // 0x0078 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0079 (size: 0x7)
    FAIFwBTNodePropertyBool bUseNavAgentLocation;                                     // 0x0080 (size: 0x18)
    FAIFwBTNodePropertyBool bUseAbs;                                                  // 0x0098 (size: 0x18)

}; // Size: 0xB0

class USBBTCheckNavigationRaycast : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBBTCheckUnderFootRaycast : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBBTComposite_Branch_If : public UBTCompositeNode
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBBTComposite_Branch_Random : public UBTCompositeNode
{
    char padding_0[0x98];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x98

class USBBTComposite_Branch_Switch : public UBTCompositeNode
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBBTConditionBlackboard_Actor : public UAIFwBTNode
{
    FAIFwBTNodePropertyString Key;                                                    // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString Value;                                                  // 0x0060 (size: 0x20)

}; // Size: 0x80

class USBBTCopyBBValue : public UAIFwBTNode
{
    FAIFwBTNodePropertyString ActorKey;                                               // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0060 (size: 0x20)

}; // Size: 0x80

class USBBTCorrectMoveSpeed : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyFloat CorrectRate;                                             // 0x0038 (size: 0x18)

}; // Size: 0x50

class USBBTDecoratorBase : public UBTDecorator
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBBTDecorator_BranchTag : public UBTDecorator
{
    bool m_bUseBBValue;                                                               // 0x0068 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0069 (size: 0x7)
    FBlackboardKeySelector m_bbkValue;                                                // 0x0070 (size: 0x28)
    float m_fWeight;                                                                  // 0x0098 (size: 0x4)

}; // Size: 0xA0

class USBBTDecorator_CheckDistance : public USBBTDecoratorBase
{
    FBlackboardKeySelector m_bbkTargetLoc;                                            // 0x0068 (size: 0x28)
    bool m_bUseBBKDistance;                                                           // 0x0090 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0091 (size: 0x7)
    FBlackboardKeySelector m_bbkDistance;                                             // 0x0098 (size: 0x28)
    float m_fDistance;                                                                // 0x00C0 (size: 0x4)
    float m_fMinDistance;                                                             // 0x00C4 (size: 0x4)
    bool m_bIgnoreZ;                                                                  // 0x00C8 (size: 0x1)

}; // Size: 0xD0

class USBBTDecorator_IsBattle : public USBBTDecoratorBase
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBBTDecorator_IsDead : public USBBTDecoratorBase
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBBTDisableInput : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0038 (size: 0x20)

}; // Size: 0x58

class USBBTDisableInteraction : public UAIFwBTDecoratorNode
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBBTDisableUpdateRateOptimizations : public UAIFwBTDecoratorNode
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBBTEnemySubmargedExit : public UAIFwBTDecoratorNode
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBBTEnemyTargetingUnderFoot : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString BlackBoradKey_UnderFootZMargin;                         // 0x0038 (size: 0x20)

}; // Size: 0x58

class USBBTEvaluationDot : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyFloat DotMin;                                                  // 0x0060 (size: 0x18)
    FAIFwBTNodePropertyFloat DotMax;                                                  // 0x0078 (size: 0x18)

}; // Size: 0x90

class USBBTFleeFrom : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyString BlackBoradKey_TargetActorOrLocation;                    // 0x0068 (size: 0x20)
    FAIFwBTNodePropertyFloat FleeDistance;                                            // 0x0088 (size: 0x18)
    FAIFwBTNodePropertyBool bAllowNotEnoughPath;                                      // 0x00A0 (size: 0x18)
    FAIFwBTNodePropertyFloat AcceptableMoveDistanceOfTarget;                          // 0x00B8 (size: 0x18)
    FAIFwBTNodePropertyString BlackBoradKey_NavQueryFilter;                           // 0x00D0 (size: 0x20)

}; // Size: 0xF0

class USBBTFlyingHeight : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyFloat FlyingHeight;                                            // 0x0038 (size: 0x18)

}; // Size: 0x50

class USBBTFollowingAnchor : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString BaseLocationKey;                                        // 0x0038 (size: 0x20)
    FAIFwBTNodePropertyString BaseVelocityActorKey;                                   // 0x0058 (size: 0x20)
    FAIFwBTNodePropertyFloat AnchorTime;                                              // 0x0078 (size: 0x18)
    FAIFwBTNodePropertyString AnchorKey;                                              // 0x0090 (size: 0x20)
    FAIFwBTNodePropertyBool IgnoreZVelocity;                                          // 0x00B0 (size: 0x18)

}; // Size: 0xC8

class USBBTFollowingWarp : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyString BlackBoradKey_TargetActorOrLocation;                    // 0x0068 (size: 0x20)
    FAIFwBTNodePropertyString BlackBoradKey_TargetRotation;                           // 0x0088 (size: 0x20)

}; // Size: 0xA8

class USBBTGiveOrders : public UAIFwBTNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBBTIgnorePushOut : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString Character;                                              // 0x0038 (size: 0x20)

}; // Size: 0x58

class USBBTIsAiming : public UAIFwBTNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBBTIsBlendAction : public UAIFwBTNode
{
    FAIFwBTNodePropertyString ActionName;                                             // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBBTLookAt : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyBool bEnabled;                                                 // 0x0038 (size: 0x18)
    FAIFwBTNodePropertyBool bUsingFocus;                                              // 0x0050 (size: 0x18)
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0068 (size: 0x20)
    FAIFwBTNodePropertyInt LookAtIndex;                                               // 0x0088 (size: 0x18)

}; // Size: 0xA0

class USBBTLookAt_UnderFootLocation : public USBBTLookAt
{
    FAIFwBTNodePropertyString BlackBoradKey_UnderFootZMargin;                         // 0x00A0 (size: 0x20)

}; // Size: 0xC0

class USBBTMakeNewOrder : public UAIFwBTNode
{
    FAIFwBTNodePropertyString MemberKey;                                              // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyBool bCanCancel;                                               // 0x0060 (size: 0x18)
    FAIFwBTNodePropertyString DebugName;                                              // 0x0078 (size: 0x20)

}; // Size: 0x98

class USBBTMoveGoalVelocity : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString GoalVelocityKey;                                        // 0x0038 (size: 0x20)

}; // Size: 0x58

class USBBTMoveToAttackTag : public UAIFwBTDecoratorNode
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBBTMoveToStaticContext : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0048 (size: 0x20)
    FAIFwBTNodePropertyFloat AcceptableRadius;                                        // 0x0068 (size: 0x18)
    TSubclassOf<class UNavigationQueryFilter> FilterClass;                            // 0x0080 (size: 0x8)
    FAIFwBTNodePropertyBool bAllowStrafe;                                             // 0x0088 (size: 0x18)
    FAIFwBTNodePropertyBool bAllowPartialPath;                                        // 0x00A0 (size: 0x18)
    FAIFwBTNodePropertyBool bReachTestIncludesAgentRadius;                            // 0x00B8 (size: 0x18)
    FAIFwBTNodePropertyBool bReachTestIncludesGoalRadius;                             // 0x00D0 (size: 0x18)

}; // Size: 0xE8

class USBBTNPCFinishTalk : public UAIFwBTDecoratorNode
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBBTNPCTalkTurnTo : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0068 (size: 0x20)
    FAIFwBTNodePropertyString Command;                                                // 0x0088 (size: 0x20)
    FAIFwBTNodePropertyString FailedLocationKey;                                      // 0x00A8 (size: 0x20)

}; // Size: 0xC8

class USBBTNPCTurnTo : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0068 (size: 0x20)

}; // Size: 0x88

class USBBTOrderBase : public UAIFwBTNode
{
    FAIFwBTNodePropertyString MemberKey;                                              // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBBTOrderCond_ActiveListener : public USBBTOrderBase
{
    FAIFwBTNodePropertyString ListenerKey;                                            // 0x0060 (size: 0x20)

}; // Size: 0x80

class USBBTOrderCond_HPRate : public USBBTOrderBase
{
    FAIFwBTNodePropertyString ActorKey;                                               // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyFloat HPRate;                                                  // 0x0080 (size: 0x18)
    ESBAIOrderConditionComparison ComparisonType;                                     // 0x0098 (size: 0x1)

}; // Size: 0xA0

class USBBTOrderCond_OrderedAttack : public USBBTOrderBase
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBBTOrderCond_Time : public USBBTOrderBase
{
    FAIFwBTNodePropertyFloat Time;                                                    // 0x0060 (size: 0x18)

}; // Size: 0x78

class USBBTOrderParam_Object : public USBBTOrderBase
{
    FAIFwBTNodePropertyString Name;                                                   // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyString ValueKey;                                               // 0x0080 (size: 0x20)

}; // Size: 0xA0

class USBBTOrderParam_ObjectArray : public USBBTOrderBase
{
    FAIFwBTNodePropertyString Name;                                                   // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyString ValueKey;                                               // 0x0080 (size: 0x20)

}; // Size: 0xA0

class USBBTOrderParam_String : public USBBTOrderBase
{
    FAIFwBTNodePropertyString Name;                                                   // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyString Value;                                                  // 0x0080 (size: 0x20)

}; // Size: 0xA0

class USBBTOrder_AreaRestriction : public USBBTOrderBase
{
    ESBAIActionAreaType Type;                                                         // 0x0060 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0061 (size: 0x7)
    FAIFwBTNodePropertyString OriginKey;                                              // 0x0068 (size: 0x20)
    FAIFwBTNodePropertyFloat Range;                                                   // 0x0088 (size: 0x18)

}; // Size: 0xA0

class USBBTOrder_CopyBBToParam : public USBBTOrderBase
{
    TArray<FString> Parameters;                                                       // 0x0060 (size: 0x10)

}; // Size: 0x70

class USBBTOrder_TacticalSkill : public USBBTOrderBase
{
    TSubclassOf<class USBAITacticalSkill> TacticalSkill;                              // 0x0060 (size: 0x8)

}; // Size: 0x68

class USBBTPreventPlanning : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyBool bPrevention;                                              // 0x0038 (size: 0x18)

}; // Size: 0x50

class USBBTRequestReplanningToCombatCoordinator : public UAIFwBTNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBBTRequiresComboToEndAttackHit : public UAIFwBTNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBBTRunAutoPlayTask : public UAIFwBTNode
{
    TSubclassOf<class UAutoPlayTask> TaskClass;                                       // 0x0040 (size: 0x8)
    bool bService;                                                                    // 0x0048 (size: 0x1)

    void ReceiveInitAutoPlayTask(class UAutoPlayTask* AutoPlayTask, const FAIFwBlackboard& Blackboard);
}; // Size: 0x50

class USBBTRunaway : public UAIFwBTRunAITask
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBBTSendAnimCommandWithAbility : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyString Command;                                                // 0x0068 (size: 0x20)
    FAIFwBTNodePropertyString SubCommand;                                             // 0x0088 (size: 0x20)

}; // Size: 0xB0

class USBBTSetEnemyTargetInfo : public UAIFwBTNode
{
    ESBEnemyTargetType TargetType;                                                    // 0x0040 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0041 (size: 0x7)
    FString BlackboardKey;                                                            // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBBTSortTargetInfo_CombineBit : public UAIFwBTNode
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBBTSquadOrder : public UAIFwBTNode
{
    FAIFwBTNodePropertyString MemberKey;                                              // 0x0040 (size: 0x20)
    class USBAICommand* Order;                                                        // 0x0060 (size: 0x8)
    TArray<FString> Parameters;                                                       // 0x0068 (size: 0x10)

}; // Size: 0x78

class USBBTStoreActionArea : public UAIFwBTNode
{
    FAIFwBTNodePropertyString AreaOriginKey;                                          // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString AreaRadiusKey;                                          // 0x0060 (size: 0x20)

}; // Size: 0x80

class USBBTStoreEstimatedLocation : public UAIFwBTNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString ActorKey;                                               // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyFloat Time;                                                    // 0x0080 (size: 0x18)
    FAIFwBTNodePropertyString ActionName;                                             // 0x0098 (size: 0x20)

}; // Size: 0xB8

class USBBTStoreLastKnownLocation : public UAIFwBTNode
{
    FAIFwBTNodePropertyString ActorKey;                                               // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0060 (size: 0x20)

}; // Size: 0x80

class USBBTStoreRelativeLocation : public UAIFwBTNode
{
    FAIFwBTNodePropertyString Key;                                                    // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyFloat Offset;                                                  // 0x0060 (size: 0x18)
    FAIFwBTNodePropertyFloat Angle;                                                   // 0x0078 (size: 0x18)

}; // Size: 0x90

class USBBTSuperFastMoveTo : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyString Command;                                                // 0x0068 (size: 0x20)
    FAIFwBTNodePropertyString BlackBoradKey_TargetActorOrLocation;                    // 0x0088 (size: 0x20)
    FAIFwBTNodePropertyFloat OffsetDistance;                                          // 0x00A8 (size: 0x18)
    FAIFwBTNodePropertyFloat AcceptableMoveDistanceOfTarget;                          // 0x00C0 (size: 0x18)

}; // Size: 0xD8

class USBBTTSRunMappedQuery : public UAIFwBTRunPerceptionTree
{
    FAIFwBTNodePropertyString Key;                                                    // 0x0088 (size: 0x20)

}; // Size: 0xA8

class USBBTTask_SendAnimCommand : public UBTTaskNode
{
    FName Command;                                                                    // 0x0070 (size: 0x8)

}; // Size: 0x78

class USBBTTask_SetBattleState : public UBTTaskNode
{
    bool bEnable;                                                                     // 0x0070 (size: 0x1)

}; // Size: 0x78

class USBBTTask_SetEnemyTargetInfo : public UBTTaskNode
{
    ESBEnemyTargetType TargetType;                                                    // 0x0070 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0071 (size: 0x7)
    FBlackboardKeySelector TargetKey;                                                 // 0x0078 (size: 0x28)

}; // Size: 0xA0

class USBBTTask_SetProjectileTarget : public UBTTaskNode
{
    FString ProjectileTargetKey;                                                      // 0x0070 (size: 0x10)
    FBlackboardKeySelector ProjectileTargetKey_UE4;                                   // 0x0080 (size: 0x28)

}; // Size: 0xA8

class USBBTTask_UpdateBattleState : public UBTTaskNode
{
    TArray<FBlackboardKeySelector> PerceptedActorKeys;                                // 0x0070 (size: 0x10)

}; // Size: 0x80

class USBBTToggleSense : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString SenseTag;                                               // 0x0038 (size: 0x20)
    FAIFwBTNodePropertyBool bEnabled;                                                 // 0x0058 (size: 0x18)

}; // Size: 0x70

class USBBTTurnTo : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0068 (size: 0x20)

}; // Size: 0x88

class USBBTWaitForAiming : public UAIFwBTNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBBTWaitForAnimation : public UAIFwBTRunAITask
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBBTWaitForWarpTiming : public UAIFwBTNode
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBBTWalkingMode : public UAIFwBTDecoratorNode
{
    FSBBTNodePropertyWalkingMode WalkingMode;                                         // 0x0038 (size: 0x18)

}; // Size: 0x50

class USBBTWalkingModeByMinSpeed : public USBBTWalkingMode
{
    FAIFwBTNodePropertyFloat MinSpeed;                                                // 0x0050 (size: 0x18)
    FAIFwBTNodePropertyBool bUseHighestModeIfFailed;                                  // 0x0068 (size: 0x18)

}; // Size: 0x80

class USBBTWarpMoveTo : public UAIFwBTRunAITask
{
    FAIFwBTNodePropertyString BlackBoradKey_TargetActorOrLocation;                    // 0x0068 (size: 0x20)
    FSBBTNodePropertyWarpDirectionType WarpDirectionType;                             // 0x0088 (size: 0x18)

}; // Size: 0xA0

class USBBalloonWindow : public UUserWidget
{
    FSBBalloonWindowEndDelegate EndDelegate;                                          // 0x0278 (size: 0x10)
    void EndDelegate(class USBBalloonWindow* InBalloonWindow);

    void Terminate();
    void Show(const FSBBalloonWindowRequest& InRequest, bool isForce);
    void SetUseCamera(bool IsFlag);
    void SetRoundPosition(bool IsFlag);
    void SetIgnoreInput(bool IsFlag);
    void SetHide(bool IsFlag);
    void PlayAnimOut();
    void PlayAnimIn();
    void OnTick();
    void OnShow(const FSBBalloonWindowRequest& InRequest);
    bool IsUseCamera();
    bool IsRoundPosition();
    bool IsIgnoreInput();
    void Hide();
    void EndDelegate__DelegateSignature(class USBBalloonWindow* InBalloonWindow);
    void CallEndDelegate(bool bInClear);
}; // Size: 0x290

class USBBalloonWindowComponent : public UActorComponent
{
    int32 RenderTargetSizeX;                                                          // 0x00B8 (size: 0x4)
    int32 RenderTargetSizeY;                                                          // 0x00BC (size: 0x4)
    char padding_0[0x8];                                                              // 0x00C0 (size: 0x8)
    class UTextureRenderTarget2D* RenderTarget;                                       // 0x00C8 (size: 0x8)

    void ShowWindow(FString InText);
    void SetForceShow(bool IsFlag);
    void OnCloseWindow(class USBBalloonWindow* InWindow);
}; // Size: 0xD8

class USBBattleBPFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetEffectParamForIdentificationFriendOrFoe(class UParticleSystemComponent* PS, const class AActor* InstigatorActor, bool bHeal);
    bool RequestPlayerDeactivateReverberationGodMode(class ASBPlayerCharacter* PlayerCharacter);
    bool RequestPlayerDeactivateGodMode(class ASBPlayerCharacter* PlayerCharacter, ESBGodModeType GodModeType, bool bReverberation);
    bool RequestPlayerActivateGodMode(class ASBPlayerCharacter* PlayerCharacter, ESBGodModeType GodModeType);
    void RequestFinishCutInImagine(class AActor* Instigator);
    bool IsShieldThroughDefenceIncludeAttackType(ESBDamageAttackType AttackType, const FSBDefenceGuardConfig& Defence);
    bool IsShieldDefenceIncludeAttackType(ESBDamageAttackType AttackType, const FSBDefenceGuardConfig& Defence);
    bool IsPlayerSameParty(const class AActor* Owner, const class AActor* Target);
    bool IsPlayerIsInBattle(class UObject* WorldContextObject);
    bool IsLocalHitAuthority(class AActor* Owner);
    bool IsInParty(const class AActor* Owner);
    bool IsHostile(const class AActor* Owner, const class AActor* Target);
    bool IsExistPlayerBlockCollision(const class ASBPlayerCharacter* PlayerCharacter, FVector Direction, float Distance, float SphereRadius);
    bool IsDelegateHitAuthority(class AActor* Owner);
    bool IsCharacterWalking(const class ACharacter* Character);
    bool IsBattleStatusEffectiveFlag(class AActor* Owner, ESBAbilityFlags Flag);
    bool IsAllyOrMyself(const class AActor* Owner, const class AActor* Target);
    bool IsAlly(const class AActor* Owner, const class AActor* Target);
    float GetPlayerDiedCountDown(class UObject* WorldContextObject, int32 TeamNumber);
    float GetCapsuleToTargetDistanceXY(const class AActor* Actor, const class USBTargetableComponent* OtherComp);
    float GetCapsuleToLocationDistanceXY(const class AActor* Actor, const FVector& Location);
    float GetCapsuleToCapsuleDistanceXY(const class AActor* Actor, const class AActor* OtherActor);
    float GetCapsuleSize(const class AActor* Actor);
    class UDataTable* GetBattleStatusDataTableSerchByName(FName AssetName);
    FVector GetAttackMoveDestination(const class ASBPlayerCharacter* PlayerCharacter, const float MaxRange, const int32 MoveSpeedRateAffectType, const float RangeOffset, const bool bSetNoTargetRange, const float NoTargetRange, const float NoTargetHeightOffset, ESBAttackMoveDestinationHeight HeightType, const float BlockingCheckRadius, const bool bOverrideBlockingCheckPitch, const float BlockingCheckPitch, const float TargetHeightLimit);
    void GetAllBattleStatusDataTable(TArray<class UDataTable*>& Tables, TArray<FName>& Names);
    void CreateEffectDynamicMaterialInstance(class UParticleSystemComponent* PS);
    float ComvertAddElementResistRate(float InValue);
    bool CanAttack(const class AActor* Owner, const class AActor* Target);
    void ApplyFixDamageBySystem(int32 AttackID, class AActor* DamagedActor, float SendDamageValue, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass, FSBAttackStunSetting StunSetting);
    void ApplyFixDamageByAttackID(int32 AttackID, class AActor* DamagedActor, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass, FSBAttackStunSetting StunSetting);
    void ApplyFixDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass, FSBAttackStunSetting StunSetting);
    void ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass, FSBAttackStunSetting StunSetting);
}; // Size: 0x28

class USBBattleCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void PrintDuplicateIDOfBattleStatusTable();
}; // Size: 0x28

class USBBattleContentsHUD : public USBUserWidget
{
    class USBCharacterCardHUD* CharacterCardHUD;                                      // 0x02B0 (size: 0x8)

    void SetVisibleCharacterCard(bool isForce, bool InIsVisible);
    void SetVisibilityHUD(bool TrueIsVisible);
    void SetupCharacterCard();
    void OnUnbind();
    void OnTerminate();
    void OnMapLevelInfoInitialized();
    void OnInitialize();
    void OnBind();
    class UUserWidget* GetCurrentHUD();
    bool GetCharacterCardVisibility();
    void CloseCharacterCard();
}; // Size: 0x2D0

class USBBattleManager : public UObject
{
    TSubclassOf<class USBDamageType> m_DefaultDamageType;                             // 0x0028 (size: 0x8)
    class USBDamageType* m_DefaultDamageTypeCache;                                    // 0x0030 (size: 0x8)
    class UCurveFloat* LevelCoefficientDamageModifyCurve;                             // 0x0038 (size: 0x8)
    TSubclassOf<class ASBReplicateTestActor> TestReplicateActor;                      // 0x0040 (size: 0x8)
    TArray<int32> m_StunLevelList;                                                    // 0x0048 (size: 0x10)
    float m_StunResetTime;                                                            // 0x0058 (size: 0x4)
    float StunDamageDecreaseSpeed;                                                    // 0x005C (size: 0x4)
    class UCurveFloat* BackHitStunPercentCurve;                                       // 0x0060 (size: 0x8)
    float ElementGaugeResetTime;                                                      // 0x0068 (size: 0x4)
    char padding_0[0x4];                                                              // 0x006C (size: 0x4)
    class UCurveFloat* ElementResistanceDamageRateCurve;                              // 0x0070 (size: 0x8)
    class UCurveFloat* ElementResistanceElementAccumulationRateCurve;                 // 0x0078 (size: 0x8)
    int32 OppositeElementStatusAilmentDamageAddRate;                                  // 0x0080 (size: 0x4)
    int32 SameElementStatusAilmentDamageAddRate;                                      // 0x0084 (size: 0x4)
    TMap<ESBAttribute, float> PlayerElementBurstBonusTimeList;                        // 0x0088 (size: 0x50)
    TMap<ESBAttribute, float> EnemyElementBurstBonusTimeList;                         // 0x00D8 (size: 0x50)
    TArray<FSBElementBurstBonusLevelSetting> PlayerElementalBurstBonusLevelList;      // 0x0128 (size: 0x10)
    TArray<FSBElementBurstBonusLevelSetting> EnemyElementalBurstBonusLevelList;       // 0x0138 (size: 0x10)
    class UCurveFloat* AttackAttributeTypeResistanceDamageRateCurve;                  // 0x0148 (size: 0x8)
    float CenterExplosionGuardDistance;                                               // 0x0150 (size: 0x4)
    float KnockBackBaseDistance;                                                      // 0x0154 (size: 0x4)
    TMap<ESBHitKnockBackPower, float> KnockBackPowerList;                             // 0x0158 (size: 0x50)
    TMap<ESBHitKnockBackTime, float> KnockBackTimeList;                               // 0x01A8 (size: 0x50)
    TArray<FSBKnockBackWeightClass> KnockBackWeightClassList;                         // 0x01F8 (size: 0x10)
    float KnockBackDistanceFloatScale;                                                // 0x0208 (size: 0x4)
    float KnockBackTimeFloatScale;                                                    // 0x020C (size: 0x4)
    float KnockBackDistanceLieOnGroundScale;                                          // 0x0210 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0214 (size: 0x4)
    class UCurveFloat* m_KnockBackCurve;                                              // 0x0218 (size: 0x8)
    TArray<FSBGuardKnockBackSetting> GuardKnockBackSettingList;                       // 0x0220 (size: 0x10)
    TArray<FSBHitSlomoCurveSetting> HitSlomoSettingList;                              // 0x0230 (size: 0x10)
    TArray<FSBSplitDamageUESetting> SplitDamageUISettingList;                         // 0x0240 (size: 0x10)
    TMap<class ESBPartyChainSettingType, class FSBPartyChainSettingParam> PartyChainSettingMap; // 0x0250 (size: 0x50)

    int32 GetStunValueBP(ESBAttribute ElementType, int32 StunLevel);
}; // Size: 0x2A0

class USBBattleMenu : public UUserWidget
{
    TArray<FSBLobbyEntry> LobbyList;                                                  // 0x0278 (size: 0x10)

    void OnJoinRoom();
    void OnFindRoomsCompleted(bool IsExists);
    void OnCreateRoom();
    bool JoinRoom(int32 SessionIndex);
    bool FindRooms();
    bool CreateRoom(FName DungeonId);
    bool CloseRoom();
}; // Size: 0x2D0

class USBBattleRegidentData : public UPrimaryDataAsset
{
    TSoftClassPtr<ASBBattleHUD> BattleHUD;                                            // 0x0030 (size: 0x28)
    TSoftClassPtr<ASBPlayerCharacter> PlayerCharacter;                                // 0x0058 (size: 0x28)
    TSoftClassPtr<ASBEnemyCharacter> EnemyCharacter;                                  // 0x0080 (size: 0x28)
    TSoftClassPtr<ASBNpcCharacter> NpcCharacter;                                      // 0x00A8 (size: 0x28)
    TSoftClassPtr<ASBSkySphere> SkySphere;                                            // 0x00D0 (size: 0x28)

}; // Size: 0xF8

class USBBattleStatusComponent : public UActorComponent
{
    FSBBattleStatusComponentOnClientRecieveBattleStatusDelegete OnClientRecieveBattleStatusDelegete; // 0x00C8 (size: 0x10)
    void OnClientRecieveBattleStatusDelegete();
    FSBBattleStatusComponentOnClientSendEffectiveBattleStatusParamDelegete OnClientSendEffectiveBattleStatusParamDelegete; // 0x00D8 (size: 0x10)
    void OnClientSendEffectiveBattleStatusParamDelegete(const FSBEffectiveStatusParam& StatusParam, bool bUpdateBaseStatus);
    FSBBattleStatusComponentOnClientSendImportantBattleEffectiveDelegete OnClientSendImportantBattleEffectiveDelegete; // 0x00E8 (size: 0x10)
    void OnClientSendImportantBattleEffectiveDelegete(const FSBEffectiveImpotantStatusParam& PrevParam, const FSBEffectiveImpotantStatusParam& NewParam);
    FSBBattleStatusComponentOnCreateTriggerPartsDelegete OnCreateTriggerPartsDelegete; // 0x00F8 (size: 0x10)
    void OnCreateTriggerPartsDelegete();
    FSBBattleStatusComponentOnOverrideTriggerPartsDelegete OnOverrideTriggerPartsDelegete; // 0x0108 (size: 0x10)
    void OnOverrideTriggerPartsDelegete();
    TArray<FDataTableRowHandle> StatusAilmentBuildResourceHandleList;                 // 0x0118 (size: 0x10)
    TArray<class UDataTable*> BattleStatusBuildResourceLists;                         // 0x0128 (size: 0x10)
    TArray<class UDataTable*> BattleStatusEffectBuildResourceTables;                  // 0x0138 (size: 0x10)
    TArray<FSBPassiveHandle> PassiveHandles;                                          // 0x0148 (size: 0x10)
    TArray<FSBDynamicTriggerData> DynamicTriggerDataList;                             // 0x0158 (size: 0x10)
    TArray<FSBEffectiveStatusAilment> EffectiveStatusList;                            // 0x0168 (size: 0x10)
    FSBEffectiveStatusParam StoreEquipEffectiveStatusParam;                           // 0x0178 (size: 0x2E8)
    FSBEffectiveStatusParam StoreNoBillingEffectiveStatusParam;                       // 0x0460 (size: 0x2E8)
    FSBEffectiveStatusParam EffectiveStatusParam;                                     // 0x0748 (size: 0x2E8)
    FSBEffectiveStatusParam EffectiveStatusParamDummy;                                // 0x0A30 (size: 0x2E8)
    FSBEffectiveImpotantStatusParam EffectiveImportantStatusParam;                    // 0x0D18 (size: 0x34)

    void Server_UpdateDynamicTriggerData(ESBAbilityDynamicTriggerType DynamicTriggerType);
    void Server_SendDeactiveStatusGroupByInteraction();
    void Server_DebugSetEnemyAbility(class ASBEnemyCharacter* pEnemy, int32 InAbilityID, int32 InTime);
    void OnRep_EffectiveStatusParam(const FSBEffectiveStatusParam& PrevParam);
    void OnRep_EffectiveStatusList();
    void OnRep_EffectiveImportantStatusParam(const FSBEffectiveImpotantStatusParam PrevParam);
    void OnOverrideTriggerPartsDelegete__DelegateSignature();
    void OnCreateTriggerPartsDelegete__DelegateSignature();
    void OnClientSendImportantBattleEffectiveDelegete__DelegateSignature(const FSBEffectiveImpotantStatusParam& PrevParam, const FSBEffectiveImpotantStatusParam& NewParam);
    void OnClientSendEffectiveBattleStatusParamDelegete__DelegateSignature(const FSBEffectiveStatusParam& StatusParam, bool bUpdateBaseStatus);
    void OnClientRecieveBattleStatusDelegete__DelegateSignature();
    void OnCharacterDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void MulticastExtendTimeNegativeEffectiveStatus();
    void Multicast_SendStunEvent();
    void Multicast_SendImportantBattleEffective(const FSBEffectiveImpotantStatusParam& PrevParam, const FSBEffectiveImpotantStatusParam& NewParam);
    void Multicast_SendFreezeEvent();
    void Multicast_SendFlashStunEvent();
    void Multicast_SendExtendTimeEffectiveStatus(uint8 EffectiveUniqueHandle, int64 LimitTimeTicks);
    void Multicast_SendDeactivateEffectiveStatus(uint8 EffectiveUniqueHandle, ESBEffectiveStatusDeactiveReason DeactiveReason);
    void Multicast_SendDeactivateAbility(uint8 abilityUniqueHandle);
    void Multicast_NotifyEffectiveStatusToClient(const TArray<FSBEffectiveStatusAilment>& UpdateStatusArray);
    void Multicast_FailureBattleStatusByResist(ESBFailureUpdateBattleStatusOneReason Reason, ESBStatusAilmentIconType FailureIconType);
    bool IsRegisterEffectiveStatusList(const FDataTableRowHandle NewStatus);
    bool IsEffectiveStatusGroup(const ESBBattleEffectiveGroup Group);
    bool IsEffectiveStatusAliment(const ESBBattleEffective Status);
    bool IsEffectiveStatusAilmentHandle(const FDataTableRowHandle CheckStatus, class AActor* Invoker);
    bool IsEffectiveAbilityOnlyPlayerStatus(ESBAbilityOnlyPlayerStatus PlayerStatus);
    bool IsBattleEffectiveGroup(const ESBBattleEffectiveGroup Group);
    bool IsBattleEffectiveFlag(ESBAbilityFlags Flag);
    TArray<FSBStatusAilmentIconConfig> GetGatherCurrentStatusAilmentIcons();
    void DebugServer_ActiveAbilityID(FSBAbilityMasterID AbilityID, int32 Parts1Variable1, int32 Parts1Variable2, int32 Parts2Variable1, int32 Parts2Variable2, int32 Time, class AActor* Causer, class AActor* Receiver, ESBAbilityRequestSource RequestType, int32 ItemId);
    void ClientSetDebugCacheBattleStatusResist(const TArray<ESBBattleStatusResistType>& NewTypeList, const TArray<int32>& NewValueList);
}; // Size: 0xF78

class USBBattleStatusManager : public UObject
{
    TArray<class UDataTable*> RegisterBattleStatusTables;                             // 0x0028 (size: 0x10)
    TArray<class UDataTable*> RegisterBattleStatusTablesRedident;                     // 0x0038 (size: 0x10)
    class UDataTable* StatusCommonTable;                                              // 0x0048 (size: 0x8)
    class UDataTable* StatusMapGimmickTable;                                          // 0x0050 (size: 0x8)
    class UDataTable* BattleStatusEffectTable;                                        // 0x0058 (size: 0x8)
    TArray<class UDataTable*> BattleStatusProjectileTables;                           // 0x0060 (size: 0x10)
    class UDataTable* AbilityConditionTable;                                          // 0x0070 (size: 0x8)
    class UDataTable* AbilityTable;                                                   // 0x0078 (size: 0x8)
    TMap<class ESBBattleEffectiveGroup, class FSBAbilityGroupConfig> AbilityGroups;   // 0x0080 (size: 0x50)
    TMap<class ESBAbilityLimitType, class TSubclassOf<USBAbilityLimit>> AbilityLimitParamObjects; // 0x00D0 (size: 0x50)
    TArray<float> BattleStatusTimeExtendList;                                         // 0x0120 (size: 0x10)
    float FearDistance;                                                               // 0x0130 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0134 (size: 0x4)
    TArray<FSBAccumulationResistSetting> AccumulationResists;                         // 0x0138 (size: 0x10)
    TMap<class ESBAbilityCalcSuccessRate, class ESBAbilityControlBadCondition> ControlBadConditions; // 0x0148 (size: 0x50)
    class UCurveFloat* AbilitySuccessCorrectionTable;                                 // 0x0198 (size: 0x8)

    void RequestBattleItemEffectByName(class ACharacter* SBChara, FName RowName);
    void RegisterBattleStatusTable(class UDataTable* Table);
    FDataTableRowHandle GetStatusCommonHandle(const FName RowName);
}; // Size: 0x1A0

class USBBerserkerBerserkModeSkill : public USBSkillInfoClass
{
    TArray<FSBActiveArtsID> ActiveArtsList;                                           // 0x02A0 (size: 0x10)
    TArray<FSBBerserkerBerserkModeComboGaugeModifyDamageUpSetting> ComboGaugeModifyDamageUpSettingList; // 0x02B0 (size: 0x10)

}; // Size: 0x2C0

class USBBerserkerBerserkModeSkillRecastDownPassiveSkill : public USBPlayerPassiveSkill
{
    float ModifyTime;                                                                 // 0x0040 (size: 0x4)

}; // Size: 0x48

class USBBerserkerBloodAxeSkill : public USBSkillInfoClass
{
    FDataTableRowHandle StatusRowHandle;                                              // 0x02A0 (size: 0x10)
    TArray<FSBConditionCheckFloatParam> TimeUpComboGaugeRecoveryList;                 // 0x02B0 (size: 0x10)
    TArray<FSBConditionCheckFloatParam> DamageUpSettingList;                          // 0x02C0 (size: 0x10)

}; // Size: 0x2D0

class USBBerserkerBoneCutSkill : public USBBerserkerSkillInfo
{
    FSBPlayerSkillChargeSetting ChargeSkillSetting;                                   // 0x02D0 (size: 0x28)

}; // Size: 0x2F8

class USBBerserkerBrutalBlowSkill : public USBBerserkerSkillInfo
{
    FSBPlayerSkillChargeSetting ChargeSkillSetting;                                   // 0x02D0 (size: 0x28)

}; // Size: 0x2F8

class USBBerserkerEngramAbsorbSkill : public USBBerserkerSkillInfo
{
    FSBPlayerSkillChargeSetting ChargeSkillSetting;                                   // 0x02D0 (size: 0x28)

}; // Size: 0x2F8

class USBBerserkerMoveSpeedUpWhileFullComboGaugePassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBConditionCheckFloatParam> MoveSpeedRateSettingList;                     // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBBerserkerPartyChainDrainPassiveSkill : public USBPlayerPassiveSkill
{
    FSBPassiveArtsID PassiveArtsID;                                                   // 0x0040 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0044 (size: 0x4)
    TArray<FSBBerserkerPartyChainDrainSetting> PartyChainDrainSettingList;            // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBBerserkerRoundBlowSkill : public USBBerserkerSkillInfo
{
    float LoopStamina;                                                                // 0x02C8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02CC (size: 0x4)
    TArray<FSBConditionCheckFloatParam> LoopStaminaModifyList;                        // 0x02D0 (size: 0x10)

}; // Size: 0x2E0

class USBBerserkerSkillInfo : public USBSkillInfoClass
{
    TArray<FSBBerserkerComboGaugeCastSetting> SkillCastComboGaugeChangeList;          // 0x02A0 (size: 0x10)
    TArray<FSBBerserkerConsumeComboAttackSetting> ConsumeComboAttackSettingList;      // 0x02B0 (size: 0x10)
    ESBBerserkerConsumeComboTiming ConsumeComboAttackConsumeTiming;                   // 0x02C0 (size: 0x1)

}; // Size: 0x2C8

class USBBlackListComponent : public USBPlayerPropertyComponent
{
    class USBChatMessage* TmpMessage;                                                 // 0x00B8 (size: 0x8)
    FSBBlackListComponentOnCheckBlockStatus OnCheckBlockStatus;                       // 0x00C0 (size: 0x10)
    void OnCheckBlockStatus(const bool bCheckBlockStatus);
    FSBBlackListComponentOnIsBlackListed OnIsBlackListed;                             // 0x00D0 (size: 0x10)
    void OnIsBlackListed(const bool bIsBlackListed);

    void Server_UpdateBlackListedInfos();
    void Server_RegisterBlockList(FString TargetId);
    void Server_CheckBlockStatus(FString TargetId);
    void Server_CheckBlockedMyCharacter(FString AddedPlayerCharacterId);
    void RequestNotifyUnBlackListedPlayer(FString CharacterId);
    void RequestNotifyBlackListedPlayer(FString CharacterId);
    ESBIsRquestBlackListResult Request_IsBlackListed(FString Target);
    void RegisterBlockList(FString TargetId, class USBChatMessage* Message);
    void OnIsBlackListed__DelegateSignature(const bool bIsBlackListed);
    void OnCheckBlockStatus__DelegateSignature(const bool bCheckBlockStatus);
    void Client_UpdateBlackListedInfos(const TArray<FString>& BlackListedInfos);
    void Client_RegisterBlockList(bool IsSuccessed, FString TargetId, const bool IsBlocked, const bool IsPlatformBlocked, const bool IsPSOnlyDiff);
    void Client_CheckBlockStatus(bool IsSuccessed, FString TargetId, const bool IsBlocked, const bool IsPlatformBlocked);
    void Client_CheckBlockedMyCharacter(FString AddedPlayerCharacterId, const bool IsBlocked, const bool IsPlatformBlocked);
    void CheckBlockStatus(FString TargetId);
}; // Size: 0xE8

class USBBlasterChargeShootSkillInfo : public USBBlasterShootSkillInfo
{
    FSBBlasterSkillChargeSetting ChargeSkillSetting;                                  // 0x02D0 (size: 0x28)
    TArray<FSBBlasterWeakPointHitDamageUpSetting> WeakPointHitDamageUpSettingList;    // 0x02F8 (size: 0x10)

}; // Size: 0x308

class USBBlasterDodgeSkillInfo : public USBBlasterShootSkillInfo
{
    TArray<FSBCurveMoveSetting> CurveMoveSettingList;                                 // 0x02D8 (size: 0x10)
    FName DodgeSucceededCharacterMaterial;                                            // 0x02E8 (size: 0x8)
    TArray<FSBConditionCheckParam> DodgeSuccessAttackConditionList;                   // 0x02F0 (size: 0x10)

}; // Size: 0x300

class USBBlasterElementSpreadShotSkill : public USBBlasterChargeShootSkillInfo
{
    FSBAttackID AttackID;                                                             // 0x0308 (size: 0x4)
    char padding_0[0x4];                                                              // 0x030C (size: 0x4)
    TArray<FSBBlasterElementSpreadProjectileSetting> ElementSpreadProjectileSettingList; // 0x0310 (size: 0x10)
    TArray<FSBBlasterElementSpreadAccumulationSetting> ElementSpreadAccumulationSettingList; // 0x0320 (size: 0x10)
    bool IsSpreadDuringElementalBurst;                                                // 0x0330 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0331 (size: 0x7)
    TArray<FSBBlasterBattleStatusSpreadSetting> BattleStatusSpreadSettingList;        // 0x0338 (size: 0x10)

}; // Size: 0x348

class USBBlasterGravityGrenadeSkill : public USBBlasterChargeShootSkillInfo
{
    TArray<FDataTableRowHandle> SpecialHandleList;                                    // 0x0308 (size: 0x10)

}; // Size: 0x318

class USBBlasterHatTrickSkillInfo : public USBBlasterSkillInfo
{
    TArray<FSBBlasterHatTrickSetting> HatTrickSettingList;                            // 0x02B0 (size: 0x10)
    TArray<FSBBlasterHatTrickWeakPointHitDamageModifySetting> HatTrickWeakPointHitDamageModifySettingList; // 0x02C0 (size: 0x10)

}; // Size: 0x2D0

class USBBlasterHatTrickWeakPointHitCriticalPassiveSkill : public USBPlayerPassiveSkill
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBBlasterMarkerShootSkill : public USBBlasterChargeShootSkillInfo
{
    FSBSkillMarkerSetting MarkerSetting;                                              // 0x0310 (size: 0x70)

}; // Size: 0x380

class USBBlasterMultiShotSkill : public USBBlasterShootSkillInfo
{
    char padding_0[0x2C8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2C8

class USBBlasterRegularBuffArrowSkill : public USBBlasterShootSkillInfo
{
    float GaugeAmountBaseMultiplier;                                                  // 0x02D0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02D4 (size: 0x4)
    TArray<float> GaugeAmountSkillLevelMultiplierList;                                // 0x02D8 (size: 0x10)
    TArray<FSBBlasterGaugeAmountAddSetting> GaugeAmountAddSettingList;                // 0x02E8 (size: 0x10)
    TArray<FSBBlasterGaugeAmountWeakPointHitMultiplierSetting> GaugeAmountWeakPointHitMultiplierSettingList; // 0x02F8 (size: 0x10)
    float GaugeAmountCriticalHitMultiplier;                                           // 0x0308 (size: 0x4)
    float GaugeAmountResetTime;                                                       // 0x030C (size: 0x4)
    FSBSkillMarkerSetting MarkerSetting;                                              // 0x0310 (size: 0x70)
    TArray<FSBRegularBuffArrowLevelSetting> GaugeLevelSettingList;                    // 0x0380 (size: 0x10)
    float MaxGaugeAmount;                                                             // 0x0390 (size: 0x4)

}; // Size: 0x398

class USBBlasterShootSkillInfo : public USBBlasterSkillInfo
{
    TArray<FSBBlasterHoldingArrowEffectSetting> HoldArrowSettingList;                 // 0x02B0 (size: 0x10)
    bool bRemoveHoldArrowWhenCastSkill;                                               // 0x02C0 (size: 0x1)

}; // Size: 0x2C8

class USBBlasterSkillInfo : public USBSkillInfoClass
{
    TArray<FSBWeaponAnimationTagPlayParam> BowAnimationList;                          // 0x02A0 (size: 0x10)

}; // Size: 0x2B0

class USBBlasterStepShotSkill : public USBBlasterShootSkillInfo
{
    TArray<FSBCurveMoveSetting> CurveMoveSettingList;                                 // 0x02D0 (size: 0x10)

}; // Size: 0x2E0

class USBBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UnlockLoadingScreen(class UObject* WorldContextObject, const FString InName);
    void UnloadAllStreamLevels(class UObject* WorldContextObject);
    TArray<FLinearColor> TransformToMatrix(const FTransform& InTransform, bool Inverse, bool ByColumn);
    class ASBLevelSequenceActor* SpawnLevelSequence(class UObject* WorldContextObject, TSubclassOf<class ASBLevelSequenceActor> LevelSequenceClass, class ULevelSequence* Sequence, bool bAutoPlay, bool bAutoDestroy);
    TArray<FString> SortStringList(TArray<FString> StringList);
    TArray<FName> SortNameList(TArray<FName> NameList);
    void SnapToGround(const bool InAlign, const bool InUseLineTrace, const bool InUseBounds, const bool InUsePivot, class USceneComponent* InDestination);
    void ShowMessageLogDialog(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, FName TextTableName, int32 TextId, const FText Message);
    void ShowMessageLogCodeDialog(class UObject* WorldContextObject, int32 RetCode, int32 LocalErrCode);
    void ShowLoadingScreenFromType(class UObject* WorldContextObject, const ELoadingType LoadingType, const FName GameContentId);
    void ShowLoadingScreen(class UObject* WorldContextObject, const FName GameContentId);
    void SetSkipTutorial(class UObject* WorldContextObject);
    void SetGameQuitFlag(class UObject* WorldContextObject);
    void SetFadeScreenColor(class UObject* WorldContextObject, float Red, float Green, float Blue);
    void SetDemoBattleEffectHidden(bool bHidden);
    void SBPlayWorldCameraShake(const class UObject* WorldContextObject, TSubclassOf<class UCameraShakeBase> Shake, FVector Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter, ESBCameraShakeControlType ControlType);
    void SBClientStopCameraShake(class APlayerController* PlayerController, TSubclassOf<class UCameraShakeBase> Shake, bool bImmediately);
    void SBClientStartCameraShake(class APlayerController* PlayerController, TSubclassOf<class UCameraShakeBase> Shake, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot, ESBCameraShakeControlType ControlType);
    bool ReturnToRoom(class UObject* WorldContextObject);
    void RequestDemoHidden(class AActor* TargetActor, bool bIsHidden);
    void RemoveResidentTextures(class AActor* Actor);
    void PrintServerMsgToClient(const class APawn* Player, FString Msg, FLinearColor Col, float Timer, bool ToScreen);
    bool PreloadMapByLevelName(const FName InLevelName);
    bool PreloadMap(FPrimaryAssetId PrimaryAsset);
    void PlayDemoWait(class UObject* WorldContextObject, FName Name, FLatentActionInfo LatentInfo);
    bool PlayDemo(class UObject* WorldContextObject, FName Name);
    void OverrideGameTime(class UObject* WorldContextObject, bool Override, int32 Hour, int32 Minute);
    FRotator NormalizeRotator(FRotator Rotator);
    void ModifySceneComponentMobility(class USceneComponent* SceneComponent, TEnumAsByte<EComponentMobility::Type> NewMobility);
    void ModifyLightComponentPerformance(class ULightComponent* LightComponent, float MaxDrawDistance, float MaxDistanceFadeRange);
    TMap<class FString, class FString> Make2StrMap(const TArray<FString>& Key, const TArray<FString>& Value);
    void LockLoadingScreen(class UObject* WorldContextObject, const FString InName);
    bool LoadCurrentMapSublevel(class UObject* WorldContextObject, int32& OutStreamLoadNum, TArray<FName>& OutSublevelLevelNames, FDateTime InDateTimeOverride, class UObject* CBObj, FName CBFunc);
    class USBCharaCreateData* LoadCharaCreateData(const class USBCharaCreateComponent* CharaCreateComponent);
    bool IsWarpPointNameCheck(class UObject* WorldContextObject, FString DestMapName);
    bool IsShowLoadingScreen(const class UObject* WorldContextObject);
    bool IsScenarioMode(const class UObject* WorldContextObject);
    bool IsSameWorld(const class UObject* ObjectA, const class UObject* ObjectB);
    bool IsRouteGuideEnableMode(class UObject* WorldContextObject);
    bool IsRequestDemoHidden(class AActor* TargetActor);
    bool IsPvPCurrentGameState(const class UObject* WorldContextObject);
    bool IsPromotionMode();
    bool IsPlayInEditor();
    bool IsPlayGame(class UObject* WorldContextObject);
    bool IsMapLevelInfoInitialized(const class UObject* WorldContextObject);
    bool IsFadeingScreen(const class UObject* WorldContextObject);
    bool IsFadedOutScreen(const class UObject* WorldContextObject);
    bool IsEventTermNoneLimmit(const class UObject* WorldContextObject, FString TermId);
    bool IsEventTermActive(const class UObject* WorldContextObject, FString TermId);
    bool IsEditor();
    bool IsDHCGameContentId(const class UObject* WorldContextObject);
    bool IsDemoPlaying(const class UObject* WorldContextObject);
    bool IsCurrentMapLevelEscapeConfirmation(const class UObject* WorldContextObject);
    bool IsCurrentMapLevel(const class UObject* WorldContextObject, TEnumAsByte<ESBMapType> MapType);
    bool IsCurrentGameContentId(const class UObject* WorldContextObject, const FString InGameContentId);
    bool IsCostumeEquippableToEquipType_ForMulti(const TArray<ESBCharaEquipType>& InEquipTypes, const TArray<FCharaEquipItemInfo>& InCostumeEquipItemInfos, const TArray<FCharaEquipItemCharaCreateInfo>& InCostumeEquipItemCharaCreateInfos);
    bool IsCostumeEquippableToEquipType(const ESBCharaEquipType InEquipType, const FCharaEquipItemInfo& InCostumeEquipItemInfo, const FCharaEquipItemCharaCreateInfo& InCostumeEquipItemCharaCreateInfo);
    bool IsCityOfMapName(FString MapName);
    bool IsCityCurrentMapLevel(const class UObject* WorldContextObject);
    bool IsBattleMode(const class UObject* WorldContextObject);
    bool IsAvailableMapEventTerm(class UObject* WorldContextObject, FName GameContentId);
    bool IsAllRegidentAssetLoaded();
    bool IsAllMasterDataAvailable();
    bool IsActiveBillingShop();
    TArray<int32> IntArraySort(TArray<int32> inArray, bool AscendingOrder);
    void HideSplashScreen();
    void HideLoadingScreen(class UObject* WorldContextObject);
    bool HasNgWordWithTarget(bool& IsValid, FString CheckWords, const ESBNgWordTarget NgWordTargetType);
    bool HasNgWord(bool& IsValid, FString CheckWords);
    FVector GetWorldVectorFromScreenVector(const FVector2D ScreenVector, const FTransform WorldTransform, const float Scale);
    class ASBWorldSettings* GetWorldSettings(const class UObject* WorldContextObject);
    class USBWeaponManager* GetWeaponManager(bool& IsValid);
    void GetWarpPointLocationFromId(class UObject* WorldContextObject, const FName WarpPointId, FVector& Location);
    bool GetViewportSize(const class UObject* WorldContextObject, FVector2D& ViewportSize);
    float GetVectorAngleWithAxis(FVector A, FVector B, FVector Axis);
    class USBUIManager* GetUIManager(bool& IsValid);
    class USBUIAssetManager* GetUIAssetManager(bool& IsValid);
    bool GetTokenParamIsUser(int32 InTokenId);
    class USBSystemMessageManager* GetSystemMessageManager(bool& IsValid);
    bool GetStreamingLevelNames(class UObject* WorldContextObject, TArray<FName>& levels);
    class USBSoundManager* GetSoundManager(bool& IsValid);
    class USBSkinMaterialManager* GetSkinMaterialManager();
    bool GetScreenLocation(const class UObject* WorldContextObject, FVector WorldLocation, FVector2D& ScreenLocation, bool& IsInScreen);
    FRotator GetRotatorFromVectorDirection(const FVector& Normal);
    bool GetRequestPlayDemo(FSBDemoData& OutputDemoData);
    int32 GetRenderingShadowQuality();
    bool GetRelativeScreenLocation(const class UObject* WorldContextObject, FVector2D ScreenLocation, FVector2D& RelativeScreenLocation);
    FName GetRegionId(const FString InLevelName);
    class USBQuestManager* GetQuestManager(bool& IsValid);
    FString GetProjectVersion(const class UObject* WorldContextObject);
    class USBProjectileManager* GetProjectileManager(bool& IsValid);
    ESBPlayGameMode GetPlayGameMode(const class UObject* WorldContextObject);
    class USBPlayerManager* GetPlayerManager();
    ESBPlatformId GetPlatformIdFromPlatformName(FString PlatformName);
    class USBCharaPartsManager* GetPartsManager();
    int32 GetPartsIndexIDFromPartName(FString PartsName);
    class USBNpcManager* GetNpcManager(const class UObject* WorldContextObject, bool& IsValid);
    FDateTime GetNowDateFromEventScheduler(const class UObject* WorldContextObject);
    class USBNetworkDataCache* GetNetworkDataCache(const class UObject* WorldContextObject, bool& IsValid);
    class USBMatchingManager* GetMatchingManager(const class UObject* WorldContextObject, bool& IsValid);
    void GetMasterRewardData(const TArray<FName>& INIdList, TArray<FSBMasterReward>& OutRewardList);
    class USBMasterDataManager* GetMasterDataManager(bool& IsValid);
    bool GetMapNameByGameContentId(FName GameContentId, FString& OutMapName);
    bool GetMapInfoByGameContentId(FName GameContentId, FSBMapInfo& OutMapInfo);
    class USBMakeupManager* GetMakeupManager();
    class ASBLocationAnchorManager* GetLocationAnchorManager(const class UObject* WorldContextObject, bool& IsValid);
    FString GetLoadingScreenStatus(const class UObject* WorldContextObject);
    bool GetLoadingScreenDebugEnable();
    class USBLibrarySaveManager* GetLibrarySaveManager(bool& IsValid);
    void GetLevelNameByActor(const class AActor* Actor, FName& LevelName);
    class UJingleManager* GetJingleManager(bool& IsValid);
    int32 GetIntFromActorName(const class AActor* Actor);
    class USBHttpQueryManager* GetHttpQueryManager(bool& IsValid);
    class USBGameSingleton* GetGameSingleton(bool& IsValid);
    FString GetGameServerIPAddr(bool& IsValid);
    FString GetGameModeStringByContentId(FName GameContentId);
    bool GetGameModeInfoByContentId(FName GameContentId, FSBGameModeInfo& OutGameModeInfo);
    int32 GetFrameNumber();
    class APlayerController* GetFirstLocalPlayerController(class UObject* WorldContextObject);
    class USBEventTriggerDatabase* GetEventTriggerDatabase(bool& IsValid);
    class USBEnemyManager* GetEnemyManager(bool& IsValid);
    class USBEffectManager* GetEffectManager();
    bool GetEditorCurrentCameraLocationAndRotation(FVector& Location, FRotator& Rotation);
    class USBDroppingTextManager* GetDroppingTextManager(bool& IsValid);
    TSoftObjectPtr<UTexture> GetDigitalSignageTexture(const FName& InName, bool& bOutExist);
    class USBDemoManager* GetDemoManager(bool& IsValid);
    class UObject* GetDefaultObject(const UClass* C);
    class USBDebugFunction* GetDebugFunction(bool& IsValid);
    float GetDaytimeRate(FDateTime Time);
    ESBDayTime GetDayTime(FDateTime Time);
    FString GetCurrentSessionUuid(const class UObject* WorldContextObject);
    ESBPlatformId GetCurrentPlatformId();
    bool GetCurrentMapLevelInfo(const class UObject* WorldContextObject, FSBMapLevelInfo& OutMapLevelInfo);
    bool GetCurrentMapInfo(const class UObject* WorldContextObject, FSBMapInfo& OutMapInfo);
    bool GetCurrentGameModeInfo(class UObject* WorldContextObject, FSBGameModeInfo& OutGameModeInfo);
    FString GetCurrentGameContentIdFromMapLevelInfo(const class UObject* WorldContextObject);
    FName GetCurrentGameContentId(const class UObject* WorldContextObject);
    void GetCurrentDaytimeRate(const class UObject* WorldContextObject, bool& bOutIsDaytime, float& OutDaytimeRate);
    ESBDayTime GetCurrentDayTime(const class UObject* WorldContextObject);
    bool GetCostumePartsLocation(const ESBCharaEquipType& InType, ECharaPartsLocation& OutPartsLocation);
    int32 GetConnectedPlayersNum(const class UObject* WorldContextObject);
    FString GetCommandLineOption(const FString InKey, bool& bOutExist);
    class USBCharaCreateColorManager* GetColorManager();
    class USBColoringShopManager* GetColoringShopManager();
    class AActor* GetClosestActor(class UObject* WorldContextObject, FVector InLocation, float InLimit, TSubclassOf<class AActor> InActorClass, float& Distance);
    FString GetClientName(const class UObject* WorldContextObject);
    bool GetCharaEquipNakedPartsName(const ESBCharaEquipType Type, FString& OutPartsName);
    bool GetCharaEquipItemCharaCreateInfo(const FCharaEquipItemInfo& ItemInfo, const ESBCharaEquipType Type, FCharaEquipItemCharaCreateInfo& InCreateInfo);
    bool GetCharaCostumeCharaCreateInfo(const FCharaEquipItemInfo& ItemInfo, const ESBCharaEquipType Type, FCharaEquipItemCharaCreateInfo& InCreateInfo);
    class USBCharaCreateBoneScaleManager* GetBoneScaleManager();
    class USBBattleStatusManager* GetBattleStatusManager(bool& IsValid);
    class USBBattleManager* GetBattleManager();
    bool GetAllLevelNames(class UObject* WorldContextObject, TArray<FString>& levels);
    void GetAllComponentsWithInterface(const class UObject* WorldContextObject, TSubclassOf<class UInterface> Interface, TArray<class UActorComponent*>& OutComponents);
    void GetAllComponentsOfClass(const class UObject* WorldContextObject, TSubclassOf<class UActorComponent> ComponentClass, TArray<class UActorComponent*>& OutComponents);
    class USBAdditionalColorManager* GetAdditionalColorManager();
    void FSBSetKawaiiPhysicsForcedWind(bool sw);
    bool FindStampData(const int32 StampId, FSBStampData& Data);
    bool FindStampCategoryData(const int32 CategoryId, FSBStampCategoryData& Data);
    bool FindMasterInterruptQuestDestructibleObjectList(const FName& InSpawnId, TArray<FSBInterruptQuestDestructibleObjectMasterData>& OutParamList);
    bool FindInterruptQuestTreasureSettingData(const FName& InDataId, FSBInterruptQuestTreasureObjectParam& OutTreasureData);
    bool FileSaveStringArray(TArray<FString> SaveTextB, FString FileNameB);
    bool FileSaveString(FString SaveTextB, FString FileNameB);
    void FileOperation(FString DstFolderName, FString DstFileName, int32 FileNo, bool Gender, bool Weapon, bool IsNumbering);
    bool FileLoadString(FString FileNameA, FString& SaveTextA);
    FSBDebugWaveEnemyParamSettingBase FileLoadAndReturnWaveSetting(FString FileNameA);
    FString FileLoadAndReturnString(FString FileNameA);
    bool FileLoadAndReturnDebugMemo(FString FileNameA, TArray<FSBDebugMemoSetting>& LoadDebugMemoSetting);
    void FadeOutScreenWait(class UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo, bool IsNoTransparencyInterpolation);
    void FadeOutScreen(class UObject* WorldContextObject, float Duration, bool IsNoTransparencyInterpolation);
    void FadeInScreen(class UObject* WorldContextObject, float Duration, bool IsNoTransparencyInterpolation);
    void ExecuteExportAsJSON(class UObject* WorldContextObject, TArray<class UObject*> InObjects, const FString InHeaderString, const FString InEndString);
    bool EncroachingBlockingGeometry(const class UObject* WorldContextObject, UClass* Class, const FTransform& UserTransform);
    void DeleteFolderOperation(FString DeleteFolderName);
    void CustomScreenShot(FString ViewSize, bool DumpBufferVisualizationTargets, bool MaskEnabled);
    bool CanUseItemMapLevel(class UObject* WorldContextObject);
    bool CanBattleCurrentMapLevel(const class UObject* WorldContextObject);
    float CalcRangeRatio(int32 Now, int32 Begin, int32 End);
    float CalcBlendAnimationTranslation(const float TranslationA, const float TranslationB, const int32 FrameA, const int32 FrameB, const float BlendRate);
    float CalcBlendAnimationMoveSpeedBlendRate(const float MoveSpeed, const float TranslationA, const float TranslationB, const int32 FrameA, const int32 FrameB);
    float CalcBlendAnimationMoveSpeed(const float TranslationA, const float TranslationB, const int32 FrameA, const int32 FrameB, const float BlendRate);
    void AddResidentTextures(class AActor* Actor);
    void AddEditorNotification(const FString InMessage);
}; // Size: 0x28

class USBBlueprintFunctionLibraryCS : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void XUIDToGamerTag(FString xuid, FXUIDToGamerTagDelegate Delegate);
    void ToGamerTagDelegate__DelegateSignature(FString gamerTag);
    void ShowProfileUI(FString ID);
    void SetEnableTalkMode(class UObject* WorldContextObject, bool enable);
    void SCENpStopPremium();
    bool SCENpCheckPremium(const class UObject* WorldContextObject);
    void PlayerSessionJoinErrorNotified();
    class USBShowWebBrowserImpl* OpenWebBrowserSync(class UObject* WorldContextObject, FString OpenUrl, FString CloseUrl, int32 offsetX, int32 offsetY, int32 SizeX, int32 SizeY, const bool IsForceOpen);
    bool OpenWebBrowser(FString OpenUrl, FString CloseUrl, int32 offsetX, int32 offsetY, int32 SizeX, int32 SizeY, FOpenWebBrowserOnClose OnClose, const bool IsForceOpen);
    bool NeedPlayerSessionJoinErrorNotification();
    void LeavePlayerSession();
    bool IsValidSuccessLinkageURL(FString InURL, FString& LinkageToken);
    bool IsSCENpPremium();
    bool IsCSPlatform();
    bool IsChunkInstalled();
    bool HasPrivilegeCacheUGC();
    bool HasCommunicateRestrict();
    FString GetUrl(FString InURLName);
    FString GetMyGamerTag();
    void CloseDelegate__DelegateSignature(FString CloseUrl);
    float ChunkInstallTotalSizeGB();
    float ChunkInstalledSizeGB();
    void CheckXboxUserCompleteDelegate__DelegateSignature(FString xuid, bool IsEnabled);
    void CheckXboxUserCommunication(FString xuid, FCheckXboxUserCommunicationResult Result);
    void CheckPrivilege(ESBUserPrivileges privilege, bool isShowUI, FCheckPrivilegeResult Result);
    bool CheckPlatform(ESBPlatformId platformId);
    void CheckCompleteDelegate__DelegateSignature(bool IsEnabled, bool IsCheckFailed);
    void CheckAnonymousUserCompleteDelegate__DelegateSignature(bool isFriend, bool IsEnabled, bool IsCheckFailed);
    void CheckAnonymousUserCommunication(bool isFriend, FCheckAnonymousUserCommunicationResult Result);
}; // Size: 0x28

class USBBlurBox : public UContentWidget
{
    bool bRetainRender;                                                               // 0x0138 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0139 (size: 0x3)
    FMargin Padding;                                                                  // 0x013C (size: 0x10)
    TEnumAsByte<EHorizontalAlignment> HorizontalAlignment;                            // 0x014C (size: 0x1)
    TEnumAsByte<EVerticalAlignment> VerticalAlignment;                                // 0x014D (size: 0x1)
    bool bApplyAlphaToBlur;                                                           // 0x014E (size: 0x1)
    char padding_1[0x1];                                                              // 0x014F (size: 0x1)
    float BlurStrength;                                                               // 0x0150 (size: 0x4)
    bool bOverrideAutoRadiusCalculation;                                              // 0x0154 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0155 (size: 0x3)
    int32 BlurRadius;                                                                 // 0x0158 (size: 0x4)
    bool RenderOnInvalidation;                                                        // 0x015C (size: 0x1)
    bool ContinueRendering;                                                           // 0x015D (size: 0x1)

    void SetVerticalAlignment(TEnumAsByte<EVerticalAlignment> InVerticalAlignment);
    void SetRetainRendering(bool bInRetainRendering);
    void SetPadding(FMargin InPadding);
    void SetHorizontalAlignment(TEnumAsByte<EHorizontalAlignment> InHorizontalAlignment);
    void SetBlurStrength(float InStrength);
    void SetBlurRadius(int32 InBlurRadius);
    void SetApplyAlphaToBlur(bool bInApplyAlphaToBlur);
    void RequestRender();
}; // Size: 0x170

class USBBoneScaleCacheData : public UObject
{
    char padding_0[0xF0];                                                             // 0x0000 (size: 0x0)

    float GetCrtBoneScale(ECharaPartsCrtBone CrtBoneID);
    FVector GetBoneScale(ECharaCreateBoneScaleID BoneScaleID);
}; // Size: 0xF0

class USBBoolParam : public UObject
{
    bool bValue;                                                                      // 0x0028 (size: 0x1)

    class USBBoolParam* SetValue(bool bInValue);
}; // Size: 0x30

class USBBossBGMDataTable : public UDataTable
{
    char padding_0[0xB0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB0

class USBBossHPGauge : public UUserWidget
{
    class UCanvasPanelSlot* HPSlot;                                                   // 0x0280 (size: 0x8)
    FVector2D SlotSizeXY;                                                             // 0x0288 (size: 0x8)

    void UpdateHPGaugeSize(float InHPRate);
    void OnSetBossCharacter(class ASBEnemyCharacter* InBoss);
    void OnReset();
}; // Size: 0x298

class USBBossHPGaugeList : public UUserWidget
{
    class UCanvasPanel* CanvasPanel;                                                  // 0x0278 (size: 0x8)
    class USBBossHPGauge* BossNamePlate_0;                                            // 0x0280 (size: 0x8)
    class USBBossHPGauge* BossNamePlate_1;                                            // 0x0288 (size: 0x8)
    class USBBossHPGauge* BossNamePlate_2;                                            // 0x0290 (size: 0x8)
    class USBBossHPGauge* BossNamePlate_3;                                            // 0x0298 (size: 0x8)
    class USBBossHPGauge* BossNamePlate_4;                                            // 0x02A0 (size: 0x8)
    class USBBossHPGauge* BossNamePlate_5;                                            // 0x02A8 (size: 0x8)

    void OnInAnimationCall();
}; // Size: 0x2D0

class USBBotCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SpawnBot();
}; // Size: 0x28

class USBBotPathFollowingComponent : public UPathFollowingComponent
{
    char padding_0[0x270];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x270

class USBBotProjectSettings : public UObject
{
    FSoftClassPath BotControllerClass;                                                // 0x0028 (size: 0x18)

}; // Size: 0x40

class USBBoxSoundComponent : public UBoxComponent
{
    class UAkComponent* AkComponent;                                                  // 0x0490 (size: 0x8)

}; // Size: 0x4D0

class USBBuddyConditionalVoiceManager : public UObject
{
    char padding_0[0x160];                                                            // 0x0000 (size: 0x0)

    void OnPlayEndConditionVoice();
    void NotifyCondition(FName ConditionId, class ASBEnemyCharacter* InBuddyEnemy);
}; // Size: 0x160

class USBBuddyEnemyManager : public UObject
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)

    void SetStopUpdateRevival(bool bInStop);
    void ReviveAllBuddies();
    bool IsStopUpdateRevival();
    class ASBEnemyCharacter* GetBuddy(FString InEnemyId);
}; // Size: 0x80

class USBBuddyFindMasterComponent : public UActorComponent
{
    FSBBuddyFindMasterComponentOnChangedMasterDelegate OnChangedMasterDelegate;       // 0x00C8 (size: 0x10)
    void SBChangedMasterDelegate(class AActor* Actor);

    float GetFollowingMasterSheatheTime();
    class ASBPlayerCharacter* GetFollowingMaster();
    class ASBPlayerCharacter* FindMaster();
}; // Size: 0xD8

class USBBuffIcon : public UUserWidget
{
    FSBBuffIconOnEndDelegate OnEndDelegate;                                           // 0x0278 (size: 0x10)
    void OnEndDelegate();
    bool IsLargeIcon;                                                                 // 0x0288 (size: 0x1)

    void Setup(const FSBStatusAilmentIconConfig& InConfig, bool IsFixedIcon);
    void SetRemainTime(float InTime);
    void SetIconConfig(const FSBStatusAilmentIconConfig& InConfig);
    void OnSetup();
    void OnSetRemainTime();
    void OnEndDelegate__DelegateSignature();
    void OnEnd();
    bool IsTypeNone();
    bool IsType(ESBStatusAilmentIconType InType);
    bool IsIconConfig(const FSBStatusAilmentIconConfig& InConfig);
    ESBStatusAilmentIconType GetType();
    float GetRemainTime();
    FSBStatusAilmentIconConfig GetIconConfig();
    float GetBlinkTime();
    void End();
}; // Size: 0x2A8

class USBBuffListWidget : public UUserWidget
{
    FSBBuffListWidgetOnClientRecieveBattleStatusDelegete OnClientRecieveBattleStatusDelegete; // 0x0278 (size: 0x10)
    void OnClientRecieveBattleStatusDelegete();
    class USBBattleStatusComponent* BattleStatusComponent;                            // 0x0288 (size: 0x8)

    void UpdateList();
    void UnbindBattleStatusComponent();
    void SetupBattleStatusComponent(class USBBattleStatusComponent* InBattleStatusComponent);
    void Setup(const TArray<FSBStatusAilmentIconConfig>& InConfigList);
    void Reset();
    class USBBuffIcon* OnCreateIcon();
    void OnClientRecieveBattleStatusDelegete__DelegateSignature();
    class UPanelWidget* GetList();
    class USBBattleStatusComponent* GetBattleStatusComponent();
    int32 GetActiveCountList();
    void BindEventClientRecieveBattleStatus();
    void BindBattleStatusComponent();
}; // Size: 0x290

class USBBurstBonusGaugeWidget : public UUserWidget
{
    FVector2D DefaultGaugeSize;                                                       // 0x0278 (size: 0x8)

    void Update();
    void Setup(class ASBCharacter* InCharacter);
    void SetGaugeSize(const FVector2D& InSize);
    void OnUpdateTime();
    void OnUpdateLV();
    void OnSetup();
    float GetTimeRate();
    float GetTimeMax();
    float GetTime();
    int32 GetLV();
    float GetGaugeSizeRate();
}; // Size: 0x298

class USBButtonBase : public UButton
{
    class UAkAudioEvent* PressedAkAudioEvent;                                         // 0x0448 (size: 0x8)
    class UAkAudioEvent* HoveredAkAudioEvent;                                         // 0x0450 (size: 0x8)
    ESystemSE PressedSystemSEId;                                                      // 0x0458 (size: 0x1)
    ESystemSE HoveredSystemSEId;                                                      // 0x0459 (size: 0x1)

    void PreConstruct(bool IsDesignTime);
    void OnUnhoveredForSe();
    void OnPostSoundEvent_ButtonHovered();
    void OnPostSoundEvent_ButtonClicked();
    void ForceUnhover();
    void Construct();
}; // Size: 0x460

class USBButtonTowerEdit : public UButton
{
    int32 FloorIdx;                                                                   // 0x0440 (size: 0x4)

    void SetAutoPositionByIdx(float BaseX, float BaseY, float Width, float Height);
    void OnFloorButtonClicked();
}; // Size: 0x448

class USBCameraControlByPassWidget : public USBUserWidget
{
    class ASBScriptActor* ScriptActor;                                                // 0x02B0 (size: 0x8)

}; // Size: 0x2B8

class USBCameraLeaveCollisionComponent : public USphereComponent
{
    char padding_0[0x490];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x490

class USBCameraTransparentBoxComponent : public UBoxComponent
{
    char padding_0[0x490];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x490

class USBCameraTransparentCapsuleComponent : public UCapsuleComponent
{
    char padding_0[0x490];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x490

class USBCameraZoomLevelData : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBCameraZoomLevelCharacterData Data;                                             // 0x0050 (size: 0x50)

}; // Size: 0xA0

class USBCancelQuestEventParam : public UObject
{
    bool bResult;                                                                     // 0x0028 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0029 (size: 0x3)
    int32 QuestIndex;                                                                 // 0x002C (size: 0x4)

}; // Size: 0x30

class USBCashExchangeShopComponent : public USBPlayerPropertyComponent
{
    FSBCashExchangeShopComponentOnGetProductListDelegate OnGetProductListDelegate;    // 0x00B8 (size: 0x10)
    void OnGetProductListDelegate(bool Result);
    FSBCashExchangeShopComponentOnPurchaseDelegate OnPurchaseDelegate;                // 0x00C8 (size: 0x10)
    void OnPurchaseDelegate(bool Result);

    void Server_Purchase(const int32 iProductID, const int32 Amount);
    void Request_Purchase(const int32 ProductId, const int32 Amount);
    void Request_GetProductList(class ASBPlayerController* InPlayerController);
    void OnPurchaseDelegate__DelegateSignature(bool Result);
    void OnGetProductListDelegate__DelegateSignature(bool Result);
    void Client_Purchase(bool bInWasSuccessful);
}; // Size: 0xD8

class USBCharaBodyCapsuleComponent : public UASCollisionCapsuleComponent
{
    char padding_0[0x4F0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x4F0

class USBCharaBodyCapsuleGroupComponent : public UActorComponent
{
    char padding_0[0xD8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xD8

class USBCharaCreateBoneScaleData : public UDataAsset
{
    TArray<FSBCharaCreateBoneScaleGroupData> GroupList;                               // 0x0030 (size: 0x10)

}; // Size: 0x40

class USBCharaCreateBoneScaleManager : public UObject
{
    float HeadScale;                                                                  // 0x0028 (size: 0x4)
    char padding_0[0x4];                                                              // 0x002C (size: 0x4)
    FCharaCreateBoneScaleList OtherBoneScaleList;                                     // 0x0030 (size: 0x68)
    FCharaCreateBoneScaleList PlayerBoneScaleList;                                    // 0x0098 (size: 0x68)
    FCharaCreateBoneScaleList ExtraNpcBoneScaleList;                                  // 0x0100 (size: 0x68)
    FCharaCreateBoneScaleList MobBoneScaleList;                                       // 0x0168 (size: 0x68)
    FCharaCreateBoneScaleList MobR04BoneScaleList;                                    // 0x01D0 (size: 0x68)
    FCharaCreateBoneScaleList MobR05BoneScaleList;                                    // 0x0238 (size: 0x68)
    FCharaCreateBoneScaleList ShadowAvatorScaleList;                                  // 0x02A0 (size: 0x68)

}; // Size: 0x308

class USBCharaCreateColorManager : public UObject
{
    TArray<FSBCharaCreateColor> CostumeColorTable;                                    // 0x0028 (size: 0x10)
    TArray<FSBCharaCreateColor> SkinColorTable;                                       // 0x0038 (size: 0x10)
    TArray<FSBCharaCreateColor> HairColorTable;                                       // 0x0048 (size: 0x10)
    TArray<FHairColorLUT> HairBaseColorLUT;                                           // 0x0058 (size: 0x10)
    TArray<FHairColorLUT> HairShadowColorLUT;                                         // 0x0068 (size: 0x10)
    TArray<FSBCharaCreateColor> EyeColorTable;                                        // 0x0078 (size: 0x10)
    TArray<FSBCharaCreateColor> ScarColorTable;                                       // 0x0088 (size: 0x10)
    int32 DefaultHairColorValue;                                                      // 0x0098 (size: 0x4)
    char padding_0[0x4];                                                              // 0x009C (size: 0x4)
    TArray<FNpcColorByRegion> NpcColorByRegion;                                       // 0x00A0 (size: 0x10)
    TArray<FCharaPartsColorDataWeapon> WeaponColorTable;                              // 0x00B0 (size: 0x10)
    TArray<FSBCostumeColorValiation> CostumeColorValiationArray;                      // 0x00C0 (size: 0x10)
    TArray<FSBCharaCreateTweakColorOffset> TweakHairColorChannelArray;                // 0x00D0 (size: 0x10)

    FNpcColorByRegion GetNpcColorByRegion(ECharaPartsRegion Region);
    int32 GetColorTableNum(ESBCharaCreateColorTable TableType);
    TArray<FSBCharaCreateColor> GetColorTable(ESBCharaCreateColorTable TableType);
    int32 GetColorIndexByName(ESBCharaCreateColorTable TableType, FName ColorName);
    FLinearColor GetColorByIris(int32 Hue, int32 Saturation, int32 Value);
    FColor GetColorByHue(ESBCharaCreateColorHue Hue, int32 Value);
    FLinearColor GetColorByHSV(ESBCharaCreateColorHue Hue, int32 Saturation, int32 Value);
    FLinearColor GetBaseColorByName(ESBCharaCreateColorTable TableType, FName ColorName);
}; // Size: 0xE0

class USBCharaCreateComponent : public UActorComponent
{
    class USBCharaCreateData* DefaultCharaCreateData;                                 // 0x00C0 (size: 0x8)
    char padding_0[0x8];                                                              // 0x00C8 (size: 0x8)
    FSBCharaCreateParameter CharaCreateParameterData;                                 // 0x00D0 (size: 0x3C0)
    TArray<TWeakObjectPtr<UMeshComponent>> CharaPartsComponentArray;                  // 0x0490 (size: 0x10)
    TArray<FSBCharaCreatePartsSettings> PartsSettings;                                // 0x04A0 (size: 0x10)
    TSubclassOf<class UAnimInstance> FaceAnimClass;                                   // 0x04B0 (size: 0x8)
    TSubclassOf<class UAnimInstance> AccessoryAnimClass;                              // 0x04B8 (size: 0x8)
    bool bNpcUseFacialMesh;                                                           // 0x04C0 (size: 0x1)
    bool bMergeMesh;                                                                  // 0x04C1 (size: 0x1)
    bool bNeedsMergeMeshCPUAccess;                                                    // 0x04C2 (size: 0x1)
    FSBReplaceMaterialBaseType ReplaceMaterialBaseType;                               // 0x04C3 (size: 0x1)
    bool bIsLoadAllAssets;                                                            // 0x04C4 (size: 0x1)
    bool bIsHoldAllAssets;                                                            // 0x04C5 (size: 0x1)
    bool bForceSyncLoad;                                                              // 0x04C6 (size: 0x1)
    uint8 bForceMiplevelsToBeResident;                                                // 0x04C7 (size: 0x1)
    char padding_1[0x10];                                                             // 0x04C8 (size: 0x10)
    FSBCharaCreateComponentPostPhysicsTickFunction PostPhysicsTickFunction;           // 0x04D8 (size: 0x30)
    char padding_2[0x48];                                                             // 0x0508 (size: 0x48)
    TArray<class USkeletalMesh*> m_CachedBodyMergeMeshList;                           // 0x0550 (size: 0x10)
    TArray<class USkeletalMesh*> m_CachedFaceMergeMeshList;                           // 0x0560 (size: 0x10)
    char padding_3[0x10];                                                             // 0x0570 (size: 0x10)
    TArray<class UObject*> m_HoldingCharaCreateAssetsWhenUpdating;                    // 0x0580 (size: 0x10)
    FSBCharaCreateComponentOnCharaPartsLoadedDelegete OnCharaPartsLoadedDelegete;     // 0x0590 (size: 0x10)
    void SBOnCharaPartsLoadedDelegete(bool Result);
    char padding_4[0x8];                                                              // 0x05A0 (size: 0x8)
    class USBBoneScaleCacheData* BoneScaleCacheData;                                  // 0x05A8 (size: 0x8)
    class USBFacialAnimationDataHolder* FacialAnimationDataHolder;                    // 0x05B0 (size: 0x8)
    class USBCharaCreateDataHolder* CharaCreateDataHolder;                            // 0x05B8 (size: 0x8)
    char padding_5[0xEC];                                                             // 0x05C0 (size: 0xEC)
    float BlushAlpha;                                                                 // 0x06AC (size: 0x4)
    float PaleAlpha;                                                                  // 0x06B0 (size: 0x4)
    char padding_6[0xC];                                                              // 0x06B4 (size: 0xC)
    class UCurveLinearColor* BlushBaseColor;                                          // 0x06C0 (size: 0x8)
    class UCurveLinearColor* BlushColor;                                              // 0x06C8 (size: 0x8)

    void UpdatePartsName(ECharaPartsLocation PartsLocation);
    void UpdatePartsAttach(ECharaPartsLocation PartsLocation, ECharaPartsAccessoryLocation AttachLocation);
    void UpdateParts();
    void UpdateBoneScaleParameter();
    void ShowPartsGroup(ECharaPartsLocationGroup PartsLocationGroup, bool bInShow);
    void ShowParts(ECharaPartsLocation PartsLocation, bool bShow);
    bool ShouldMergeMesh();
    void SetVoiceId(const int32 InVoiceId);
    void SetTexture(const ESBCustomTextureType CustomTextureType, int32 TextureIndex);
    void SetSkinColor(FSBCharaCreateColorHSV ColorHSV);
    void SetRegionType(ECharaPartsRegion Region);
    void SetPartsName(ECharaPartsLocation PartsLocation, const FName& PartsName, bool bUpdateParts);
    void SetPartsMaterialCostume(ECharaPartsLocation PartsLocation, int32 InMaterialIndex);
    void SetPartsGroupNameByPartsName(ECharaPartsLocationGroup PartsLocationGroup, const FName& PartsName);
    void SetPartsGroupName(ECharaPartsLocationGroup PartsLocationGroup, const FName& PartsName);
    void SetPartsGroupMaterialCostume(ECharaPartsLocationGroup PartsLocationGroup, int32 InMaterialIndex);
    void SetPartsGroupColorCostume(ECharaPartsLocationGroup PartsLocationGroup, int32 InColorIndex, int32 InColorSaturation, int32 InColorValue);
    void SetPartsColorCostume(ECharaPartsLocation PartsLocation, int32 InColorIndex, int32 InColorSaturation, int32 InColorValue);
    void SetPartsAtIndex(ECharaPartsLocation PartsLocation, int32 Index);
    void SetOddEye(bool IsOddEye);
    void SetNakedView(bool bNaked);
    void SetMouthSpecular(bool bEnable);
    void SetMirror(ECharaPartsLocation PartsLocation, bool bMirror);
    void SetMakeupMoles(const TArray<bool>& InMoles);
    void SetMakeupMirror(FSBCharaCreateMakeupIndex MakeupIndex, bool IsMirror);
    void SetMakeupColor(FSBCharaCreateMakeupIndex MakeupIndex, FSBCharaCreateColorHSV HSV);
    void SetMakeup(const FSBCharaCreateMakeupIndex MakeupIndex, const FSBCharaCreateMakeup& MakeupData);
    void SetLipSyncType(const ESBLipSyncType InLipSyncType);
    void SetJobType(int32 JobType);
    void SetIrisMaterial(int32 LeftID, int32 RightID);
    void SetIrisColor(ESBIrisType IrisType, int32 ColorIndex, ESBCharaCreateColorHue Hue, int32 Saturation, int32 Value);
    void SetHairMeshSwitch(int32 MeshIndex, bool Value);
    void SetHairHat(bool bHairHat);
    void SetHairGradationType(int32 GradationType);
    void SetHairGradationRange(float Range);
    void SetHairGradationHeight(float Height);
    void SetHairColor(int32 ColorIndex, FSBCharaCreateColorHSV HSV);
    void SetFacialType(const ESBFacialType InFacialType);
    void SetFaceType(int32 FaceType);
    void SetEyelashColorValue(int32 Value);
    void SetEyelashColorIndex(int32 Value);
    void SetEyebrowColorValue(int32 Value);
    void SetEyebrowColorIndex(int32 Value);
    void SetEyebrowAngle(const float Angle);
    void SetEyeAngle(const float Angle);
    void SetDefaultCharaCreateData(class USBCharaCreateData* TempDefaultCharaCreateData);
    void SetCreationGender(ESBCharacterGender InGender);
    void SetCostumeItemID(ECharaPartsLocation PartsLocation, int32 ItemId);
    void SetColorHSV(ECharaPartsLocation PartsLocation, FSBCharaCreateColorHSV HSV);
    void SetCharacterType(ECharaPartsCharacterType NewCharacterType);
    bool SetBoneScaleSliderValue(ESBBoneScaleSliderIndex SliderIndex, float Value);
    void SetBodyType(ECharaPartsBody BodyType);
    void SetBeardColorIndex(int32 Value);
    void SBOnCharaPartsLoadedDelegete__DelegateSignature(bool Result);
    bool IsPartsShown(ECharaPartsLocation PartsLocation);
    bool IsPartsLoaded();
    bool IsDefaultCharaCreateParameterLoaded();
    bool IsAllCharaCreatePartsAssetLoaded(bool bIsInDirty);
    void ImportCharaCreateData(class USBCharaCreateData* SrcData, bool bUpdate);
    int32 GetVoiceId();
    float GetUpperLength();
    void GetSkinColor(FSBCharaCreateColorHSV& OutColorHSV);
    ECharaPartsRegion GetRegionType();
    int32 GetPartsNum(ECharaPartsLocation PartsLocation);
    FName GetPartsName(ECharaPartsLocation PartsLocation);
    class UMeshComponent* GetPartsMeshComponent(const ECharaPartsLocation PartsLocation);
    class UCharaPartsData* GetPartsData(const ECharaPartsLocation PartsLocation);
    bool GetOddEye();
    TArray<bool> GetMoleFlagArray();
    TArray<class UMeshComponent*> GetMeshComponentArrayForBP(ECharaPartsLocationGroup GroupForFiltering);
    FSBCharaCreateMakeup GetMakeup(const FSBCharaCreateMakeupIndex MakeupIndex);
    float GetLowerLength();
    ENpcJob GetJobType();
    FSBCharaCreateColorHSV GetIrisColor(ESBIrisType IrisType, int32 ColorIndex);
    float GetHeight();
    float GetHeelLength();
    float GetHairGradationRange();
    float GetHairGradationHeight();
    ESBFacialType GetFacialType();
    int32 GetFaceType();
    ESBCharacterGender GetCreationGender();
    FSBCharaCreateColorHSV GetColorHSV(ECharaPartsLocation PartsLocation);
    ECharaPartsCharacterType GetCharacterType();
    class USBCharaCreateViewerParameter* GetCharaCreateViewerParameter();
    FString GetCharaCreatePartsDebugMainInfo();
    FString GetCharaCreatePartsDebugInfo(int32 DebugInfoIndex);
    class USBCharaCreateDebugInfo* GetCharaCreateParameterDebugInfoData();
    FString GetCharaCreateParameterDebugInfo();
    FString GetCharaCreateDebugInfo(int32 Index);
    class USBCharaCreateData* GetCharaCreateDataForDebug();
    float GetBoneScaleSliderValue(ESBBoneScaleSliderIndex SliderIndex);
    ECharaPartsBody GetBodyType();
    ESBFacialType GetBaseFacialType();
    void ExportCharaCreateDataEdit();
    void ExportCharaCreateDataAsEdit();
    float CalcHeelLength();
    void BlinkPartsGroup(ECharaPartsLocationGroup PartsLocationGroup);
    void BlinkParts(ECharaPartsLocation PartsLocation);
}; // Size: 0x6D8

class USBCharaCreateData : public UDataAsset
{
    FSBCharaCreateParameter Parameter;                                                // 0x0030 (size: 0x3C0)

}; // Size: 0x3F0

class USBCharaCreateDataHolder : public USBAssetDataHolder
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBCharaCreateDebugInfo : public UObject
{
    TArray<FSBCharaCreateDebugInfoPartsNameAndPartsData> CharaPartsDataInfoArray;     // 0x0028 (size: 0x10)

}; // Size: 0x38

class USBCharaCreateViewerParameter : public UObject
{
    TArray<class UAnimMontage*> AnimMontageList;                                      // 0x0028 (size: 0x10)
    char padding_0[0x52];                                                             // 0x0038 (size: 0x52)
    ECharaPartsRegion RegionTypeCache;                                                // 0x008A (size: 0x1)
    ENpcJob JobTypeCache;                                                             // 0x008B (size: 0x1)

    void SetPlayRate(float InPlayRate);
    void SetLoopAnimation(bool bLooping);
    void SetIsResetTransform(class ACharacter* Character, bool in_bResetTransform);
    void SetAnimResetTransform(FTransform Transform);
    bool GetLoopAnimation();
}; // Size: 0x90

class USBCharaCreateViewerTools : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UpdateCharaCreateParameter(class USBCharaCreateComponent* CharaCreateComponent);
    void PlayAnimSequenceList(class USBCharaCreateViewerParameter* CharaCreateViewerParameter, int32 Index);
    void OpenCharaCreateParamDialog(class UObject* Object, const FText& Title, const FText& ToolTip, const FText& ToolButtonTip, float Width, float Height, bool bModal, bool bClose);
    TArray<class USBCharaCreateData*> GetEnpcChacaCreateDataArray();
    TArray<FName> GetAnimSequenceList(class USBCharaCreateViewerParameter* CharaCreateViewerParameter);
    void DebugDrawClothCollisions(class USkeletalMeshComponent* SkelMesh);
    void BindEditorTools();
}; // Size: 0x28

class USBCharaCreateWidget : public USBUserWidget
{
    FSBCharaCreateWidgetOnTickDoOnceDelegate OnTickDoOnceDelegate;                    // 0x02B0 (size: 0x10)
    void OnTickDoOnceDelegate();

    void OnTickDoOnceDelegate__DelegateSignature();
    void OnFailedConnectServer(int32 RetCode);
    bool ConnectToServer(class UObject* WorldContextObject, FString CharacterId);
}; // Size: 0x2C8

class USBCharaMemoryManager : public UObject
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBCharaPartsBodyComponent : public USBCharaPartsComponent
{
    char padding_0[0xF90];                                                            // 0x0000 (size: 0x0)
}; // Size: 0xF90

class USBCharaPartsComponent : public USBSkeletalMeshComponent
{
    class USBCharaPartsMaterial* CharaPartsMaterial;                                  // 0x0F80 (size: 0x8)
    char padding_0[0x2];                                                              // 0x0F88 (size: 0x2)
    bool bPartsScreenShotFlag;                                                        // 0x0F8A (size: 0x1)

}; // Size: 0xF90

class USBCharaPartsFaceComponent : public USBCharaPartsComponent
{
    ESBFacialType FacialType;                                                         // 0x0F90 (size: 0x1)
    ESBFacialType OverrideFacialType;                                                 // 0x0F91 (size: 0x1)
    char padding_0[0xA];                                                              // 0x0F92 (size: 0xA)
    bool bEyeBlinkEnable;                                                             // 0x0F9C (size: 0x1)
    char padding_1[0x3];                                                              // 0x0F9D (size: 0x3)
    float EyeBlinkIntervalMin;                                                        // 0x0FA0 (size: 0x4)
    float EyeBlinkIntervalMax;                                                        // 0x0FA4 (size: 0x4)
    float EyeBlinkSpeed;                                                              // 0x0FA8 (size: 0x4)
    int32 EyeBlinkTwiceRate;                                                          // 0x0FAC (size: 0x4)
    int32 EyeBlinkFrameKey;                                                           // 0x0FB0 (size: 0x4)
    char padding_2[0xD];                                                              // 0x0FB4 (size: 0xD)
    ESBLipSyncType LipSyncType;                                                       // 0x0FC1 (size: 0x1)
    char padding_3[0x2];                                                              // 0x0FC2 (size: 0x2)
    float LipSyncSpeed;                                                               // 0x0FC4 (size: 0x4)
    int32 LipSyncRatio;                                                               // 0x0FC8 (size: 0x4)

    void SetOverrideFrame(int32 InFrame);
    void SetLipSyncSpeed(float InSpeed);
    void SetLipSyncRatio(int32 InRatio);
    void SetLipSyncAnim(bool bInLipSyncAnim);
    void SetFacialType(ESBFacialType InFacialType);
    void ReserveFacialType(ESBFacialType InFacialType, float ApplyDelay, float KeepTime);
    bool IsValidFacialType(ESBFacialType InFacialType);
    int32 GetOverrideFrame();
    float GetLipSyncSpeed();
    int32 GetLipSyncRatio();
    int32 GetLipSyncFrame();
    ESBFacialType GetFacialType();
    int32 GetEyeBlinkFrame();
}; // Size: 0xFE0

class USBCharaPartsManager : public UObject
{
    class UDataTable* CharaPartsDB;                                                   // 0x0028 (size: 0x8)
    TArray<class UDataTable*> CharaPartsDBArray;                                      // 0x0030 (size: 0x10)
    TArray<class UDataTable*> EnpcCharaPartsDBArray;                                  // 0x0040 (size: 0x10)
    TArray<class UDataTable*> MobCharaPartsDBArray;                                   // 0x0050 (size: 0x10)
    TArray<class UDataTable*> EnemyCharaPartsDBArray;                                 // 0x0060 (size: 0x10)
    TArray<class UDataTable*> ShadowAvatorCharaPartsDBArray;                          // 0x0070 (size: 0x10)
    TArray<class UObject*> m_HoldingCharaCreateAssets;                                // 0x0080 (size: 0x10)
    TArray<class UObject*> m_HoldingCharaCreateMaterialAssets;                        // 0x0090 (size: 0x10)
    char padding_0[0x68];                                                             // 0x00A0 (size: 0x68)
    TArray<class USkeletalMesh*> SkeletonMergingMesh;                                 // 0x0108 (size: 0x10)
    TArray<class USkeletalMesh*> MergingMesh;                                         // 0x0118 (size: 0x10)

    int32 GetPartsNum(ECharaPartsCharacterType CharacterType, ECharaPartsLocation PartsLocation);
    TArray<FName> GetPartsNameListFromData(const class USBCharaCreateData* CharaCreateData, ECharaPartsLocation PartsLocation);
    TArray<FName> GetPartsNameListFromComponent(const class USBCharaCreateComponent* CharaCreateComponent, ECharaPartsLocation PartsLocation);
    TArray<FName> GetPartsNameListForNpc(const TArray<class UDataTable*>& InCharaPartsDBArray, ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType);
    TArray<FName> GetPartsNameListForMob(const TArray<class UDataTable*>& InCharaPartsDBArray, ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType, ENpcJob JobType, ECharaPartsRegion Region);
    TArray<FName> GetPartsNameListForAll(ECharaPartsCharacterType CharaPartsCharacterType, ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType, int32 FaceType, ENpcJob JobType, ECharaPartsRegion Region);
    TArray<FName> GetPartsNameList(const TArray<class UDataTable*>& InCharaPartsDBArray, ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType, int32 FaceType);
    FName GetPartsName(ECharaPartsCharacterType CharacterType, ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType, FName PartsId);
    FName GetPartsIDAtIndex(ECharaPartsCharacterType CharacterType, ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType, int32 Index);
    class UCharaPartsData* GetPartsDataAtPartsID(ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType, FName PartsId);
    class UCharaPartsData* GetPartsDataAtIndex(ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType, int32 Index);
    class UCharaPartsData* GetPartsData(class UDataTable* CharaPartsDB, ECharaPartsLocation PartsLocation, ECharaPartsBody BodyType, FName PartsId);
    TArray<class UDataTable*> GetDBArray(ECharaPartsCharacterType CharaPartsCharacterType);
}; // Size: 0x1C8

class USBCharaPartsMaterial : public UObject
{
    TArray<class UMaterialInterface*> MaterialInstanceOriginalList;                   // 0x0030 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> MaterialInstanceDefaultList;              // 0x0040 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> MaterialInstanceCharacreateList;          // 0x0050 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> MaterialInstanceCharacreateSkinList;      // 0x0060 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> MaterialInstanceReplaceList;              // 0x0070 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> MaterialInstanceCustomList;               // 0x0080 (size: 0x10)
    TArray<EMaterialType> MaterialTypeList;                                           // 0x0090 (size: 0x10)
    TArray<EMaterialLocation> MaterialLocationList;                                   // 0x00A0 (size: 0x10)
    TArray<FString> OriginalMaterialNameList;                                         // 0x00B0 (size: 0x10)
    TArray<class UMaterialInstanceDynamic*> StaticMaterialInstanceList;               // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class USBCharaPartsStaticComponent : public USBStaticMeshComponent
{
    uint8 bRenderStaticLOD;                                                           // 0x0511 (size: 0x1)
    bool PartsScreenShotFlag;                                                         // 0x0512 (size: 0x1)
    char padding_0[0x5];                                                              // 0x0513 (size: 0x5)
    class USBCharaPartsMaterial* CharaPartsMaterial;                                  // 0x0518 (size: 0x8)

    bool GetPartsScreenShotFlag();
}; // Size: 0x530

class USBCharaPartsTickComponent : public USBCharaPartsComponent
{
    char padding_0[0xF90];                                                            // 0x0000 (size: 0x0)
}; // Size: 0xF90

class USBCharacterAnimInstance : public USBAnimInstance
{
    float HeadScale;                                                                  // 0x04A0 (size: 0x4)
    char padding_0[0x8];                                                              // 0x04A4 (size: 0x8)
    int32 TestBustType;                                                               // 0x04AC (size: 0x4)
    char padding_1[0x14];                                                             // 0x04B0 (size: 0x14)
    FVector CachedVelocity;                                                           // 0x04C4 (size: 0xC)
    float CachedAnimTime;                                                             // 0x04D0 (size: 0x4)
    FVector CachedInputVector;                                                        // 0x04D4 (size: 0xC)
    TWeakObjectPtr<class USBPartsDamageAnimParamter> PartsDamageAnimParamter;         // 0x04E0 (size: 0x8)
    bool bSitActive;                                                                  // 0x04E8 (size: 0x1)
    bool bLookAtActive;                                                               // 0x04E9 (size: 0x1)
    bool bLookAtForceDisable;                                                         // 0x04EA (size: 0x1)
    bool bLookAtCustomEyeActive;                                                      // 0x04EB (size: 0x1)
    FVector LookAtCustomEyePosition;                                                  // 0x04EC (size: 0xC)
    FVector LookAtPosition;                                                           // 0x04F8 (size: 0xC)
    FVector TargetingPosition;                                                        // 0x0504 (size: 0xC)
    FSBLookAtCustomParam LookAtCustomParam;                                           // 0x0510 (size: 0x1C)
    bool bExtraLookAtActive1;                                                         // 0x052C (size: 0x1)
    char padding_2[0x3];                                                              // 0x052D (size: 0x3)
    FVector ExtraLookAtPosition1;                                                     // 0x0530 (size: 0xC)
    bool bExtraLookAtActive2;                                                         // 0x053C (size: 0x1)
    char padding_3[0x3];                                                              // 0x053D (size: 0x3)
    FVector ExtraLookAtPosition2;                                                     // 0x0540 (size: 0xC)
    bool bExtraLookAtActive3;                                                         // 0x054C (size: 0x1)
    char padding_4[0x3];                                                              // 0x054D (size: 0x3)
    FVector ExtraLookAtPosition3;                                                     // 0x0550 (size: 0xC)
    bool bIKActive;                                                                   // 0x055C (size: 0x1)
    char padding_5[0x3];                                                              // 0x055D (size: 0x3)
    FSBIKStatusAll IKStatusAll;                                                       // 0x0560 (size: 0x10)
    bool bLieOnGroundActive;                                                          // 0x0570 (size: 0x1)
    bool bRunningLieOnGroundActive;                                                   // 0x0571 (size: 0x1)
    bool bLimbsRetargetActive;                                                        // 0x0572 (size: 0x1)
    char padding_6[0x1];                                                              // 0x0573 (size: 0x1)
    TWeakObjectPtr<class USBDemoParameterComponent> DemoParameterComponent;           // 0x0574 (size: 0x8)
    bool bBreastPhysicsActive;                                                        // 0x057C (size: 0x1)
    char padding_7[0x3];                                                              // 0x057D (size: 0x3)
    float BreastPhysicsScale;                                                         // 0x0580 (size: 0x4)
    char padding_8[0x4];                                                              // 0x0584 (size: 0x4)
    FSBExtraCurveForce BreastPhysicsExternalForce;                                    // 0x0588 (size: 0x150)
    FSBExtraCurveForce LeftBreastPhysicsExternalForce;                                // 0x06D8 (size: 0x150)
    FSBExtraCurveForce RightBreastPhysicsExternalForce;                               // 0x0828 (size: 0x150)
    bool bHairPhysicsActive;                                                          // 0x0978 (size: 0x1)
    bool bPartsDamageShake;                                                           // 0x0979 (size: 0x1)
    bool bHairComponentSpaceSimulation;                                               // 0x097A (size: 0x1)
    char padding_9[0x5];                                                              // 0x097B (size: 0x5)
    FSBExtraCurveForce HairPhysicsExternalForce;                                      // 0x0980 (size: 0x150)
    FVector IKOffset;                                                                 // 0x0AD0 (size: 0xC)
    char padding_10[0x4B4];                                                           // 0x0ADC (size: 0x4B4)
    FSBLimbIKUpdateParam HandIKParamL;                                                // 0x0F90 (size: 0x10)
    FSBLimbIKUpdateParam HandIKParamR;                                                // 0x0FA0 (size: 0x10)
    bool bIsHandIkActive;                                                             // 0x0FB0 (size: 0x1)
    bool bIsLookAtTargetActive;                                                       // 0x0FB1 (size: 0x1)
    char padding_11[0x2];                                                             // 0x0FB2 (size: 0x2)
    FSBLimbIKUpdateParam HoldHandIKParamL;                                            // 0x0FB4 (size: 0x10)
    FSBLimbIKUpdateParam HoldHandIKParamR;                                            // 0x0FC4 (size: 0x10)
    bool bIsHoldHandIkActive;                                                         // 0x0FD4 (size: 0x1)

    void TriggerHairPhysics();
    void TriggerBreastPhysics();
    FVector SetTemporaryVector(FName TypeName, FVector Value);
    class USceneComponent* SetTemporarySceneComponent(FName TypeName, class USceneComponent* SceneComponent);
    FRotator SetTemporaryRotator(FName TypeName, FRotator Value);
    FName SetTemporaryName(FName TypeName, FName Value);
    int32 SetTemporaryInt32(FName TypeName, int32 Value);
    float SetTemporaryFloat(FName TypeName, float Value);
    bool SetTemporaryBool(FName TypeName, bool Value);
    class AActor* SetTemporaryActor(FName TypeName, class AActor* Actor);
    void RemoveTemporaryVariable(const TArray<FName>& TypeNameList);
    FVector GetTemporaryVector(FName TypeName);
    class USceneComponent* GetTemporarySceneComponent(FName TypeName);
    FRotator GetTemporaryRotator(FName TypeName);
    FName GetTemporaryName(FName TypeName);
    int32 GetTemporaryInt32(FName TypeName);
    float GetTemporaryFloat(FName TypeName);
    bool GetTemporaryBool(FName TypeName);
    class AActor* GetTemporaryActor(FName TypeName);
    TEnumAsByte<ERootMotionMode::Type> GetRootMotionMode();
    FVector AddTemporaryVector(FName TypeName, FVector Value);
    FRotator AddTemporaryRotator(FName TypeName, FRotator Value);
    int64 AddTemporaryInt64(FName TypeName, int64 Value);
    int32 AddTemporaryInt32(FName TypeName, int32 Value);
    float AddTemporaryFloat(FName TypeName, float Value);
}; // Size: 0xFE0

class USBCharacterAnimationSamplingAsset : public UObject
{
    TSoftClassPtr<ASBEnemyCharacter> OwnerEnemy;                                      // 0x0028 (size: 0x28)
    TSoftClassPtr<ASBCharacter> OwnerCharacter;                                       // 0x0050 (size: 0x28)
    FSBCharacterAnimationSamplingResult SampleData;                                   // 0x0078 (size: 0x190)

}; // Size: 0x208

class USBCharacterAnimationSamplingBlueprintFunctionalLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SampleTriggerEvent(FName TaskName, const class AActor* OwnerActor, const class UObject* Instigator, const class UObject* AnimNotify);
}; // Size: 0x28

class USBCharacterAnimationSamplingComponent : public UActorComponent
{
    class USBCharacterAnimationSamplingAsset* AnimationSamplingAsset;                 // 0x00D0 (size: 0x8)

}; // Size: 0x270

class USBCharacterAnimationSamplingTaskBase : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCharacterAnimationSamplingTask_BatchEnemy : public USBCharacterAnimationSamplingTaskBase
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCharacterAnimationSamplingTask_SimulateEnemyAction : public USBCharacterAnimationSamplingTaskBase
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCharacterAnimationSamplingTask_SimulatePlayerAction : public USBCharacterAnimationSamplingTaskBase
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCharacterCampFireComponent : public USBPlayerControllerComponentBase
{
    FSBCharacterCampFireComponentOnChangedDataDelegate OnChangedDataDelegate;         // 0x00B8 (size: 0x10)
    void OnChangedDataDelegate();

    void Server_AddActivatedCampFire(const class AActor* InCauserActor, FString LocationId);
    bool RequestAddActivated(const class AActor* InCauserActor, const FName LocationId);
    void OnChangedDataDelegate__DelegateSignature();
    bool IsActivatedCampFire(FName LocationId);
    void GetActivatedCampFires(TArray<FName>& OutArray);
    void Client_OnAddActivatedCampFireComplete(const TArray<FName>& InActivates, bool bInWasSuccessful);
}; // Size: 0xD8

class USBCharacterCardHUD : public UUserWidget
{
    class USBCharacterCardList* CharacterCardList;                                    // 0x0278 (size: 0x8)

    void OnIsNewMemberFoundInParty();
    void OnInitialize(const TArray<FString>& InPartyMemberCharacterIds);
    void OnCloseCharacterCard(const bool InResetMenuModeOnly);
}; // Size: 0x280

class USBCharacterCardList : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    bool IsSingleParticipant();
    void GetPartyMemberCharacterIds(TArray<FString>& OutCharacterIds);
}; // Size: 0x278

class USBCharacterChanceTimeDownComponent : public UActorComponent
{
    bool bUseElementalBurstChanceTimeDown;                                            // 0x00E0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00E1 (size: 0x7)
    FSBCharacterChanceTimeTableElementalBurst ChanceTimeTableStartElementalBurst;     // 0x00E8 (size: 0x50)
    FSBCharacterChanceTimeTableElementalBurst ChanceTimeTableEndElementalBurst;       // 0x0138 (size: 0x50)
    FSBCharacterChanceTimeTablePartsBreak ChanceTimeTablePartsBreak;                  // 0x0188 (size: 0x50)
    float GuardBreakChanceTime;                                                       // 0x01D8 (size: 0x4)
    float AnimNotifyChanceTime;                                                       // 0x01DC (size: 0x4)
    TMap<FName, float> ChanceTimeOthersMap;                                           // 0x01E0 (size: 0x50)

    void BeginChanceTimeByStartElementalBurst(ESBAttribute Attribute);
    void BeginChanceTimeByOthersKeyName(FName KeyName);
    void BeginChanceTimeByEndElementalBurst(ESBAttribute Attribute);
}; // Size: 0x238

class USBCharacterChangeEmissiveColorComponent : public UActorComponent
{
    TArray<FName> TargetTagNameList;                                                  // 0x00B8 (size: 0x10)
    TArray<FSBMaterialColorInfo> ChangedMaterialColorList;                            // 0x00C8 (size: 0x10)
    TArray<FSBWeaponColorInfo> ChangedWeaponColorList;                                // 0x00D8 (size: 0x10)
    char padding_0[0xA0];                                                             // 0x00E8 (size: 0xA0)
    TArray<FLinearColor> EmissiveColorList;                                           // 0x0188 (size: 0x10)

    void OnRep_ChangedWeaponColorList();
    void OnRep_ChangedMaterialColorList();
    bool IsMaterialEmissiveColorChanged(const int32 MaterialIndex);
    void ChangeWeaponEmissiveColor(const int32 NewColorIndex, const int32 WeaponIndex, const TArray<int32>& MaterialIndices);
    void ChangeMaterialEmissiveColor(const int32 NewColorIndex, const TArray<int32>& MaterialIndices, FName TargetTagName);
}; // Size: 0x198

class USBCharacterChantBaseComponent : public UActorComponent
{
    char padding_0[0x228];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x228

class USBCharacterData : public UObject
{
    FSBCharacterMisc Data;                                                            // 0x0028 (size: 0x1E0)
    char padding_0[0x18];                                                             // 0x0208 (size: 0x18)
    FSBCharacterDataOnLevelUpDelegate OnLevelUpDelegate;                              // 0x0220 (size: 0x10)
    void OnLevelUpDelegate(int32 InPrevLevel, int32 InCurLevel, const FSBExtraExpParse& InExtraExpParse);
    FSBCharacterDataOnSCRUpDelegate OnSCRUpDelegate;                                  // 0x0230 (size: 0x10)
    void OnSCRUpDelegate(int32 InRank, int32 InRankMax);
    FSBCharacterDataOnLearningSkillDelegate OnLearningSkillDelegate;                  // 0x0240 (size: 0x10)
    void OnLearningSkillDelegate(const TArray<FCharaSkillMasteryInfo>& NewSkill);
    FSBCharacterDataOnSubPaletteReleaseDelegate OnSubPaletteReleaseDelegate;          // 0x0250 (size: 0x10)
    void OnSubPaletteReleaseDelegate();
    char padding_1[0x8];                                                              // 0x0260 (size: 0x8)
    FSBCharacterDataOnInitMapPinDelegate OnInitMapPinDelegate;                        // 0x0268 (size: 0x10)
    void OnLoadMapPinInfosDelegate();

    void OnSubPaletteReleaseDelegate__DelegateSignature();
    void OnSCRUpDelegate__DelegateSignature(int32 InRank, int32 InRankMax);
    void OnLoadMapPinInfosDelegate__DelegateSignature();
    void OnLevelUpDelegate__DelegateSignature(int32 InPrevLevel, int32 InCurLevel, const FSBExtraExpParse& InExtraExpParse);
    void OnLearningSkillDelegate__DelegateSignature(const TArray<FCharaSkillMasteryInfo>& NewSkill);
    TArray<FString> GetTraverse();
}; // Size: 0x278

class USBCharacterDataBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool SkillCanLearned(const class UObject* InWorldContextObject, int32 SkillId, int32 SkillLV);
    void SetSeasonPoint(const class UObject* InWorldContextObject, const int32 InSp);
    void SetRoseOrbPaid(const class UObject* InWorldContextObject, const int32 InPaid);
    void SetRoseOrbFree(const class UObject* InWorldContextObject, const int32 InFree);
    bool SetPlayerPresetEquipListByIndex(const class UObject* WorldContextObject, int32 PresetListIndex, const FSBPlayerPresetEquipList& Param);
    bool SetPlayerPresetEquipList(const class UObject* WorldContextObject, const TArray<FSBPlayerPresetEquipList>& Param);
    bool SetPlayerPresetEquipItemByIndex(const class UObject* WorldContextObject, int32 PresetListIndex, int32 PresetItemIndex, const FSBPlayerPresetEquipItem& Param);
    bool SetPlayerPresetEquipItem(const class UObject* WorldContextObject, int32 PresetListIndex, const TArray<FSBPlayerPresetEquipItem>& Param);
    void SetExpiredTimeRoseOrbPaid(const class UObject* InWorldContextObject, const FDateTime InExpired);
    void SetExpiredTimeRoseOrbFree(const class UObject* InWorldContextObject, const FDateTime InExpired);
    void SetExpiredTimeBPPoint(const class UObject* InWorldContextObject, const FDateTime InExpired);
    void SetEquipItemInfo(const class UObject* InWorldContextObject, const ESBCharaEquipType InEquipType, const FCharaEquipItemInfo& InEquipItemInfo);
    void SetCommandMenuPlayerAvatarPoseId(const class UObject* InWorldContextObject, const int32 InPoseId);
    void SetClassMaxDamage(const class UObject* InWorldContextObject, const int32 InValue);
    void SetBPPoint(const class UObject* InWorldContextObject, const int32 InBp);
    void RemoveStepList(class UObject* InWorldContextObject, const FSBCharacterStepListInfo InStepListInfo);
    bool IsTargetEnemyId(class UObject* InWorldContextObject, FString InEnemyId, int32 InEnemylevel);
    bool IsSubPaletteReleased(const class UObject* InWorldContextObject, const ESBClassType InClassType);
    bool IsRewardGet(const class UObject* InWorldContextObject, const TArray<FSBMasterReward>& RewardList);
    bool IsPresetEquipExect(const class UObject* WorldContextObject, const ESBClassType ClassType, const ESBPlayerPresetType Type, const TArray<FSBPlayerPresetEquipItem>& item, int32& rRetCode);
    bool IsPlayerPresetEquipItem(const class UObject* WorldContextObject, FString InUniqueId);
    bool IsMasterySkillOthersIncluded(const class UObject* InWorldContextObject, const int32 SkillId);
    bool IsMasterySkill(const class UObject* InWorldContextObject, const int32 SkillId);
    bool IsEquipTypeAreEquipped(const class UObject* InWorldContextObject, const ESBCharaEquipType EquipType);
    bool IsEquipmentItemByItemIndex(const class UObject* InWorldContextObject, const int32 InItemIndex);
    bool IsEquipmentItem(const class UObject* InWorldContextObject, FString InUniqueId);
    bool IsEquipedArtsSkillId(const class UObject* InWorldContextObject, const int32 InSkillId);
    bool isClassLevelLimit(const class UObject* InWorldContextObject);
    bool IsClassLevelCounterStop(const class UObject* InWorldContextObject);
    int32 GetTotalPowerBySelectStackBType(const class UObject* InWorldContextObject, const int32 LevelSyncTarget, const ESBStackBEnableType StackBEnableType);
    int32 GetTotalPowerByOtherChara(const class UObject* InWorldContextObject, const class USBPartyMemberState* MemberState, const TArray<FBattleMemberLevelSyncInfo>& BattleMemberLevelSyncInfos, int32 LevelSyncTarget, ESBStackBEnableType StackBEnableType);
    int32 GetTotalPowerByCharaEquipInfo(const class UObject* InWorldContextObject, const FCharaEquipInfo& EquipInfo, const int32 LevelSyncTarget, const ESBClassType InClassType, const ESBStackBEnableType StackBEnableType);
    int32 GetTotalPower(const class UObject* InWorldContextObject, const int32 LevelSyncTarget);
    TArray<FSBCharacterToken> GetTokenList(const class UObject* InWorldContextObject);
    FSBCharacterToken GetTokenFromPlaceToConsume(const class UObject* InWorldContextObject, ESBTokenPlaceToConsumeType InTokenPlaceToConsumeType);
    int32 GetTokenAmount(const class UObject* InWorldContextObject, const int32 InTokenId);
    FSBCharacterToken GetToken(const class UObject* InWorldContextObject, int32 InTokenId);
    int32 GetTensionTag(const class UObject* InWorldContextObject);
    int32 GetSubPaletteReleaseLevel(const class UObject* InWorldContextObject);
    class USBOwnItemListContainer* GetStorage(const class UObject* InWorldContextObject, const int32 InStorageNumber);
    FShortcutInfo GetShortcutInfo(const class UObject* InWorldContextObject);
    int32 GetRoseOrbPaid(const class UObject* InWorldContextObject);
    int32 GetRoseOrbFree(const class UObject* InWorldContextObject);
    FSBCharacterQuestSetting GetQuestSetting(const class UObject* InWorldContextObject);
    FString GetProfileComment(const class UObject* InWorldContextObject);
    bool GetPlayerPresetEquipNowEquipBattleSet(const class UObject* WorldContextObject, TArray<FSBPlayerPresetEquipItem>& OutParam);
    bool GetPlayerPresetEquipListByIndex(const class UObject* WorldContextObject, int32 PresetListIndex, FSBPlayerPresetEquipList& OutParam);
    bool GetPlayerPresetEquipList(const class UObject* WorldContextObject, TArray<FSBPlayerPresetEquipList>& OutParam, bool bEmptyBottom);
    bool GetPlayerPresetEquipItemByIndex(const class UObject* WorldContextObject, int32 PresetListIndex, int32 PresetItemIndex, FSBPlayerPresetEquipItem& OutParam);
    bool GetPlayerPresetEquipItem(const class UObject* WorldContextObject, int32 PresetListIndex, TArray<FSBPlayerPresetEquipItem>& OutParam);
    bool GetOpenCommandMenuFlag(const class UObject* InWorldContextObject);
    float GetNowLevelClassExtraExpRatio(const class UObject* InWorldContextObject);
    int32 GetNowLevelClassExtraExpMax(const class UObject* InWorldContextObject);
    float GetNowLevelClassExpRatio(const class UObject* InWorldContextObject);
    int32 GetNowLevelClassExpPoint(const class UObject* InWorldContextObject);
    int32 GetNowLevelClassExpMax(const class UObject* InWorldContextObject);
    FSBAdventurerRankMasterData GetNowAdventurerRankMasterData(const class UObject* InWorldContextObject, bool& IsExists);
    float GetMountEnergyMax(const class UObject* InWorldContextObject);
    float GetMountEnergy(const class UObject* InWorldContextObject);
    int32 GetMoney(const class UObject* InWorldContextObject);
    int32 GetMissionQuestRank(const class UObject* InWorldContextObject);
    FMapPinListInfo GetMapPinListInfo(const class UObject* InWorldContextObject);
    int32 GetLevelLimitClassExpMax(const class UObject* InWorldContextObject);
    int32 GetLevelLimit(const class UObject* InWorldContextObject);
    bool GetKeyValue(const class UObject* InWorldContextObject, const FName InKeyName, FString& OutValue);
    class USBOwnItemListContainer* GetItemBag(const class UObject* InWorldContextObject);
    class USBOwnItemListContainer* GetInventory(const class UObject* InWorldContextObject);
    FDateTime GetExpiredTimeRoseOrbPaid(const class UObject* InWorldContextObject);
    FDateTime GetExpiredTimeRoseOrbFree(const class UObject* InWorldContextObject);
    FDateTime GetExpiredTimeBPPoint(const class UObject* InWorldContextObject);
    class USBOwnItemListContainer* GetEquipmentBag(const class UObject* InWorldContextObject);
    FCharaEquipItemInfo GetEquipItemInfoFromUniqueId(const class UObject* InWorldContextObject, FString InUniqueId);
    FCharaEquipItemInfo GetEquipItemInfo(const class UObject* InWorldContextObject, const ESBCharaEquipType EquipType);
    FCharaEquipInfo GetEquipInfo(const class UObject* InWorldContextObject);
    FEquipedArtsListInfo GetEquipedArtsInfoList(const class UObject* InWorldContextObject);
    int32 GetEquipedArtsId(const class UObject* InWorldContextObject, const ESBPlayerArtsType InArtsType, const int32 InSlotId);
    void GetEquipedActiveArtsAbility(const class UObject* InWorldContextObject, const int32 InSlotId, bool& OutIsActiveAbilityEquiped, ESBSkillAbilityType& OutEquipedActiveAbilityType, int32& OutEquipedActiveAbilitySkillId);
    int32 GetEqipedArtsInfoIndex(const class UObject* InWorldContextObject, const ESBPlayerArtsType InArtsType, const int32 InSlotId);
    bool GetEqipedActiveAbility(const class UObject* InWorldContextObject, int32& OutSkillId, const int32 InArtsId);
    TArray<FString> GetEnemyIdListFromStepList(class UObject* InWorldContextObject);
    int32 GetCurrentSkilllevelOthersIncludedPlus(const class UObject* InWorldContextObject, const int32 SkillId);
    int32 GetCurrentSkillLevelOthersIncluded(const class UObject* InWorldContextObject, const int32 SkillId);
    int32 GetCurrentSkillLevel(const class UObject* InWorldContextObject, const int32 SkillId);
    int32 GetCounterStopClassLevel(const class UObject* InWorldContextObject);
    int32 GetCommandMenuPlayerAvatarPoseId(const class UObject* InWorldContextObject);
    ESBClassType GetClassType(const class UObject* InWorldContextObject);
    int32 GetClassMaxDamage(const class UObject* InWorldContextObject, const ESBClassType InClassType);
    int32 GetClassLevelFromClassType(const class UObject* InWorldContextObject, ESBClassType InClassType);
    void GetClassLevelAddExpCalculation(const class UObject* InWorldContextObject, int32 AddExp, int32& AfterLevel, int32& AfterExp, int32& AfterMaxExp, bool& bExpOver);
    int32 GetClassLevel(const class UObject* InWorldContextObject);
    int32 GetClassExtraExp(const class UObject* InWorldContextObject);
    int32 GetClassExp(const class UObject* InWorldContextObject);
    TArray<int32> GetCheckableQuest(class UObject* InWorldContextObject, bool isCheckUpdate);
    class USBOwnItemListContainer* GetCharacterStorage(const class UObject* InWorldContextObject);
    FString GetCharacterName(const class UObject* InWorldContextObject);
    class USBCharacterData* GetCharacterData(const class UObject* InWorldContextObject);
    TArray<FSBSkillTreeHorizonBranchData> GetBranchingSkilHorizonlListData(const class UObject* InWorldContextObject, int32 SkillId, int32 SkillLV, int32 CheckDepthNum);
    int32 GetBPPoint(const class UObject* InWorldContextObject);
    int32 GetBP(const class UObject* InWorldContextObject);
    int32 GetBlackListNum(const class UObject* InWorldContextObject);
    FString GetBestScore(const class UObject* InWorldContextObject);
    int32 GetAdventurerRankLimit(const class UObject* InWorldContextObject);
    int32 GetAdventurerRank(const class UObject* InWorldContextObject);
    int32 GetAchievementId(const class UObject* InWorldContextObject);
    class USBOwnItemListContainer* GetAccountStorage(const class UObject* InWorldContextObject);
    int32 FindQuestCheckList(class UObject* InWorldContextObject, const int32 InQuestIndex);
    ESBCharaEquipType FindEquipItemInfo(const class UObject* InWorldContextObject, FString InUniqueId);
    ESBCharaEquipType FindCharaEquipTypeFromEquipTypeJsonObjectName(const class UObject* InWorldContextObject, FString InEquipTypeJsonObjectName);
    bool ExistKeyValue(const class UObject* InWorldContextObject, const FName InKeyName);
    void ExcludePlayerPresetEquipItemNotInEquipmentBag(const class UObject* InWorldContextObject, const TArray<FSBPlayerPresetEquipItem>& InPresetEquipItems, TArray<FSBPlayerPresetEquipItem>& OutPresetEquipItems);
    void DumpQuestCheckList(class UObject* InWorldContextObject);
    void DebugAddClassExp(const class UObject* InWorldContextObject, const int32 InValue);
    void CreatePresetEquipSetAllDataSlot(const class UObject* WorldContextObject);
    void ClearStepList(class UObject* InWorldContextObject);
    void ClearPresetEquipSetAllDataSlot(const class UObject* WorldContextObject);
    bool ClearPlayerPresetEquipData(const class UObject* WorldContextObject, int32 PresetListIndex);
    void CleanupQuestCheckList(class UObject* InWorldContextObject);
    bool CheckBlackList(const class UObject* InWorldContextObject, const FString CharacterId);
    void AddStepList(class UObject* InWorldContextObject, const FSBCharacterStepListInfo InStepListInfo);
}; // Size: 0x28

class USBCharacterElementalBurstComparison : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCharacterLoopCounterComponent : public UActorComponent
{
    uint16 CountLoopMax;                                                              // 0x00BA (size: 0x2)

}; // Size: 0xC0

class USBCharacterMovementBaseComponent : public UASCharacterMovementComponent
{
    char padding_0[0xBE0];                                                            // 0x0000 (size: 0x0)

    void RemoveSwimmingAreaActor(class ASBWaterMeshActor* tgt);
    float GetWaterflowVelocity(FVector& waterflowVelocity);
    float GetSwimmingWaterHeight();
    void GetSwimmingSurface(FHitResult& Surface);
    int32 GetSwimmingAreaCount();
    class ASBOceanGrid* GetOceanGrid();
    float GetImmersionDepth();
    void AddSwimmingAreaActor(class ASBWaterMeshActor* tgt);
}; // Size: 0xBE0

class USBCharacterMovementComponent : public USBCharacterMovementBaseComponent
{
    float InitialGravityScale;                                                        // 0x0BD8 (size: 0x4)
    float InitialMaxWalkSpeed;                                                        // 0x0BDC (size: 0x4)
    char padding_0[0xC];                                                              // 0x0BE0 (size: 0xC)
    float CapsuleSweepRadius;                                                         // 0x0BEC (size: 0x4)
    char padding_1[0x8];                                                              // 0x0BF0 (size: 0x8)
    FVector LastFallingVelocity;                                                      // 0x0BF8 (size: 0xC)

    void StopFlying();
    void StartFlying();
    void RestoreMaxWalkSpeed();
    void RestoreGroundFriction();
    void RestoreGravityScale();
    void RestoreFallingLateralFriction();
    void ResetDisableOrientRotation(const FName Name);
    void OnBeginAdjustRootMotion(bool bAdjustWithZAxis);
    float GetInitialGravityScale();
    void DisableOrientRotation(const FName Name);
}; // Size: 0xCC0

class USBCharacterPlayRateModifier : public UActorComponent
{
    char padding_0[0xE8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xE8

class USBCharacterSelectWindow : public UUserWidget
{
    FText DisplayPlayerName;                                                          // 0x0278 (size: 0x18)
    FText CurDisplayCharacterName;                                                    // 0x0290 (size: 0x18)
    FText CurDisplayCharacterLocation;                                                // 0x02A8 (size: 0x18)
    int32 CurCharacterTensionTag;                                                     // 0x02C0 (size: 0x4)
    ESBClassType CurCharacterClass;                                                   // 0x02C4 (size: 0x1)
    char padding_0[0x3];                                                              // 0x02C5 (size: 0x3)
    int32 CurEngram;                                                                  // 0x02C8 (size: 0x4)
    int32 CurLevel;                                                                   // 0x02CC (size: 0x4)
    int32 CurAdventureRank;                                                           // 0x02D0 (size: 0x4)
    int32 CurCharacterSlotMax;                                                        // 0x02D4 (size: 0x4)
    int32 CurCharacterSlotAddMax;                                                     // 0x02D8 (size: 0x4)
    char padding_1[0x4];                                                              // 0x02DC (size: 0x4)
    FString CurPermanentDeletedAt;                                                    // 0x02E0 (size: 0x10)
    int32 NameChangeTicketCount;                                                      // 0x02F0 (size: 0x4)
    char padding_2[0x4];                                                              // 0x02F4 (size: 0x4)
    FDateTime CurPermanentDeletedTime;                                                // 0x02F8 (size: 0x8)
    ESBBanType CurBanType;                                                            // 0x0300 (size: 0x1)
    ESBLoginBanDurationType CurLoginBanDurationType;                                  // 0x0301 (size: 0x1)
    ESBBanBasisType CurLoginCharacterBanBasisType;                                    // 0x0302 (size: 0x1)
    char padding_3[0x5];                                                              // 0x0303 (size: 0x5)
    TArray<FSBCharacterNotification> CurCharacterNotifications;                       // 0x0308 (size: 0x10)
    FSBCharacterBanFinishedTimeInfos CurCharacterBanFinishedTimeInfos;                // 0x0318 (size: 0xC)

    void UpdatePlayerInfo(class UObject* WorldContextObject);
    void SetLoginCharacterRejectedReturnDisconnectedParty(FString CharacterId, const bool RejectedReturnDisconnectedParty);
    void SetLoginCharacterRejectedReturnContent(FString CharacterId, const bool RejectedReturnContent);
    void SetCurrentCharacter(FString CharacterId);
    void RequestRestoreCharacter(class UObject* WorldContextObject, FString CharacterId);
    void RequestRefuseReJoinParty(class UObject* WorldContextObject, FString CharacterId);
    void RequestGetCryptocurrency(class UObject* WorldContextObject);
    void RequestDeleteCharacter(class UObject* WorldContextObject, FString CharacterId, bool bForceDelete);
    void RequestCharacterSlotPurchase(class UObject* WorldContextObject);
    void RequestCharacterRename(class UObject* WorldContextObject, FString CharacterId, FString NewName);
    void RequestBuySlot(class UObject* WorldContextObject);
    void OnUpdatePlayerInfo(bool bWasSuccessful, FString DefaultCharacterId);
    void OnRestoreCharacter(int32 RetCode);
    void OnRefuseReJoinParty(int32 RetCode);
    void OnGetCryptocurrency(int32 RetCode, const FSBCryptoCurrency InCryptocurrency);
    void OnDeletedCharacter(int32 RetCode, bool bForceDelete);
    void OnCharacterSlotPurchase(bool bWasSuccessful, int32 RetCode);
    void OnCharacterRename(int32 RetCode);
    void OnCharacterBuySlot(bool bWasSuccessful, int32 RetCode);
    bool IsReadyToOpenCharacterSelectMap();
    bool IsLoginCharacterRejectedReturnDisconnectedParty(FString CharacterId);
    bool IsLoginCharacterRejectedReturnContent(FString CharacterId);
    bool IsEnablePartyRejoinTime();
    bool IsEnableContentRejoinTime();
    int32 GetPurchaseAmount();
    FSBLastJoinedPartyInfoState GetLastJoinedPartyInfoState();
    FSBLastJoinedContentInfoState GetLastJoinedContentInfoState();
    float GetEnablePartyRejoinRemainingTime();
    float GetEnableContentRejoinRemainingTime();
    void CharacterNotificationsClean(class UObject* WorldContextObject, FString CharacterId);
    void CharacterDataAdaptation();
}; // Size: 0x378

class USBCharacterTimeDilationComponent : public UActorComponent
{
    char padding_0[0xD8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xD8

class USBCharacterTrackingComponent : public UActorComponent
{
    FString LayerName;                                                                // 0x00B8 (size: 0x10)
    float MinTrackingDistance;                                                        // 0x00C8 (size: 0x4)
    float Radius;                                                                     // 0x00CC (size: 0x4)
    float Value;                                                                      // 0x00D0 (size: 0x4)

}; // Size: 0xE0

class USBCharactersLogComponent : public UActorComponent
{
    FSBCharactersLogComponentOnCharactersLogLoadedDelegete OnCharactersLogLoadedDelegete; // 0x00B8 (size: 0x10)
    void SBOnCharactersLogLoadedDelegete(bool Result);
    FSBCharactersLogComponentOnObtainedItemListLoadedDelegete OnObtainedItemListLoadedDelegete; // 0x00C8 (size: 0x10)
    void SBOnObtainedItemListLoadedDelegete(bool Result);
    FSBCharactersLogComponentOnEnemyKillCountListLoadedDelegete OnEnemyKillCountListLoadedDelegete; // 0x00D8 (size: 0x10)
    void SBOnEnemyKillCountListLoadedDelegete(bool Result);

    void UnlockDefaultTutorialHelp(const FSBTutorialHelpData& InTutorialHelpData, const FName& InTutorialHelpId);
    void SBOnObtainedItemListLoadedDelegete__DelegateSignature(bool Result);
    void SBOnEnemyKillCountListLoadedDelegete__DelegateSignature(bool Result);
    void SBOnCharactersLogLoadedDelegete__DelegateSignature(bool Result);
    bool Request_RegistTutorialHelp(const FName& InTutorialHelpId);
    bool Request_RegistNPC(FString InNpcId);
    bool LoadObtainedItemList();
    void LoadEnemyLogs(class ASBPlayerController* PlayerController, bool InIsStartSequence);
    bool LoadCharacterLogs();
    bool IsVisitedMap(FString MapName);
    bool IsVisitedContent(const FName& GameContentId);
    bool IsUnlockTutorialHelp(const FName InTutorialHelpId);
    bool IsObtainedImagine(const FName& InEnemyId);
    bool IsLogInitialized();
    bool IsLibraryWeaponLogs(const int32 InWeaponID);
    bool IsLibraryItemLogs(const int32 InItemID);
    bool IsLibraryImagineLogs(const int32 InImagineId, ELibraryImagineType ImagineType);
    bool IsEnemyKilled(const FName& InEnemyId);
    bool HasLoadedObtainedItemList();
    void GetObtainedItemList(TArray<FItemMasterData>& OutList);
    void GetItemLogs(TArray<int32>& OutList);
    void GetImagineList(TArray<FSBMasterImagine>& OutList);
    TArray<FName> GetConditionClearTutorialHelpIdList();
    bool AddCharacterAction_Resurrection(int32 Count);
}; // Size: 0x1C0

class USBChatBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FString StringReplaceCommand(class UObject* WorldContextObject, FString ChatMessage);
    void RequestEmoteFor(class UObject* WorldContextObject, const FName& InEmotionId, const class ASBPlayerCharacter* PlayerCharacter, const class ASBPlayerState* OtherPlayerState);
    void RequestEmote(class UObject* WorldContextObject, const FName& InEmotionId, const class ASBPlayerCharacter* PlayerCharacter);
    void PushWeaponUsagePeriodEndLog(class UObject* WorldContextObject, const int32 InExpiredWeaponItemId, const int32 InReplacedWeaponItemId);
    void PushWeaponSkinUsagePeriodEndLog(class UObject* WorldContextObject, const FString InWeaponUniqueId);
    void PushMatchingTimeoutLog(class UObject* WorldContextObject);
    void PushLiquidMemoryEfficacyLog(class UObject* WorldContextObject, const ESBLiquidMemoryEfficacyType InEfficacyType);
    void PushGetStampSystemLog(class UObject* WorldContextObject, int32 StampId);
    void PushExpiredRoseOrbSystemLog(class UObject* WorldContextObject);
    void PushExpiredBPPSystemLog(class UObject* WorldContextObject);
    void PushEraseBarrierLog(class UObject* WorldContextObject);
    void PushEquipmentUsagePeriodEndLog(class UObject* WorldContextObject, const int32 InExpiredEquipmentItemId, const EItemType InItemType);
    void PushEquipmentChangeLog(class UObject* WorldContextObject, const FString InEquipmentItemUniqueId);
    void PushEmotionLog(class UObject* WorldContextObject, const FName& EmotionId, FString SenderCharacterName);
    void PushEmotionForLog(class UObject* WorldContextObject, const FName& EmotionId, const class ASBCharacter* TargetCharacter);
    void PushContentsAFKWarning(class UObject* WorldContextObject, const float Second);
    void PushContentsAFKKicked(class UObject* WorldContextObject);
    void PushBattleLogText(class UObject* WorldContextObject, const FText& InMessage, ESBSystemLogDetailType DetailType, ESBChatLogOption Option);
    void PushBattleLog(class UObject* WorldContextObject, const ESBBattleLogType BattleLogType, const TArray<FString>& ParamNames, const TArray<FText>& ParamValues);
    void PushAFKWarning(class UObject* WorldContextObject, const float Second);
    void PushAchievementGainedLog(class UObject* WorldContextObject, const int32 InAchievementId);
    bool ParseEmotionMessageFromId(const FText& InMessageText, FString EmotionId, FText& OutMessageText);
    FString MakeStampMessage(FString StampId);
    bool IsStampMessage(class UObject* WorldContextObject, const FText& InMessage, int32& RetStampID, FText& OutMessage);
    bool IsPlayerSameParty(const class AActor* Owner, const class AActor* Target);
    bool IsLocalUserMessage(class UObject* WorldContextObject, class USBChatMessage* Message);
    bool IsInThisParty(const class ASBPlayerCharacter* Player, const class USBPartyGameState* PartyGameState);
    bool IsInParty(const class AActor* Owner);
    bool IsEmotionMessage(class UObject* WorldContextObject, const FText& InMessage, FString& RetEmotionId);
    FString GetOpenChatModeKeyTextbyMouseAndKeyboard();
    FString GetGameSessionId(class UObject* WorldContextObject);
    bool GetEmotionMessageInEmotionId(FString InEmotionMessage, FString& RetEmotionId);
    ESBChatLogType GetChatTypeChangeSuitableOne(class UObject* WorldContextObject, ESBChatLogType InType);
    FString GetChatRoomID(class UObject* WorldContextObject, ESBChatLogType InType);
    class USBChatManager* GetChatManager(class UObject* WorldContextObject);
    FSBChatSpecialCommandInfo CheckSpecialCommand(FString ChatMessage);
    bool CheckChatUnreadNotifyValid(class UObject* WorldContextObject, const FSBChatUIMessage& Mess, const bool IsNoStackCheck);
    bool CanLocalUserChat(class UObject* WorldContextObject);
}; // Size: 0x28

class USBChatLogWindow : public USBUserWidget
{
    char padding_0[0x2B0];                                                            // 0x0000 (size: 0x0)

    bool IsCreateChat(const FSBChatUIMessage& Mess, const int32& FilterType, const int32 DetailFilterType);
}; // Size: 0x2B0

class USBChatLogWindowStatusData : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBChatSaveDatas datas;                                                           // 0x0050 (size: 0x28)

}; // Size: 0x78

class USBChatManager : public UObject
{
    FSBChatManagerOnChatSendErrorDelegete OnChatSendErrorDelegete;                    // 0x00E8 (size: 0x10)
    void OnChatSendErrorDelegete(ESBChatSendErrorType ErrorType);
    char padding_0[0x28];                                                             // 0x00F8 (size: 0x28)
    FSBChatManagerOnChangeCoolTimeEmotionDelegate OnChangeCoolTimeEmotionDelegate;    // 0x0120 (size: 0x10)
    void OnChangeCooltimeDelegate(bool IsCoolTime);
    FSBChatManagerOnChangeCoolTimeStampDelegate OnChangeCoolTimeStampDelegate;        // 0x0130 (size: 0x10)
    void OnChangeCooltimeDelegate(bool IsCoolTime);
    char padding_1[0x30];                                                             // 0x0140 (size: 0x30)
    FSBChatManagerOnReciveMessageToUnreadNotify OnReciveMessageToUnreadNotify;        // 0x0170 (size: 0x10)
    void OnReciveMessageToUnreadNotify(const TEnumAsByte<ESBChatLogWindowSlot::Type> Slot, const FSBChatUIMessage& UIMessage);
    FSBChatManagerOnLogWindowTempVisibleDelegate OnLogWindowTempVisibleDelegate;      // 0x0180 (size: 0x10)
    void OnLogWindowTempVisibleDelegate();
    FSBChatManagerOnDirectChatSenderRemoveDelegate OnDirectChatSenderRemoveDelegate;  // 0x0190 (size: 0x10)
    void OnDirectChatSenderRemoveDelegate(FString CharacterId);

    void SetCoolTimeStamp();
    void SetCoolTimeEmotion();
    void SendTeamChat(FString MsgBody);
    void SendPrivateChat(FString UserId, FString CharacterId, FString MsgBody);
    void SendPartyChat(FString MsgBody);
    void SendOpenChat(FString MsgBody);
    void SendGuildChat(FString MsgBody);
    void SendCloseAreaChat(FString MsgBody);
    void OnReciveMessageToUnreadNotify__DelegateSignature(const TEnumAsByte<ESBChatLogWindowSlot::Type> Slot, const FSBChatUIMessage& UIMessage);
    void OnLogWindowTempVisibleDelegate__DelegateSignature();
    void OnDirectChatSenderRemoveDelegate__DelegateSignature(FString CharacterId);
    void OnChatSendErrorDelegete__DelegateSignature(ESBChatSendErrorType ErrorType);
    void OnChangeCooltimeDelegate__DelegateSignature(bool IsCoolTime);
    bool IsCoolTimeCountStamp();
    bool IsCoolTimeCountEmotion();
    void CallReciveMessageToUnreadNotify(const TEnumAsByte<ESBChatLogWindowSlot::Type> Slot, const FSBChatUIMessage& UIMessage);
}; // Size: 0x1A0

class USBChatMemberState : public UObject
{
    FUniqueNetIdRepl UniqueId;                                                        // 0x0030 (size: 0x28)

    bool IsLocalPlayer();
    class ASBPlayerState* GetPlayerState();
    class ASBPlayerCharacter* GetPlayerCharacter();
    FText GetDisplayName();
}; // Size: 0x80

class USBChatMessage : public UObject
{
    char padding_0[0x100];                                                            // 0x0000 (size: 0x0)

    void MakeMessageStruct(FSBChatRoomMessage& OutMessage);
    bool IsUnread();
    bool IsDead();
    bool IsCloseArea();
    bool IsChat();
    bool HasSender();
    FDateTime GetTimestamp();
    ESBSystemLogDetailType GetSystemLogDetailType();
    FText GetSenderName();
    class USBChatMemberState* GetSenderMemberState();
    FString GetSenderId();
    FString GetSenderCharacterId();
    class USBChatMemberState* GetReceiverMemberState();
    FString GetReceiverId();
    ESBChatLogType GetChatLogType();
    ESBChatLogOption GetChatLogOption();
    FText GetBody();
}; // Size: 0x100

class USBChatWindow : public USBUserWidget
{
    FSBChatWindowOnChatSendErrorDelegete OnChatSendErrorDelegete;                     // 0x02B0 (size: 0x10)
    void OnChatSendErrorDelegete();

    void OnPress_EndChat();
    void OnChatSendErrorDelegete__DelegateSignature();
    void OnChanged_ConnectionChatServer(bool IsLogin);
    void Native_EndChat();
    bool IsActive();
    void Deactive();
    void Active();
}; // Size: 0x2D8

class USBCheatCommandBaseComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBCheatCommandPlayerComponent : public USBCheatCommandBaseComponent
{
    TArray<class AActor*> TestReplicateActorList;                                     // 0x00B8 (size: 0x10)
    TArray<class AActor*> FreeArrangeActorList;                                       // 0x00C8 (size: 0x10)
    bool bDebugFollow;                                                                // 0x00D8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00D9 (size: 0x3)
    FVector DebugFollowPoint;                                                         // 0x00DC (size: 0xC)

    void Server_SubClassExp(const int32 Value);
    void Server_SetClassLevel(const int32 Level);
    void Server_SetClassExp(const int32 Value);
    void Server_SetClassExExp(const int32 Value);
    void Server_AddClassExp(const int32 Value);
    void Client_SaveLevel(const int32 AddExp, const FSBExtraExpParse ExtraExpParse);
    void Client_SaveExp(const int32 Exp);
    void CheatCommand_TestSpawnReplicateActor(int32 SpawnNum, float Min, float Max);
    void CheatCommand_TestDestroyReplicateActor();
    void CheatCommand_SubClassExp(const int32 Value);
    void CheatCommand_SpawnFreeArrangeActor(int32 ActorID);
    void CheatCommand_ShieldDamage(const float DamageValue);
    void CheatCommand_SetClassLevel(const int32 Level);
    void CheatCommand_SetClassExp(const int32 Value);
    void CheatCommand_SetClassExExp(const int32 Value);
    void CheatCommand_ServerTriggerAbility(int32 ID, int32 Parts1Value1, int32 Parts1Value2, int32 Parts2Value1, int32 Parts2Value2, int32 Time, bool Passive, ESBAbilityRequestSource RequestType);
    void CheatCommand_ServerPrintBattleEffective();
    void CheatCommand_ServerGatherPlayerStateMachine();
    void CheatCommand_ServerGatherPlayerParameter();
    void CheatCommand_ServerGatherAroundPlayerParameter(float Radius);
    void CheatCommand_ServerForceSyncInitialParametersLoadCompleted();
    void CheatCommand_ServerForceSyncClientReady();
    void CheatCommand_SendMaterialParamAroundPlayer(FName MaterialName, float Value, float Radius);
    void CheatCommand_SelfDamage(const float DamageValue, FSBAttackStunSetting AttackStunSetting);
    void CheatCommand_PlayerRadiusDamage(const float DamageValue, const float Radius);
    void CheatCommand_GatherPlayerParameter();
    void CheatCommand_GatherAroundPlayerParameter(float Radius);
    void CheatCommand_DestroyFreeArrangeActor();
    void CheatCommand_ClientGatherPlayerStateMachine(const FSBDebugGatherStateMachineParam& ServerStateMachineParam);
    void CheatCommand_ClientGatherPlayerParameter(const FSBDebugGatherPlayerParam& DebugPlayerParam);
    void CheatCommand_ClientGatherAroundPlayerParameter(const TArray<FSBDebugGatherAroundPlayerParam>& DebugAroundPlayerParam);
    void CheatCommand_AddClassExp(const int32 Value);
}; // Size: 0xE8

class USBCheatCommandProjectileComponent : public USBCheatCommandBaseComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)

    void CheatCommand_WorldProjectileNum();
    void CheatCommand_TestProjectile(FName SkillName, bool bFirst, int32 Index);
}; // Size: 0xB8

class USBCheatCommandUtilityComponent : public USBCheatCommandBaseComponent
{
    FSBCheatCommandUtilityComponentOnCompleteAPICheck OnCompleteAPICheck;             // 0x00B8 (size: 0x10)
    void CheatAPIChecked(bool bWasSuccessful, FString Response);

    void Server_UncheaterServerInit();
    void Server_UncheaterServerExit();
    void Server_SetAllClimbingPointActive(const bool IsActive);
    void Server_PlayWorldCameraShake(TSubclassOf<class UCameraShakeBase> Shake, const FVector& Epicenter);
    void Server_CheckGetAPI(FString URL);
    void Server_CheckAPI(FString URL, FString PostData);
    void Multicast_PlayWorldCameraShake(TSubclassOf<class UCameraShakeBase> Shake, const FVector& Epicenter);
    void Client_OnUncheaterServerInit(FString InDescription);
    void Client_CheckAPI(bool bWasSuccessful, FString Response);
    void CheatCommand_SetServerFrameRate(int32 fps);
    void CheatCommand_ServerSendCommand(FString Command);
    void CheatCommand_ServerDumpObjectProperty(FString ClassName, FString PropertyName);
    void CheatCommand_Server_RequestReloadMasters();
    void CheatCommand_ForceLogOutput();
    void CheatCommand_DisconnectCaller();
    void CheatCommand_ClientDumpObjectProperty(FString Result, const int32 ResultLength);
    void CheatCommand_Client_CompleteServer_ReloadAllMasters();
    void CheatAPIChecked__DelegateSignature(bool bWasSuccessful, FString Response);
}; // Size: 0xC8

class USBCheatManager : public UCheatManager
{
    class ASBDebugCameraController* OtherViewController;                              // 0x0088 (size: 0x8)
    TSubclassOf<class UCameraShakeBase> CameraShakeData;                              // 0x0090 (size: 0x8)
    TSubclassOf<class ASBPhotoModeController> PhotoModeControllerClass;               // 0x0098 (size: 0x8)
    class ASBPhotoModeController* PhotoModeControllerRef;                             // 0x00A0 (size: 0x8)
    class USBBotCheatCommand* BotCommand;                                             // 0x00A8 (size: 0x8)
    class USBEnemyCheatCommand* EnemyCommand;                                         // 0x00B0 (size: 0x8)
    class USBMobCheatCommand* MobCommand;                                             // 0x00B8 (size: 0x8)
    class USBPlayerCheatCommand* PlayerCommand;                                       // 0x00C0 (size: 0x8)
    class USBDungeonCheatCommand* DungeonCommand;                                     // 0x00C8 (size: 0x8)
    class USBStorageCheatCommand* StorageCommand;                                     // 0x00D0 (size: 0x8)
    class USBMatchCheatCommand* MatchCommand;                                         // 0x00D8 (size: 0x8)
    class USBEventCheatCommand* EventCommand;                                         // 0x00E0 (size: 0x8)
    class USBUICheatCommand* UICommand;                                               // 0x00E8 (size: 0x8)
    class USBPartyCheatCommand* PartyCheatCommand;                                    // 0x00F0 (size: 0x8)
    class USBPerformanceCheckCheatCommand* PerformanceCheckCommand;                   // 0x00F8 (size: 0x8)
    class USBBattleCheatCommand* BattleCheatCommand;                                  // 0x0100 (size: 0x8)
    class USBUncheaterCheatCommand* UncheaterCommand;                                 // 0x0108 (size: 0x8)
    class USBHttpQueryCheatCommand* HttpQueryCommand;                                 // 0x0110 (size: 0x8)
    class USBQuestCheatCommand* QuestCommand;                                         // 0x0118 (size: 0x8)
    class USBOnlineCheatCommand* OnlineCommand;                                       // 0x0120 (size: 0x8)
    class USBDebugCheatCommand* DebugCommand;                                         // 0x0128 (size: 0x8)

    void WorldProjectileNum();
    void WarpToTarget(const float Distance, const float Yaw);
    void UpdateFieldStatusAll();
    void UpdateCreationParts();
    void UpdateActorTransparent();
    void UnlockLiquidMemoryLevel(const uint32 InLiquidMemoryId, const int32 InLevel);
    void UnlockAllCraftRecepis();
    void UnlockAdventurerRankFlag();
    void UnloadMap();
    void TutHelpRequest(const FName& TutorialHelpId);
    void TutHelpAllOpen();
    void TryClassChange(ESBClassType Class);
    void TriggerAssertionServer();
    void TriggerAssertion();
    void ToggleSlateCursorDebug();
    void TogglePhotoMode();
    void ToggleOtherView();
    void ToggleEnableAvatarRandomWait();
    void ToggleDebugCameraHUD();
    void TestSpawnReplicateActor(int32 SpawnNum, float Min, float Max);
    void TestLaunchProjectile(FName SkillName, bool bFirst, int32 Index);
    void TestDestroyReplicateActor();
    void TeleportToLocation(const float X, const float Y, const float Z);
    void TakeDamageDestructible(float Damage);
    void SwitchOceanCollision(bool sw);
    void StopServerShutDownNotice();
    void StartTerrainCheck(float UnitSize);
    void StartInstanceBattle(FName DungeonId);
    void StartAwsServerShutDownNotice();
    void StartAutoScalingServerShutDownNotice(const int32 InRemainMinutes);
    void SpawnFreeArrangeActor(int32 ActorID);
    void SkipTheaterCheck();
    void ShowWeapon_LocallyPlayer();
    void ShowTerrainCheckResult();
    void ShowSimpleSystemMessage(const FText& Message);
    void ShowRouteGuideDest();
    void ShowPlayerStateFields();
    void ShowPlayerControllerFields();
    void ShowPlayerCharacterFields();
    void ShowMapInfo();
    void ShowLocalCharacterList();
    void ShowLoadingScreen(const FName& GameContentId);
    void ShowFallDeadVolume();
    void SetUserFlag(FString FlagId, const bool bValue);
    void SetUnauthorizedTextConcealment(const bool InEnable);
    void SetUIVisibleSetting(const ESBUIType InUIType, bool bInVisibility);
    void SetSlateDebugFlag(const int32 Value);
    void SetSkyDebug(bool sw);
    void SetSkipTutorial(bool bSkip);
    void SetServerFrameRate(int32 fps);
    void SetSchedulerVirtualDateStopType(FString DateString);
    void SetSchedulerVirtualDateMoveType(FString DateString);
    void SetRouteGuideDest(FName DestinationId);
    void SetRotation(const float InPitch, const float InYaw, const float InRoll);
    void SetPlayerGodMode(const bool bActivate);
    void SetNetUpdateFrequency(const float Value);
    void SetLocation(const float X, const float Y, const float Z);
    void SetLoadingCollisionDisable(bool IsDisable);
    void SetForceShowOpenCmdMenuIcon(bool bShow);
    void SetFoliageReactionMax(int32 Num);
    void SetEnableTextVersionDialog(const bool InEnable);
    void SetDigitalSignageSetupTextureDelayWaitUseFlag(const bool InUseFlag);
    void SetDemoBattleEffectHidden(bool bHidden);
    void SetCursorSpeedNormal(const float InSpeed);
    void SetCursorSpeedLow(const float InSpeed);
    void SetCurrentCulture(FString culture);
    void SetContentsAFKAutoKickDisable(bool bIsIgnore);
    void SetContentLock(const ESBContentLockType ContentLockType, const bool bLock);
    void SetCommandMenuDebugAlpha(float Alpha);
    void SetCharacterWidth(const float SliderValue);
    void SetCharacterHeight(const float SliderValue);
    void SetCharacterBust(const float SliderValue);
    void SetBattleStatusSelectTableName(FName Name);
    void SetBattleStatusDeactive(bool B);
    void SetAllNpcHidden(bool bHidden);
    void SetAllMobNpcSpawnFadeInTime(float Time);
    void SetAllClimbingPointActive(const bool IsActive);
    void SetAFKAutoKickDisable(bool bIsIgnore);
    void SetAdventurerRank(const int32 Value);
    void SetActorTransparentFlag_Debug();
    void SetActorHiddenInGame(FString ClassName, bool bFlag);
    void ServerSendCommand(FString Command);
    void ServerGatherEnemyParam();
    void Server_CheckRaidBattleGateStatus(FString CharacterId, FString TermId);
    void SchedulerVirtualDateStop();
    void SBShowNavigation(FString InNavMesh);
    void RunNetworkError();
    void RunGarbageCollectionIfNeededDebug(int32 Time, int32 Count);
    void RouteGuideStart(bool sw, bool DebugSw);
    void ReviveSelf();
    void ReturnToRoom();
    void RestartGame();
    void ResetExportLocationFile();
    void RequestLoadDebugTickableObject();
    void RequestLoadDebugProjectileList();
    void RequestGetRewardBoost();
    void RequestForceLogOutput();
    void RequestDisconnectCaller();
    void RequestAdventurerRankUp();
    void ReloadLocalTranslationText();
    void ReloadClimbingPoint();
    void ReloadAllMasters(bool bApplyServer);
    void ReleaseContentLock(const FName& ContentType);
    void RankingRewardDebug();
    void PostEventScriptSEAsync(FString EventName);
    void PlayWorldCameraShake(float X, float Y, float Z);
    void PlayLevelSequence(FString AssetPath);
    void PlayInterruptQuestBGM(ESBInterruptQuestBGMType MissionType, ESBInterruptQuestBGMState MissionState);
    void PlayerShortPinDebug();
    void PlayDemo(const FName& Name);
    void PlayBuddyConditionalVoice(FName& InConditionId);
    void PartsBreakMulti(FName PartsName1, FName PartsName2, FName PartsName3, FName PartsName4, bool bSoon);
    void PartsBreak(FName PartsName, bool bSoon);
    void OwnItemIndexRewritingAll(int32 InStartIndex);
    void OwnItemIndexRewriting(int32 InTargetNum, int32 InRewritingIndex);
    void OutputDXPlayerContributionValue();
    void OutputCollisionParam(FString SearchActorName, FString SearchComponentName);
    void OutCheckDebugMode();
    void OutCheckDebugLogMode();
    void OpenLevelDesignEnemyParamSetting();
    void OpenExportLocationSaveDirectory();
    void OpenAdminUserPage();
    void OpenAdminPage();
    void OpenAdminMasterPage(FString InMasterDataType);
    void OpenAdminCharacterPage();
    void OnUnlockLiquidMemoryLevel(int32 RetCode);
    void OnAddLiquidMemory(int32 RetCode);
    void OnAccumulateLiquidMemory(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos);
    void Note(FString Note);
    void MasterWeaponIndexRewritingAll(int32 InStartIndex);
    void MasterMountImagineIndexRewritingAll(int32 InStartIndex);
    void MasterItemIndexRewritingAll(int32 InStartIndex);
    void MasterImagineIndexRewritingAll(int32 InStartIndex);
    void MasterCostumeIndexRewritingAll(int32 InStartIndex);
    void LookAtToCamera(bool Flag);
    void LoadMap(FString MapName);
    void LoadBattleRegident();
    void LeaveDungeon();
    void KillSelf();
    void KillAllPlayerAndEnemyInBattleArea();
    void KillAllEnemyInBattleArea();
    void KillAllEnemyAndPlayerInBattleArea();
    void KillAllEnemy();
    void KeyConfigSetup();
    void JumpToDungeonLastBoss();
    void JingleStackClear(bool IsDump);
    void JingleRequest(const TEnumAsByte<EJingleType::Type> Type);
    void JingleDump();
    void ItemDefaultOrderDebug();
    void ItemAppraisalResultDebug();
    bool IsTraverseDebug();
    bool IsTraverseAllClearDebug();
    bool IsRunGarbageCollectionIfNeededDebug();
    bool IsRankingRewardDebug();
    bool IsPlayerShortPinDebug();
    bool IsOutCheckDebugMode();
    bool IsOutCheckDebugLogMode();
    bool IsItemDefaultOrderDebug();
    bool IsItemAppraisalResultDebug();
    bool IsDhcBattleDebugMode();
    bool IsBattleStatusDeactive();
    void InitFaceAnim(bool bForceReInit);
    void IncompleteDungeon(FName DungeonId);
    void HideWeapon_LocallyPlayer();
    void HideLoadingScreen();
    void HideFallDeadVolume();
    void HasNgWord(FString CheckText);
    void GetTransform();
    void GetLocation();
    void GetEventTermNextOffLabelDataTimeTest(FString InTermId, FString InDateString);
    int32 GetConnectToServerFailureDebug();
    float GetCommandMenuDebugAlpha();
    FName GetBattleStatusSelectTableName();
    void ForceReadMark();
    void ForceGarbageCollection();
    void ForceClearDungeon();
    void FlyingPlatform();
    void FadeOutScreen();
    void FadeInScreen();
    void ExportLocation();
    void EventExecutor_SetOutputLog(bool bValue);
    void EventExecutor_OutputInfo();
    void EventExecutor_ExecuteEvent(FName EventName, FString Param);
    void EnemyHitPointForceSync();
    void EndTutorialMap();
    void DxBattleCastleGateInfinityHP(bool SetFlag);
    void DumpUserFlag();
    void DumpTraverse();
    void DumpServerObjectProperty(FString ClassName, FString PropertyName);
    void DumpSBTextTableCash(const FString OutputFilePath);
    void DumpSBTextTable(const FString OutputFilePath);
    void DumpPrimitiveComponentWithCollision(const FName& Name);
    void DumpOptionServerSendData();
    void DumpNpcListOnManager();
    void DumpNgWord();
    void DumpLoadingScreenStatus();
    void DumpHudLayoutData();
    void DumpGameSessionState();
    void DisplayTextId(const ESBDisplayTextIdFlag InFlag1, const ESBDisplayTextIdFlag InFlag2, const ESBDisplayTextIdFlag InFlag3, const ESBDisplayTextIdFlag InFlag4);
    void DigitalSignageMasterDataLogPut();
    void DigitalSignageDownLoadTextureRelease(FString Name);
    void DhcBattleDebugMode();
    void DestroyFreeArrangeActor();
    void DebugWeaponLog();
    void DebugTraverseAllClear();
    void DebugTraverse();
    void DebugPrintLogVFXSetting();
    void DebugPlayTide(bool sw, float TimeSec);
    void DebugLogSoundLoadAsset();
    void DebugLogEffectSpawnCount();
    void DebugLogBGM();
    void DebugLogAkEventTrigger();
    void DebugLogActorVisibility(FString ActorName);
    void DebugChangeLocalizeVoice(FString Language);
    void DebugCameraDistanceLimit(float Limit);
    void DeactivateWarpPoint(FString WarpPointId);
    void DeactivateDungeon(FString DungeonId);
    void DB_SetHintDialogShowed(bool IsShowed);
    void DB_DumpHintDialogShowed();
    void ConnectToServerFailureDebug(int32 InRetCode);
    void ConfigSeaverSaveDataClear();
    void CompleteDungeon(FName DungeonId);
    void CheckRaidBattleGateStatus(FString TermId);
    void CheckEventTermData(FString TermId, int32 Index, FString DateString);
    void CheckDigitalSignageStatus(FString Name);
    void CharaCreateDebugInfo();
    void ChangeEffectAttachedTest(FName SocketName);
    void BugReport();
    void BeginTutorialMap(FString CharacterId);
    void AdminExecuteCommand(FString InputText);
    void AddMoney(const int32 Value);
    void AddLocation(const float X, const float Y, const float Z);
    void AddLiquidMemory(const int32 InLiquidMemoryId, const bool bMaxAccumulatedFlag, const int32 InLevel);
    void AddLine2NotifyMessage(const FText& InMainMessage, const FText& InSubMessage);
    void AddLine1NotifyMessage(const FText& InMessage);
    void AddLine1LNotifyMessage(const FText& InMessage);
    void AddImagineRecepi(const int32 RecepiId, const bool IsNoItem);
    void AddCraftRecepi(const int32 RecepiId, const bool IsNoItem);
    void ActivateWarpPoint(FString WarpPointId);
    void ActivateEnemySetHPLog();
    void ActivateDungeon(FString DungeonId);
    void AccumulateLiquidMemory(const uint32 InConditionType);
}; // Size: 0x130

class USBCheckBoxBase : public UCheckBox
{
    class UAkAudioEvent* CheckedAkAudioEvent;                                         // 0x0790 (size: 0x8)
    class UAkAudioEvent* UncheckedAkAudioEvent;                                       // 0x0798 (size: 0x8)
    class UAkAudioEvent* HoveredAkAudioEvent;                                         // 0x07A0 (size: 0x8)
    ESystemSE CheckedSystemSEId;                                                      // 0x07A8 (size: 0x1)
    ESystemSE UncheckedSystemSEId;                                                    // 0x07A9 (size: 0x1)
    ESystemSE HoveredSystemSEId;                                                      // 0x07AA (size: 0x1)

    void OnPostSoundEvent_CheckBoxStateChanged(bool bIsChecked);
    void OnMouseLeave(const FPointerEvent& MouseEvent);
    void OnMouseEnter(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent);
}; // Size: 0x7B0

class USBCheckInitialRepComponent : public UActorComponent
{
    uint8 bInitial;                                                                   // 0x00B8 (size: 0x1)

}; // Size: 0xC0

class USBCheckSwimmingAreaBImagine : public UActorComponent
{
    char padding_0[0x178];                                                            // 0x0000 (size: 0x0)

    void RemoveSwimmingAreaActor(class ASBWaterMeshActor* tgt);
    int32 GetSwimmingAreaCount();
    void AddSwimmingAreaActor(class ASBWaterMeshActor* tgt);
}; // Size: 0x178

class USBChildWaterNavModifierVolumeComponent : public UChildActorComponent
{
    TSubclassOf<class UNavArea> NavModifierArea;                                      // 0x0240 (size: 0x8)
    TMap<class FName, class FNavMeshInWaterDepthSetting> NavMeshDepthSettings;        // 0x0248 (size: 0x50)
    TArray<class TSubclassOf<AActor>> TargetActors;                                   // 0x0298 (size: 0x10)

    void SetChildNavModifierVolumeClass(TSubclassOf<class AActor> InClass);
}; // Size: 0x2B0

class USBChoiceDialog : public UUserWidget
{
    FSBChoiceDialogOnSelectItem OnSelectItem;                                         // 0x0278 (size: 0x10)
    void OnSelectItem(const int32 InSelectItemIndex);

    void Show();
    void SetQuestion(const FText& InText);
    void OnSelectItem__DelegateSignature(const int32 InSelectItemIndex);
    void AddItem(const FText& InText);
}; // Size: 0x288

class USBCircleSoundComponent : public USBShapeSoundBaseComponent
{
    bool bIsEllipse;                                                                  // 0x0410 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0411 (size: 0x3)
    float Radius;                                                                     // 0x0414 (size: 0x4)
    FVector Offset;                                                                   // 0x0418 (size: 0xC)
    FVector2D EllipseVector;                                                          // 0x0424 (size: 0x8)

    void SetEllipse(FVector2D InEllipseVector, const FVector& InOffset);
    void SetCircle(float InRadius, const FVector& InOffset);
}; // Size: 0x430

class USBClassHUD : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    bool Show();
    void SetVisibleSettingFlag(bool Flag);
    void SetVisibleFlag(bool Flag);
    void SetReserveFlag6(bool Flag);
    void SetReserveFlag5(bool Flag);
    void SetReserveFlag4(bool Flag);
    void SetReserveFlag3(bool Flag);
    void SetReserveFlag2(bool Flag);
    void SetReserveFlag1(bool Flag);
    void SetEditMode(bool InIsEdit);
    void PlayAnimReverseInOut();
    void PlayAnimForwardInOut();
    void OnUnbind();
    void OnTick();
    void OnTerminate();
    void OnSetEditMode(bool InIsEdit);
    void OnInitialize();
    void OnBind();
    bool IsVisibleSettingFlag();
    bool IsVisibleFlag();
    bool IsReserveFlag6();
    bool IsReserveFlag5();
    bool IsReserveFlag4();
    bool IsReserveFlag3();
    bool IsReserveFlag2();
    bool IsReserveFlag1();
    bool Hide();
    void ChangeVisibleSetting(bool InIsVisibleSetting);
}; // Size: 0x280

class USBClassHUDComponent : public UActorComponent
{
    class USBClassHUD* ClassHUD_;                                                     // 0x00B8 (size: 0x8)

    void VisibleUI(bool InIsVisible, bool InIsForce);
    void VisibleSetting(bool InIsVisible);
    void Update();
    void UnSheathe();
    void Sheathe();
    void SetShowAlwaysHUDFlag(bool Flag);
    void OnUpdateLayoutView();
    void OnUpdate();
    void OnUnbind();
    void OnSetup();
    void OnRemoveUI();
    void OnCreateUI();
    void OnBind();
    bool IsVisibleSettingFlag();
    bool IsShowAlwaysHUDFlag();
    bool IsMountingFlag();
    ESBUIType GetUIType();
}; // Size: 0xC8

class USBClassHUDP019 : public USBClassHUD
{
    char padding_0[0x288];                                                            // 0x0000 (size: 0x0)

    void VisibleCartridge(int32 CartridgeNum, bool PowerBulletActive, bool HealBulletActive);
}; // Size: 0x288

class USBClassHUDP020 : public USBClassHUD
{
    TArray<class USBP020_CountIcon_PartsWidget*> IconList;                            // 0x0280 (size: 0x10)
    int32 MarkNum;                                                                    // 0x0290 (size: 0x4)

    void OnChangeVisibleSetting(bool InIsVisibleSetting);
}; // Size: 0x298

class USBClassIcon : public UUserWidget
{
    class UImage* IconImage;                                                          // 0x0278 (size: 0x8)
    class UTexture2D* NoDataTexture;                                                  // 0x0280 (size: 0x8)
    ESBClassType ClassType;                                                           // 0x0288 (size: 0x1)

    void UpdateClassIcon();
    void SetClass(ESBClassType InType);
    void OnUpdateClassIcon();
    class UTexture2D* GetIconTexture();
    ESBClassType GetClass();
}; // Size: 0x290

class USBClimbingData : public UObject
{
    TArray<FClimbingPoint> Points;                                                    // 0x0028 (size: 0x10)
    bool bIsUseNearWaterCamera;                                                       // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBClimbingPointsManagerComponent : public USceneComponent
{
    TArray<FClimbingPoint> ClimbingPoints;                                            // 0x0208 (size: 0x10)
    bool bIsUseNearWaterCamera;                                                       // 0x0218 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0219 (size: 0x7)
    class USBClimbingData* ClimbingDataAsset;                                         // 0x0220 (size: 0x8)
    TArray<FClimbingPoint> RepClimbingPoints;                                         // 0x0228 (size: 0x10)
    char padding_1[0x14];                                                             // 0x0238 (size: 0x14)
    float CreatePointOffset;                                                          // 0x024C (size: 0x4)
    bool bIsDisableDisplay;                                                           // 0x0250 (size: 0x1)
    bool bIsDisplayWithinRange;                                                       // 0x0251 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0252 (size: 0x2)
    float DisplayRange;                                                               // 0x0254 (size: 0x4)
    float PointDisplaySize;                                                           // 0x0258 (size: 0x4)
    bool bIsDisplayPointsCoordinateSystems;                                           // 0x025C (size: 0x1)
    char padding_3[0x3];                                                              // 0x025D (size: 0x3)
    float PointsCoordinateSize;                                                       // 0x0260 (size: 0x4)
    bool bIsAutoSaveCreatedAsset;                                                     // 0x0264 (size: 0x1)

    void SetPointActiveByPointID_Server(const int32 PointID, const bool IsActive);
    void SetPointActiveByPointID_Multicast(const int32 PointID, const bool IsActive);
    void SetPointActiveByGroupID_Server(const int32 GroupId, const bool IsActive);
    void SetPointActiveByGroupID_Multicast(const int32 GroupId, const bool IsActive);
    void SetPointActiveByAll_Server(const bool IsActive);
    void SetPointActiveByAll_Multicast(const bool IsActive);
    void Request_SetPointActiveByPointID(const int32 PointID, const bool IsActive);
    void Request_SetPointActiveByGroupID(const int32 GroupId, const bool IsActive);
    void Request_SetPointActiveByAll(const bool IsActive);
    void OnRep_ClimbingPoints();
    bool GetPointLocation(const int32 PointID, FVector& Location);
    bool GetLinkLocation(const int32 OriginPointID, TMap<int32, FVector>& OutLinkList, const bool IsIgnoreInactive);
}; // Size: 0x270

class USBCmnStatusUDBase : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void SetValue(float Value);
    void Clear();
}; // Size: 0x278

class USBCollisionBoxComponent : public UASCollisionBoxComponent
{
    char padding_0[0x4D0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x4D0

class USBCollisionCapsuleComponent : public UASCollisionCapsuleComponent
{
    char padding_0[0x4C0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x4C0

class USBCollisionDisableManager : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBCollisionGroupComponent : public UASCollisionGroupComponent
{
    int32 GroupId;                                                                    // 0x0230 (size: 0x4)

}; // Size: 0x240

class USBCollisionSphereComponent : public UASCollisionSphereComponent
{
    char padding_0[0x4D0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x4D0

class USBColoringShopComponent : public UActorComponent
{
    FSBColoringShopComponentOnSaveCharaCostumeEquipInfosDelegate OnSaveCharaCostumeEquipInfosDelegate; // 0x00B8 (size: 0x10)
    void OnSaveCharaCostumeEquipInfosDelegate(const bool Result, const int32 RetCode);

    void Server_RequestSaveCharaCostumeEquipInfos(class ASBPlayerController* InPlayerController, const TArray<ESBCharaEquipType>& InEquipItemTypes, const TArray<FCharaEquipItemInfo>& InEquipItemInfos, const TArray<FCharaEquipItemCharaCreateInfo>& InEquipItemCharaCreateInfos);
    void Server_OnSaveCharaCostumeEquipInfos(const bool bSuccessed, const int32 InRetCode, class USBNetworkDataCache* NetworkDataCache, const TArray<ESBCharaEquipType>& DirtyEquipTypes, const TArray<FCharaEquipItemInfo>& DirtyEquipItemInfos);
    void Request_SaveCharaCostumeEquipInfos(class ASBPlayerController* InPlayerController, const TArray<ESBCharaEquipType>& InEquipItemTypes, const TArray<FCharaEquipItemInfo>& InEquipItemInfos, const TArray<FCharaEquipItemCharaCreateInfo>& InEquipItemCharaCreateInfos);
    void OnSaveCharaCostumeEquipInfosDelegate__DelegateSignature(const bool Result, const int32 RetCode);
    void GetDyeItemHoldAmounts(class USBOwnItemListContainer* InOwnItemListContainer, const int32 InDyeItemId, int32& OutNormalHoldAmount, int32& OutDistributionHoldAmount);
    bool GetDistributionItemIdFromNormalDyeItemId(const int32 InDyeItemId, int32& OutDistributionItemId);
    void Client_OnSaveCharaCostumeEquipInfos(const bool bSuccessed, const int32 InRetCode, class USBNetworkDataCache* NetworkDataCache, const TArray<ESBCharaEquipType>& DirtyEquipTypes, const TArray<FCharaEquipItemInfo>& DirtyEquipItemInfos);
    bool CalculateConsumptionOfHoldDyeItemsRequiredForDyeing(class USBOwnItemListContainer* InOwnItemListContainer, const int32 InDyeItemId, const int32 InRequiredDyeItemNum, int32& OutHoldNormalDyeItemConsumeNum, int32& OutHoldDistributionDyeItemConsumeNum);
}; // Size: 0xC8

class USBColoringShopManager : public UObject
{
    class UDataTable* RequiredColoringItemForCostumeDB;                               // 0x0028 (size: 0x8)

}; // Size: 0x30

class USBComboBoxStringBase : public UComboBoxString
{
    class UAkAudioEvent* OpeningAkAudioEvent;                                         // 0x0E58 (size: 0x8)
    class UAkAudioEvent* CancelClosingAkAudioEvent;                                   // 0x0E60 (size: 0x8)
    class UAkAudioEvent* SelectionChangedAkAudioEvent;                                // 0x0E68 (size: 0x8)
    class UAkAudioEvent* HoveredAkAudioEvent;                                         // 0x0E70 (size: 0x8)
    ESystemSE OpeningSystemSeId;                                                      // 0x0E78 (size: 0x1)
    ESystemSE CancelClosingSystemSeId;                                                // 0x0E79 (size: 0x1)
    ESystemSE SelectionChangedSystemSeId;                                             // 0x0E7A (size: 0x1)
    ESystemSE HoveredSystemSEId;                                                      // 0x0E7B (size: 0x1)

    void UpdateDecideButton();
    void OnRowMouseEnter(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent);
    void OnMouseEnter(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent);
}; // Size: 0xEA8

class USBCommandButton : public USBUserWidget
{
    FSBCommandButtonOnCommandButtonEndDelegate OnCommandButtonEndDelegate;            // 0x02B0 (size: 0x10)
    void OnCommandButtonEndDelegate(int32 SelectedButtonId);

    void ShowCommandButton(const TArray<FText>& CommandTexts);
    void OnEndCommandButton(int32 SelectedButtonId);
    void OnCommandButtonEndDelegate__DelegateSignature(int32 SelectedButtonId);
}; // Size: 0x2C0

class USBCommandMenu : public USBUserWidget
{
    char padding_0[0x2B0];                                                            // 0x0000 (size: 0x0)

    ESBCommandMenuType QuickAccess2CommandMenuType(const TEnumAsByte<ESBKeyConfigAction::Type>& Action);
    void OnSubMenuTermReady();
    void OnRequestDirectChat();
    void OnAddBgGroupContents(class UUserWidget* InWidget);
    void CallTryTerm();
}; // Size: 0x2B0

class USBCommandMenuChildBase : public UUserWidget
{
    class USBCommandMenu* OwnerCommandMenu;                                           // 0x0278 (size: 0x8)
    FName ParamName;                                                                  // 0x0280 (size: 0x8)
    FString OpenBookMark;                                                             // 0x0288 (size: 0x10)
    FString NowBookMark;                                                              // 0x0298 (size: 0x10)

    void SetParamName(const FName& InParamName);
    void SetOwnerCommandMenu(class USBCommandMenu* InOwnerCommandMenu);
    void SetOpenBookMark(FString InBookMarkType);
    void SetNowBookMark(FString InBookMarkType);
}; // Size: 0x2A8

class USBCommonIconWidget : public UUserWidget
{
    class UCanvasPanel* NewIconGrp;                                                   // 0x0278 (size: 0x8)
    bool ReadedNewEnable;                                                             // 0x0280 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0281 (size: 0x7)
    FString BadgeUniqueId;                                                            // 0x0288 (size: 0x10)

    void UpdateNewBadgeVisibleByReaded();
    void SetNewBadgeVisibleByReaded(bool bEnable, FString UniqueId);
    void DeleteNewIconByReaded();
}; // Size: 0x298

class USBCommonSaveGame : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBCommonSaveData Data;                                                           // 0x0050 (size: 0x68)

}; // Size: 0xB8

class USBCompleteQuestEventParam : public UObject
{
    int32 RetCode;                                                                    // 0x0028 (size: 0x4)
    int32 QuestIndex;                                                                 // 0x002C (size: 0x4)

}; // Size: 0x30

class USBConditionFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsAllSatisfied(const TArray<FSBConditionCheckParam>& ConditionCheckParamList, const class AActor* CauserActor, const class AActor* TargetActor);
}; // Size: 0x28

class USBConfigDataFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UpdateWishlist(class UObject* WorldContextObject, FString CharacterId, const FSBWishListData& Data);
    void UpdateVSync(class UObject* InWorldContextObject);
    void UpdateVGAMode();
    void UpdateSortRecentSort(class UObject* WorldContextObject, TEnumAsByte<ESBSortFilterSaveType::Type> SaveType, TEnumAsByte<ESBItemSortType::Type> SortType);
    void UnregisterBookMark(class UObject* WorldContextObject, const FString BookMark);
    void SetSoundVolumeEx(TEnumAsByte<ESBSoundVolumeType::Type> SoundType, int32 Volume, bool bIsMute, FSBConfigureSaveData_Sound& SoundSaveData);
    void SetSoundVolume(TEnumAsByte<ESBSoundVolumeType::Type> SoundType, int32 Volume, bool bIsMute);
    void SetShowedHintDialog(class UObject* InWorldContextObject, TEnumAsByte<ESBHintShowTypes::Type> ShowType, bool bIsShowed);
    void SetResolutionScaleValue(float NewScaleValue);
    void SetEventShopStorageData(class UObject* WorldContextObject, FString CharacterId, const ESBEventShopStorage& Data);
    void SetEnemyVisibleDistanceValue(int32 DistanceValue);
    void SetAutoStampId(class UObject* InWorldContextObject, const EAutoWordEventType InEventType, FString InAutoStampData);
    void SetAutoStampData(class UObject* InWorldContextObject, const EAutoWordEventType InEventType, const FAutoStampWordData& InWordData);
    void SetAutoeStampDisabled(class UObject* InWorldContextObject, const bool IsDisabled);
    void ResetBookMark(class UObject* WorldContextObject);
    void RemoveWishlist(class UObject* WorldContextObject, FString CharacterId, const FSBWishListData& Data);
    bool IsShowedHintDialog(class UObject* InWorldContextObject, TEnumAsByte<ESBHintShowTypes::Type> ShowType);
    bool IsRegistedWishlist(class UObject* WorldContextObject, FString CharacterId, const FSBWishListData& Data);
    bool IsAutoStampDisabled(class UObject* InWorldContextObject);
    int32 GetWishlistRegistedCount(class UObject* WorldContextObject, FString CharacterId, const ESBWishListType Type);
    FShortcutInfo GetShortcutItemInfo(class UObject* InWorldContextObject, int32 SlotNo);
    EShortcutIconType GetShortcutIconByStamp(bool& bIsExist, class UObject* InWorldContextObject, FString InStamp, const int32 SlotNo);
    EShortcutIconType GetShortcutIconByItem(bool& bIsExist, class UObject* InWorldContextObject, const int32 InItemID, const int32 SlotNo);
    EShortcutIconType GetShortcutIconByEmotion(bool& bIsExist, class UObject* InWorldContextObject, FString InEmotion, const int32 SlotNo);
    FString GetScreenshotSaveDirectory(const class UObject* InWorldContextObject);
    TEnumAsByte<ESBItemSortType::Type> GetRecentSortType(class UObject* WorldContextObject, TEnumAsByte<ESBSortFilterSaveType::Type> SaveType);
    ESBEventShopStorage GetEventShopStorageData(class UObject* WorldContextObject);
    float GetEnemyVisibleDistanceScaleValue();
    int32 GetConfigViewDistanceScaleMax();
    class USBConfigureSaveManager* GetConfigSaveManager(bool& IsValid);
    FString GetBookMarkTypeNone();
    FString GetBookMarkTypeKey(class UObject* WorldContextObject, FString BookmarkType);
    ESBBookMarkerSlot GetBookMarkAction2BookMark(bool& bIsValid, const TEnumAsByte<ESBKeyConfigAction::Type> Action);
    FString GetBookMark(class UObject* WorldContextObject, ESBBookMarkerSlot Slot);
    FAutoStampWordData GetAutoStampData(class UObject* InWorldContextObject, bool& IsValid, const EAutoWordEventType InEventType);
    TArray<FSBWishListData> GetAllWishlistData(class UObject* WorldContextObject, FString CharacterId);
    int32 GetActivatedShortcutSlotMax();
    int32 FrameRateEnum2Int(const ESBFrameRateLimitType Type);
    bool FindBookMarkSlot_New(class UObject* WorldContextObject, FString BookMark, ESBBookMarkerSlot& Slot);
    bool ApplyBookMark(class UObject* WorldContextObject, FKey Key, FString BookMark, ESBBookMarkerSlot& Slot);
    void AddWishlist(class UObject* WorldContextObject, FString CharacterId, const FSBWishListData& Data);
}; // Size: 0x28

class USBConfigSave_SoundUser : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FSBConfigureSaveData_SoundUser Data;                                              // 0x0040 (size: 0x18)

}; // Size: 0x58

class USBConfigureSaveManager : public UObject
{
    FSBConfigureSaveManagerOnUpdateOperationMode OnUpdateOperationMode;               // 0x0028 (size: 0x10)
    void OnUpdateOperateMode();
    FSBConfigureSaveManagerOnUpdateHudBeltVisible OnUpdateHudBeltVisible;             // 0x0038 (size: 0x10)
    void OnUpdateHUDBeltVisible();
    FSBConfigureSaveManagerOnUpdateWeaponVisibleType OnUpdateWeaponVisibleType;       // 0x0048 (size: 0x10)
    void OnUpdateWeaponVisibleType(const ESBWeaponVisibleType eVisibleType);
    FSBConfigureSaveManagerOnUpdateAutoTargetSightFocus OnUpdateAutoTargetSightFocus; // 0x0058 (size: 0x10)
    void OnUpdateAutoTargetSightFocus(const bool bSightFocus);
    FSBConfigureSaveManagerOnUpdateAutoTargetEnable OnUpdateAutoTargetEnable;         // 0x0068 (size: 0x10)
    void OnUpdateAutoTargetEnable(const bool bEnable);
    FSBConfigureSaveManagerOnChangePadSkinType OnChangePadSkinType;                   // 0x0078 (size: 0x10)
    void OnChangePadSkinType(const ESBPadKeySkinType SkinType);
    char padding_0[0x18];                                                             // 0x0088 (size: 0x18)
    FSBConfigureSaveManagerOnUpdateChatSound OnUpdateChatSound;                       // 0x00A0 (size: 0x10)
    void OnUpdateChatSound(const FSBConfigureSaveData_ChatSound SoundData);
    FSBConfigureSaveManagerOnChangeShowFPS OnChangeShowFPS;                           // 0x00B0 (size: 0x10)
    void OnChangeShowFPS();
    FSBConfigureSaveManagerOnChangeNameplateParty OnChangeNameplateParty;             // 0x00C0 (size: 0x10)
    void OnChangeUserGraphicsSetting(const bool bIsShow);
    FSBConfigureSaveManagerOnChangeNameplateOther OnChangeNameplateOther;             // 0x00D0 (size: 0x10)
    void OnChangeUserGraphicsSetting(const bool bIsShow);
    FSBConfigureSaveManagerOnChangeShowAlwaysHUD OnChangeShowAlwaysHUD;               // 0x00E0 (size: 0x10)
    void OnChangeUserGraphicsSetting(const bool bIsShow);
    FSBConfigureSaveManagerOnChangeTeamTagVisibility OnChangeTeamTagVisibility;       // 0x00F0 (size: 0x10)
    void OnChangeUserGraphicsSetting(const bool bIsShow);
    FSBConfigureSaveManagerOnChangeOtherPCVfx OnChangeOtherPCVfx;                     // 0x0100 (size: 0x10)
    void OnUpdateOtherPCVFX(const int32 Value);
    FSBConfigureSaveManagerOnChangeImagineAlpha OnChangeImagineAlpha;                 // 0x0110 (size: 0x10)
    void OnUpdateOtherImagineAlpha(bool IsAlpha);
    FSBConfigureSaveManagerOnChangeVFXSetting OnChangeVFXSetting;                     // 0x0120 (size: 0x10)
    void OnChangeVFXSetting(const ESBBattleEffectVisibleCategory Category, const ESBBattleEffectVisibleType Type, bool Visible);
    FSBConfigureSaveManagerOnChangeVFXCustomMode OnChangeVFXCustomMode;               // 0x0130 (size: 0x10)
    void OnUpdateVFXCustomMode(const bool bCustom);
    FSBConfigureSaveManagerOnSavedShortcutInfo OnSavedShortcutInfo;                   // 0x0140 (size: 0x10)
    void OnSavedShortcutInfo();
    FSBConfigureSaveManagerOnHUDLayoutUpdated OnHUDLayoutUpdated;                     // 0x0150 (size: 0x10)
    void OnUpdateHUDLayout();
    FSBConfigureSaveManagerOnUpdateWishlist OnUpdateWishlist;                         // 0x0160 (size: 0x10)
    void OnUpdateWishlist();
    char padding_1[0x109];                                                            // 0x0170 (size: 0x109)
    ESBFrameRateLimitType eFrameRateLimitType;                                        // 0x0279 (size: 0x1)
    char padding_2[0x6];                                                              // 0x027A (size: 0x6)
    FConfigSaveData_GraphicsUser UserGraphicsSetting;                                 // 0x0280 (size: 0x18)
    TEnumAsByte<ESBLowVGAMemory::Type> eLowVGAMemoryMode;                             // 0x0298 (size: 0x1)
    bool bIsNowVGAMemoryInitialized;                                                  // 0x0299 (size: 0x1)
    bool bIsVsync;                                                                    // 0x029A (size: 0x1)
    bool bIsUltimateSkillPerformance;                                                 // 0x029B (size: 0x1)
    bool bIsBattleImagineCutinPerformance;                                            // 0x029C (size: 0x1)
    bool bAlphaBlend_OtherPCImagine;                                                  // 0x029D (size: 0x1)
    char padding_3[0x2];                                                              // 0x029E (size: 0x2)
    int32 OtherPCVisibleVFXValue;                                                     // 0x02A0 (size: 0x4)
    char padding_4[0x70C];                                                            // 0x02A4 (size: 0x70C)
    TMap<class FString, class bool> CraftableFilterCraftMachine;                      // 0x09B0 (size: 0x50)
    TMap<class FString, class bool> CraftableFilterImaginCraft;                       // 0x0A00 (size: 0x50)
    TMap<class FString, class bool> UnequipableItemsSettingEventShop;                 // 0x0A50 (size: 0x50)

    void UpdateWatchedTime();
    void SetWeaponVisibleType(ESBWeaponVisibleType eVisibleType);
    void SetVsync(const bool InVsync);
    void SetVFXVisible(ESBBattleEffectVisibleCategory Category, ESBBattleEffectVisibleType Type, bool bVisible);
    void SetVFXCustomSetting(bool IsCustom);
    void SetUseCheckDialogActive(const bool& bActive);
    void SetUnequipableItemsSettingEventShop(FString CharacterId, bool bIsChecked);
    void SetUltimateSkillPerformance(bool InPerformance);
    void SetSSLogoPosition(ESBSSLogoPosition LogoPosition);
    void SetSoundConfigData(const FSBConfigureSaveData_Sound& ConfigData);
    void SetSortType(const TEnumAsByte<ESBSortFilterSaveType::Type> SaveType, const TEnumAsByte<ESBItemSortType::Type> SortType);
    void SetSilentInterruptDialog(bool bIsSilent);
    void SetShowScreenshotNotifications(bool bValue);
    void SetShowPartyNamePlate(FString InUserId, bool bIsShow);
    void SetShowOtherNamePlate(FString InUserId, bool bIsShow);
    void SetShowFPSCounter(bool bIsShow);
    void SetShortcutRingMode(ESBShortcutRingMode RingMode);
    void SetShortcutRingCloseMode(bool IsAutoClose);
    void SetShortcutRingAutoCommand(bool IsAutoExecute);
    void SetShortcutInfo(const FSBShortcutDatas& Info);
    void SetScreenshotSaveDirectory(FString Path);
    void SetPSOnlyMode(const bool& bValue);
    void SetPlayNonActiveWindowSound(bool bIsPlay);
    void SetPlayerVisibleLimitNum(FString InUserId, const TEnumAsByte<ESBPlayerVisibleLimit::Type> LimitType);
    void SetPadKeySkinType(ESBPadKeySkinType InSkinType);
    void SetPadDecideButonSwaped(bool bSwaped);
    void SetOtherPCVisibleValue(int32 VfxValue);
    void SetOtherPCImajinAlpha(bool bIsAlpha);
    void SetOperateModeGuideVisibility(ESBKeyGuideDisplayType bIsVisible);
    void SetOperateMode(ESBOperateMode OpedrateMode);
    void SetNotificationDataParam(FString InPlayerId, const FSBNotificationDataParam& InParam);
    void SetMuteSoundGesture(bool bMute);
    void SetMuteSoundCostume(bool bMute);
    void SetMainSelectTab(int32 TabId);
    void SetMailAutoDeleteFlag(bool Flag);
    void SetLowVGAMode(bool bIsLowMode);
    void SetLogDispTimeType(int32 Type);
    void SetIsTeamTagVieible(FString InUserId, bool bIsVisible);
    void SetIsSlientBaloon(bool IsSilent);
    void SetIsShowDemoCaption(bool bIsShow);
    void SetImagineCraftSaveStorage(FString InCharacterId, bool bIsStorage);
    void SetHUDBeltVisible(bool IsViaible);
    void SetHideOthersPlayerAtFishing(const bool& bValue);
    void SetHideHudAtScreenshot(bool bValue);
    void SetGraphicsCondigData(const FSBConfigureSaveData_Graphics& ConfigData);
    int32 SetGamepadUISpeed(const int32 Speed);
    void SetFrameRateLimit(const ESBFrameRateLimitType Type);
    void SetEventShopStorage(const ESBEventShopStorage Storage);
    void SetEnableUsedCheckDialog(ESBUseCheckDialogType Type, bool bEnable);
    void SetDontDisplayThePhotoModeQuitConfirmDialog(const bool& bValue);
    bool SetDirectMode(bool InDirectMode);
    void SetCraftMachineSaveStorage(FString InCharacterId, bool bIsStorage);
    void SetCraftableFilterImagine(FString CharacterId, bool bIsFilterd);
    void SetCraftableFilterCraftMachine(FString CharacterId, bool IsFilterd);
    void SetChatSoundData(const FSBConfigureSaveData_ChatSound& ChatData);
    bool SetChatLogWindowSlotData(const TEnumAsByte<ESBChatLogWindowSlot::Type> Slot, FSBChatLogWindowStatusSave Data);
    bool SetChatLogTextSizeIndex(int32 TextSize, int32 Index);
    void SetCameraZoomLevelData(FString CharacterId, const FSBCameraZoomLevelDatas& Data);
    void SetBattleImagineCutinPerformance(bool InPerformance);
    void SetAutoTargetSightFocus(bool bSightFocus);
    void SetAutoTargetEnable(bool bEnable);
    void SetAlwaysShowFieldHUD(FString InUserId, bool bIsShow);
    void SendServerSaveData(class APlayerController* InRequester);
    void SendKPI(class APlayerController* InRequester, class ULocalPlayer* InLocalPlayer);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveWishList(FString InPlayerId);
    void SaveStampHistoryIdsData(const TArray<int32> IDs);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveStampHistoryData(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveSoundUserData(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveSoundConfigData();
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveSortTypes(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveShortcutInfo();
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveShopSetting(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveNotificationData(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveMacheneCache();
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveKeyConfigData(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveHudLayoutWindowSize(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveHudLayout(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveHintStatus(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveGraphicsVFXSaveData(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveGraphicsConfigData();
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveGeneralConfigData(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveCustomHudLayout(FString PlayerId, ESBCustomHudLayoutSlot SlotType, FString CustomName);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveCommonSaveData(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveChatLogWindow(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveCameraZoomLevelData(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveBookMark(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> SaveAutoStamp(FString PlayerId);
    void ResetUserSounds();
    void ReceiveServerSaveData(class APlayerController* InRequester);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadWishList(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadStampHistoryData(const class UObject* WorldContextObject, FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadSoundUserData(FString InPlayerId);
    FSBConfigureSaveData_Sound LoadSoundConfigData(TEnumAsByte<ESBConfigSaveDataResult::Type>& Result);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadSortTypes(FString PlayerId);
    FSBShortcutDatas LoadShortcutInfo(TEnumAsByte<ESBConfigSaveDataResult::Type>& Result);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadShopSetting(FString InPlayerId);
    bool LoadPresetData(FString InPresetString);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadNotificationData(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadMacheneCache();
    FSBKeyConfigDatas LoadKeyConfigData(TEnumAsByte<ESBConfigSaveDataResult::Type>& Result, FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadHudLayoutWindowSize(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadHudLayout(FString PlayerId, ESBCustomHudLayoutSlot SlotType);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadHintStatus(FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadGraphicsVFXSaveData(FString InPlayerId);
    FSBConfigureSaveData_Graphics LoadGraphicsConfigData(TEnumAsByte<ESBConfigSaveDataResult::Type>& Result);
    FSBConfigureSaveData_General LoadGeneralConfigData(TEnumAsByte<ESBConfigSaveDataResult::Type>& Result, FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadCommonSaveData(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadChatLogWindow(FString PlayerId);
    FSBCameraZoomLevelCharacterData LoadCameraZoomLevelData(TEnumAsByte<ESBConfigSaveDataResult::Type>& Result, FString PlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadBookMark(FString InPlayerId);
    TEnumAsByte<ESBConfigSaveDataResult::Type> LoadAutoStamp(FString PlayerId);
    bool IsVsync();
    bool IsUsedZOrder(const int32 ZOrder, const ESBCustomHudLayoutSlot Slot);
    bool IsUseCheckDialogActive();
    bool IsUnequipableItemsSettingEventShop(FString CharacterId);
    bool IsUltimateSkillPerformance();
    bool IsTodayWatched();
    bool IsTeamTagVisible(FString InUserId);
    bool IsSilentInterruptDialog();
    bool IsSilentBalloon();
    bool IsShowScreenshotNotifications();
    bool IsShowPartyNamePlate(FString InUserId);
    bool IsShowOtherNamePlate(FString InUserId);
    bool IsShowFPSCounter();
    bool IsShowDemoCaption();
    bool IsShortcutRingCloseMode();
    bool IsShortcutRingAutoCommand();
    bool IsServerSaveDataLoaded();
    bool IsPSOnlyMode();
    bool IsPadDecideButtonSwaped();
    bool IsOtherPCImajinAlpha();
    ESBKeyGuideDisplayType IsOperateModeGuideVisibility();
    bool IsModifyHUDLayoutWindowSize();
    bool IsModifyHUDLayout();
    bool IsModifyGraphicsVFXSaveData();
    bool IsModifyGeneralConfigSave();
    bool IsLowVGAModeFirstInitialized();
    bool IsLowVGAMode();
    bool IsLoadedWishList();
    bool IsLoadedUserSoundConfig();
    bool IsLoadedStampHistoryData();
    bool IsLoadedSoundConfigData();
    bool IsLoadedSortTypes();
    bool IsLoadedShortcutInfo();
    bool IsLoadedShopSetting();
    bool IsLoadedNotificationData();
    bool IsLoadedMachineCache();
    bool IsLoadedKeyConfigData();
    bool IsLoadedHudLayoutWindowSizeData();
    bool IsLoadedHudLayoutData(const ESBCustomHudLayoutSlot Slot);
    bool IsLoadedHintStatus();
    bool IsLoadedGraphicsVFXSaveData();
    bool IsLoadedGraphicsConfigData();
    bool IsLoadedGeneralConfigSave();
    bool IsLoadedCommonSaveData();
    bool IsLoadedChatLogWindowStatus();
    bool IsLoadedCameraZoomLevelData();
    bool IsLoadedBookMark();
    bool IsLoadedAutoStampData();
    bool IsHUDBeltVisible();
    bool IsHideOthersPlayerAtFishing();
    bool IsHideHudAtScreenshot();
    bool IsEnableUsedCheckDialog(ESBUseCheckDialogType Type);
    bool IsDontDisplayThePhotoModeQuitConfirmDialog();
    bool IsDirectMode();
    bool IsCraftableFilterImagine(FString CharacterId);
    bool IsCraftableFilterCraftMachine(FString CharacterId);
    bool IsBattleImagineCutinPerformance();
    bool IsAlwaysShowFieldHUD(FString InUserId);
    ESBWeaponVisibleType GetWeaponVisibleType();
    bool GetVFXVisible(ESBBattleEffectVisibleCategory Categoty, ESBBattleEffectVisibleType Type, bool bVerborse);
    bool GetVFXCustomSetting();
    TArray<int32> GetStampHistoryIdsData(bool& IsFound);
    ESBSSLogoPosition GetSSLogoPosition();
    FSBConfigureSaveData_Sound GetSoundConfigData(bool& bIsLoaded);
    TEnumAsByte<ESBItemSortType::Type> GetSortType(const TEnumAsByte<ESBSortFilterSaveType::Type> SaveType);
    ESBShortcutRingMode GetShortcutRingMode();
    FSBShortcutDatas GetShortcutInfo(bool& bIsLoaded);
    FString GetScreenshotSaveDirectory();
    bool GetPlayNonActiveWindowSound();
    TEnumAsByte<ESBPlayerVisibleLimit::Type> GetPlayerVisibleTypeLimit(FString InUserId);
    ESBPadKeySkinType GetPadSkinType();
    int32 GetOtherPCVisibleValue();
    ESBOperateMode GetOperateMode();
    bool GetNotificationDataParam(FString InPlayerId, FSBNotificationDataParam& OutParam);
    bool GetMuteSoundGesture();
    bool GetMuteSoundCostume();
    int32 GetMainSelectTab();
    bool GetMailAutoDeleteFlag();
    int32 GetLogDispTimeType();
    bool GetImagineCraftSaveStorage(FString InCharacterId);
    FSBConfigureSaveData_Graphics GetGraphicsConfigData(bool& bIsLoaded);
    int32 GetGamepadUISpeed();
    ESBFrameRateLimitType GetFrameRateLimit();
    ESBEventShopStorage GetEventShopStorage();
    FString GetCustomSaveName(FString InPlayerId, ESBCustomHudLayoutSlot SlotType, TEnumAsByte<ESBConfigSaveDataResult::Type>& Result);
    bool GetCraftMachineSaveStorage(FString InCharacterId);
    FSBConfigureSaveData_ChatSound GetChatSoundData();
    FSBChatLogWindowStatusSave GetChatLogWindowSlotData(const TEnumAsByte<ESBChatLogWindowSlot::Type> Slot, bool& bIsSuccess);
    int32 GetChatLogTextSizeIndex();
    int32 GetChatLogTextSize();
    FSBCameraZoomLevelDatas GetCameraZoomLevelData(FString CharacterId);
    bool GetAutoTargetSightFocus();
    bool GetAutoTargetEnable();
    FVector2D FindLayoutWindowSizeData(bool& IsFound, FString Key);
    FVector2D FindLayoutPresetData(bool& IsFound, FString Key, FString LayoutString, FAnchors& Anchors, int32& ZOrder);
    FVector2D FindLayoutData(bool& IsFound, FString Key, FAnchors& Anchors, int32& ZOrder, const ESBCustomHudLayoutSlot Slot);
    void EndFirstLowVGAMode();
    void AddLayoutWindowSizeData(FString Key, const FVector2D& Value);
    void AddLayoutData(FString Key, const FVector2D& Value, const FAnchors& Anchors, const int32 ZOrder, const ESBCustomHudLayoutSlot Slot);
}; // Size: 0xAA0

class USBConfigureSave_General : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBConfigureSaveData_General Data;                                                // 0x0050 (size: 0x80)

}; // Size: 0xD0

class USBConfigureSave_Graphics : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FSBConfigureSaveData_Graphics graphics;                                           // 0x0040 (size: 0x2C)
    bool bIsShowFPSCounter;                                                           // 0x006C (size: 0x1)
    ESBFrameRateLimitType FrameLimitType;                                             // 0x006D (size: 0x1)
    char padding_0[0x2];                                                              // 0x006E (size: 0x2)
    FConfigSaveData_GraphicsUser userSetting;                                         // 0x0070 (size: 0x18)
    TEnumAsByte<ESBLowVGAMemory::Type> LowVGAMemoryMode;                              // 0x0088 (size: 0x1)
    bool bIsVsync;                                                                    // 0x0089 (size: 0x1)
    bool bIsUltimateSkillPerformance;                                                 // 0x008A (size: 0x1)
    bool bIsBattleImagineCutinPerformance;                                            // 0x008B (size: 0x1)
    bool bAlphaBlend_OtherPCImagine;                                                  // 0x008C (size: 0x1)
    char padding_1[0x3];                                                              // 0x008D (size: 0x3)
    int32 OtherPCVisibleVFXValue;                                                     // 0x0090 (size: 0x4)

}; // Size: 0x98

class USBConfigureSave_Sound : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FSBConfigureSaveData_Sound Sound;                                                 // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBConfigureSave_VFX : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FConfigSaveData_VFX Data;                                                         // 0x0050 (size: 0x58)

}; // Size: 0xA8

class USBContentsHUDBase : public USBUserWidget
{
    class UTextBlock* respawncountertextblock;                                        // 0x02B8 (size: 0x8)
    class UTextBlock* timertextblock_min;                                             // 0x02C0 (size: 0x8)
    class UTextBlock* timertextblock_sec;                                             // 0x02C8 (size: 0x8)
    class UTextBlock* timertextblock_millisec;                                        // 0x02D0 (size: 0x8)

    void SetTimerTextBlock(const class UTextBlock* respawncountertextblock, const class UTextBlock* timertextblock_min, const class UTextBlock* timertextblock_sec, const class UTextBlock* timertextblock_millisec);
    void SetDungeonDisplayName(const class UTextBlock* DungeonNamePlate);
    void OnDelegated_StopTimerTimeOver();
    void OnDelegated_StopTimerGameOver();
    void Init();
}; // Size: 0x2D8

class USBCountdownUI : public USBUserWidget
{
    FSBCountdownUIEndCountdownDynamicDelegate EndCountdownDynamicDelegate;            // 0x02C0 (size: 0x10)
    void CountdownEndDynamicDelegate(ECountdownResult Result);

    void StartNoCountdown_ECountdownType(const ECountdownType InCountdownType);
    void StartNoCountdown_BattleAreaMessage();
    void StartNoCountdown(const FText& InMessage);
    void StartCountdown_ECountdownType(const ECountdownType InCountdownType, const int32 InCountdownTime);
    void StartCountdown(const FText& InMessage, const int32 InCountdownTime);
    void OnEndCountdownUI(const ECountdownResult Result);
    void CountdownEndDynamicDelegate__DelegateSignature(ECountdownResult Result);
}; // Size: 0x2D0

class USBCounterTextBlock : public USBRuntimeTextBlock
{
    bool bUseGrouping;                                                                // 0x031A (size: 0x1)

    void SetCounter(int32 InStartValue, int32 InEndValue, float InMoveTime);
}; // Size: 0x330

class USBCustomState_AddAnimTags : public UASState_BlueprintBase
{
    TArray<FName> AnimTags;                                                           // 0x0038 (size: 0x10)

}; // Size: 0x48

class USBCustomState_AddNextAnimStateCount : public UASState_BlueprintBase
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBCustomState_AdjustRootMotion : public UASState_Base
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCustomState_BlueprintBase : public UASState_BlueprintBase
{
    bool bSkipEvalueteInServer;                                                       // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBCustomState_ChangeAnimSpeed : public UASState_BlueprintBase
{
    float StartTime;                                                                  // 0x0038 (size: 0x4)
    float EndTime;                                                                    // 0x003C (size: 0x4)
    float StartPlayRate;                                                              // 0x0040 (size: 0x4)
    float EndPlayRate;                                                                // 0x0044 (size: 0x4)
    float Ease_Exp;                                                                   // 0x0048 (size: 0x4)
    float StartRootScale;                                                             // 0x004C (size: 0x4)
    float EndRootScale;                                                               // 0x0050 (size: 0x4)

}; // Size: 0x58

class USBCustomState_DodgeAttack : public UASState_BlueprintBase
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBCustomState_EnemyActionWaitEnd : public UASState_Base
{
    float PlayRatio;                                                                  // 0x0028 (size: 0x4)

}; // Size: 0x30

class USBCustomState_EnemyActivateModifier : public UASState_Base
{
    TArray<FName> ModifierNames;                                                      // 0x0028 (size: 0x10)

}; // Size: 0x38

class USBCustomState_EnemyBeginChant : public UASState_Base
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCustomState_EnemyQuickTurn : public UASState_Base
{
    float BlendSpaceLimitAngle;                                                       // 0x0028 (size: 0x4)

}; // Size: 0x30

class USBCustomState_EnemyQuickTurn2D : public UASState_Base
{
    float TurnStopAngle;                                                              // 0x0028 (size: 0x4)
    float BlendSpaceMaxAngle;                                                         // 0x002C (size: 0x4)
    float ChangeBlendSpaceSpeed;                                                      // 0x0030 (size: 0x4)

}; // Size: 0x38

class USBCustomState_Float : public UASState_Base
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCustomState_ImagineArtsCheckPress : public UASState_BlueprintBase
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBCustomState_IncrementPlaySkillSoundCount : public UASState_Base
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBCustomState_LAN_ChargeMainAttackStart : public UASState_BlueprintBase
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBCustomState_LaunchAndDestroyProjectile : public UASState_BlueprintBase
{
    TArray<FSBLaunchAndDestroyProjectileSetting> LaunchAndDestroyProjectileSettingList; // 0x0038 (size: 0x10)

}; // Size: 0x58

class USBCustomState_MoveToCachedLocation : public UASState_BlueprintBase
{
    float MoveSpeed;                                                                  // 0x0038 (size: 0x4)
    float BlockingCheckRadius;                                                        // 0x003C (size: 0x4)
    float BlockingCheckDistance;                                                      // 0x0040 (size: 0x4)
    float BlockingCheckTimeScale;                                                     // 0x0044 (size: 0x4)
    char padding_0[0xC];                                                              // 0x0048 (size: 0xC)
    bool IsShowMoveDistance;                                                          // 0x0054 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0055 (size: 0x3)
    float FrameRateMultiplierDebug;                                                   // 0x0058 (size: 0x4)
    float ScatteringMultiplierDebug;                                                  // 0x005C (size: 0x4)

}; // Size: 0x60

class USBCustomState_PlayEffect : public UASState_BlueprintBase
{
    TArray<FSBEffectSetting> EffectList;                                              // 0x0038 (size: 0x10)

}; // Size: 0x48

class USBCustomState_PlayerDamageReaction : public UASState_BlueprintBase
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBCustomState_PlayerSkillAction : public UASState_BlueprintBase
{
    ESkillActionPosition SkillPosition;                                               // 0x0038 (size: 0x1)
    EPlayerStateMachine StateMachineType;                                             // 0x0039 (size: 0x1)

}; // Size: 0x40

class USBCustomState_PlayerTransform : public UASState_BlueprintBase
{
    ESBPlayerTransformCharacter TransformCharacter;                                   // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBCustomState_ResetDynamics : public UASState_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBCustomState_ResetElapsedTimeAfterGuardSucceeded : public UASState_BlueprintBase
{
    bool bResetZero;                                                                  // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBCustomState_SamplingDelayCommandTransition : public UASState_Base
{
    float Time;                                                                       // 0x0028 (size: 0x4)

}; // Size: 0x30

class USBCustomState_SetAimBodyParam : public UASState_BlueprintBase
{
    ESBAimDirection AimDirection;                                                     // 0x0038 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0039 (size: 0x3)
    float PitchRangeMin;                                                              // 0x003C (size: 0x4)
    float PitchRangeMax;                                                              // 0x0040 (size: 0x4)
    float YawRangeMin;                                                                // 0x0044 (size: 0x4)
    float YawRangeMax;                                                                // 0x0048 (size: 0x4)
    bool bInterpolation;                                                              // 0x004C (size: 0x1)
    char padding_1[0x3];                                                              // 0x004D (size: 0x3)
    float PitchSpeed;                                                                 // 0x0050 (size: 0x4)
    float YawSpeed;                                                                   // 0x0054 (size: 0x4)
    bool bAutoEndInterpolation;                                                       // 0x0058 (size: 0x1)

}; // Size: 0x60

class USBCustomState_ShieldDashLoop : public UASState_BlueprintBase
{
    float MotionMoveSpeed;                                                            // 0x0038 (size: 0x4)
    float ShieldDashMoveSpeedScale;                                                   // 0x003C (size: 0x4)
    float RootMotionScaleAdjustLv3;                                                   // 0x0040 (size: 0x4)

}; // Size: 0x48

class USBCustomState_TurnActorBase : public UASState_BlueprintBase
{
    ESBTurnPlayerActorType TurnType;                                                  // 0x0038 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0039 (size: 0x3)
    uint32 ClassBitmask;                                                              // 0x003C (size: 0x4)

    bool ReceiveIsOnce();
    bool ReceiveIsFixFirstCalcDirection();
    int32 ReceiveGetPriority();
    float ReceiveGetInterpSpeed();
    ESBTurnPlayerActorDirection ReceiveGetInterpDirection();
    float ReceiveGetFrontYawMin();
    float ReceiveGetFrontYawMax();
    float ReceiveGetBackYawMin();
    float ReceiveGetBackYawMax();
    bool ReceiveCanFinishInterp();
}; // Size: 0x40

class USBCustomState_WeaponHandIK : public UASState_Base
{
    bool bRightHand;                                                                  // 0x0028 (size: 0x1)

}; // Size: 0x38

class USBDPICustomScalingRule : public UDPICustomScalingRule
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBDamageType : public UASDamageType
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBDamageUI : public UUserWidget
{
    char padding_0[0x2B0];                                                            // 0x0000 (size: 0x0)

    void SetNumber();
    void SetMiss();
    void SetDamageCorrectionIcon();
    void SetBorderAlignment();
    void PlayAnim();
    bool IsHeal();
    bool IsDamage();
    bool IsCriticalHit();
    FSBDamageUIRequestInfo GetRequestInfo();
    int32 GetNumberDataIndex();
}; // Size: 0x2B0

class USBDangerParabolaComponent : public UActorComponent
{
    TSubclassOf<class ASBProjectilePath> DangerParabolaActor;                         // 0x00B8 (size: 0x8)
    float DangerParabolaHeightRate;                                                   // 0x00C0 (size: 0x4)

    void StartDangerParabola(class ASBCharacter* InOriginCharacter, TArray<class ASBCharacter*> InTargetCharacterList);
    void EndDangerParabola();
}; // Size: 0xF0

class USBDateTimeTextBlock : public USBRuntimeTextBlock
{
    ESBDateTimeTextTemplate TemplateType;                                             // 0x0318 (size: 0x1)
    ESBDateTimeTextRemainTimespanType RemainTimespanType;                             // 0x0319 (size: 0x1)
    ESBDateTimeFinishedTextTemplate FinishedTextTemplate;                             // 0x031A (size: 0x1)
    char padding_0[0x5];                                                              // 0x031B (size: 0x5)
    FDateTime DateTime;                                                               // 0x0320 (size: 0x8)
    FTimespan Timespan;                                                               // 0x0328 (size: 0x8)
    bool bIsTermDateTime;                                                             // 0x0330 (size: 0x1)

    void SetTimespan(FTimespan Value);
    void SetTemplateType(ESBDateTimeTextTemplate Value);
    void SetFinishedText(FText Value);
    ESBDateTimeTextRemainTimeFlag SetDateTimeAndTemplateType(FDateTime InDateTime, ESBDateTimeTextTemplate InTemplateType);
    ESBDateTimeTextRemainTimeFlag SetDateTime(FDateTime Value);
}; // Size: 0x358

class USBDeadMarkerWidget : public UUserWidget
{
    class UMaterialInstanceDynamic* Gauge1Mat;                                        // 0x0278 (size: 0x8)
    bool bMarkerVisibility;                                                           // 0x0280 (size: 0x1)

    void SetAutoRespawnRemainTime(float RemainTime);
    void DeadMarkerVisibility(bool bVisibility);
}; // Size: 0x288

class USBDebugCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void OpenLogFolder();
    void NotificationMenu();
}; // Size: 0x28

class USBDebugEnemyFieldLoggerComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBDebugFiler : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    FString SmartJoinPath(FString Lhs, FString rhs, FString JoinStr);
    void FindFiles(TArray<FString>& Files, FString Directory, FString Filter);
    void FindDirectories(TArray<FString>& Directories, FString Directory, FString Filter);
}; // Size: 0x278

class USBDebugFunction : public UObject
{
    class UDataTable* MenuTable;                                                      // 0x0068 (size: 0x8)
    FSBDebugFunctionOnDebugValueChanged OnDebugValueChanged;                          // 0x0070 (size: 0x10)
    void OnDebugValueChanged(TEnumAsByte<ESBDebugMenuType> MenuType, FName RowName);
    TArray<class UUserWidget*> CreateDebugWidget;                                     // 0x0080 (size: 0x10)

    void SetString(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName, const TArray<FString>& String);
    void SetSelectedOption(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName, FString SelectedOption);
    void SetScalabilityValue(FText ParameterName, FText Value);
    void SetInt32(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName, int32 Value);
    void SetFloat(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName, float Value);
    void SetCommand(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName, const TArray<FString>& String);
    void SetBool(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName, bool Value);
    TEnumAsByte<ESBSaveGameReturn> SaveDebugSettings();
    void Reset(bool SkipTopMenu);
    void OnDebugValueChanged__DelegateSignature(TEnumAsByte<ESBDebugMenuType> MenuType, FName RowName);
    TEnumAsByte<ESBSaveGameReturn> LoadDebugSettings();
    void Initialize();
    TArray<FString> GetString(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName);
    FString GetSelectedOption(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName);
    FText GetScalabilityValue(FText ParameterName);
    int32 GetInt32(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName);
    float GetFloat(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName);
    TArray<FString> GetCommand(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName);
    bool GetBoolByName(const FName& TableRowName, const FName& RowName);
    bool GetBool(const TEnumAsByte<ESBDebugMenuType> Type, const FName& RowName);
    bool FindRow(const class UDataTable* DataTable, const FName& RowName, FSBDebugParameter& OutData);
    void BenchmarkQualityLevels();
}; // Size: 0x90

class USBDebugFunctionComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)

    void DrawDebugSphere_Server(const FVector& Center, float Radius, int32 Segments, const FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
    void DrawDebugSphere_Multicast(const FVector& Center, float Radius, int32 Segments, const FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
    void DrawDebugLine_Server(const FVector& LineStart, const FVector& LineEnd, const FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
    void DrawDebugLine_Multicast(const FVector& LineStart, const FVector& LineEnd, const FColor& Color, bool bPersistentLines, float LifeTime, uint8 DepthPriority, float Thickness);
}; // Size: 0xB8

class USBDebugScriptActorList : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    TArray<FName> GetMainTriggers(const class ASBNpcSpawnPoint* InPoint);
    void FindLevelSciptActors(TArray<class AActor*>& OutActors);
}; // Size: 0x278

class USBDebugSettingsSaveGame : public USaveGame
{
    FString SaveSlotName;                                                             // 0x0028 (size: 0x10)
    uint32 UserIndex;                                                                 // 0x0038 (size: 0x4)
    char padding_0[0x4];                                                              // 0x003C (size: 0x4)
    TArray<FSBDebugSettingByMenu> AllMenus;                                           // 0x0040 (size: 0x10)
    FSBScalability Scalability;                                                       // 0x0050 (size: 0x38)

}; // Size: 0x88

class USBDebugSpawnPointRenderingComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBDelegateHitAuthComponent : public UActorComponent
{
    char padding_0[0x130];                                                            // 0x0000 (size: 0x0)

    void MulticastFailedOnAttackStopDebugLog(int32 AttackID, class UAnimSequenceBase* Animation);
}; // Size: 0x130

class USBDemoManager : public UObject
{
    FSBDemoManagerDemoPlayStartDelegate DemoPlayStartDelegate;                        // 0x0028 (size: 0x10)
    void DemoPlayStartDelegate();
    FSBDemoManagerDemoPlayStartSequencerDelegate DemoPlayStartSequencerDelegate;      // 0x0038 (size: 0x10)
    void DemoPlayStartSequencerDelegate(const class ASBLevelSequenceActor* SequencerActor);
    FSBDemoManagerDemoPlayEndDelegate DemoPlayEndDelegate;                            // 0x0048 (size: 0x10)
    void DemoPlayEndDelegate();
    FSBDemoManagerDemoPlayEndSequencerDelegate DemoPlayEndSequencerDelegate;          // 0x0058 (size: 0x10)
    void DemoPlayEndSequencerDelegate(const class ASBLevelSequenceActor* SequencerActor);
    char padding_0[0x8];                                                              // 0x0068 (size: 0x8)
    class UDataTable* DemoDB;                                                         // 0x0070 (size: 0x8)
    char padding_1[0x10];                                                             // 0x0078 (size: 0x10)
    class ULevelSequence* LevelSequenceAsset;                                         // 0x0088 (size: 0x8)
    UClass* LevelSequenceClass;                                                       // 0x0090 (size: 0x8)
    TArray<class UStreamableRenderAsset*> ResidentAssets;                             // 0x0098 (size: 0x10)
    char padding_2[0x30];                                                             // 0x00A8 (size: 0x30)
    TArray<class UObject*> CharaCreateAssets;                                         // 0x00D8 (size: 0x10)

    void OnPlayEnd(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    FName GetPlayingDemoName();
    void DemoCapturePlayStart();
    void DemoCapturePlayEnd();
}; // Size: 0xE8

class USBDemoParameterComponent : public UActorComponent
{
    FSBLimbIKUpdateParam LimbIKUpdateParamFootL;                                      // 0x00B8 (size: 0x10)
    FSBLimbIKUpdateParam LimbIKUpdateParamFootR;                                      // 0x00C8 (size: 0x10)
    FSBLimbIKUpdateParam LimbIKUpdateParamWristL;                                     // 0x00D8 (size: 0x10)
    FSBLimbIKUpdateParam LimbIKUpdateParamWristR;                                     // 0x00E8 (size: 0x10)
    bool bIsPlayDemo;                                                                 // 0x00F8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00F9 (size: 0x7)
    class USBDemoParameterComponent* CacheObject;                                     // 0x0100 (size: 0x8)

}; // Size: 0x108

class USBDhcBattleComponent : public USBPlayerPropertyComponent
{
    FSBDhcBattleComponentOnLoadDhcBattleHighScoreInfoDelegate OnLoadDhcBattleHighScoreInfoDelegate; // 0x00B8 (size: 0x10)
    void OnLoadDhcBattleHighScoreInfoDelegate(const int32 InRetCode, const FSBDhcBattleInfo& InAttackCheckerInfo);
    FSBDhcBattleComponentOnSaveDhcBattleHighScoreInfoDelegate OnSaveDhcBattleHighScoreInfoDelegate; // 0x00C8 (size: 0x10)
    void OnSaveDhcBattleHighScoreInfoDelegate(const int32 InRetCode, const bool InResult);

    void SetCurrentDhcMesurer(class AActor* DhcMesurer);
    void Server_SaveHighScoreInfo(FString InWeaponUniqueId, class AActor* DHCMeasurer);
    void RequestSaveHighScoreInfo(FString InWeaponUniqueId, class AActor* DHCMeasurer);
    bool RequestLoadHighScoreInfo();
    void OnSaveDhcBattleHighScoreInfoDelegate__DelegateSignature(const int32 InRetCode, const bool InResult);
    void OnLoadDhcBattleHighScoreInfoDelegate__DelegateSignature(const int32 InRetCode, const FSBDhcBattleInfo& InAttackCheckerInfo);
    class AActor* GetCurrentDhcMesurer();
    void Client_SaveHighScoreInfo(const int32 InRetCode, const bool InResult);
}; // Size: 0x100

class USBDialog : public USBUserWidget
{
    FSBDialogEndDynamicDelegate EndDynamicDelegate;                                   // 0x02C8 (size: 0x10)
    void DialogEndDynamicDelegate(EDialogResult Result);
    EDialogResult OkOperation;                                                        // 0x02D8 (size: 0x1)
    EDialogResult CancelOperation;                                                    // 0x02D9 (size: 0x1)
    bool CheckBoxStatus;                                                              // 0x02DA (size: 0x1)

    void StartYesNoDialog(const FText& Message, EDialogPositionType Type, bool bEnableBgBlur);
    void StartMessageDialog(const FText& Message, EDialogPositionType Type, bool bEnableBgBlur);
    void ShowWarning(bool bVisible);
    void SetYesButtonClickSe(class UAkAudioEvent* AkEvent, FString EventName);
    void SetDefaultOperation(EDialogResult InOkOperation, EDialogResult InCancelOperation);
    void SetCheckBoxMessage(bool bVisible, const FText& Message);
    void OnEndDialog(const EDialogResult Result);
    void DialogEndDynamicDelegate__DelegateSignature(EDialogResult Result);
}; // Size: 0x2E0

class USBDodgeSkillInfo : public USBSkillInfoClass
{
    TArray<FSBCurveMoveSetting> CurveMoveSettingList;                                 // 0x02B0 (size: 0x10)
    FName DodgeSucceededCharacterMaterial;                                            // 0x02C0 (size: 0x8)
    TArray<FSBConditionCheckParam> DodgeSuccessAttackConditionList;                   // 0x02C8 (size: 0x10)

}; // Size: 0x2D8

class USBDownloadImageImpl : public UObject
{
    bool bSuccess;                                                                    // 0x0028 (size: 0x1)
    bool bDownload;                                                                   // 0x0029 (size: 0x1)
    char padding_0[0x6];                                                              // 0x002A (size: 0x6)
    class UTexture2DDynamic* Texture;                                                 // 0x0030 (size: 0x8)
    char padding_1[0x28];                                                             // 0x0038 (size: 0x28)
    class UAsyncTaskDownloadImage* AsyncTask;                                         // 0x0060 (size: 0x8)

    void OnSuccess(class UTexture2DDynamic* InTexture);
    void OnFail(class UTexture2DDynamic* InTexture);
}; // Size: 0x70

class USBDragonAlbusComponent : public USBEnemySpecializerComponent
{
    bool bIsHornGuard;                                                                // 0x00B8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00B9 (size: 0x3)
    float HornGuardTime;                                                              // 0x00BC (size: 0x4)

    bool IsHornGuard();
    void ActivateHornGuard(TSubclassOf<class ASBWeapon> AssetClass, TEnumAsByte<ESBWeaponAttach> WeaponAttach, FTransform Transform, const int32 GuardTime);
}; // Size: 0xC0

class USBDroppingTextBase : public USBUserWidget
{
    FText DisplayMessage;                                                             // 0x02B0 (size: 0x18)

    void Start();
    void SetMessageTextInItemName(const FText& ItemName, const int32 Amount, ESBDroppingTextOption Option);
    void SetMessageTextInItem(const EItemType ItemType, const int32 ItemId, const int32 Amount, ESBDroppingTextOption Option, bool bUnidentified, bool bIsBonusAdd);
    void SetMessageTextInFree(const FText& InText, ESBDroppingTextOption Option);
    void SetMessageText(const FText& InText);
}; // Size: 0x2C8

class USBDroppingTextManager : public UObject
{
    TSubclassOf<class USBDroppingTextBase> CreateDroppingTextureUI;                   // 0x0028 (size: 0x8)
    TSubclassOf<class USBDroppingTextBase> CreateDroppingTextRareUI;                  // 0x0030 (size: 0x8)

    void ShowDroppingTextItemName(class UObject* WorldContextObject, const FText& ItemName, const int32 Amount, ESBDroppingTextOption Option);
    void ShowDroppingTextItemArray(class UObject* WorldContextObject, const TArray<FSBDiffItemInfo>& Items);
    void ShowDroppingTextItem(class UObject* WorldContextObject, const EItemType ItemType, const int32 ItemId, const int32 Amount, ESBDroppingTextOption Option, bool bUnidentified, bool bIsBonusAdd, bool bRare);
    void ShowDroppingText(class UObject* WorldContextObject, const FText& Message, ESBDroppingTextOption Option);
    class USBDroppingTextBase* CreateDroppingUI(class UObject* WorldContextObject, bool bRare);
}; // Size: 0x38

class USBDsStateWidget : public UUserWidget
{
    bool bIsLayoutableHUD;                                                            // 0x0278 (size: 0x1)

    void OnShow();
    void OnSetCount(int32 Count);
    void OnHide();
    void OnChangeEffect(int32 Index);
}; // Size: 0x288

class USBDummyDataUtility : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBDungeonBattleinfoHUDWidget : public UUserWidget
{
    bool bIsRootVisible;                                                              // 0x0278 (size: 0x1)

    void OnUpdate();
}; // Size: 0x280

class USBDungeonBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    int32 TeleportDungeonBattleNpcToLocation(class UObject* WorldContextObject, FVector Location, FRotator Rotation);
    int32 TeleportAllPlayersToTarget(class UObject* WorldContextObject, FName ActorTag, bool bWithNpc, bool bWithFade, float FadeTime);
    bool StartTowerChallenge(class UObject* WorldContextObject, const FName& ChallengeID);
    bool StartMission(class UObject* WorldContextObject, const FName& MissionId);
    void SetPlayerCurrentLocationToReturnLocation(class UObject* WorldContextObject);
    void SetEditorGameContentId(FName GameContentId, FString GameModeName);
    void SetClearTowerChallengeNoCounter(class UObject* WorldContextObject);
    void RetireDungeonGame(class UObject* WorldContextObject, class APlayerController* PlayerController);
    int32 ResetCoolTimeAllPlayers(class UObject* WorldContextObject, FString ModeStr);
    int32 RecoverHpAllPlayers(class UObject* WorldContextObject);
    void PrintServerString(class UObject* WorldContextObject, FString Msg, FLinearColor Col, float Timer, bool ToScreen);
    void NotifyLevelBuddyVoiceCondition(class UObject* WorldContextObject, ESBLevelBuddyVoiceCondition Condition);
    bool IsWaitingDungeonStart(const class UObject* WorldContextObject);
    bool IsStartImmediately(class UObject* WorldContextObject);
    bool IsScenarioDungeon(class UObject* WorldContextObject);
    bool IsInMission(class UObject* WorldContextObject);
    bool IsGameModeSurvival(const FName GameContentId);
    bool IsGameModeSksBattle(const FName GameContentId);
    bool IsGameModeRankUpExam(const FName GameContentId);
    bool IsGameModeRaidBattle(const FName GameContentId);
    bool IsGameModePublicDungeon(const FName GameContentId);
    bool IsGameModeOfflineDemo(const FName GameContentId);
    bool IsGameModeKwmBattle(const FName GameContentId);
    bool IsGameModeInstanceArea(const FName GameContentId);
    bool IsGameModeField(const FName GameContentId);
    bool IsGameModeDxBattle(const FName GameContentId);
    bool IsGameModeDungeonTimeAttack(const FName GameContentId);
    bool IsGameModeDungeonScoreAttack(const FName GameContentId);
    bool IsGameModeDungeonScenario(const FName GameContentId);
    bool IsGameModeDungeonNormal(const FName GameContentId);
    bool IsGameModeDungeon(const class UObject* WorldContextObject, const FName GameContentId);
    bool IsGameModeCity(const FName GameContentId);
    bool IsGameModeBattleArenaEx(const FName GameContentId);
    bool IsGameModeBattleArena(const FName GameContentId);
    bool IsFromBattleMode(class UObject* WorldContextObject);
    bool IsDungeonResultMenuStarted(class UObject* WorldContextObject);
    bool IsDungeonPlaying(const class UObject* WorldContextObject);
    bool IsDungeonMap(class UObject* WorldContextObject, const FName& GameContentId);
    bool IsDungeonGameStarted(const class UObject* WorldContextObject);
    bool IsDungeonEnd(const class UObject* WorldContextObject);
    bool IsDungeonBossEnemy(class UObject* WorldContextObject, const FString InEnemyId);
    bool IsAvailableContent(class UObject* WorldContextObject, const FName& GameContentId);
    bool InDungeonGame(class UObject* WorldContextObject);
    void IncrementTowerChallengeFreecCounter(class UObject* WorldContextObject);
    void GetSortedPlayerState(class UObject* WorldContextObject, TArray<class APlayerState*>& PlayerStates);
    bool GetResultOverLimit(const class UObject* WorldContextObject, FSBOverLimit& OutOverLimit);
    bool GetResultLetter(const class UObject* WorldContextObject, FSBLetter& OutLetter);
    int32 GetMissionCount(class UObject* WorldContextObject);
    int32 GetMissionClearCount(class UObject* WorldContextObject);
    ESBDungeonMatchMenuRegisterType GetMatchMenuRegisterType(const FName& GameContentId);
    bool GetGameModeInfo(const FName& GameContentId, FSBGameModeInfo& GameModeInfo);
    TSubclassOf<class AGameModeBase> GetGameModeClassByName(FString GameModeName);
    void GetGameContentIdListByGameMode(const FString GameMode, TArray<FName>& ContentIdList);
    void GetEnemyListWithoutBuddy(class UObject* WorldContextObject, TArray<class ASBEnemyCharacter*>& EnemyList);
    FString GetEditorGameModeNameByContentId(FName GameContentId);
    bool GetDungeonStartLocation(const class ASBPlayerStart* PlayerStart, int32 DngId, FVector& Location, float& Yaw, bool& narrow);
    bool GetDungeonRewardInfo(const TArray<FSBMasterReward>& RewardArray, FSBDungeonRewardInfo& RewardInfo);
    bool GetDungeonRewardArray(const FName& GameContentId, TArray<FSBMasterReward>& RewardArray, int32 ClassId, int32 EvaluationId);
    ESBDungeonEvaluation GetDungeonRankedRewardArray(const FName& GameContentId, TArray<FSBMasterReward>& RewardArray, int32 ClassId, int32 ResultValue);
    bool GetDungeonMapInfo(const FName& GameContentId, FSBMapInfo& MapInfo);
    FString GetDungeonGameMode(class UObject* WorldContextObject);
    bool GetDungeonCurrentStepInfo(class UObject* WorldContextObject, int32& MaxStep, int32& CurStep);
    int32 GetDungeonBattleNpcList(class UObject* WorldContextObject, TArray<class ASBEnemyCharacter*>& BattleNpcList);
    bool GetCurrentSessionDungeonId(class UObject* WorldContextObject, FName& DungeonId);
    ESBBattleRule GetBattleRule(class UObject* WorldContextObject);
    int32 ForceResurrectAllPlayers(class UObject* WorldContextObject, float HpPercentage);
    bool FindGameContentIdByMapName(const FString MapName, FName& GameContentId);
    void ClearDungeonCurrentStep(class UObject* WorldContextObject);
}; // Size: 0x28

class USBDungeonCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ShowGameContentId();
    void ShowDungeonProcessLog(bool sw);
    void SetTowerNextFloor(const int32 InFloor);
    void SetScoreAttackNowScore(const int32 InScore);
    void SetScoreAttackComboLimitTime(const float InTimeSec);
    void SetMinutesPerDay(const int32 InMinutesPerDay);
    void SetDungeonRemainTime(const int32 InMinute, const int32 InSecond);
    void SetDungeonClearCheckParty(bool IsPartyCheck);
    void SetDunegonInstanceLifeTime(int32 TimeSec);
    void Server_RaidBattleDebugLogPirnt(FString InPlayerName, bool IsLogPut);
    void RetryDungeon(int32 Mode);
    void RetireDungeon();
    void ResetBhtSignalStatus();
    void RaidBattleMasterDataLogPut();
    void RaidBattleDebugLogPirntReset();
    void RaidBattleDebugLogPirnt(bool IsLogPut);
    void OutputRaidPlayerContributionValue();
    void OutputDungeonScoreDebug();
    void OutputBhtSignalStatus();
    void LevelBuddyVoice(ESBLevelBuddyVoiceCondition Condition);
    void KillDungeonTaggedEnemy();
    void ForceDetectCheating(int32 PlayerId);
    void EraseStaticMeshCollision(FName LevelName);
    void DebugUnloadStreamLevel(FName LevenName);
    void DebugLoadStreamLevel(FName LevenName);
    void ClearTowerChallenge();
    void ClearTimeAttack(const float InTime);
    void ClearScoreAttack(const int32 InScore);
}; // Size: 0x28

class USBDungeonClearConditionWatcher : public USceneComponent
{
    int32 CurStep;                                                                    // 0x0218 (size: 0x4)
    char padding_0[0x14];                                                             // 0x021C (size: 0x14)
    FDungeonClearConditionProgressInfo ProgressInfo;                                  // 0x0230 (size: 0x10)
    char padding_1[0x10];                                                             // 0x0240 (size: 0x10)
    bool bCompleted;                                                                  // 0x0250 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0251 (size: 0x7)
    FSBDungeonClearConditionWatcherOnClearConditionChangeDelegate OnClearConditionChangeDelegate; // 0x0258 (size: 0x10)
    void OnClearConditionChangeDelegate();
    FSBDungeonClearConditionWatcherOnClearConditionUpdateProgressDelegate OnClearConditionUpdateProgressDelegate; // 0x0268 (size: 0x10)
    void OnClearConditionUpdateProgressDelegate(const FDungeonClearConditionProgressItemInfo& InProgressItem, const int32 InStepNum, const int32 InProgressIndex);
    FSBDungeonClearConditionWatcherOnClearConditionChangeStepDelegate OnClearConditionChangeStepDelegate; // 0x0278 (size: 0x10)
    void OnClearConditionChangeStepDelegate(const int32 InCurStep);
    FSBDungeonClearConditionWatcherOnClearConditionCompleteDelegate OnClearConditionCompleteDelegate; // 0x0288 (size: 0x10)
    void OnClearConditionCompleteDelegate(const FName& InDungeonName);

    void ServerForceComplete();
    void ServerClearCurrentStep();
    void ServerClearCondition(const int32 InStep, const int32 InConditionId);
    void OnRep_UpdateProgress();
    void OnRep_CurStep();
    void OnRep_Completed();
    void OnClearConditionUpdateProgressDelegate__DelegateSignature(const FDungeonClearConditionProgressItemInfo& InProgressItem, const int32 InStepNum, const int32 InProgressIndex);
    void OnClearConditionCompleteDelegate__DelegateSignature(const FName& InDungeonName);
    void OnClearConditionChangeStepDelegate__DelegateSignature(const int32 InCurStep);
    void OnClearConditionChangeDelegate__DelegateSignature();
    bool IsConditionInitialized();
    bool IsCompleted();
    bool IsClearConditionExist();
    void ForceComplete();
    void ClearCurrentStep();
    void ClearCondition(const int32 InStep, const int32 InConditionId);
}; // Size: 0x2A0

class USBDungeonClearConditionWatcher2 : public USBDungeonClearConditionWatcher
{
    TArray<FSBDungeonProcessCondition> DugeonProcessConditoins;                       // 0x0298 (size: 0x10)
    char padding_0[0x8];                                                              // 0x02A8 (size: 0x8)
    TArray<FString> EventScriptList;                                                  // 0x02B0 (size: 0x10)
    TMap<class FName, class FSBDungeonProcessCondition> ProcessConditionMap;          // 0x02C0 (size: 0x50)
    TArray<FName> ProcessClearQueue;                                                  // 0x0310 (size: 0x10)
    int32 ProcessClearQueueId;                                                        // 0x0320 (size: 0x4)

    TArray<FName> UpdateProcessCondition(ESBDungeonClearCondition ClearType, const FString ClearParameter);
    void SetupProcessConditionTable(class UDataTable* ProcessTable);
    void SetupProcessCondition(const TArray<FSBDungeonProcess> Processes);
    void NotifyPlayerInteraction(const class ASBInteractionSwBase* InteractionSw);
}; // Size: 0x370

class USBDungeonRecordList : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    void GetDungeonRecord(const FName& InDungeonId, FSBDungeonRecord& OutRecord);
}; // Size: 0x38

class USBDxBattleBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsDxBattle(class UObject* WorldContextObject);
    int32 GetDxBattleContributionClass(const TArray<FSBDxBattleGameScore>& ScoreList);
    int32 GetDxBattleContribution(const TArray<FSBDxBattleGameScore>& ScoreList);
    int32 GetDxBattleAwardValue(const TArray<FSBDxBattleGameScore>& ScoreList, ESBDxBattleAwardFlag Award);
    int32 GetDxBattleAwardIndex(ESBDxBattleAwardFlag Award);
    ESBDxBattleAwardFlag GetDxBattleAwardFlag(int32 Index);
    bool DrawDxPlayerInfo(class UObject* WorldContextObject, const class ASBPlayerCharacter* Character, float InSeconds, const TArray<FSBDxBattleGameScore>& PlayerScoreList, int32 EnemyGateDestructNum, int32 EnemyBufferDestructNum);
}; // Size: 0x28

class USBDxBattleEnemyGateComponent : public UActorComponent
{
    FSBDxBattleEnemyGateComponentOnCallSpawnEnemyDelegate OnCallSpawnEnemyDelegate;   // 0x00B8 (size: 0x10)
    void SBOnCallSpawnEnemyDelegate();
    FSBDxBattleEnemyGateComponentOnTickComponentDelegate OnTickComponentDelegate;     // 0x00C8 (size: 0x10)
    void SBOnTickComponentDelegate();
    char padding_0[0x8];                                                              // 0x00D8 (size: 0x8)
    float CallSpawnEnemyDelayTime;                                                    // 0x00E0 (size: 0x4)

    void SBOnTickComponentDelegate__DelegateSignature();
    void SBOnCallSpawnEnemyDelegate__DelegateSignature();
    float GetSpawnTimerRemaininig();
    void EnableTickComponent();
    void CallSpawnEnemy();
}; // Size: 0xE8

class USBDxBattleEnemyGateSpawnerComponent : public UActorComponent
{
    char padding_0[0xD0];                                                             // 0x0000 (size: 0x0)

    bool SpawnEnemyByEncounterVolume(int32 MaxEnemyCount);
    void ReleaseEncounterVolume();
    void OnActorSpawned(class AActor* Actor);
    void OnActorDestroyed(class AActor* Actor);
    int32 GetSpawnedEnemyNum();
    int32 GetSpawnedEnemyGateAttackerNum();
    void EscapeAllEnemies();
    void EntryEncounterVolume(class ASBEncounterVolume* InEncounterVolume);
}; // Size: 0xD0

class USBDxBattleHUD : public UUserWidget
{
    FSBDxBattleHUDOnStartGameDelegate OnStartGameDelegate;                            // 0x02A8 (size: 0x10)
    void OnStartGameDelegate();
    bool m_IsStartGame;                                                               // 0x02B8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x02B9 (size: 0x3)
    float m_WallHP;                                                                   // 0x02BC (size: 0x4)
    float m_CurSeqElapsedTime;                                                        // 0x02C0 (size: 0x4)
    float m_SeqTimeLimit;                                                             // 0x02C4 (size: 0x4)
    char padding_1[0x40];                                                             // 0x02C8 (size: 0x40)
    int32 m_DefenseTargetMaxHP;                                                       // 0x0308 (size: 0x4)
    int32 m_DefenceTragetHP;                                                          // 0x030C (size: 0x4)
    class UTextBlock* m_TimerTextBlockMinutes;                                        // 0x0310 (size: 0x8)
    class UTextBlock* m_TimerTextBlockSeconds;                                        // 0x0318 (size: 0x8)
    class UTextBlock* m_TimerTextBlockMilliSecond;                                    // 0x0320 (size: 0x8)
    class UTextBlock* m_TextBlockWallHP;                                              // 0x0328 (size: 0x8)
    class UTextBlock* m_TextBlockEnemyCount;                                          // 0x0330 (size: 0x8)
    class UTextBlock* m_TextBlockEnemyGateCount;                                      // 0x0338 (size: 0x8)
    class UTextBlock* m_TextBlockEnemyKyokaSoutiCount;                                // 0x0340 (size: 0x8)

    void WallAnimation(const FLinearColor Color, class UImage* Image, int32 sec);
    void UpdateTargetHP(int32 DefenceTragetHP);
    void UpdateParamsTick(int32 InfiniteEnemyNum, int32 GateEnemyNum, int32 CurrentGateNum, int32 DestroyedGateNum, int32 CurrentSupplierNum, int32 LotCountDown);
    void UpdateParams(int32 DxBattleSeqId, float SeqTimeLimit, float LotSpan, int32 QualityGateNum, int32 InfiniteEnemyMax, int32 GateEnemyMax, int32 CurrentGateMax, int32 CurrentSupplierMax, int32 CurSequenceType, int32 DefenseTargetMaxHP);
    void UpdateCurrectEnergy(int32 Val);
    void StopGame();
    void StartGame();
    void SetTimerTextBlock(class UTextBlock* TimerTextBlockMinutes, class UTextBlock* TimerTextBlockSeconds, class UTextBlock* TimerTextBlockMilliSecond);
    void SetTextBlocks(class UTextBlock* TextBlockWallHP, class UTextBlock* TextBlockEnemyCount, class UTextBlock* TextBlockEnemyGateCount, class UTextBlock* TextBlockEnemyKyokaSoutiCount);
    void OnStartGameDelegate__DelegateSignature();
    float GetTimerCount();
    void AttackedWall();
}; // Size: 0x350

class USBDxBattleManager : public UObject
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)

    void OnMasterDataAvailable();
}; // Size: 0x48

class USBEDTransition_EnemyAttackGuarded : public UASTransitionEventDriven_Base
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBEDTransition_EnemyAttackHit : public UASTransitionEventDriven_Base
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBEDTransition_EnemyCommand : public UASTransitionEventDriven_Command
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBEGaugeWidget : public UUserWidget
{
    class UImage* Current;                                                            // 0x0278 (size: 0x8)
    class UImage* GrayOut;                                                            // 0x0280 (size: 0x8)
    class UImage* Icon;                                                               // 0x0288 (size: 0x8)
    TMap<class ESBAttribute, class UTexture2D*> GaugeImage;                           // 0x0290 (size: 0x50)
    TMap<class ESBAttribute, class UTexture2D*> IconImage;                            // 0x02E0 (size: 0x50)
    FVector2D GaugeSize;                                                              // 0x0330 (size: 0x8)

    void Update(class ASBCharacter* TargetCharacter);
    void OnUpdate();
    void OnPlayAnimNormal();
    void OnPlayAnimBlink();
    float GetTime();
    float GetGaugeRate(float Value);
    float GetGaugeLVRate(int32 Level);
    float GetCurrentGaugeRate();
}; // Size: 0x348

class USBEffectManager : public UObject
{
    FSBDamageHitEffectSetting DamageHitSettings_Slash;                                // 0x0040 (size: 0x540)
    FSBDamageHitEffectSetting DamageHitSettings_Blow;                                 // 0x0580 (size: 0x540)
    FSBDamageHitEffectSetting DamageHitSettings_Thrust;                               // 0x0AC0 (size: 0x540)
    FSBDamageHitEffectSetting DamageHitSettings_Claw;                                 // 0x1000 (size: 0x540)
    FSBDamageHitEffectSetting DamageHitSettings_Fang;                                 // 0x1540 (size: 0x540)
    FSBElementHitEffectSetting ElementEffectSetting_Earth;                            // 0x1A80 (size: 0x540)
    FSBElementHitEffectSetting ElementEffectSetting_Fire;                             // 0x1FC0 (size: 0x540)
    FSBElementHitEffectSetting ElementEffectSetting_Ice;                              // 0x2500 (size: 0x540)
    FSBElementHitEffectSetting ElementEffectSetting_Thunder;                          // 0x2A40 (size: 0x540)
    FSBElementHitEffectSetting ElementEffectSetting_Light;                            // 0x2F80 (size: 0x540)
    FSBElementHitEffectSetting ElementEffectSetting_Darkness;                         // 0x34C0 (size: 0x540)
    FSBEffectSetting ElementHitGlitterMode;                                           // 0x3A00 (size: 0x150)
    FSBEffectSetting GeneralEffectiveHit;                                             // 0x3B50 (size: 0x150)
    FSBEffectSetting SuperArmorHit;                                                   // 0x3CA0 (size: 0x150)
    FSBEffectSetting BackAttackrHit;                                                  // 0x3DF0 (size: 0x150)
    FSBEffectSetting ElementSpread;                                                   // 0x3F40 (size: 0x150)
    FSBEffectSetting ProjectileInWater;                                               // 0x4090 (size: 0x150)
    float WeaponRollThreshold;                                                        // 0x41E0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x41E4 (size: 0x4)
    TArray<FSBHitCameraShakeSetting> HitCameraShakeList;                              // 0x41E8 (size: 0x10)
    FSBEffectSetting RollDodgeSuccessEffect;                                          // 0x41F8 (size: 0x150)
    FSBEffectSetting StepDodgeSuccessEffect;                                          // 0x4348 (size: 0x150)
    FSBEffectSetting DodgeAttackAfterDodgeSucceeded;                                  // 0x4498 (size: 0x150)
    class UCurveFloat* DodgeSuccessMaterialCurve;                                     // 0x45E8 (size: 0x8)
    FSBEffectSetting BuffAuraATKEffect;                                               // 0x45F0 (size: 0x150)
    FSBEffectSetting BuffAuraDEFEffect;                                               // 0x4740 (size: 0x150)
    FSBEffectSetting EnemySpawnEffect;                                                // 0x4890 (size: 0x150)
    FSBEffectSetting AerialAttackBonusEffect;                                         // 0x49E0 (size: 0x150)
    TSubclassOf<class USBAttributeSlashDiskList> AttributeSlashDiskList;              // 0x4B30 (size: 0x8)
    class UParticleSystem* SlashDiskParticle_None;                                    // 0x4B38 (size: 0x8)
    class UParticleSystem* SlashDiskParticle_Earth;                                   // 0x4B40 (size: 0x8)
    class UParticleSystem* SlashDiskParticle_Fire;                                    // 0x4B48 (size: 0x8)
    class UParticleSystem* SlashDiskParticle_Ice;                                     // 0x4B50 (size: 0x8)
    class UParticleSystem* SlashDiskParticle_Thunder;                                 // 0x4B58 (size: 0x8)
    class UParticleSystem* SlashDiskParticle_Light;                                   // 0x4B60 (size: 0x8)
    class UParticleSystem* SlashDiskParticle_Darkness;                                // 0x4B68 (size: 0x8)
    class UParticleSystem* SlashDiskParticle_GlitterMode;                             // 0x4B70 (size: 0x8)
    float SlashDiskSpeedRateMin;                                                      // 0x4B78 (size: 0x4)
    char padding_1[0x4];                                                              // 0x4B7C (size: 0x4)
    FSBEffectSetting Resurrection;                                                    // 0x4B80 (size: 0x150)
    FSBEffectSetting ResurrectionComp;                                                // 0x4CD0 (size: 0x150)
    FSBEffectSetting SpecialGaugeFull;                                                // 0x4E20 (size: 0x150)
    FSBEffectSetting ImagineGaugeFull;                                                // 0x4F70 (size: 0x150)
    FSBPlayerWarpEffect m_WarpInEffect;                                               // 0x50C0 (size: 0xA8)
    FSBPlayerWarpEffect m_RespawnInEffect;                                            // 0x5168 (size: 0xA8)
    FSBPlayerWarpEffect m_EngramCannonGetOffEffect;                                   // 0x5210 (size: 0xA8)
    FSBPlayerWarpEffect m_WarpOutEffect;                                              // 0x52B8 (size: 0xA8)
    FSBPlayerWarpEffect m_DeathOutEffect;                                             // 0x5360 (size: 0xA8)
    FSBPlayerWarpEffect m_FallDeathOutEffect;                                         // 0x5408 (size: 0xA8)
    FSBPlayerWarpEffect m_EngramCannonGetOnEffect;                                    // 0x54B0 (size: 0xA8)
    FSBEffectSetting m_WarpShowEffect;                                                // 0x5558 (size: 0x150)
    float m_WarpShowEffectDeactivateDelayTime;                                        // 0x56A8 (size: 0x4)
    char padding_2[0x4];                                                              // 0x56AC (size: 0x4)
    FSBPlayerWarpEffect m_BattleNPCWarpInEffect;                                      // 0x56B0 (size: 0xA8)
    FSBEffectSetting m_ClassLevelUpEffect;                                            // 0x5758 (size: 0x150)
    FSBEffectSetting m_AdventurerRankUpEffect;                                        // 0x58A8 (size: 0x150)
    TArray<FSBEffectSetting> DashEffectList;                                          // 0x59F8 (size: 0x10)
    class UCurveFloat* m_FootprintDecalOpaictyCurve;                                  // 0x5A08 (size: 0x8)
    char padding_3[0x4];                                                              // 0x5A10 (size: 0x4)
    float MeshLODOffsetBoundSize;                                                     // 0x5A14 (size: 0x4)
    char padding_4[0x4];                                                              // 0x5A18 (size: 0x4)
    int32 m_PlayerFootprintParticleLOD;                                               // 0x5A1C (size: 0x4)
    int32 m_NPCFootprintParticleLOD;                                                  // 0x5A20 (size: 0x4)
    int32 m_EnemyFootprintParticleLOD;                                                // 0x5A24 (size: 0x4)
    int32 m_DefaultFootprintParticleLOD;                                              // 0x5A28 (size: 0x4)
    char padding_5[0x7C];                                                             // 0x5A2C (size: 0x7C)
    float CullDistanceDefault;                                                        // 0x5AA8 (size: 0x4)
    float CullDistanceProjectile;                                                     // 0x5AAC (size: 0x4)
    char padding_6[0x8];                                                              // 0x5AB0 (size: 0x8)
    float m_ShaderParamChangeTime;                                                    // 0x5AB8 (size: 0x4)
    char padding_7[0xC];                                                              // 0x5ABC (size: 0xC)
    FSBEffectSetting DebugAxisEffect;                                                 // 0x5AC8 (size: 0x150)

    class UParticleSystemComponent* SpawnSlashDisk(class USBAnimNotifyState_SlashDisk* NotifyState, class ACharacter* OwnerCharacter, FName AttachPointName, FVector Location, FRotator Rotation, TSubclassOf<class USBAttributeSlashDiskList> InAttributeSlashDiskList);
    void SetVFXSetting(const ESBBattleEffectVisibleCategory Category, const ESBBattleEffectVisibleType Type, bool bVisible);
    void SetVFXCustomMode(const bool bCustom);
    void SetParticleAlphaValue(int32 AlphaValue);
    void SetFootprintTestOverrideMaterial(TEnumAsByte<EPhysicalSurface> SurfaceType);
    void SetBattleImagineTransparent(bool bIsTransparent);
    void ClearFootprintTestOverrideMaterial();
}; // Size: 0x5C18

class USBEffectManagerFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UpdateEffectVisibility();
    class UNiagaraComponent* SpawnNiagaraAttached(const FSBSpawnNiagaraAttachedParam& SpawnNiagaraParam);
    class UNiagaraComponent* SpawnNiagaraAtLocation(const FSBSpawnNiagaraAtLocationParam& SpawnNiagaraParam);
    class UParticleSystemComponent* SpawnFootprintEffectAtLocation(const FSBSpawnEmitterAtLocationParam& SpawnEmitterParam, class USBSurfaceFootprintSetting* SurfaceFootprintSetting, TEnumAsByte<EPhysicalSurface> SurfaceType);
    class UParticleSystemComponent* SpawnEmitterAttached_Simple(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, ESBEffectVisibleType VisibleType);
    class UParticleSystemComponent* SpawnEmitterAttached(const FSBSpawnEmitterAttachedParam& SpawnEmitterParam);
    class UParticleSystemComponent* SpawnEmitterAtLocation_Simple(class UParticleSystem* EmitterTemplate, class AActor* SourceActor, FVector Location, ESBEffectVisibleType VisibleType);
    class UParticleSystemComponent* SpawnEmitterAtLocation(const FSBSpawnEmitterAtLocationParam& SpawnEmitterParam);
    class UDecalComponent* SpawnDecalAttached_Simple(class UMaterialInterface* DecalMaterial, class USceneComponent* AttachToComponent, ESBEffectVisibleType VisibleType);
    class UDecalComponent* SpawnDecalAttached(const FSBSpawnDecalAttachedParam& SpawnDecalParam);
    class UDecalComponent* SpawnDecalAtLocation_Simple(class UMaterialInterface* DecalMaterial, class AActor* SourceActor, FVector Location, ESBEffectVisibleType VisibleType);
    class UDecalComponent* SpawnDecalAtLocation(const FSBSpawnDecalAtLocationParam& SpawnDecalParam);
    void AddSpawnNiagaraList(class UNiagaraComponent* Niagara, class AActor* SourceActor, ESBEffectVisibleType VisibleType, bool bVisibleByHiddenSourceActor, ESBEffectCullingType CullingType);
    void AddSpawnEmitterList(class UParticleSystemComponent* ParticleSystem, class AActor* SourceActor, ESBEffectVisibleType VisibleType, bool bVisibleByHiddenSourceActor, ESBEffectCullingType CullingType);
    void AddSpawnDecalList(class UDecalComponent* Decal, class AActor* SourceActor, ESBEffectVisibleType VisibleType, bool bVisibleByHiddenSourceActor);
}; // Size: 0x28

class USBEffectValueComponent : public UActorComponent
{
    FSBNotifyEffectValue NotifyConfig;                                                // 0x00B8 (size: 0x4)
    float InitialValue;                                                               // 0x00BC (size: 0x4)
    FVector AttackCollisionScale;                                                     // 0x00C0 (size: 0xC)
    FVector AttackCollision;                                                          // 0x00CC (size: 0xC)
    FVector AttackCollisionOffset;                                                    // 0x00D8 (size: 0xC)
    char padding_0[0x4];                                                              // 0x00E4 (size: 0x4)
    TArray<TWeakObjectPtr<AActor>> SpawnEffectActor;                                  // 0x00E8 (size: 0x10)
    TWeakObjectPtr<class AActor> SpawnOwner;                                          // 0x00F8 (size: 0x8)
    TWeakObjectPtr<class AActor> SpawnRootOwner;                                      // 0x0100 (size: 0x8)
    float CollisionStartTime;                                                         // 0x0108 (size: 0x4)
    FVector BeamBeginLocation;                                                        // 0x010C (size: 0xC)
    FVector BeamEndLocation;                                                          // 0x0118 (size: 0xC)
    ESBEffectVisibleType EffectVisibleType;                                           // 0x0124 (size: 0x1)

    class AActor* GetRootEffectOwner();
    class AActor* GetProjectileEffectOwner();
    float GetInitialLifeTime();
    ESBEffectVisibleType GetEffectVisibleTypeOnValueComp();
    float GetCollisionStartTime();
    FVector GetBeamEndLocation();
    FVector GetBeamBeginLocation();
    FVector GetAttackCollisionScale();
    FVector GetAttackCollisionOffset();
    float GetAttackCollisionFloat();
    FVector GetAttackCollision();
}; // Size: 0x128

class USBEncounterTypeBase : public UObject
{
    class ASBEncounterVolume* OwnerVolume;                                            // 0x0028 (size: 0x8)

}; // Size: 0x30

class USBEncounterType_Event : public USBEncounterTypeBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBEncounterType_Infinite : public USBEncounterTypeBase
{
    uint8 bBeginPlayToStart;                                                          // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    float StartSpawnDelay;                                                            // 0x0034 (size: 0x4)
    uint8 bEnableSpawnMax;                                                            // 0x0038 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0039 (size: 0x3)
    int32 SpawnMax;                                                                   // 0x003C (size: 0x4)
    ESBSpawnFailedProcessType FailedProcessType;                                      // 0x0040 (size: 0x1)
    char padding_2[0x17];                                                             // 0x0041 (size: 0x17)
    FTimerHandle StartTimerHandle;                                                    // 0x0058 (size: 0x8)
    FTimerHandle RequestTimerHandle;                                                  // 0x0060 (size: 0x8)

    void SetSpawnMax(bool sw, int32 MaxNum);
    void OnStopSpawn();
    void OnStartSpawn();
    void OnRequestSpawn(class ASBEncounterVolume* EncounterVolume);
}; // Size: 0x68

class USBEncounterType_Pacing : public USBEncounterTypeBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBEncounterType_Spawnable : public USBEncounterTypeBase
{
    uint8 bEnableSpawnMax;                                                            // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    int32 SpawnMax;                                                                   // 0x0034 (size: 0x4)

    void OnSpawn();
    void OnCooldownFinished(class ASBEncounterVolume* EncounterVolume);
    bool IsSpawnable();
}; // Size: 0x48

class USBEncounterType_Trigger : public USBEncounterTypeBase
{
    uint8 bTriggerOnce;                                                               // 0x0030 (size: 0x1)

    void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
}; // Size: 0x38

class USBEncounterVolumePreviewComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBEncounterVolumeRenderingComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBEncryptor : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FString EncryptNew(FString InputString, FString Key);
    FString Encrypt(FString InputString, FString Key);
    FString DecryptNew(FString InputString, FString Key);
}; // Size: 0x28

class USBEnemyAbilitySystemComponent : public UAbilitySystemComponent
{
    TSubclassOf<class UGameplayAbility> AttackAbilityClass;                           // 0x1340 (size: 0x8)
    TSubclassOf<class UGameplayAbility> MovementAbilityClass;                         // 0x1348 (size: 0x8)
    TSubclassOf<class UGameplayAbility> AttackCancelAbilityClass;                     // 0x1350 (size: 0x8)

    void DrawDebugMessages();
}; // Size: 0x1360

class USBEnemyActionParamComponent : public UActorComponent
{
    TMap<class TSoftObjectPtr<UASStateMachine>, class bool> BlendActionSettings;      // 0x0138 (size: 0x50)
    class UDataTable* ActionTableNormalMode;                                          // 0x0188 (size: 0x8)
    class UDataTable* ActionTableBattleMode;                                          // 0x0190 (size: 0x8)
    class UDataTable* ActionTableExtra;                                               // 0x0198 (size: 0x8)
    char padding_0[0xD0];                                                             // 0x01A0 (size: 0xD0)
    TArray<FSBEnemyChantEffectMotionStoredAddress> ChantEffectMotionStoredAddressArray; // 0x0270 (size: 0x10)
    FName ActionStateMachineKeyName;                                                  // 0x0280 (size: 0x8)

    void SetRecastTime(const FName& ActionName, float RecastTime);
    bool IsCommandRecasting(const FName& ActionName);
    void InitializeToBattle();
    float GetActionRecastTime(const FName& ActionName);
}; // Size: 0x288

class USBEnemyAnimUpdateRateSignificanceManagerComponent : public UActorComponent
{
    float CameraYawAngleThreshold;                                                    // 0x00B8 (size: 0x4)
    float AnimUpdateDistanceThreshold;                                                // 0x00BC (size: 0x4)

}; // Size: 0xC0

class USBEnemyAssetLoadComponent : public UActorComponent
{
    TArray<FString> LoadEnemyIds;                                                     // 0x00D8 (size: 0x10)

}; // Size: 0xE8

class USBEnemyAttributeAdditionalSettingComponent : public UActorComponent
{
    TArray<FSBHitDirectionResistanceCorrection> HitDirectionResistanceCorrection;     // 0x00B8 (size: 0x10)
    TArray<FSBCollisionGroupResistanceCorrection> CollisionGroupResistanceCorrection; // 0x00C8 (size: 0x10)

}; // Size: 0xE8

class USBEnemyAvatarComponent : public UActorComponent
{
    class USBEnemyAvatarComponent* Master;                                            // 0x00B8 (size: 0x8)
    TArray<class USBEnemyAvatarComponent*> Avatars;                                   // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class USBEnemyBDFObjectComponent : public UActorComponent
{
    FSBEnemyBDFObjectComponentOnUpdateStateDelegate OnUpdateStateDelegate;            // 0x00B8 (size: 0x10)
    void OnUpdateStateDelegate();
    bool bDeployed;                                                                   // 0x00C8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00C9 (size: 0x7)
    class USBEnemyBDFObjectManagerComponent* BDFObjectManagerCompoennt;               // 0x00D0 (size: 0x8)
    float InitialHitPoint;                                                            // 0x00D8 (size: 0x4)
    float MaxHitPoint;                                                                // 0x00DC (size: 0x4)

    void SetStatusParameter(float NewInitialHitPoint, float NewMaxHitPoint);
    void SetDeployed(bool bNewDeployed);
    void OnUpdateStateDelegate__DelegateSignature();
    void OnRep_Deployed();
    bool IsTargetableEnabled();
    bool IsDamageCollisionEnabled();
}; // Size: 0xE0

class USBEnemyBDFObjectManagerComponent : public UActorComponent
{
    TMap<class ESBBDFObjectType, class FSBBDFObjectCommonTypeInfo> CommonTypeInfo;    // 0x00B8 (size: 0x50)
    TArray<FSBBDFObjectParts> BDFObjectPartsList;                                     // 0x0108 (size: 0x10)
    int32 NumRedBlackParts;                                                           // 0x0118 (size: 0x4)
    char padding_0[0x4];                                                              // 0x011C (size: 0x4)
    FSBBDFObjectPartsHealEffectInfo PartsHealEffectInfo;                              // 0x0120 (size: 0x50)
    FString BDFObjectEnemyID;                                                         // 0x0170 (size: 0x10)
    char padding_1[0x20];                                                             // 0x0180 (size: 0x20)
    ESBBDFObjectManagerState State;                                                   // 0x01A0 (size: 0x1)

    void ToNormal();
    void SpawnPartsHealEffect();
    void RegisterBDFObjectProjectile(class AActor* Projectile);
    void OnRep_State();
    void OnRep_BDFObjectPartsList();
    void OnInhaledBDFObjectIntoSphere();
    void OnDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    bool IsAllPartsBroken();
    ESBBDFObjectType GetPartsTypeByIndex(int32 Index);
    TArray<FSBBDFObjectParts> GetBDFObjectPartsList();
    void FeedBackDamage();
    void EndDeployBDFObject();
    void EndCollectBDFObject();
    void DrawRedBlackPartsLottery();
    void BeginDeployBDFObject();
    void BeginCollectBDFObject();
    void ActivateExtraParts();
}; // Size: 0x1A8

class USBEnemyBPFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void WaitForAnimationTag(class UObject* WorldContextObject, class ASBEnemyCharacter* EnemyCharacter, FString AnimTag, bool bIsEqual, FLatentActionInfo LatentInfo);
    class ASBEnemyCharacter* SpawnEnemyWithEnemyID(class UObject* WorldContextObject, FString EnemyId, const int32 Level, FVector Location, FRotator Rotation);
    void SpawnEnemyWithEncounterVolume(class UObject* WorldContextObject, class ASBEncounterVolume* EncounterVolume);
    void RunAITask(class UAITask* Task);
    bool OverridePartyIdForPriorityTarget(class AController* Controller);
    void NotifyPhaseProgression(class ASBEnemyCharacter* Enemy, int32 PhaseNum);
    class UAITask* NewAITask(class AAIController* OwnerAI, TSubclassOf<class UAITask> TaskClass, uint8 InPriority);
    bool IsUnmovable(class ASBCharacter* Character);
    int32 GetEnemysWithTag(class UObject* WorldContextObject, FName Tag, TArray<class ASBEnemyCharacter*>& EnemyList);
    float GetAttackMaxRange(class ASBEnemyCharacter* Enemy, FName Command);
    FString ComplementEnemyId(FString InEnemyId);
}; // Size: 0x28

class USBEnemyBadZoneAvoidanceComponent : public UActorComponent
{
    bool bUseBadZoneAvoidance;                                                        // 0x00C8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00C9 (size: 0x7)
    TArray<FSBBadZoneAvoidanceAngle> BadZoneAvoidanceAngleArray;                      // 0x00D0 (size: 0x10)
    float BadZoneRotationRate;                                                        // 0x00E0 (size: 0x4)
    bool bShowBZADebug;                                                               // 0x00E4 (size: 0x1)
    char padding_1[0x3];                                                              // 0x00E5 (size: 0x3)
    float BZAArrowSize;                                                               // 0x00E8 (size: 0x4)
    float BZAAreaLength;                                                              // 0x00EC (size: 0x4)
    class UArrowComponent* BZAMovementArrow;                                          // 0x00F0 (size: 0x8)
    class UArrowComponent* BZACharacterArrow;                                         // 0x00F8 (size: 0x8)
    class UArrowComponent* BZAControllRotaionArrow;                                   // 0x0100 (size: 0x8)

}; // Size: 0x108

class USBEnemyBattleConditionComponent : public UActorComponent
{
    FSBEnemyBattleConditionComponentToNormalMode ToNormalMode;                        // 0x00C8 (size: 0x10)
    void ModeChangeSignature();
    FSBEnemyBattleConditionComponentToBattleMode ToBattleMode;                        // 0x00D8 (size: 0x10)
    void ModeChangeSignature();
    char padding_0[0x18];                                                             // 0x00E8 (size: 0x18)
    bool bIsBattleMode;                                                               // 0x0100 (size: 0x1)
    bool bIsInstantBattleTransition;                                                  // 0x0101 (size: 0x1)
    bool bResetBattleSequenceToNormal;                                                // 0x0102 (size: 0x1)

    void SetBattleMode(bool bInValue, bool bInstantTransition);
    void MulticastInitializeToNormal();
    void MulticastInitializeToBattle();
    void ModeChangeSignature__DelegateSignature();
}; // Size: 0x108

class USBEnemyBattleNormalBossComponent : public UActorComponent
{
    FSBEnemyBattleNormalBossComponentOnBattleStartDelegate OnBattleStartDelegate;     // 0x00B8 (size: 0x10)
    void OnBossBattleStartDelegate();
    FSBEnemyBattleNormalBossComponentOnBattleEndDelegate OnBattleEndDelegate;         // 0x00C8 (size: 0x10)
    void OnBossBattleEndDelegate();
    FName BossAreaTag;                                                                // 0x00D8 (size: 0x8)
    bool bLastBossArea;                                                               // 0x00E0 (size: 0x1)

    void SetCleared(bool sw);
    void SetBossAreaTag(FName AreaTag);
    void OnBossBattleStartDelegate__DelegateSignature();
    void OnBossBattleEndDelegate__DelegateSignature();
    bool IsStandby();
    bool IsLastBossArea();
    bool IsCleared();
    bool IsBattle();
    FName GetBossAreaTag();
    bool CheckMoveToBossAreaBattle();
}; // Size: 0xE8

class USBEnemyBattlePartComponent : public UActorComponent
{
    int32 InitPart;                                                                   // 0x00C0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00C4 (size: 0x4)
    TArray<FSBEnemyBattlePart> BattleParts;                                           // 0x00C8 (size: 0x10)
    TArray<FName> IgnoreActionNames;                                                  // 0x00D8 (size: 0x10)
    char padding_1[0x8];                                                              // 0x00E8 (size: 0x8)
    class USBEnemyBattlePartTransition* Transition;                                   // 0x00F0 (size: 0x8)

}; // Size: 0xF8

class USBEnemyBattlePartTransition : public UObject
{
    uint8 bNeedsToIdle;                                                               // 0x0028 (size: 0x1)
    uint8 bEnableTotalActionCount;                                                    // 0x0028 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0029 (size: 0x3)
    int32 TotalActionNum;                                                             // 0x002C (size: 0x4)

}; // Size: 0x88

class USBEnemyBlendSpaceInputComponent : public UActorComponent
{
    uint8 bIsEnableTurnInput;                                                         // 0x00E0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00E1 (size: 0x3)
    float DeltaTurn;                                                                  // 0x00E4 (size: 0x4)

    bool IsEnableTurnInput();
    bool IsEnableMovementInput();
}; // Size: 0xF0

class USBEnemyBuddyRevivalComponent : public UActorComponent
{
    int32 ResurrectionAttackID;                                                       // 0x00C8 (size: 0x4)
    float BuddyRevivalWaitTime;                                                       // 0x00CC (size: 0x4)
    bool bRevivalable;                                                                // 0x00D0 (size: 0x1)

}; // Size: 0xE8

class USBEnemyChantComponent : public USBCharacterChantBaseComponent
{
    TWeakObjectPtr<class USBEnemyChantMarkerManagerComponent> pMarkerManagerComponent; // 0x0258 (size: 0x8)

    void BeginChant();
}; // Size: 0x2C8

class USBEnemyChantMarkerManagerComponent : public USBEnemyMarkerManagerComponent
{
    TArray<FSBEnemyChantMarkerStruct> m_ChantMarkerList;                              // 0x0148 (size: 0x10)

}; // Size: 0x1B8

class USBEnemyCharacterAnimInstance : public USBCharacterAnimInstance
{
    TSoftObjectPtr<UASAnimationSet> AnimationSetEnemy;                                // 0x0FE0 (size: 0x28)
    float Speed;                                                                      // 0x1008 (size: 0x4)
    float Right;                                                                      // 0x100C (size: 0x4)
    FVector HipVector;                                                                // 0x1010 (size: 0xC)
    FName HipBone;                                                                    // 0x101C (size: 0x8)
    float AimBodyBlendRate;                                                           // 0x1024 (size: 0x4)
    float EnemyTempCounter;                                                           // 0x1028 (size: 0x4)
    FName PrevSnapshotName;                                                           // 0x102C (size: 0x8)

    class UASStateMachine* GetStateMachine();
    class UASAnimationSet* GetAnimationSet();
    class UASStateMachine* GetAimStateMachine();
}; // Size: 0x1050

class USBEnemyCharacterMovementComponent : public USBCharacterMovementComponent
{
    float MinGroundSpeed;                                                             // 0x0CB8 (size: 0x4)
    float MaxRunSpeed;                                                                // 0x0CBC (size: 0x4)
    float MaxDashSpeed;                                                               // 0x0CC0 (size: 0x4)
    bool bCanStrafe;                                                                  // 0x0CC4 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0CC5 (size: 0x3)
    FName NormalTurnCommand;                                                          // 0x0CC8 (size: 0x8)
    FName BattleTurnCommand;                                                          // 0x0CD0 (size: 0x8)
    char padding_1[0x38];                                                             // 0x0CD8 (size: 0x38)
    float StuckThresholdTime;                                                         // 0x0D10 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0D14 (size: 0x4)
    float FallingStackWarpTimerThreshold;                                             // 0x0D18 (size: 0x4)
    float FallingStuckWarpVelocityThreshold;                                          // 0x0D1C (size: 0x4)
    char padding_3[0x90];                                                             // 0x0D20 (size: 0x90)
    class USBEnemyBadZoneAvoidanceComponent* BadZoneAvoidanceComp;                    // 0x0DB0 (size: 0x8)
    bool bIsStrafing;                                                                 // 0x0DB8 (size: 0x1)
    bool bIsPerfromingRootMotion;                                                     // 0x0DB9 (size: 0x1)

    void StopRootMotionVelocityRotation();
    void StartRootMotionVelocityRotation(float PitchRate, float MaxPitch);
    void RequestUseControllerRotation(float NewRotationRate, float YawOffset, bool bLimitRotation, FRotator MinRotation, FRotator MaxRotation, bool bNoAffectRootMotionVelocity);
    void RequestOrientRotationToMovement();
    bool IsStuck();
    bool IsInTidalArea();
    void DebugDrawPath(const TArray<FVector>& PathPoints, float LifeTime);
}; // Size: 0xDC0

class USBEnemyCheatCommand : public UObject
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    void SwitchEnemyTacticalSkillDebugMode(int32 Mode);
    void SwitchEnemyTacticalSkillActivation(FString Command, bool bEnable);
    void SpawnEnemy(FString EnemyId, int32 Level);
    void SpawnBuddy(FString EnemyId, int32 Level);
    void ShowSpawnPointInHabitat(FString HabitatName);
    void ShowSpawnedEnemyNum();
    void ShowEnemyStateMachineTree(const FName& KeyName);
    void ShowEnemyStateMachineLog();
    void SetTargetEnemyAbility(int32 InAbilityID, int32 InTime);
    void SetIMapLayerValueRange(FString LayerName, float MinValue, float MaxValue);
    void SetEnemyRefreshBones(bool bEnable);
    void SetEnemyFieldSpawnRangeFromPlayer(float InRange);
    void SetEnemyFieldSpawnElavationHeightFromPlayer(float InHeight);
    void SetEnemyFieldSpawnElavationAngleFromPlayer(float InAngle);
    void SetEnemyAnimTickPoseAndBone(bool bEnable);
    void SetEnemyAnimationTick(bool bEnable);
    void SetEnemyAlwaysRefreshBones(bool bEnable);
    void ReviveAllBuddies();
    void PlayEnemyAnimation4(FString AnimationFilterName1, FString AnimationFilterName2, FString AnimationFilterName3, FString AnimationFilterName4, bool IsLoop, float PlaySpeed, FString AnimationSearchPath);
    void PlayEnemyAnimation3(FString AnimationFilterName1, FString AnimationFilterName2, FString AnimationFilterName3, bool IsLoop, float PlaySpeed, FString AnimationSearchPath);
    void PlayEnemyAnimation2(FString AnimationFilterName1, FString AnimationFilterName2, bool IsLoop, float PlaySpeed, FString AnimationSearchPath);
    void PlayEnemyAnimation(FString AnimationFilterName1, bool IsLoop, float PlaySpeed, FString AnimationSearchPath);
    void PauseEnemyBehavior();
    void OverrideEnemyDropRatio(ESBEnemyDropItemType DropItemType, float DropRatio);
    void OverrideEnemyBlackBoardVector(FString Key, float X, float Y, float Z);
    void OverrideEnemyBlackBoardString(FString Key, FString NewValue);
    void OverrideEnemyBlackBoardFloat(FString Key, float NewValue);
    void OverrideEnemyBlackBoardBool(FString Key, bool NewValue);
    void KillAllBuddies();
    void HideSpawnPointInHabitat();
    void GiveAllEnemyParalyze();
    class ASBEnemyCharacter* GetPlayerTargetingEnemy();
    void ForceShieldBreak();
    void ForceChangeFieldEnemyToSubmargedExit();
    void ForceActivateSpawnAction(FString InSpawnActionCommand);
    void EnemySendCommand(FName Command1, FName Command2, FName Command3, FName Command4);
    void EnemyPhaseProgress(int8 AddPhaseProgress);
    void EnemyInitAnim();
    void EnableEnemyActionViewer(FString EnemyId);
    void DumpEnemyStateMachineLog();
    void DisableEnemyActionViewer();
    void CheckServerLocationAnchor();
    void ActivateAction(FString ActivateActionCommand);
}; // Size: 0x30

class USBEnemyCollisionHitComponent : public UActorComponent
{
    char padding_0[0x120];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x120

class USBEnemyConditionalVoiceComponent : public UActorComponent
{
    FSBBossWeakConditionCheck BossWeakConditionCheck;                                 // 0x00D0 (size: 0xC)

}; // Size: 0xE0

class USBEnemyControlKeyAction_ActionCancelAbility : public USBPawnControlKeyAction
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBEnemyControlKeyAction_AnimCommand : public USBPawnControlKeyAction
{
    FSBEnemyCommandSelector PressCommand;                                             // 0x0038 (size: 0x18)
    FString PressCommandString;                                                       // 0x0050 (size: 0x10)
    FSBEnemyCommandSelector ReleaseCommand;                                           // 0x0060 (size: 0x18)
    FString ReleaseCommandString;                                                     // 0x0078 (size: 0x10)
    TArray<FName> PressCommandArray;                                                  // 0x0088 (size: 0x10)
    TArray<FName> ReleaseCommandArray;                                                // 0x0098 (size: 0x10)
    bool bProjectile;                                                                 // 0x00A8 (size: 0x1)

}; // Size: 0xB0

class USBEnemyControlKeyAction_MoveDown : public USBEnemyControlKeyAction_MoveUp
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBEnemyControlKeyAction_MoveUp : public USBPawnControlKeyAction
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBEnemyControlKeyAction_Strafe : public USBPawnControlKeyAction
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBEnemyControlSettings : public USBPawnControlSettings
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)

    void SetDamageBlock(float Rate);
    void ChangeControlledEnemy(FString EnemyId);
}; // Size: 0x50

class USBEnemyDeathEffectBase : public UObject
{
    bool bIsEnd;                                                                      // 0x0028 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0029 (size: 0x3)
    FName AttributeMaterialParamName;                                                 // 0x002C (size: 0x8)
    FName PreviousAttributeMaterialParamName;                                         // 0x0034 (size: 0x8)
    float AttributeMaterialStartValue;                                                // 0x003C (size: 0x4)
    float AttributeMaterialEndValue;                                                  // 0x0040 (size: 0x4)
    float PreviousAttributeMaterialStartValue;                                        // 0x0044 (size: 0x4)
    bool bActivateAttributeDeathEffect;                                               // 0x0048 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0049 (size: 0x3)
    float DeadCurveValue;                                                             // 0x004C (size: 0x4)

    void ReceiveTickVanish(float DeltaTime, class ASBEnemyCharacter* OwnerEnemyCharacter);
    void ReceiveTickFadeOut(float DeltaTime, class ASBEnemyCharacter* OwnerEnemyCharacter);
    void ReceiveTick(float DeltaTime, class ASBEnemyCharacter* OwnerEnemyCharacter);
    void ReceiveMaterialUpdated(EDeathEffectType DeathEffectType, class ASBEnemyCharacter* OwnerEnemyCharacter);
    void ReceiveBeginVanish(float WaitTime, class ASBEnemyCharacter* OwnerEnemyCharacter);
    void ReceiveBeginFadeOut(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void ReceiveBegin(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void PlayEffectActor(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void PlayEffect(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void PlayAkEvent(class ASBEnemyCharacter* OwnerEnemyCharacter);
    bool IsDemoPlayingOnClient(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void End();
}; // Size: 0x50

class USBEnemyDeathEffectComponent : public UActorComponent
{
    class UCurveFloat* FadeInCurve;                                                   // 0x00C8 (size: 0x8)
    TMap<class ESBAttribute, class FSBDeathEffectParams> DeathEffects;                // 0x00D0 (size: 0x50)
    TMap<class ESBAttribute, class FName> DeathMaterialParams;                        // 0x0120 (size: 0x50)
    TSubclassOf<class USBEnemyDeathEffectBase> DeathEffectBase;                       // 0x0170 (size: 0x8)
    bool bIsStartWithDeath;                                                           // 0x0178 (size: 0x1)
    bool bDeactivateParticleEffects;                                                  // 0x0179 (size: 0x1)
    char padding_0[0x2];                                                              // 0x017A (size: 0x2)
    float EffectDeactivateThreshold;                                                  // 0x017C (size: 0x4)
    char padding_1[0x8];                                                              // 0x0180 (size: 0x8)
    bool bIsRunning;                                                                  // 0x0188 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0189 (size: 0x7)
    TArray<TWeakObjectPtr<UMaterialInstanceDynamic>> DynamicMaterials;                // 0x0190 (size: 0x10)
    char padding_3[0x8];                                                              // 0x01A0 (size: 0x8)
    EDeathEffectType DeathEffectType;                                                 // 0x01A8 (size: 0x1)
    char padding_4[0x7];                                                              // 0x01A9 (size: 0x7)
    class USBEnemyDeathEffectBase* Effect;                                            // 0x01B0 (size: 0x8)
    class AActor* SpawnedEffectActor;                                                 // 0x01B8 (size: 0x8)
    ESBAttribute DeathElementType;                                                    // 0x01C0 (size: 0x1)
    ESBAttribute HighestLevelAttributeOnDeath;                                        // 0x01C1 (size: 0x1)

    bool StartVanish(float WaitTime);
    bool StartFadeOutEffect();
    bool StartDeathEffect();
    void SetIsStartWithDeath(bool bStartWithDeath);
    void SetDeathEffectClass(TSubclassOf<class USBEnemyDeathEffectBase> DeathEffectClass);
    void PlayRespawnEffect_Multicast(FVector TargetLocation);
    void PlayEffectActor();
    void PlayEffect();
    void PlayAkEvent();
    bool IsStartWithDeath();
    bool IsEffectDeactivate();
    EDeathEffectType GetDeathEffectType();
}; // Size: 0x1C8

class USBEnemyDebugActionPlayerComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)

    bool IsOverrideAttackableArea();
    bool IsBrokenAction();
    FString GetUpperAngle();
    FString GetRightAngle();
    FString GetMinRange();
    FString GetMaxRange();
    FString GetLowerAngle();
    FString GetLeftAngle();
    FString GetActionName();
}; // Size: 0xB8

class USBEnemyDebugLogStoreComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBEnemyDropComponent : public UActorComponent
{
    float ExpBonus;                                                                   // 0x00B8 (size: 0x4)
    FSBEnemyExpBonusScale ExpBonusScale;                                              // 0x00BC (size: 0x20)
    char padding_0[0x4];                                                              // 0x00DC (size: 0x4)
    TSubclassOf<class ASBTreasureSpot> DropTreasureClass;                             // 0x00E0 (size: 0x8)

    void MulticastDebugLog(const ESBEnemyDropLogType logType, const class ASBPlayerController* pPlayerController, const class ASBPlayerCharacter* pPlayerCharacter, const uint16 Value1, const uint16 Value2);
    void MulticastDebugHudPrint(FString STR, const class ASBPlayerCharacter* pPlayerCharacter);
}; // Size: 0x1A8

class USBEnemyDxBattleComponent : public UActorComponent
{
    FSBEnemyDxBattleComponentOnServerChangeFocusPlayerDelegete OnServerChangeFocusPlayerDelegete; // 0x00B8 (size: 0x10)
    void OnServerChangeFocusPlayerDelegete();
    char padding_0[0x8];                                                              // 0x00C8 (size: 0x8)
    class UDataTable* DxBattleTable;                                                  // 0x00D0 (size: 0x8)

    void OnServerChangeFocusPlayerDelegete__DelegateSignature();
    void OnEnemyTakeDamage(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    bool IsFocusPlayer();
    ESBEnemyWalkingMode GetGateWalkingMode();
}; // Size: 0xF0

class USBEnemyDxBattleNetCullingDamageComponent : public UActorComponent
{
    float EnemyDamageInterval;                                                        // 0x00B8 (size: 0x4)
    float BossEnemyDamage;                                                            // 0x00BC (size: 0x4)
    float SpecialEnemyDamage;                                                         // 0x00C0 (size: 0x4)
    float OtherEnemyDamage;                                                           // 0x00C4 (size: 0x4)
    int32 BossEnemyCount;                                                             // 0x00C8 (size: 0x4)
    int32 SpecialEnemyCount;                                                          // 0x00CC (size: 0x4)
    int32 OtherEnemyCount;                                                            // 0x00D0 (size: 0x4)
    int32 PlayerCount;                                                                // 0x00D4 (size: 0x4)

    void IncrementSpecialEnemyCount();
    void IncrementPlayerCount();
    void IncrementOtherEnemyCount();
    void IncrementBossEnemyCount();
    void DecrementSpecialEnemyCount();
    void DecrementPlayerCount();
    void DecrementOtherEnemyCount();
    void DecrementBossEnemyCount();
}; // Size: 0xE0

class USBEnemyEmotionComponent : public USBAIEmotionComponent
{
    char padding_0[0x140];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x140

class USBEnemyExChantComponent : public UActorComponent
{
    char padding_0[0x288];                                                            // 0x0000 (size: 0x0)

    void BeginChant();
}; // Size: 0x288

class USBEnemyExitEffectBase : public UObject
{
    bool bIsEnd;                                                                      // 0x0028 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0029 (size: 0x3)
    float ExitCurveValue;                                                             // 0x002C (size: 0x4)

    void ReceiveTick(float DeltaTime, class ASBEnemyCharacter* OwnerEnemyCharacter);
    void ReceiveMaterialUpdated(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void ReceiveBegin(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void PlayEffectActor(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void PlayEffect(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void PlayAkEvent(class ASBEnemyCharacter* OwnerEnemyCharacter);
    bool IsEnd();
    bool IsDemoPlayingOnClient(class ASBEnemyCharacter* OwnerEnemyCharacter);
    void End();
}; // Size: 0x30

class USBEnemyExitEffectComponent : public UActorComponent
{
    FSBExitEffectParams ExitEffect;                                                   // 0x00C8 (size: 0x48)
    TSubclassOf<class USBEnemyExitEffectBase> ExitEffectBase;                         // 0x0110 (size: 0x8)
    bool bDeactivateParticleEffects;                                                  // 0x0118 (size: 0x1)
    bool bIsRunning;                                                                  // 0x0119 (size: 0x1)
    char padding_0[0x6];                                                              // 0x011A (size: 0x6)
    class USBEnemyExitEffectBase* Effect;                                             // 0x0120 (size: 0x8)
    class AActor* SpawnedEffectActor;                                                 // 0x0128 (size: 0x8)

    void SetExitEffectClass(TSubclassOf<class USBEnemyExitEffectBase> ExitEffectClass);
    void PlayEffectActor();
    void PlayEffect();
    void PlayAkEvent();
}; // Size: 0x130

class USBEnemyFanShapeRenderingComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBEnemyFieldSpawnTideComponent : public UActorComponent
{
    FSBEnemyFieldSpawnTideComponentOnStartTideDelegate OnStartTideDelegate;           // 0x00C8 (size: 0x10)
    void OnStartTideDelegate(class USBEnemyFieldSpawnTideComponent* FieldSpawnTideComp);
    FSBEnemyFieldSpawnTideComponentOnTickTideDelegate OnTickTideDelegate;             // 0x00D8 (size: 0x10)
    void OnTickTideDelegate(class USBEnemyFieldSpawnTideComponent* FieldSpawnTideComp, float TideHeight);
    FSBEnemyFieldSpawnTideComponentOnFinishTideDelegate OnFinishTideDelegate;         // 0x00E8 (size: 0x10)
    void OnFinishTideDelegate(class USBEnemyFieldSpawnTideComponent* FieldSpawnTideComp);

    void OnTickTideDelegate__DelegateSignature(class USBEnemyFieldSpawnTideComponent* FieldSpawnTideComp, float TideHeight);
    void OnStartTideDelegate__DelegateSignature(class USBEnemyFieldSpawnTideComponent* FieldSpawnTideComp);
    void OnStartTide();
    void OnFinishTideDelegate__DelegateSignature(class USBEnemyFieldSpawnTideComponent* FieldSpawnTideComp);
    void OnFinishTide();
}; // Size: 0x110

class USBEnemyGuardComponent : public USBGuardComponent
{
    bool bIsInifinityShieldDurability;                                                // 0x0458 (size: 0x1)
    bool bInitializeCreatedShield;                                                    // 0x0459 (size: 0x1)
    bool bBarrierGuard;                                                               // 0x045A (size: 0x1)
    char padding_0[0x1];                                                              // 0x045B (size: 0x1)
    float MaxBarrierLifeTime;                                                         // 0x045C (size: 0x4)
    char padding_1[0x4];                                                              // 0x0460 (size: 0x4)
    float MaxBarrierRecoveryInterval;                                                 // 0x0464 (size: 0x4)
    char padding_2[0x8];                                                              // 0x0468 (size: 0x8)
    TArray<class TSubclassOf<USBAICustom_Base>> AICustoms;                            // 0x0470 (size: 0x10)
    TArray<FSBElementResistanceCorrectionSetting> GuardAttributeRegistanceCorrectSettings; // 0x0480 (size: 0x10)
    bool bCanPerceiveAttackGuard;                                                     // 0x0490 (size: 0x1)
    ESBPerceiveLevel PerceiveLevel;                                                   // 0x0491 (size: 0x1)

    void StartBarrier();
    void RequestServerDestroyCreatedShield();
    void RequestServerCreateShield(TSubclassOf<class ASBWeapon> AssetClass, TEnumAsByte<ESBWeaponAttach> WeaponAttach, FTransform Transform);
    void MulticastSetBarrier(bool bIsBarrierGuardActive, bool bPlayEndEffect);
    void MulticastDestroyCreatedShield();
    void MulticastCreateShield(UClass* AssetClass, TEnumAsByte<ESBWeaponAttach> WeaponAttach, FTransform Transform);
    void MulticastAddShieldDurability(const float AddDurability);
    class ASBWeapon* GetCreatedShield();
    bool CanBarrier();
}; // Size: 0x4B0

class USBEnemyHabitatRenderingComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBEnemyIntensiveAttackCheckerComponent : public UActorComponent
{
    FSBEnemyIntensiveAttackCheckerComponentOnBeginIntensiveAttackedDelegate OnBeginIntensiveAttackedDelegate; // 0x00B8 (size: 0x10)
    void BeginIntensiveAttackedDelegate();
    FSBEnemyIntensiveAttackCheckerComponentOnEndIntensiveAttackedDelegate OnEndIntensiveAttackedDelegate; // 0x00C8 (size: 0x10)
    void EndIntensiveAttackedDelegate();
    bool bActivateOnServer;                                                           // 0x00D8 (size: 0x1)
    bool bActivateOnClient;                                                           // 0x00D9 (size: 0x1)
    char padding_0[0x2];                                                              // 0x00DA (size: 0x2)
    float InfoKeepTime;                                                               // 0x00DC (size: 0x4)
    float MaxDistanceToStore;                                                         // 0x00E0 (size: 0x4)
    int32 ThresholdAttackedActorNum;                                                  // 0x00E4 (size: 0x4)

    void RegisterDamageInfo(class ASBEnemyCharacter* DamagedActor, float Damage, const FSBDamageEvent& DamageEvent, class AController* InstigatedBy, class AActor* DamageCauser);
    bool IsIntensiveAttacked();
    void EndIntensiveAttackedDelegate__DelegateSignature();
    void ClearAttackedActorInfo(uint32 TargetUniqueID);
    void BeginIntensiveAttackedDelegate__DelegateSignature();
}; // Size: 0x140

class USBEnemyManager : public UObject
{
    class UDataTable* EstimatePlayerRoleDataTable;                                    // 0x0028 (size: 0x8)
    float DeathLogDistance;                                                           // 0x0030 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0034 (size: 0x4)
    class UMaterialInstanceConstant* TransparentMaterial;                             // 0x0038 (size: 0x8)

    void OnMasterDataAvailableDelegate__DelegateSignature();
    void OnMasterDataAvailable();
}; // Size: 0x1D8

class USBEnemyMarkerManagerComponent : public UActorComponent
{
    TArray<FSBEnemyChantMarkerStruct> m_MarkerList;                                   // 0x00B8 (size: 0x10)
    TArray<FSBEnemyChantMarkerStruct> m_ParabolaMarkerList;                           // 0x00C8 (size: 0x10)
    TArray<FSBMarkerTargetInfo> TargetInfos;                                          // 0x00D8 (size: 0x10)

    void PostSpawnChantProjectileRPC_32bit(uint32 SerializedData);
    void PostSpawnChantProjectileRPC_16bit(uint16 SerializedData);
    void PostSpawnChantProjectileRPC(uint64 HandleUniqueID, uint8 NotifyID, bool bIsChantAction);
    void OnRep_TargetInfos();
}; // Size: 0x148

class USBEnemyMaterialManagerComponent : public UActorComponent
{
    TArray<FSBEnemyChangeableMaterialInfo> ChangeableMaterialInfoList;                // 0x00B8 (size: 0x10)
    TArray<FSBEnemyChangedMaterialInfo> ChangedMaterialInfoList;                      // 0x00C8 (size: 0x10)
    char padding_0[0x50];                                                             // 0x00D8 (size: 0x50)
    TArray<FSBMaterialVisibilityInfo> MaterialVisibilityList;                         // 0x0128 (size: 0x10)
    char padding_1[0x50];                                                             // 0x0138 (size: 0x50)
    TArray<FSBMaterialParamInfo> MaterialScalarParamList;                             // 0x0188 (size: 0x10)
    char padding_2[0x50];                                                             // 0x0198 (size: 0x50)
    TArray<FSBMaterialVectorParamInfo> MaterialVectorParamList;                       // 0x01E8 (size: 0x10)

    void SwitchMaterialVisibility(TArray<int32> TargetMaterials, bool bChangeToVisible);
    void OnRep_MaterialVisibilityList();
    void OnRep_MaterialVectorParamList();
    void OnRep_MaterialScalarParamList();
    void OnRep_ChangedMaterialInfoList();
}; // Size: 0x250

class USBEnemyModifierComponent : public UActorComponent
{
    class USBEnemyModifierTemplate_BlueprintBase* Sentinels;                          // 0x00B8 (size: 0x8)
    TMap<class FName, class FSBEnemyModifierRegisteredConfigInfo> ModifierMap;        // 0x00C0 (size: 0x50)
    char padding_0[0x50];                                                             // 0x0110 (size: 0x50)
    TArray<int8> ActiveModifierIds;                                                   // 0x0160 (size: 0x10)

    void MulticastDeactivateModifier(const int8 ModifierId);
    void MulticastActivateModifier(const int8 ModifierId);
    void DeactivateModifier(const FName ModifierName);
    void ActivateModifier(const FName ModifierName);
}; // Size: 0x170

class USBEnemyModifierTemplate_BlueprintBase : public UObject
{
    uint8 bEnableNeedTurn;                                                            // 0x0028 (size: 0x1)
    uint8 bEnableNeedStrafe;                                                          // 0x0028 (size: 0x1)
    uint8 bEnableVisibility;                                                          // 0x0028 (size: 0x1)
    uint8 bEnableOffTarget;                                                           // 0x0028 (size: 0x1)
    uint8 bEnableOffPushOut;                                                          // 0x0028 (size: 0x1)
    uint8 bEnableWalkSpeed;                                                           // 0x0028 (size: 0x1)
    uint8 bEnableRunSpeed;                                                            // 0x0028 (size: 0x1)
    uint8 bEnableDashSpeed;                                                           // 0x0028 (size: 0x1)
    uint8 bEnableRotationRate;                                                        // 0x0029 (size: 0x1)
    uint8 bEnableMovabilityType;                                                      // 0x0029 (size: 0x1)
    uint8 bEnableSetRecastTime;                                                       // 0x0029 (size: 0x1)
    uint8 bEnableAddStatusAilment;                                                    // 0x0029 (size: 0x1)
    uint8 bEnableRemoveStatusAilment;                                                 // 0x0029 (size: 0x1)
    uint8 bEnableAttributeRegistanceCorrection;                                       // 0x0029 (size: 0x1)
    uint8 bEnableAddAICustom;                                                         // 0x0029 (size: 0x1)
    uint8 bEnableRemoveAICustom;                                                      // 0x0029 (size: 0x1)
    uint8 bEnableActivatedTemporaryAICustom;                                          // 0x002A (size: 0x1)
    uint8 bEnableAIMessage;                                                           // 0x002A (size: 0x1)
    uint8 bEnableBehaviorTree;                                                        // 0x002A (size: 0x1)
    uint8 bEnableUtilityOptionWhenBegin;                                              // 0x002A (size: 0x1)
    uint8 bEnableUtilityOptionWhenEnd;                                                // 0x002A (size: 0x1)
    uint8 bEnableNoActionInhibitionStatus;                                            // 0x002A (size: 0x1)
    uint8 bNeedTurn;                                                                  // 0x002A (size: 0x1)
    uint8 bNeedStrafe;                                                                // 0x002A (size: 0x1)
    uint8 bVisibility;                                                                // 0x002B (size: 0x1)
    uint8 bOffTarget;                                                                 // 0x002B (size: 0x1)
    uint8 bOffPushOut;                                                                // 0x002B (size: 0x1)
    float WalkSpeed;                                                                  // 0x002C (size: 0x4)
    float RunSpeed;                                                                   // 0x0030 (size: 0x4)
    float DashSpeed;                                                                  // 0x0034 (size: 0x4)
    FRotator RotationRate;                                                            // 0x0038 (size: 0xC)
    EMovabilityType MovabilityType;                                                   // 0x0044 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0045 (size: 0x3)
    TMap<FName, float> RecastTimeParams;                                              // 0x0048 (size: 0x50)
    TArray<FDataTableRowHandle> AddStatusAilments;                                    // 0x0098 (size: 0x10)
    TArray<FDataTableRowHandle> RemoveStatusAilments;                                 // 0x00A8 (size: 0x10)
    TArray<FSBCollisionGroupResistanceCorrection> AttributeRegistanceCorrections;     // 0x00B8 (size: 0x10)
    TArray<class TSubclassOf<USBAICustom_Base>> AddAICustoms;                         // 0x00C8 (size: 0x10)
    TArray<class TSubclassOf<USBAICustom_Base>> RemoveAICustoms;                      // 0x00D8 (size: 0x10)
    TArray<class TSubclassOf<USBAICustom_Base>> ActivatedTemporaryAICustoms;          // 0x00E8 (size: 0x10)
    TArray<FName> AIMessages;                                                         // 0x00F8 (size: 0x10)
    class UBehaviorTree* BehaviorTree;                                                // 0x0108 (size: 0x8)
    TArray<class USBUtilityOption*> UtilityOptionsWhenBegin;                          // 0x0110 (size: 0x10)
    TArray<class USBUtilityOption*> UtilityOptionsWhenEnd;                            // 0x0120 (size: 0x10)
    uint8 bNoActionInhibitionStatus;                                                  // 0x0130 (size: 0x1)

}; // Size: 0x1D8

class USBEnemyNamePlateWidget : public USBNamePlateWidget
{
    TWeakObjectPtr<class ASBEnemyCharacter> EnemyCharacter;                           // 0x0288 (size: 0x8)
    class UImage* HPPrev;                                                             // 0x0290 (size: 0x8)
    class UWidgetSwitcher* WSBar;                                                     // 0x0298 (size: 0x8)
    class UWidgetSwitcher* WSLine;                                                    // 0x02A0 (size: 0x8)
    class UWidgetSwitcher* WSIcon;                                                    // 0x02A8 (size: 0x8)
    class UUserWidget* PartyIcon;                                                     // 0x02B0 (size: 0x8)
    class UUserWidget* HateAlertIcon;                                                 // 0x02B8 (size: 0x8)
    class USBP020_MarkEnemy* P020_MarkEnemy;                                          // 0x02C0 (size: 0x8)
    class USBBurstBonusGaugeWidget* BurstBonusGauge;                                  // 0x02C8 (size: 0x8)
    class USBEGaugeWidget* EGauge;                                                    // 0x02D0 (size: 0x8)
    class UCanvasPanelSlot* HPPrevSlot;                                               // 0x02D8 (size: 0x8)
    class UCanvasPanelSlot* HPSlot;                                                   // 0x02E0 (size: 0x8)
    bool LerpHpRate;                                                                  // 0x02E8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x02E9 (size: 0x3)
    float CurHpRate;                                                                  // 0x02EC (size: 0x4)
    float PrevHpRate;                                                                 // 0x02F0 (size: 0x4)
    float ItplSpeed;                                                                  // 0x02F4 (size: 0x4)
    FVector2D SlotSizeXY;                                                             // 0x02F8 (size: 0x8)
    bool IsBurstBonus;                                                                // 0x0300 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0301 (size: 0x7)
    class UDataTable* P020_StatusAlimentConfigDataTable;                              // 0x0308 (size: 0x8)

    void UpdateHPSize(float InHPRate);
    void UpdateHPPrevSize(float InHPRate);
    void SetupEGauge();
    void ResetEGauge();
}; // Size: 0x310

class USBEnemyPartsManagerComponent : public UActorComponent
{
    FSBEnemyPartsManagerComponentOnPartsBrokenMulticastDelegate OnPartsBrokenMulticastDelegate; // 0x00B8 (size: 0x10)
    void PartsBrokenMulticastDelegate(FName BrokenCollisionGroupName, int32 StepId);
    char padding_0[0x28];                                                             // 0x00C8 (size: 0x28)
    TArray<FSBEnemyPartsBreakInfo> PartsBreakInfo;                                    // 0x00F0 (size: 0x10)
    TArray<FSBEnemyCompoundPartsBreakInfo> CompoundPartsBreakInfos;                   // 0x0100 (size: 0x10)
    char padding_1[0x50];                                                             // 0x0110 (size: 0x50)
    TMap<class FName, class FSBEnemyPartsCollisionStates> DamageCollisionStates;      // 0x0160 (size: 0x50)
    TMap<class FName, class FSBEnemyPartsCollisionStates> PartsCollisionStates;       // 0x01B0 (size: 0x50)
    TArray<class UActorComponent*> CachedPartsCollision;                              // 0x0200 (size: 0x10)
    TMap<class FName, class FSBEnemyPartsTargetableState> TargetableStates;           // 0x0210 (size: 0x50)

    void SetPartsStep(FName TargetCollsionGroupName, int32 InputStep, bool bSetHpStepMax, bool bAppearEffect);
    void SetPartsHP(FName TargetCollsionGroupName, float InputHpRate);
    void ResetAllPartsBreakCount();
    void PartsBrokenMulticastDelegate__DelegateSignature(FName BrokenCollisionGroupName, int32 StepId);
    void NetmulticastPartsRepair(int32 TargetCollsionGroupId, int32 NewStep, int32 PreviousStep);
    void NetmulticastPartsBroken(int32 BrokenCollsionGroupId, int32 NewStep, int32 PreviousStep, bool bAppearEffect);
    bool IsDelayBrokenParts(FName TargetCollsionGroupName);
    void FullHealAllParts();
    int32 CountBrokenParts();
    void AddPartsHP(FName TargetCollsionGroupName, float AddHpRate);
}; // Size: 0x260

class USBEnemyPathFollowingComponent : public UPathFollowingComponent
{
    class AActor* GoalVelocityActor;                                                  // 0x0280 (size: 0x8)

    void OnMovementModeChanged(class ACharacter* Character, TEnumAsByte<EMovementMode> PreviousMovementMode, uint8 PreviousCustomMode);
}; // Size: 0x290

class USBEnemyPerformanceLogger : public UObject
{
    bool bEnablePerformanceOutput;                                                    // 0x0038 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0039 (size: 0x3)
    float PerformanceOutputInterval;                                                  // 0x003C (size: 0x4)
    float DataTransferOutputInterval;                                                 // 0x0040 (size: 0x4)

}; // Size: 0x58

class USBEnemyPhaseComponent : public UActorComponent
{
    TArray<class TSubclassOf<USBEnemyPhase_Base>> PhaseRegister;                      // 0x00B8 (size: 0x10)
    int8 CurrentPhaseIndex;                                                           // 0x00C8 (size: 0x1)

    void SetPhaseControlIndex(int32 Index);
    void OnRep_BeginTask();
    bool IsFinalPhase();
    bool IsChanged(TSubclassOf<class USBEnemyPhase_Base> PhaseClass);
    int32 GetCurrentPhase();
    void AddMinion(class ASBCharacter* Minion);
}; // Size: 0xE8

class USBEnemyPhase_Base : public UObject
{
    bool bCheckIdle;                                                                  // 0x0028 (size: 0x1)
    bool bCheckMinionsDead;                                                           // 0x0029 (size: 0x1)
    bool bCheckNoBurstBonus;                                                          // 0x002A (size: 0x1)
    char padding_0[0x1];                                                              // 0x002B (size: 0x1)
    float HitPointRate;                                                               // 0x002C (size: 0x4)
    bool bSkippablePhase;                                                             // 0x0030 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0031 (size: 0x3)
    int32 PhaseControlIndex;                                                          // 0x0034 (size: 0x4)
    char padding_2[0x10];                                                             // 0x0038 (size: 0x10)
    TArray<FName> ActivateModifierNames;                                              // 0x0048 (size: 0x10)

    void SetPhaseChangeExpression(FSBEnemyPhaseChangeRuleExpression Expression);
    FSBEnemyPhaseChangeRuleExpression PhaseChangeRule_SelectValue(ESBEnemyPhaseChangeRuleType Type);
    FSBEnemyPhaseChangeRuleExpression PhaseChangeRule_OperatorOr(TArray<FSBEnemyPhaseChangeRuleExpression> Expressions);
    FSBEnemyPhaseChangeRuleExpression PhaseChangeRule_OperatorAnd(TArray<FSBEnemyPhaseChangeRuleExpression> Expressions);
    bool CompareHitPointRate(const class ASBEnemyCharacter* OwnerEnemyCharacter);
}; // Size: 0x58

class USBEnemyPhase_BlueprintBase : public USBEnemyPhase_Base
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)

    void ReceiveTick(float DeltaTime, class ASBEnemyCharacter* OwnerEnemyCharacter, const class USBEnemyPhaseComponent* OwnerComp);
    void ReceiveInitialize();
    bool ReceiveCheckPhaseChangeRule(class ASBEnemyCharacter* OwnerEnemyCharacter, const class USBEnemyPhaseComponent* OwnerComp);
    void ReceiveBegin(class ASBEnemyCharacter* OwnerEnemyCharacter, const class USBEnemyPhaseComponent* OwnerComp);
}; // Size: 0x58

class USBEnemyProjectSettings : public UObject
{
    FSoftObjectPath EnemyWaveTreeName;                                                // 0x0028 (size: 0x18)

}; // Size: 0x40

class USBEnemySABComponent : public UActorComponent
{
    char padding_0[0xC0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC0

class USBEnemySceneComponent : public UCapsuleComponent
{
    EMovabilityType MovabilityType;                                                   // 0x0488 (size: 0x1)

}; // Size: 0x490

class USBEnemySenseChangerComponent : public UActorComponent
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC8

class USBEnemySenserSetting : public UDataAsset
{
    FSBSenserData DefaultSensers;                                                     // 0x0030 (size: 0x10)
    TMap<class ESBLocationType, class FSBSenserData> SenserOnLocation;                // 0x0040 (size: 0x50)

}; // Size: 0x90

class USBEnemySetAsset : public UObject
{
    TArray<FSBEnemySetData> EnemySets;                                                // 0x0028 (size: 0x10)

}; // Size: 0x38

class USBEnemySkeletalMeshComponent : public USBCharaPartsBodyComponent
{
    float SubspeciesScaleRate;                                                        // 0x0F90 (size: 0x4)
    bool bDisableServerRefreshBones;                                                  // 0x0F94 (size: 0x1)

}; // Size: 0xFA0

class USBEnemySpawnSystemComponent : public UActorComponent
{
    TArray<class AActor*> SpawnedActors;                                              // 0x00E0 (size: 0x10)
    class ASBEnemySpawner* Spawner;                                                   // 0x00F0 (size: 0x8)

    void NotifyActorDestroyed(class AActor* Actor);
    int32 GetSpawnedActorsNum();
}; // Size: 0x140

class USBEnemySpecializerComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBEnemyStanceComponent : public UActorComponent
{
    int32 CurrentStance;                                                              // 0x00C0 (size: 0x4)
    char padding_0[0x10];                                                             // 0x00C4 (size: 0x10)
    FName InitStanceName;                                                             // 0x00D4 (size: 0x8)
    char padding_1[0x4];                                                              // 0x00DC (size: 0x4)
    TArray<FSBEnemyStanceSetting> StanceSettings;                                     // 0x00E0 (size: 0x10)

    FName GetCurrentStanceName();
}; // Size: 0xF0

class USBEnemyStateMachineReplayComponent : public UActorComponent
{
    uint8 LastChangedStateCounter;                                                    // 0x00C8 (size: 0x1)

    void OnRep_StateChange();
}; // Size: 0xD0

class USBEnemyStateManagerComponent : public UActorComponent
{
    char padding_0[0x130];                                                            // 0x0000 (size: 0x0)

    bool IsReadyForAction();
}; // Size: 0x130

class USBEnemySummonComponent : public USBEnemySpawnSystemComponent
{
    TArray<FSBEnemySummonInfo> SummonList;                                            // 0x0140 (size: 0x10)
    bool bSummonImagine;                                                              // 0x0150 (size: 0x1)
    bool bAvatar;                                                                     // 0x0151 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0152 (size: 0x6)
    class USBSquadMemberComponent* SquadMemberComponent;                              // 0x0158 (size: 0x8)

    bool ReserveNextSummonSlot(int32 SummonNum);
    void OnCharacterDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
}; // Size: 0x160

class USBEnemySwitchWeaponAttachmentComponent : public UActorComponent
{
    TArray<int32> NotifyTargetWeaponIndex;                                            // 0x00C0 (size: 0x10)

    void SetUnsheatheAttach(const int32 WeaponIndex);
    void SetSheatheAttach(const int32 WeaponIndex);
}; // Size: 0xD0

class USBEnemyTakeDamageCounterComponent : public UActorComponent
{
    TMap<FName, int32> LinkAttackIDToNameMap;                                         // 0x0118 (size: 0x50)

    void OnExecuteEventRegisterDelegate__DelegateSignature(int32 AttackID, int32 Count);
    void AddNewEvent(FAddNewEventDelegate Delegate, FName AttackIDName, int32 TriggerCount);
}; // Size: 0x168

class USBEnemyTakeDamageEffectComponent : public UActorComponent
{
    TMap<FName, int32> LinkAttackIDToNameMap;                                         // 0x00C8 (size: 0x50)

    void AddNewEvent(FName AttackIDName, class UParticleSystem* Particle, int32 LimitCount);
}; // Size: 0x118

class USBEnemyTargetingComponent : public UActorComponent
{
    FSBEnemyMultiTargetInfo ProjectileMultiTargetInfo;                                // 0x00D8 (size: 0x10)
    FSBEnemyMultiTargetInfo AdjustRootMotionMultiTargetInfo;                          // 0x00E8 (size: 0x10)
    char padding_0[0x10];                                                             // 0x00F8 (size: 0x10)
    bool bIsTargetingUnderFoot;                                                       // 0x0108 (size: 0x1)

    void SetUseCachedTarget(bool Flag);
    void SetTargetInfoAsVector(const FVector& TargetLocation, ESBEnemyTargetType Type, int32 Index);
    void SetTargetInfoAsActor(const class AActor* TargetActor, ESBEnemyTargetType Type, int32 Index);
    void SetMultiTargetInfo(const TArray<FSBEnemyTargetInfo>& MultiTargetInfo, ESBEnemyTargetType Type);
    bool IsValidTargetLocation(ESBEnemyTargetType Type, int32 Index);
    bool IsValidIndex(ESBEnemyTargetType Type, int32 Index);
    bool GetTargetLocationByIndex(FVector& OutTargetLocation, ESBEnemyTargetType Type, int32 Index);
    class AActor* GetTargetActorByIndex(ESBEnemyTargetType Type, int32 Index);
    TArray<FSBEnemyTargetInfo> GetMultiTargetInfo(ESBEnemyTargetType Type);
    void ClearTargetInfo(ESBEnemyTargetType Type);
    void AddTargetInfoAsVector(const FVector& TargetLocation, ESBEnemyTargetType Type);
    void AddTargetInfoAsActor(const class AActor* TargetActor, ESBEnemyTargetType Type);
    void AddTargetInfo(const FSBEnemyTargetInfo& MultiTargetInfo, ESBEnemyTargetType Type);
}; // Size: 0x138

class USBEnemyTideComponent : public UActorComponent
{
    bool bDisableSubmargedExit;                                                       // 0x00C8 (size: 0x1)
    char padding_0[0x2];                                                              // 0x00C9 (size: 0x2)
    bool bSubmargedExit;                                                              // 0x00CB (size: 0x1)

    void OnTickTide(class USBEnemyFieldSpawnTideComponent* InFieldSpawnTideComp, float TideHeight);
    void OnStartTide(class USBEnemyFieldSpawnTideComponent* InFieldSpawnTideComp);
    void OnRep_SetSubmargedExit();
    void OnFinishTide(class USBEnemyFieldSpawnTideComponent* InFieldSpawnTideComp);
    bool IsSubmargedExit();
}; // Size: 0xD0

class USBEnemyUROManagerComponent : public UActorComponent
{
    FName AnimTagName;                                                                // 0x00C8 (size: 0x8)
    TArray<float> OverrideBaseVisibleDistanceFactorThresholds;                        // 0x00D0 (size: 0x10)

}; // Size: 0xF8

class USBEnemyWaveSettingsAsset : public UObject
{
    TArray<FSBEnemyWaveData> EnemyWaves;                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

class USBErrorProc : public UObject
{
    class USBDialog* MessageDialog;                                                   // 0x0030 (size: 0x8)

    void OnMessageFinished(const EDialogResult InResult);
}; // Size: 0x50

class USBEventCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void StartScriptByTrigger(const FName& InTrigger, const bool bIsForce);
    void SearchUserFlagFromAllScriptAssets();
    void ScriptExecutor();
    void PlayTheater(const FName& InDemoId);
    void OpenOffDemoLevel(const FName& ContentId, FString GameModeId);
    void LevelScriptList();
    void ExecScriptCommand(FString InCode);
}; // Size: 0x28

class USBEventExecutor : public UObject
{
    TMap<class FName, class FSBEventExecutorItems> EventReceiverListMap;              // 0x0028 (size: 0x50)
    TSet<FName> SuspendEventNameSet;                                                  // 0x0078 (size: 0x50)
    TArray<FSBEventExecutorSuspendedEventItem> SuspendedEventItemList;                // 0x00C8 (size: 0x10)

    void RemoveReceiverAll(class UObject* Receiver, bool bStrict);
    void RemoveReceiver(FName EventName, class UObject* Receiver, bool bStrict);
    void RemoveInvalidReceiver();
    void ExecuteEventStringParam(FName EventName, class UObject* Sender, FString Param, ESBEventExecutorOption Option);
    void ExecuteEventIntParam(FName EventName, class UObject* Sender, int32 Param, ESBEventExecutorOption Option);
    void ExecuteEventBoolParam(FName EventName, class UObject* Sender, bool bParam, ESBEventExecutorOption Option);
    void ExecuteEvent(FName EventName, class UObject* Sender, class UObject* Param, ESBEventExecutorOption Option);
    void AddReceiver(FName EventName, class UObject* Receiver, FAddReceiverDelegate Delegate);
}; // Size: 0xD8

class USBEventParamAdventureBoardClear : public UObject
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    ESBAdventureBoardClearStatus GetStatus();
}; // Size: 0x30

class USBEventSceneBPFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBShowYesNoDialog2Impl* ShowYesNoDialog2(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, FName TextTableName, const FSBTextTableHash TextId, const FText Message, class UUserWidget* InParentWidget, TEnumAsByte<EUIZOrder::Type> InZOrder, EDialogPositionType PosType, EDialogResult OkOperation, EDialogResult CancelOperation, bool bEnableBgBlur);
    class USBDialog* ShowYesNoDialog(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, FName TextTableName, const FSBTextTableHash TextId, const FText Message, FShowYesNoDialogEndDelegate EndDelegate, class UUserWidget* InParentWidget, TEnumAsByte<EUIZOrder::Type> InZOrder, EDialogPositionType PosType, EDialogResult OkOperation, EDialogResult CancelOperation, bool bEnableBgBlur);
    void ShowMessageDialog(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, FName TextTableName, const FSBTextTableHash TextId, const FText Message, class UUserWidget* InParentWidget, TEnumAsByte<EUIZOrder::Type> InZOrder, EDialogPositionType PosType, EDialogResult OkOperation, EDialogResult CancelOperation, bool bEnableBgBlur);
    FString GetSpeakerName(class UObject* WorldContextObject, const FName InSpeakerId);
    FSBCharacterProfileLocationData FindCharacterProfileLocationData(const FName& InName, bool& bOutExist);
    FSBCharacterProfileData FindCharacterProfileData(const FName& InName, bool& bOutExist);
}; // Size: 0x28

class USBEventScheduler : public UObject
{
    TArray<FSBEventTermsChecker> EventTermsList;                                      // 0x0050 (size: 0x10)

    void OnMasterDataAvailable();
    bool IsDebugSchedulerDateTimeDraw();
    bool GetStartTime(FDateTime& OutStartTime, FString TermId);
    FDateTime GetNowDate();
    bool GetMasterDataBP(FSBEventTermsMasterData& OutMaster, FString TermId);
    bool GetEventTermNextOffLabelDataTimeToNowTime(FString InTermId, FDateTime& OutEndTime);
    bool GetEventTermNextOffLabelDataTime(FString TermId, FDateTime& OutEndTime, const FDateTime& InDateTime);
    bool GetEndTime(FDateTime& OutEndTime, FString TermId);
    bool GetCheckerBP(FSBEventTermsChecker& OutChecker, FString TermId);
}; // Size: 0x68

class USBEventShopComponent : public UActorComponent
{
    FSBEventShopComponentOnGetExchangeHistoryDelegate OnGetExchangeHistoryDelegate;   // 0x00B8 (size: 0x10)
    void OnGetExchangeHistoryDelegate(const bool Result, const int32 RetCode, const TArray<FSBEventShopExchangeHistory>& History);
    FSBEventShopComponentOnExchangeItemRemakeDelegate OnExchangeItemRemakeDelegate;   // 0x00C8 (size: 0x10)
    void OnExchangeItemRemakeDelegate(const bool Result, const int32 RetCode);

    void UpdateTacticalAbilityMasteryInfo(const TArray<FSBSkillParam>& SkillParamList);
    void SortProductList(EShopType ShopType, int32 SortId, const TArray<FSBEventShopProduct>& InProductList, TArray<FSBEventShopProduct>& OutProductList);
    void Server_OnExchangeItemRemake(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems, const TArray<FSBCharacterToken>& InTokenList, const TArray<FSBCharacterToken>& InAddTokenList);
    void Server_GetExchangeHistory();
    void Server_ExchangeItemRemake(int32 InShopId, const TArray<FSBEventShopPurchaseItemInfo>& InPurchaseList, const bool IsBag);
    void Request_GetExchangeHistory();
    void Request_ExchangeItemRemake(int32 InShopId, TArray<FSBEventShopPurchaseItemInfo> InPurchaseList, bool IsBag);
    void OnGetExchangeHistoryDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FSBEventShopExchangeHistory>& History);
    void OnExchangeItemRemakeDelegate__DelegateSignature(const bool Result, const int32 RetCode);
    void Client_GetExchangeHistory(const bool bInWasSuccessful, const int32 InRetCode, const TArray<FSBEventShopExchangeHistory>& InHistory);
    void Client_ExchangeItemRemake(bool bInWasSuccessful, const int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems, const TArray<FSBCharacterToken>& InTokenList, const TArray<FSBCharacterToken>& InAddTokenList, const TArray<int32>& InAddAdvCardCustomParts, const bool InOpenCommandMenuFlag, const int32 InRemainMoney);
}; // Size: 0xD8

class USBEventSuspend : public UObject
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    bool IsSuspend();
}; // Size: 0x30

class USBEventTriggerDatabase : public UObject
{
    TArray<class UDataTable*> EventTriggers;                                          // 0x0028 (size: 0x10)

    FSBEventTrigger BP_Find(const FName InScriptId, bool& bOutExist);
}; // Size: 0x38

class USBEventTriggerDebugMenu : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void SetScenarioFlag(const FName& InFlagName, const bool bInValue);
    void SetQuestStep(const FName& InQuestLongName, const FName& InStepId);
    void SetQuestStatus(const FName& InQuestLongName, const EQuestStatus InStatus);
}; // Size: 0x278

class USBExchangeItemComponent : public UActorComponent
{
    FSBExchangeItemComponentOnExchangeItemDelegate OnExchangeItemDelegate;            // 0x00B8 (size: 0x10)
    void OnExchangeItemDelegate(bool Result);

    void Server_OnExchangeItem(int32 InRetCode, const int32 InRetBravePoint, const TArray<FSBExchangeItemLogInfo>& InRetExchangeLogs, const TArray<FOwnItemInfo>& InRetItems);
    void Server_ExchangeItem(FString InExchangeShopId, const TArray<FExchangeShopExchangingItemInfo>& InExchangingItems);
    void Request_ExchangeItem(FString InExchangeShopId, const TArray<FExchangeShopExchangingItemInfo>& InExchangingItems);
    void OnExchangeItemDelegate__DelegateSignature(bool Result);
    void Client_ExchangeItem(int32 InRetCode, const int32 InRetBravePoint, const TArray<FSBExchangeItemLogInfo>& InRetExchangeLogs, const TArray<FOwnItemInfo>& InRetItems);
}; // Size: 0xC8

class USBExchangeItemLogList : public UObject
{
    TArray<FSBExchangeItemLogInfo> ExchangeLogs;                                      // 0x0028 (size: 0x10)

    void UpdateLog(const int32 InLogId, const FSBExchangeItemLogInfo& InLog);
    FSBExchangeItemLogInfo GetLogByLogId(const int32 InLogId, bool& bOutExist);
    int32 FindLog(const FString InShopId, const int32 InProductId, const int32 InItemID);
    int32 AddLog(const FSBExchangeItemLogInfo& InLog);
}; // Size: 0x38

class USBExecDelegateWithConditionComponent : public UActorComponent
{
    char padding_0[0x108];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x108

class USBExplosionComponent : public USceneComponent
{
    bool bExplosion;                                                                  // 0x0208 (size: 0x1)
    bool bDebugDraw;                                                                  // 0x0209 (size: 0x1)
    char padding_0[0x6];                                                              // 0x020A (size: 0x6)
    FSBExplosionParams Params;                                                        // 0x0210 (size: 0x38)
    class UAkAudioEvent* ExposionAudio;                                               // 0x0248 (size: 0x8)

    void GetExplosionCollision(FProjectileDynamicCollision& ExtendCollision);
    void ExecExplosion(class AController* EventInstigator, class AActor* DamageCauser);
}; // Size: 0x250

class USBFacialAnimInstance : public UASAnimInstance
{
    class UAnimSequenceBase* FacialAnimation;                                         // 0x0468 (size: 0x8)
    float LipSyncTime;                                                                // 0x0470 (size: 0x4)
    float EyeBlinkTime;                                                               // 0x0474 (size: 0x4)
    class USBFacialAnimationDataHolder* FacialAnimationDataHolder;                    // 0x0478 (size: 0x8)
    TArray<class UBlendSpace1D*> BS_EyeMoveUD;                                        // 0x0480 (size: 0x10)
    TArray<class UBlendSpace1D*> BS_EyeMoveLR;                                        // 0x0490 (size: 0x10)
    float EyeMoveLookAtLimitUD;                                                       // 0x04A0 (size: 0x4)
    float EyeMoveLookAtLimitLR;                                                       // 0x04A4 (size: 0x4)
    bool bEnableCCVBlendSpace;                                                        // 0x04A8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x04A9 (size: 0x7)
    class UPoseAsset* PoseAssetMouth;                                                 // 0x04B0 (size: 0x8)
    class UPoseAsset* PoseAssetBrow;                                                  // 0x04B8 (size: 0x8)
    class UPoseAsset* PoseAssetEye;                                                   // 0x04C0 (size: 0x8)
    class UPoseAsset* PoseAssetAdj;                                                   // 0x04C8 (size: 0x8)
    class UPoseAsset* PoseAssetEyelid;                                                // 0x04D0 (size: 0x8)
    class UBlendSpace1D* BlendSpaceEyeMoveUD;                                         // 0x04D8 (size: 0x8)
    class UBlendSpace1D* BlendSpaceEyeMoveLR;                                         // 0x04E0 (size: 0x8)
    float EyeMoveUD;                                                                  // 0x04E8 (size: 0x4)
    float EyeMoveLR;                                                                  // 0x04EC (size: 0x4)
    float EyeMoveUDCustomOffset;                                                      // 0x04F0 (size: 0x4)
    float EyeMoveLRCustomOffset;                                                      // 0x04F4 (size: 0x4)
    float EyeAnimChange;                                                              // 0x04F8 (size: 0x4)
    float TiltModifyFaceUD;                                                           // 0x04FC (size: 0x4)
    float TiltModifyFaceLR;                                                           // 0x0500 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0504 (size: 0x4)
    FRuntimeFloatCurve DeformFaceCurveDataUD;                                         // 0x0508 (size: 0x88)
    FRuntimeFloatCurve DeformFaceCurveDataLR;                                         // 0x0590 (size: 0x88)
    TArray<class UBlendSpace1D*> CCVBlendSpaceArray;                                  // 0x0618 (size: 0x10)
    TArray<class UAnimSequence*> CCVAnimSequenceArray;                                // 0x0628 (size: 0x10)

    void UpdateFacialAnimation(class UASAnimationSet* AnimationSet);
    void UpdateCCVBlendSpace(bool bInitialize, bool bDestroy);
}; // Size: 0x640

class USBFacialAnimationDataHolder : public USBAssetDataHolder
{
    class UDataAsset* AnimationSet;                                                   // 0x0188 (size: 0x8)
    class UPoseAsset* PoseAssetEye;                                                   // 0x0190 (size: 0x8)
    class UPoseAsset* PoseAssetBrow;                                                  // 0x0198 (size: 0x8)
    class UPoseAsset* PoseAssetMouth;                                                 // 0x01A0 (size: 0x8)
    class UPoseAsset* PoseAssetAdj;                                                   // 0x01A8 (size: 0x8)
    class UPoseAsset* PoseAssetEyelid;                                                // 0x01B0 (size: 0x8)
    class UPoseAsset* PoseAssetDfm;                                                   // 0x01B8 (size: 0x8)
    class UBlendSpace* TiltPanBlendSpace;                                             // 0x01C0 (size: 0x8)
    float TuriE;                                                                      // 0x01C8 (size: 0x4)
    float TareE;                                                                      // 0x01CC (size: 0x4)
    float TuriB;                                                                      // 0x01D0 (size: 0x4)
    float TareB;                                                                      // 0x01D4 (size: 0x4)
    bool bIsValidFacialPoseAssetDfm;                                                  // 0x01D8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x01D9 (size: 0x3)
    FRotator EyeLRotate;                                                              // 0x01DC (size: 0xC)
    FRotator EyeRRotate;                                                              // 0x01E8 (size: 0xC)
    FRotator EyebrowLRotate;                                                          // 0x01F4 (size: 0xC)
    FRotator EyebrowRRotate;                                                          // 0x0200 (size: 0xC)

}; // Size: 0x210

class USBFacilityIconStatusFunctionLibrary : public USBFieldStatusFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    EFacilityIconStatus EvaluateFacilityIconStatus(class UObject* InWorldContextObject, const FSBFacilityIconStatusSetting& InSetting);
    bool CheckFacilityIconStatusCondition(class UObject* InWorldContextObject, const FSBFacilityIconStatusConditionSetting& InConditionSetting);
}; // Size: 0x28

class USBFactionInfluenceSourceComponent : public USBInfluenceSourceComponent
{
    float InfluenceArea;                                                              // 0x00D8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00DC (size: 0x4)
    class UAIFwFactionComponent* FactionComponent;                                    // 0x00E0 (size: 0x8)

    void OnCharacterTakeDamage(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
    void OnCharacterDead(float Damage, const FSBDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* Myself);
}; // Size: 0xE8

class USBFang_ExpreditonLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetExpreditonIconPosition(class UUserWidget* Widget, FVector2D Position);
    void NeedExpeditionUseCheckDialog(class UObject* InWorldContextObject, TArray<FString> UniqueIds, bool& NeedDialog);
    void NeedCheckExpeditionUpdateSingle(FSBFang_expeditionPlayData& ExpeditionData, bool& NeedUpdate);
    void NeedCheckExpeditionUpdate(FSBFang_expeditionData& ExpeditionData, bool& NeedUpdate);
    void GetExpreditonRewardData(class ASBPlayerController* InPlayerController, FSBMailRewardData& RewardData);
    void GetExpreditonPlayingStatus(class ASBPlayerController* PlayerController, FString ID, int32 Category, TArray<int32>& PlayIconList, bool& IsNewMark, bool& IsTimeIcon);
    void GetExpreditonFangTypeCount(class UObject* InWorldContextObject, TArray<FString> UniqueIds, int32& OutCount);
    void GetExpreditonFangStorage(class UObject* InWorldContextObject, class USBTemporallyStorage*& Storage);
    void GetExpreditonAreaList(class ASBPlayerController* InPlayerController, FSBFang_expeditionData& ExpeditionData);
    void GetExpeditionUsableTokenIdList(TArray<int32>& TokenIds);
    void GetExpeditionTimeIndex(class ASBPlayerController* PlayerController, FString AreaId, FString TimeId, int32& Index);
    int32 GetExpeditionPlaySlotFreeCount(class ASBPlayerController* PlayerController);
    void GetExpeditionMiddleCategoryToField(FString SubCategory, FString& Field);
    void GetExpeditionFieldStatus(FString FieldId, FSBFang_expeditionData& ExpeditionData, TArray<FSBFang_expeditionAreaData>& AreaDataList, TArray<FSBFang_expeditionPlayData>& PlayDataList);
    void GetExpeditionFieldIconData(FSBFang_expeditionData& ExpeditionData, TArray<FSBFang_expeditionIconData>& OutData);
    void GetExpeditionDetailRewardData(class UObject* InWorldContextObject, class ASBPlayerController* PlayerController, FSBFang_expeditionPlayData& PlayData, TArray<FSBFang_expeditionRandomRewardData>& RewardData);
    void GetExpeditionDetailFixedRewardData(class ASBPlayerController* PlayerController, FSBFang_expeditionPlayData& PlayData, TArray<FSBMasterReward>& RewardDatas);
    void FindExpeditionAreaDataIndex(FSBFang_expeditionData& ExpeditionData, FString ID, int32& FindIndex);
    void CheckExpreditonUsed(class UObject* InWorldContextObject, FString UniqueId, bool& isUsed);
}; // Size: 0x28

class USBFieldActorUtilityComponent : public UActorComponent
{
    class USBActorVisibilityComponent* ActorVisibilityComponent;                      // 0x00C0 (size: 0x8)

    bool SetActorVisibility();
}; // Size: 0xC8

class USBFieldBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void GetWorldAllStaticMeshes(const class UObject* WorldContextObject, TArray<class UStaticMesh*>& Meshes);
    class UStaticMesh* GetStaticMeshByPath(FName Path);
    void GetSharedCollections(FName CollectionName, TArray<FName>& OutPaths);
    FString GetRootDir();
    FString GetProjectSavedDir();
    FString GetProjectDir();
    bool CheckWindPower(class UActorComponent* Cmp1, class UStaticMesh* Mesh);
}; // Size: 0x28

class USBFieldObjectManager : public UObject
{
    FSBFieldObjectManagerOnUpdateDelegate OnUpdateDelegate;                           // 0x0028 (size: 0x10)
    void OnUpdateDelegate();

    void RequestUpdateAll(class UObject* WorldContextObject);
    void OnUpdateDelegate__DelegateSignature();
    FString GetFieldStatusComponentInfo(class UObject* WorldContextObject);
    class USBFieldStatusComponent* GetFieldStatusComponent(class AActor* Owner, bool& Flag);
}; // Size: 0x50

class USBFieldStatusComponent : public UActorComponent
{
    bool Fixed;                                                                       // 0x00C0 (size: 0x1)
    EFieldStatus Status;                                                              // 0x00C1 (size: 0x1)
    char padding_0[0x6];                                                              // 0x00C2 (size: 0x6)
    class USBActorVisibilityComponent* ActorVisibilityComponent;                      // 0x00C8 (size: 0x8)
    FDataTableRowHandle StatusSettingHandle;                                          // 0x00D0 (size: 0x10)
    char padding_1[0x8];                                                              // 0x00E0 (size: 0x8)
    FSBFieldStatusComponentOnFieldStatusChanged OnFieldStatusChanged;                 // 0x00E8 (size: 0x10)
    void SBFieldStatusChangeSignature(EFieldStatus NewStatus);

    bool SetStatus(EFieldStatus Val, bool Force);
    void SetActorInteraction(bool sw);
    void OnRep_FieldStatus();
    EFieldStatus GetStatus();
}; // Size: 0xF8

class USBFieldStatusFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsDisplayAndQuestProceedingByFieldStatus(class UObject* InWorldContextObject, const FSBFieldStatusSetting& InSetting);
    EFieldStatus EvaluateFieldStatus(class UObject* InWorldContextObject, const FSBFieldStatusSetting& InSetting);
    bool CheckFieldStatusCondition(class UObject* InWorldContextObject, const FSBFieldStatusConditionSetting& InConditionSetting);
}; // Size: 0x28

class USBFmComponenUtility : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBPlayerFmComponent* GetFmComponent(const class UObject* WorldContextObject);
}; // Size: 0x28

class USBFocusTargetWidget : public UUserWidget
{
    class UBorder* NormalModeGrp;                                                     // 0x0278 (size: 0x8)
    class UImage* HPPrev;                                                             // 0x0280 (size: 0x8)
    class USBP020_MarkEnemy* P020_MarkEnemy;                                          // 0x0288 (size: 0x8)
    class USBBurstBonusGaugeWidget* BurstBonusGauge;                                  // 0x0290 (size: 0x8)
    class USBEGaugeWidget* EGauge;                                                    // 0x0298 (size: 0x8)
    class UCanvasPanel* HPCurSize;                                                    // 0x02A0 (size: 0x8)
    class UCanvasPanel* HPPrevSize;                                                   // 0x02A8 (size: 0x8)
    class UDataTable* P020DataTable;                                                  // 0x02B0 (size: 0x8)
    class USBBattleStatusComponent* BattleStatusComponent;                            // 0x02B8 (size: 0x8)
    class AActor* TargetActor;                                                        // 0x02C0 (size: 0x8)
    class AActor* AttackFocusActor;                                                   // 0x02C8 (size: 0x8)

    void SetPlayAnimOut(bool Flag);
    void SetPlayAnimIn(bool Flag);
    void SetOldVisible(bool Flag);
    void SetOldLockOn(bool Flag);
    void SetFadeDeath(bool Flag);
    void SetBurstBonus(bool Flag);
    void SetAttackFocusActor(class AActor* InActor);
    void ResetHPGauge();
    void OnSetTargetActor();
    void OnPlayAnimOut();
    bool IsPlayAnimOut();
    bool IsPlayAnimIn();
    bool IsOldVisible();
    bool IsOldLockOn();
    bool IsFadeDeath();
    bool IsBurstBonus();
    float GetEnemyHpBarPercent();
    void AdjustGaugeSize(class UCanvasPanelSlot* Target, float Ratio);
}; // Size: 0x2E8

class USBFoliageCollideManageComponent : public UActorComponent
{
    bool CollisionDebugDraw;                                                          // 0x00B8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00B9 (size: 0x3)
    float CollisionIntervalMax;                                                       // 0x00BC (size: 0x4)
    float CollisionIntervalMin;                                                       // 0x00C0 (size: 0x4)
    float CollisionCheckRadius;                                                       // 0x00C4 (size: 0x4)
    float CollisionCheckLocation;                                                     // 0x00C8 (size: 0x4)

    void UpdateComponentsSeParticle(FVector InCheckLocation, float InCheckRadius, float DeltaTime);
    void UpdateCharactersSeParticle(FVector InCheckLocation, float InCheckRadius, float DeltaTime);
    void SetFoliageCollisionReactions(TArray<FSBFoliageCollisionReaction> CollisionReactions);
    void GetSeParticleCollections(TArray<FName>& OutAssets);
    void FoliageCollisionReactionSeParticle(TArray<FSBFoliageCollisionResult> FoliageCollisions);
    bool FindFoliageCollide(TArray<FHitResult> HitResults, TArray<FSBFoliageCollisionResult>& OutResults);
    bool CheckFoliageCollideReactions(FVector Center, float HalfHeight, FVector Velocity, float& OutValue);
}; // Size: 0x1C0

class USBFoliageReactionCollisionComp : public UCapsuleComponent
{
    char padding_0[0x4E0];                                                            // 0x0000 (size: 0x0)

    void SetSpawnParams(const FSBFoliageReactionSpawn& SpawnParams);
    void SetParameters(float DelayTime, float LifeTime, float StartRadius, float EndRadius, float StartStrength, float EndStrength, float HalfHeight, float Center, float Peak);
    void GetFoliageReactionData(FSBFoliageReactionData& Data);
}; // Size: 0x4E0

class USBFootprintComponent : public UActorComponent
{
    float m_ParticleScale;                                                            // 0x00D0 (size: 0x4)
    float m_DecalSize;                                                                // 0x00D4 (size: 0x4)
    float m_RunFootprintSpeed;                                                        // 0x00D8 (size: 0x4)
    float m_DashFootprintSpeed;                                                       // 0x00DC (size: 0x4)
    TArray<FSBFootprintSideSocket> m_FootprintSockets;                                // 0x00E0 (size: 0x10)
    FSBSurfaceFootprintSettingList SurfaceFootprintSettingList;                       // 0x00F0 (size: 0x2B0)
    TArray<FSBFootPrintDecal> m_SpawnedDecalList;                                     // 0x03A0 (size: 0x10)
    char padding_0[0x68];                                                             // 0x03B0 (size: 0x68)
    bool m_bRecycleAkComponent;                                                       // 0x0418 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0419 (size: 0x7)
    class UAkComponent* m_pAkComponent;                                               // 0x0420 (size: 0x8)
    char padding_2[0x40];                                                             // 0x0428 (size: 0x40)
    TArray<class UObject*> LoadedAssets;                                              // 0x0468 (size: 0x10)

    void RequestFadeoutFootprintInTime(float InFadeTime, bool bIsSuspendCreate);
    void RequestCreateFootprint(FName InSocketName, class USBSurfaceFootprintSetting* Setting, EFootPrintSide Side, float LineDownLength, float LineTopLength, const FVector& LocationOffset, const FRotator& ParticleRotation, const FRotator& DecalRotation, float DecalLifeSpan, float OverrideScale, float OverrideEffectDelay, float OverrideSoundDelay, bool bDisableEffect, bool bDisableSound, bool bLocomotion, ESBEffectVisibleType VisibleType, bool bAsync, const class USBAnimNotifyState_Footprint* FootprintNotifyState, FName AttachSocketName);
    bool LineTraceForFootstep(FName InSocketName, FHitResult& OutHit, float LineDownLength, float LineTopLength);
    TEnumAsByte<EFootPrintType::Type> GetLocomotionFootprintType();
    FName GetFootprintSocketName(EFootPrintSide FootprintSide);
    class USBSurfaceFootprintSetting* GetFootprintSetting(TEnumAsByte<EFootPrintType::Type> FootPrintType);
    float GetDecalSize();
    bool CanCreateLocomotionFootprint(EFootPrintSide FPSide);
}; // Size: 0x478

class USBFrameCaptureComponent : public UActorComponent
{
    class UTextureRenderTarget2D* TextureTarget;                                      // 0x00B8 (size: 0x8)

    bool Capture();
}; // Size: 0xD0

class USBFrameTimeComponent : public UActorComponent
{
    float FrameTime;                                                                  // 0x00C8 (size: 0x4)
    int32 PhysicalMemoryTotal;                                                        // 0x00CC (size: 0x4)
    int32 PhysicalMemoryPeak;                                                         // 0x00D0 (size: 0x4)
    int32 PhysicalMemoryUsed;                                                         // 0x00D4 (size: 0x4)
    char padding_0[0x8];                                                              // 0x00D8 (size: 0x8)
    class UFont* FontObject;                                                          // 0x00E0 (size: 0x8)

}; // Size: 0xE8

class USBGameEngine : public UGameEngine
{
    char padding_0[0xDF8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0xDF8

class USBGameInstance : public UGameInstance
{
    class UDataTable* MapInfoOverride;                                                // 0x01A8 (size: 0x8)
    class UDataTable* SublevelLoadInfo;                                               // 0x01B0 (size: 0x8)
    FString LastURL;                                                                  // 0x01B8 (size: 0x10)
    FDataTableRowHandle RespawnAssistHandle;                                          // 0x01C8 (size: 0x10)
    TMap<class FUniqueNetIdRepl, class USBOnlinePlayer*> InviteRecipients;            // 0x01D8 (size: 0x50)
    FSBGameInstanceOnMatchedGame OnMatchedGame;                                       // 0x0228 (size: 0x10)
    void OnMatchedGame(class USBMatchingGameState* MatchedGame);
    bool bAdminFuncUnlocked;                                                          // 0x0238 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0239 (size: 0x7)
    class USBActorManager* ActorManager;                                              // 0x0240 (size: 0x8)
    class USBNpcManager* NpcManager;                                                  // 0x0248 (size: 0x8)
    class USBPartyManager* PartyManager;                                              // 0x0250 (size: 0x8)
    class USBFieldObjectManager* FieldObjectManager;                                  // 0x0258 (size: 0x8)
    class USBWaterFlowManager* WaterFlowManager;                                      // 0x0260 (size: 0x8)
    class USBUIVisibleSettings* UIVisibleSettings;                                    // 0x0268 (size: 0x8)
    class USBMatchingManager* MatchingManager;                                        // 0x0270 (size: 0x8)
    class USBOnlineMessageManager* MessageManager;                                    // 0x0278 (size: 0x8)
    class USBChatManager* ChatManager;                                                // 0x0280 (size: 0x8)
    class USBProfileManager* ProfileManager;                                          // 0x0288 (size: 0x8)
    class USBPlaylog* Playlog;                                                        // 0x0290 (size: 0x8)
    char padding_1[0x80];                                                             // 0x0298 (size: 0x80)
    class USBRaidBattleManager* RaidBattleManager;                                    // 0x0318 (size: 0x8)
    class USBInterruptQuestManager* InterruptQuestManager;                            // 0x0320 (size: 0x8)
    class USBAutoDeliveryQuestManager* AutoDeliveryQuestManager;                      // 0x0328 (size: 0x8)
    class USBAdventureBoardManager* AdventureBoardManager;                            // 0x0330 (size: 0x8)
    class USBScriptManager* ScriptManager;                                            // 0x0338 (size: 0x8)
    class USBTickerMessageManager* TickerMessageManager;                              // 0x0340 (size: 0x8)
    class USBNetworkCafeMessageManager* NetworkCafeMessageManager;                    // 0x0348 (size: 0x8)
    class USBEventScheduler* EventScheduler;                                          // 0x0350 (size: 0x8)
    class USBDxBattleManager* DxBattleManager;                                        // 0x0358 (size: 0x8)
    char padding_2[0x30];                                                             // 0x0360 (size: 0x30)
    FSBGameInstanceOnAddPointDelegate OnAddPointDelegate;                             // 0x0390 (size: 0x10)
    void OnAddPointDelegate(const int32& Point);
    char padding_3[0x30];                                                             // 0x03A0 (size: 0x30)
    TArray<class USBChatMessage*> UninspectedMessageList;                             // 0x03D0 (size: 0x10)
    TArray<FSBDownloadImageCache> DownloadImageCacheList;                             // 0x03E0 (size: 0x10)
    char padding_4[0x10];                                                             // 0x03F0 (size: 0x10)
    FSBGameInstanceOnNotificationBlackListedDelegate OnNotificationBlackListedDelegate; // 0x0400 (size: 0x10)
    void OnNotificationBlackListedDelegate(const bool bBlackListed, FString SenderId);
    FSBGameInstanceOnReceiveMessageDelegate OnReceiveMessageDelegate;                 // 0x0410 (size: 0x10)
    void OnReceiveMessageDelegate(const class USBChatMessage* Message, const FSBChatUIMessage Mess);
    FSBGameInstanceOnJoinPlayerCharacterDelegate OnJoinPlayerCharacterDelegate;       // 0x0420 (size: 0x10)
    void OnJoinPlayerCharacterDelegate(class ASBPlayerState* PlayerState);
    char padding_5[0x8];                                                              // 0x0430 (size: 0x8)
    FSBGameInstanceOnUpdatePartyMemberDelegate OnUpdatePartyMemberDelegate;           // 0x0438 (size: 0x10)
    void OnUpdatePartyMemberDelegate();
    TSubclassOf<class USBNetworkDataCache> NetworkDataCacheClass;                     // 0x0448 (size: 0x8)
    class USBNetworkDataCache* NetworkDataCache;                                      // 0x0450 (size: 0x8)
    class USBEventExecutor* EventExecutor;                                            // 0x0458 (size: 0x8)
    TSubclassOf<class USBScreenShotUtils> ScreenShotUtilsClass;                       // 0x0460 (size: 0x8)
    class USBScreenShotUtils* ScreenShotUtils;                                        // 0x0468 (size: 0x8)
    char padding_6[0x18];                                                             // 0x0470 (size: 0x18)
    FSBGameInstanceOnChangeInvitePartyConvocationDelegate OnChangeInvitePartyConvocationDelegate; // 0x0488 (size: 0x10)
    void OnChangeInvitePartyConvocationDelegate(const bool bCanceled, const int32 MigrationResponseCode);
    FSBGameInstanceOnExecutePartyMigrationDelegate OnExecutePartyMigrationDelegate;   // 0x0498 (size: 0x10)
    void OnExecutePartyMigrationDelegate(const bool bExecuted, const ESBPartySystemTextType MessageType, const int32 MigrationResponseCode);
    FSBGameInstanceOnPartyInviteRejectedBeforeJoinRecruitDelegate OnPartyInviteRejectedBeforeJoinRecruitDelegate; // 0x04A8 (size: 0x10)
    void OnPartyInviteRejectedBeforeJoinRecruitDelegate();
    FSBGameInstanceOnReturnDisconnectedPartyDelegate OnReturnDisconnectedPartyDelegate; // 0x04B8 (size: 0x10)
    void OnReturnDisconnectedPartyDelegate(const bool bWasSuccessful, const int32 ReturnPartyResultMessageIndex);
    class USBErrorProc* ErrorProc;                                                    // 0x04C8 (size: 0x8)
    char padding_7[0x34];                                                             // 0x04D0 (size: 0x34)
    bool bHealthCheck;                                                                // 0x0504 (size: 0x1)
    char padding_8[0x3];                                                              // 0x0505 (size: 0x3)
    float HealthCheckInterval;                                                        // 0x0508 (size: 0x4)
    char padding_9[0x4];                                                              // 0x050C (size: 0x4)
    FSBGameInstanceOnActivityStartRequestDelegate OnActivityStartRequestDelegate;     // 0x0510 (size: 0x10)
    void OnActivityStartRequestDelegate();
    char padding_10[0x8];                                                             // 0x0520 (size: 0x8)
    TArray<class USBDownloadImageImpl*> DownloadImageImplList;                        // 0x0528 (size: 0x10)

    void UpdateChatLogMessageAllAlreadyRead();
    bool Tick(const float InDeltaTime);
    void StopNetworkCafeEvent();
    void StartNetworkCafeEvent();
    bool ShouldShowCursor();
    void SetScreenshotUploadModeFlag(bool bValue);
    void SetScreenshotShowUiFlag(bool bShowUi);
    void SetOnNetworkError(const bool bInNetworkError);
    void SetFirstExpiredRoseOrb(const bool bInExpiredRoseOrb);
    void SetFirstExpiredBPP(const bool bInExpiredBPP);
    void SetFirstCharacterSpawned(const bool bInSpawned);
    void SetActiveHealthCheck(bool bInActive);
    void SendInvitation(class ASBPlayerState* RecipientPlayer, bool bNeedResponse);
    void ScreenShotSaveProcessFlagSet(int32 Value);
    void ReturnDisconnectParty();
    void ResetActivityStartRequest();
    void RemoveDirectChatLogPlayer(const FString SenderPlayerId);
    void RegistrationPartyJoinRequest(FString InRecruitPartyLeaderUserId, FString InRecruitPartyLeaderCharacterId);
    void RecruitRegistrationWithCreatePersistentParty(const FSBPartyRecruitData& RecruitData);
    void ReceiveSendInvitationComplete(const ESBPartySystemTextType InType, FString RecipientName, bool bWasSuccessful);
    void ReceivePromotePartyMember(class USBPartyMemberState* PromoteMember);
    void ReceivePartySimplycityChangeForSolo();
    void ReceivePartySimplycityChange(class USBPartyGameState* PartyState);
    void ReceivePartySameMapMemberCountChanged();
    void ReceivePartyRetireGame(class USBPartyGameState* PartyState, bool bFromLeader);
    void ReceivePartyRequestMatchmaking(class USBPartyGameState* PartyState);
    void ReceivePartyMigration(class USBPartyGameState* PartyState, bool bExecuted);
    void ReceivePartyMemberLeft(class USBPartyGameState* PartyState, bool bIsReleased);
    void ReceivePartyMemberLeaving(class USBPartyMemberState* LeavingMember, bool bIsKicked);
    void ReceivePartyMemberJoined(class USBPartyMemberState* JoinedMember, bool bExistingMember, bool bIsRejoin);
    void ReceivePartyMemberDungeonEntryChanged();
    void ReceivePartyLeft(class USBPartyGameState* PartyState, bool bIsKicked);
    void ReceivePartyJoined(class USBPartyGameState* PartyState, bool bIsRejoin);
    void ReceivePartyInvitesChanged();
    void ReceivePartyInviteResponseReceived(FString SenderId, FString SenderName, bool bIsAccepted);
    void ReceivePartyInviteReceived(FString SenderId, FString SenderName);
    void ReceivePartyConvocation(class USBPartyGameState* PartyState, bool bCanceled, const int32 MigrationResponseCode);
    void ReceiveMatchingFailed(const ESBMatchingFailureType FailureType, bool PenaltyForMe, int32 MinuteToEndPenalty);
    void ReceiveMatchedGame(class USBMatchingGameState* MatchedGame);
    void ReceiveJoinInviteParty(bool bWasSuccessful);
    void PartyInviteResponse(FString InSenderId, FString InSenderName, const bool bIsAccept);
    void OnUpdatePartyMemberDelegate__DelegateSignature();
    void OnReturnDisconnectedPartyDelegate__DelegateSignature(const bool bWasSuccessful, const int32 ReturnPartyResultMessageIndex);
    void OnReceiveMessageDelegate__DelegateSignature(const class USBChatMessage* Message, const FSBChatUIMessage Mess);
    void OnPrepareScreenshot(class UObject* Sender, class UObject* Param);
    void OnPartyInviteRejectedBeforeJoinRecruitDelegate__DelegateSignature();
    void OnNotificationBlackListedDelegate__DelegateSignature(const bool bBlackListed, FString SenderId);
    void OnMatchedGame__DelegateSignature(class USBMatchingGameState* MatchedGame);
    void OnJoinPlayerCharacterDelegate__DelegateSignature(class ASBPlayerState* PlayerState);
    void OnHackDetected(uint32 InCode);
    void OnFinishScreenshot(class UObject* Sender, class UObject* Param);
    void OnExecutePartyMigrationDelegate__DelegateSignature(const bool bExecuted, const ESBPartySystemTextType MessageType, const int32 MigrationResponseCode);
    void OnCheckMasterData();
    void OnChangeInvitePartyConvocationDelegate__DelegateSignature(const bool bCanceled, const int32 MigrationResponseCode);
    void OnAddPointDelegate__DelegateSignature(const int32& Point);
    void OnActivityStartRequestDelegate__DelegateSignature();
    void NotifyExecutePartyServerReConnectError();
    void MigrationHandleTravelError(int32 RetCode);
    bool LastInputWasGamepadKey();
    bool IsStartImmediately();
    bool IsQuitReady();
    bool IsOnNetworkError();
    bool IsJoinedBackfillMap();
    bool IsJoinableMatching();
    bool IsFirstExpiredRoseOrb();
    bool IsFirstExpiredBPP();
    bool IsFirstCharacterSpawned();
    bool IsAddDirectChatLogPlayer();
    void InternalTravelToSession(FName SessionName);
    void HandleTravelErrorInternal(TEnumAsByte<ETravelFailure::Type> FailureType);
    void HandleNetworkErrorInternal(TEnumAsByte<ENetworkFailure::Type> FailureType, bool bIsServer);
    void HandleNetworkCafeRewardNotification(const int32 NetworkCafeTotalTimePlayedToday);
    void HandleNetworkCafePlayingTimeNotification(const int32 NetworkCafeTotalTimePlayedToday);
    void HandleMigrationTravelErrorInternal(int32 RetCode);
    class USBWaterFlowManager* GetWaterFlowManager();
    class USBRaidBattleManager* GetRaidBattleManager();
    class USBNpcManager* GetNpcManager();
    class USBInterruptQuestManager* GetInterruptQuestManager();
    class USBFieldObjectManager* GetFieldObjectManager();
    class USBEventScheduler* GetEventScheduler();
    class USBEventExecutor* GetEventExecutor();
    class USBDxBattleManager* GetDxBattleManager();
    int32 GetDirectChatLogWindowIndex(const FString SenderPlayerId);
    TArray<FSBDirectChatUIMessage> GetDirectChatLogList();
    TArray<FSBChatUIMessage> GetChatLogMessage();
    class USBAutoDeliveryQuestManager* GetAutoDeliveryQuestManager();
    class USBAdventureBoardManager* GetAdventureBoardManager();
    class USBActorManager* GetActorManager();
    FSBDirectChatUIMessage FindDirectChatLogMessage(const FString SenderPlayerId);
    void ExecuteMigrationWaitMembers();
    void ExecuteMigration(const bool bExecuted, const ESBPartySystemTextType MessageType, const int32 MigrationResponseCode);
    void ClearAllChatLogMessage();
    bool CheckActivityStartRequest();
    void AddDirectChatLogPlayer(const FString SenderPlayerId, const FText SenderCharacterName, const int32 WindowIndex);
}; // Size: 0x540

class USBGameIntentManager : public UObject
{
    class USBGameIntent_Base* GameIntentPtr;                                          // 0x0028 (size: 0x8)

}; // Size: 0x30

class USBGameIntent_Base : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    void OnCreateSessionCompleteDelegate(FName InSessionName, bool bWasSuccessful);
}; // Size: 0x38

class USBGameIntent_XSX : public USBGameIntent_Base
{
    char padding_0[0x160];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x160

class USBGameModeCustomBattleComponent : public UActorComponent
{
    bool bEnableEnemyInfiniteHP;                                                      // 0x00B8 (size: 0x1)
    bool bEnablePlayerInfiniteHP;                                                     // 0x00B9 (size: 0x1)

    bool IsEnablePlayerInfiniteHP();
    bool IsEnableEnemyInfiniteHP();
}; // Size: 0xC0

class USBGameServer : public UObject
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBGameSingleton : public UObject
{
    TArray<class UObject*> LoadedAssets;                                              // 0x0110 (size: 0x10)
    char padding_0[0x18];                                                             // 0x0120 (size: 0x18)
    TSubclassOf<class USBMasterDataManager> MasterDataManager;                        // 0x0138 (size: 0x8)
    TSubclassOf<class USBHttpQueryManager> HttpQueryManager;                          // 0x0140 (size: 0x8)
    FString ServerURL;                                                                // 0x0148 (size: 0x10)
    TSubclassOf<class USBPlayerManager> PlayerManager;                                // 0x0158 (size: 0x8)
    TSubclassOf<class USBCharaPartsManager> CharaPartsManager;                        // 0x0160 (size: 0x8)
    TSubclassOf<class USBNpcParameterManager> NpcJobManager;                          // 0x0168 (size: 0x8)
    TSubclassOf<class USBConfigureSaveManager> ConfigSaveManager;                     // 0x0170 (size: 0x8)
    TSubclassOf<class USBSoundManager> SoundManager;                                  // 0x0178 (size: 0x8)
    TSubclassOf<class USBUIManager> UIManager;                                        // 0x0180 (size: 0x8)
    TSubclassOf<class USBLibrarySaveManager> LibrarySaveManager;                      // 0x0188 (size: 0x8)
    TSubclassOf<class USBNewMarkManager> NewMarkManager;                              // 0x0190 (size: 0x8)
    TSoftClassPtr<USBEffectManager> EffectManager;                                    // 0x0198 (size: 0x28)
    TSoftClassPtr<USBSkinMaterialManager> SkinMaterialManager;                        // 0x01C0 (size: 0x28)
    TSoftClassPtr<USBMakeupManager> MakeupManager;                                    // 0x01E8 (size: 0x28)
    TSoftClassPtr<USBProjectileManager> ProjectileManager;                            // 0x0210 (size: 0x28)
    TSoftClassPtr<USBQuestManager> QuestManager;                                      // 0x0238 (size: 0x28)
    TSoftClassPtr<USBCharaCreateBoneScaleManager> BoneScaleManager;                   // 0x0260 (size: 0x28)
    TSoftClassPtr<USBCharaCreateColorManager> ColorManager;                           // 0x0288 (size: 0x28)
    TSoftClassPtr<USBAdditionalColorManager> AdditionalColorManager;                  // 0x02B0 (size: 0x28)
    TSoftClassPtr<USBUIAssetManager> UIAssetManager;                                  // 0x02D8 (size: 0x28)
    TSoftClassPtr<USBWeaponManager> WeaponManager;                                    // 0x0300 (size: 0x28)
    TSoftClassPtr<USBSystemMessageManager> SystemMessageManager;                      // 0x0328 (size: 0x28)
    TSoftClassPtr<USBEnemyManager> EnemyManager;                                      // 0x0350 (size: 0x28)
    TSoftClassPtr<USBEnemyPerformanceLogger> EnemyPerformanceLogger;                  // 0x0378 (size: 0x28)
    TSoftClassPtr<USBBuddyConditionalVoiceManager> BuddyConditionalVoiceManager;      // 0x03A0 (size: 0x28)
    TSoftClassPtr<USBBuddyEnemyManager> BuddyEnemyManager;                            // 0x03C8 (size: 0x28)
    TSoftClassPtr<USBDemoManager> DemoManager;                                        // 0x03F0 (size: 0x28)
    TSoftClassPtr<USBBattleManager> BattleManager;                                    // 0x0418 (size: 0x28)
    TSoftClassPtr<USBBattleStatusManager> BattleStatusManager;                        // 0x0440 (size: 0x28)
    TSoftClassPtr<USBDroppingTextManager> DroppingTextManager;                        // 0x0468 (size: 0x28)
    TSoftClassPtr<UJingleManager> JingleManager;                                      // 0x0490 (size: 0x28)
    TSoftClassPtr<USBColoringShopManager> ColoringShopManager;                        // 0x04B8 (size: 0x28)
    TSoftClassPtr<USBEventTriggerDatabase> EventTriggerDB;                            // 0x04E0 (size: 0x28)
    TSoftClassPtr<USBDebugFunction> DebugFunction;                                    // 0x0508 (size: 0x28)
    FSBTextTableDatabase TextTableDB;                                                 // 0x0530 (size: 0x198)
    class UDataTable* ZoneDB;                                                         // 0x06C8 (size: 0x8)
    class UDataTable* PlayerClassDB;                                                  // 0x06D0 (size: 0x8)
    TSoftObjectPtr<UDataTable> CharacterSystemParamDB;                                // 0x06D8 (size: 0x28)
    TArray<TSoftObjectPtr<UDataTable>> WeaponAssetDB;                                 // 0x0700 (size: 0x10)
    TSoftObjectPtr<UDataTable> AbilityModifierDB;                                     // 0x0710 (size: 0x28)
    TSoftObjectPtr<UDataTable> AttackMasterDataModifierDB;                            // 0x0738 (size: 0x28)
    TSoftObjectPtr<UDataTable> ImagineDB;                                             // 0x0760 (size: 0x28)
    TSoftObjectPtr<UDataTable> CharacterProfileDB;                                    // 0x0788 (size: 0x28)
    TSoftObjectPtr<UDataTable> RegionDB;                                              // 0x07B0 (size: 0x28)
    TSoftObjectPtr<UDataTable> LocationDB;                                            // 0x07D8 (size: 0x28)
    TSoftObjectPtr<UDataTable> EmoteDB;                                               // 0x0800 (size: 0x28)
    TSoftObjectPtr<UDataTable> ScenarioFlagDB;                                        // 0x0828 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyTypeDB;                                           // 0x0850 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyCharaCreateDataInfoDB;                            // 0x0878 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyLvGapBiasDB;                                      // 0x08A0 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyLvGapBiasCoefficientsDB;                          // 0x08C8 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyDifficultyDB;                                     // 0x08F0 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemySetAssetDB;                                       // 0x0918 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyWaveSettingsAssetDB;                              // 0x0940 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyStatusPlayerNumBiasDB;                            // 0x0968 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyBattleStatusBiasByContentIdDB;                    // 0x0990 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyMaxSpawnNumDataByContentIdDB;                     // 0x09B8 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyReserveSlotNumDataByContentIdDB;                  // 0x09E0 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyDungeonAttributeDB;                               // 0x0A08 (size: 0x28)
    TSoftObjectPtr<UDataTable> EnemyMinimumDamageDB;                                  // 0x0A30 (size: 0x28)
    TSoftObjectPtr<UDataTable> DungeonDifficultyDB;                                   // 0x0A58 (size: 0x28)
    TSoftObjectPtr<UDataTable> StampDataDB;                                           // 0x0A80 (size: 0x28)
    TSoftObjectPtr<UDataTable> StampCategoryDataDB;                                   // 0x0AA8 (size: 0x28)
    TSoftObjectPtr<UDataTable> MailDataDB;                                            // 0x0AD0 (size: 0x28)
    TSoftObjectPtr<UDataTable> ScriptActorActionDataDB;                               // 0x0AF8 (size: 0x28)
    TSoftObjectPtr<UDataTable> RepGraphFrequencyDistDB;                               // 0x0B20 (size: 0x28)
    TSoftObjectPtr<UDataTable> WorldUIDB;                                             // 0x0B48 (size: 0x28)
    TSoftObjectPtr<UDataTable> DigitalSignageDB;                                      // 0x0B70 (size: 0x28)
    TSoftObjectPtr<UDataTable> LevelNameConventionsDB;                                // 0x0B98 (size: 0x28)
    TSoftObjectPtr<UDataTable> TraversePointDB;                                       // 0x0BC0 (size: 0x28)
    TSoftObjectPtr<UDataTable> CountryTimeZoneSettingDB;                              // 0x0BE8 (size: 0x28)
    TSoftObjectPtr<UDataTable> InterruptQuestTreasureObjectSettingDB;                 // 0x0C10 (size: 0x28)
    TSoftObjectPtr<UDataTable> BuddyEnemyIdDB;                                        // 0x0C38 (size: 0x28)
    TSoftObjectPtr<UDataTable> BuddyConditionalVoiceSettingsDB;                       // 0x0C60 (size: 0x28)
    TSoftObjectPtr<UDataTable> NpcSpawnLoadReductionDB;                               // 0x0C88 (size: 0x28)
    TSoftObjectPtr<UDataTable> NpcSpawnDistanceByContentIdDB;                         // 0x0CB0 (size: 0x28)
    TSoftObjectPtr<UDataTable> ItemInUseCanGestureDataDB;                             // 0x0CD8 (size: 0x28)
    TSoftObjectPtr<UDataTable> TutorialHelpDB;                                        // 0x0D00 (size: 0x28)
    TSoftObjectPtr<UDataTable> InvalidFlyingEnemyReductionDB;                         // 0x0D28 (size: 0x28)

    void OnReserveLoadEnemyAssetsDelegate__DelegateSignature();
    class USBWeaponManager* GetWeaponManager();
    class USBUIManager* GetUIManager();
    class USBUIAssetManager* GetUIAssetManager();
    class USBSystemMessageManager* GetSystemMessageManager();
    class USBSoundManager* GetSoundManager();
    class USBSkinMaterialManager* GetSkinMaterialManager();
    class USBQuestManager* GetQuestManager();
    class USBProjectileManager* GetProjectileManager();
    class USBPlayerManager* GetPlayerManager();
    class USBNpcParameterManager* GetNpcParameterManager();
    class USBNewMarkManager* GetNewMarkManager();
    class USBMasterDataManager* GetMasterDataManager();
    class USBMakeupManager* GetMakeupManager();
    class USBLibrarySaveManager* GetLibrarySaveManager();
    class UJingleManager* GetJingleManager();
    class USBHttpQueryManager* GetHttpQueryManager();
    class USBEventTriggerDatabase* GetEventTriggerDatabase();
    class USBEnemyPerformanceLogger* GetEnemyPerformanceLogger();
    class USBEnemyManager* GetEnemyManager();
    class USBEffectManager* GetEffectManager();
    class USBDroppingTextManager* GetDroppingTextManager();
    class USBDemoManager* GetDemoManager();
    class USBDebugFunction* GetDebugFunction();
    class USBConfigureSaveManager* GetConfigSaveManager();
    class USBCharaCreateColorManager* GetColorManager();
    class USBColoringShopManager* GetColoringShopManager();
    class USBCharaPartsManager* GetCharaPartsManager();
    class USBBuddyEnemyManager* GetBuddyEnemyManager();
    class USBBuddyConditionalVoiceManager* GetBuddyConditionalVoiceManager();
    class USBCharaCreateBoneScaleManager* GetBoneScaleManager();
    class USBBattleStatusManager* GetBattleStatusManager();
    class USBBattleManager* GetBattleManager();
    class USBAdditionalColorManager* GetAdditionalColorManager();
}; // Size: 0xD60

class USBGameViewportClient : public UGameViewportClient
{
    char padding_0[0x3B8];                                                            // 0x0000 (size: 0x0)

    void OnPlayerClassChanged(class UObject* Sender, class UObject* Param);
    void OnKeyConfigChanged(class UObject* Sender, class UObject* Param);
}; // Size: 0x3B8

class USBGameplayAbility_EnemyAction : public UGameplayAbility
{
    char padding_0[0x418];                                                            // 0x0000 (size: 0x0)

    void FinalizeActionAbility();
}; // Size: 0x418

class USBGameplayStatics : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void TraceMsg(const class UObject* WorldContextObject, bool bInExpression, FString Message);
    FDateTime SBUtcNow(const class UObject* WorldContextObject);
    void RemoveEventReceiverAll(const class UObject* WorldContextObject, class UObject* Receiver, bool bStrict);
    void RemoveEventReceiver(const class UObject* WorldContextObject, FName EventName, class UObject* Receiver, bool bStrict);
    TArray<FString> ParseIntoArrayLines(FString STR, bool bCullEmpty);
    class ASBPlayerState* GetSBPlayerState(const class UObject* WorldContextObject, int32 PlayerIndex);
    class ASBPlayerController* GetSBPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
    class ASBPlayerCharacter* GetSBPlayerCharacter(const class UObject* WorldContextObject, int32 PlayerIndex);
    class ASBGameState* GetSBGameState(const class UObject* WorldContextObject);
    class ASBGameMode* GetSBGameMode(const class UObject* WorldContextObject);
    class USBGameInstance* GetSBGameInstance(const class UObject* WorldContextObject);
    class USBPlayerStorageComponent* GetPlayerStorageComponent(const class UObject* WorldContextObject, int32 PlayerIndex);
    class ASBPhotoModeController* GetPhotoModeController(const class UObject* WorldContextObject);
    FDateTime GetNowDate(const class UObject* WorldContextObject);
    FString GetLocaleByCulture();
    class APlayerController* GetFirstLocalPlayerController(const class UObject* WorldContextObject);
    class APlayerController* GetFirstLocalOriginalPlayerController(const class UObject* WorldContextObject);
    bool GetEventTermEndTime(const class UObject* WorldContextObject, FString EventTermId, FDateTime& OutEndTime);
    class USBEventScheduler* GetEventScheduler(const class UObject* WorldContextObject);
    class USBEventExecutor* GetEventExecutor(const class UObject* WorldContextObject);
    FString GetCharacterId(const class UObject* WorldContextObject, int32 PlayerIndex);
    void ExecuteEvent(const class UObject* WorldContextObject, FName EventName, class UObject* Sender, class UObject* Param, ESBEventExecutorOption Option);
    void EnsuresbVbs(const class UObject* WorldContextObject, const bool bIsCheck);
    void EnsureMsg(const class UObject* WorldContextObject, bool bInExpression, FString Message);
    void EnsureAlwaysMsg(const class UObject* WorldContextObject, bool bInExpression, FString Message);
    FText DateTimeToText(const class UObject* WorldContextObject, const FDateTime& DateTime, bool bHideYear);
    FText DateTimeToTermText(const class UObject* WorldContextObject, const FDateTime& DateTime, bool bHideYear);
    FText DateTimeToFormatText(const class UObject* WorldContextObject, const FDateTime& DateTime, FString Format);
    bool CheckEventTermDataInstantNow(const class UObject* WorldContextObject, FString EventTermId);
    FSBEmotionInfo BP_FindEmotionInfoByIntId(int32 ID, bool& bIsValid);
    FSBEmotionInfo BP_FindEmotionInfo(FName ID, bool& bIsValid);
    void AddEventReceiver(const class UObject* WorldContextObject, FName EventName, class UObject* Receiver, FAddEventReceiverDelegate Delegate);
}; // Size: 0x28

class USBGashaComponent : public UActorComponent
{
    FSBGashaComponentOnCompleteProductsDelegate OnCompleteProductsDelegate;           // 0x00B8 (size: 0x10)
    void OnCompleteProductsDelegate(const bool Result, const int32 RetCode, const TArray<FSBGashaInfo>& InGashaList);
    FSBGashaComponentOnCompleteRateDelegate OnCompleteRateDelegate;                   // 0x00C8 (size: 0x10)
    void OnCompleteRateDelegate(const bool Result, const int32 RetCode, const int32 GashaId, const FString GashaIdName, const TArray<FSBGashaReward>& GashaRewardList);
    FSBGashaComponentOnCompletePlayCountDelegate OnCompletePlayCountDelegate;         // 0x00D8 (size: 0x10)
    void OnCompletePlayCountDelegate(const bool Result, const int32 RetCode, const TArray<FSBGashaPlayCount>& PlayCountList);
    FSBGashaComponentOnCompletePullDelegate OnCompletePullDelegate;                   // 0x00E8 (size: 0x10)
    void OnCompletePullDelegate(const bool Result, const int32 RetCode, const FSBGashaPullInfo& GashaPullInfo);

    void SortRarityGashaRewardList(TArray<FSBGashaReward>& InGashaRewardList);
    void SortGashaInfoList(TArray<FSBGashaInfo>& InGashaInfoList);
    void SortConfirmGashaRewardList(TArray<FSBGashaReward>& InGashaRewardList);
    void SetTicketGashaItemList(bool Flag);
    void SetCurrentGashaStepNow(int32 Num);
    void SetCurrentGashaStepMax(int32 Num);
    void SetCurrentGashaLapCount(int32 Num);
    void SetCurrentGashaId(FString ID);
    void ServerOnCompleteRate(int32 InRetCode, FString GashaIdName, const TArray<FSBGashaReward>& InGashaRewardList);
    void ServerOnCompletePull(int32 InRetCode, const FSBGashaPullInfo& GashaPullInfo);
    void ServerOnCompleteProducts(int32 InRetCode, const TArray<FSBGashaInfo>& InGashaList, const TArray<FSBGashaCategory>& InCategoryList);
    void ServerOnCompletePlayCount(int32 InRetCode, const TArray<FSBGashaPlayCount>& PlayCountList);
    void Server_RequestRate(class ASBPlayerController* InPlayerController, int32 GashaId, FString GashaIdName);
    void Server_RequestPull(class ASBPlayerController* InPlayerController, int32 GashaId, FString GashaIdName, int32 CurrencyType, int32 TokenID, int32 Count);
    void Server_RequestProducts(class ASBPlayerController* InPlayerController);
    void Server_RequestPlayCount(class ASBPlayerController* InPlayerController, const TArray<int32>& GashaIds, const TArray<FString>& GashaIdNameList);
    void RequestRate(int32 GashaId, FString GashaIdName);
    void RequestPull(int32 GashaId, FString GashaIdName, int32 CurrencyType, int32 TokenID, int32 Count);
    void RequestProducts();
    void RequestPlayCount(const TArray<int32>& GashaIds, const TArray<FString>& GashaIdNameList);
    void OnCompleteRateDelegate__DelegateSignature(const bool Result, const int32 RetCode, const int32 GashaId, const FString GashaIdName, const TArray<FSBGashaReward>& GashaRewardList);
    void OnCompletePullDelegate__DelegateSignature(const bool Result, const int32 RetCode, const FSBGashaPullInfo& GashaPullInfo);
    void OnCompleteProductsDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FSBGashaInfo>& InGashaList);
    void OnCompletePlayCountDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FSBGashaPlayCount>& PlayCountList);
    bool IsTicketGashaItemList();
    bool IsLoopStepUpGasha();
    bool IsCurrentStepUp();
    bool GetNextCurrencyBonusInfo(FSBGashaBonus& OutGashaBonus, int32& OutCount);
    bool GetNextBonusInfo_StepUpGasha(FSBGashaBonus& OutGashaBonus, bool& OutIsNowGetBonus);
    bool GetNextBonusInfo(FSBGashaBonus& OutGashaBonus, int32& OutCount, int32& OutPlayCount);
    void GetGashaRewardList_PurchaseType(TEnumAsByte<ESBGashaPurchaseType> Type, TArray<FSBGashaReward>& OutGashaRewardList);
    void GetGashaRewardList(int32 Step, TArray<FSBGashaReward>& OutGashaRewardList);
    bool GetGashaInfoStep(int32 Step, FSBGashaInfo& OutGashaInfo);
    FSBGashaInfo GetGashaInfo(FString GashaId);
    FSBGashaBonusListInfo GetGashaCurrencyBonusListInfo(FString GashaId);
    TArray<FSBGashaCategory> GetGashaCategoryList();
    FSBGashaBonusListInfo GetGashaBonusListInfo(FString GashaId);
    int32 GetCurrentGashaStepNow();
    int32 GetCurrentGashaStepMax();
    int32 GetCurrentGashaLapCount();
    FString GetCurrentGashaId();
    TArray<FSBGashaInfo> GetCategoryGashaInfoList(int32 InCategoryId);
    void ClientCompleteRate(int32 InRetCode, FString GashaIdName, const TArray<FSBGashaReward>& InGashaRewardList);
    void ClientCompletePull(int32 InRetCode, const FSBGashaPullInfo& GashaPullInfo);
    void ClientCompleteProducts(int32 InRetCode, const TArray<FSBGashaInfo>& InGashaList, const TArray<FSBGashaCategory>& InCategoryList);
    void ClientCompletePlayCount(int32 InRetCode, const TArray<FSBGashaPlayCount>& PlayCountList);
}; // Size: 0x148

class USBGeneralPurposeCounterComponent : public USBPlayerPropertyComponent
{
    int32 OldClassMaxDamage;                                                          // 0x00B8 (size: 0x4)
    ESBGeneralPurposeCounterType OldKindType;                                         // 0x00BC (size: 0x1)

    void SetOldClassMaxDamage(const int32 Damage);
    void Server_GeneralPurposeCounter(const ESBGeneralPurposeCounterType Type, const int32 Count);
    void Request_GeneralPurposeCounter(const ESBGeneralPurposeCounterType Type, const int32 Count);
}; // Size: 0xC0

class USBGetMaterialEventParam : public UObject
{
    FString Name;                                                                     // 0x0028 (size: 0x10)
    ESBWishListType Type;                                                             // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBGrassSoundComponent : public UActorComponent
{
    TMap<class FVector2D, class UAkComponent*> GrassSoundInstances;                   // 0x00C8 (size: 0x50)

}; // Size: 0x200

class USBGroundComponent : public USceneComponent
{
    bool bSetOnGround;                                                                // 0x0208 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0209 (size: 0x3)
    float FloatingHeight;                                                             // 0x020C (size: 0x4)

    void SetActorLocationOnGround();
}; // Size: 0x210

class USBGuardComponent : public UActorComponent
{
    float DurabilityHPScale;                                                          // 0x00C0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00C4 (size: 0x4)
    TArray<FSBConditionCheckIntParam> GuardShieldDamageModifyList;                    // 0x00C8 (size: 0x10)
    float ShieldDurability;                                                           // 0x00D8 (size: 0x4)
    char padding_1[0x1];                                                              // 0x00DC (size: 0x1)
    bool bIsGuardActive;                                                              // 0x00DD (size: 0x1)
    char padding_2[0x2];                                                              // 0x00DE (size: 0x2)
    float GuardDamageRate;                                                            // 0x00E0 (size: 0x4)
    FSBDefenceGuardConfig DefenceConfig;                                              // 0x00E4 (size: 0xC)
    char padding_3[0x19];                                                             // 0x00F0 (size: 0x19)
    bool bHideShieldWhenGuardBreak;                                                   // 0x0109 (size: 0x1)
    char padding_4[0x6];                                                              // 0x010A (size: 0x6)
    TArray<FSBGuardEffectSetting> m_GuardEffectSettingList;                           // 0x0110 (size: 0x10)
    FSBPlayingEffect m_PlayingGuardEffectList;                                        // 0x0120 (size: 0x320)

    void ServerAddShieldDurabilityByRate(float AddDurabilityRate);
    void ServerAddShieldDurability(const float AddDurability);
    void OnRep_ShieldDurability(const float OldDurability);
    void MulticastBeginGuardBreak();
    bool IsGuardBreak();
    bool IsGuard();
    float GetShieldDurability();
    class ASBWeapon* GetShield();
    float GetMaxShieldDurability();
}; // Size: 0x440

class USBHTNCheckComboEndPlanning : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString PrevActionKey;                                          // 0x0030 (size: 0x20)

}; // Size: 0x50

class USBHTNCheckState_Assigned : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString MemberKey;                                              // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyBool bAssigned;                                                // 0x0050 (size: 0x18)

}; // Size: 0x68

class USBHTNCheckState_AttackRequest : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyBool bFilled;                                                  // 0x0050 (size: 0x18)

}; // Size: 0x68

class USBHTNCheckState_Boss : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString MemberKey;                                              // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyBool bBoss;                                                    // 0x0050 (size: 0x18)

}; // Size: 0x68

class USBHTNCheckState_CanHitAttack : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString Command;                                                // 0x0030 (size: 0x20)

}; // Size: 0x50

class USBHTNCheckState_CanHitCounterAttack : public UAIFwHTNNode
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBHTNCheckState_Combo : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString PrevActionKey;                                          // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyString Command;                                                // 0x0050 (size: 0x20)

}; // Size: 0x70

class USBHTNCheckState_CommandAction : public UAIFwHTNNode
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBHTNCheckState_HeightDifference : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyFloat HeightMin;                                               // 0x0050 (size: 0x18)
    FAIFwBTNodePropertyFloat HeightMax;                                               // 0x0068 (size: 0x18)

}; // Size: 0x80

class USBHTNCheckState_IsAbsoluteCombo : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString PrevActionKey;                                          // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyString Command;                                                // 0x0050 (size: 0x20)

}; // Size: 0x70

class USBHTNGetState_SpActTargets : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString BlackboardKey;                                          // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyString TupleSpaceKey;                                          // 0x0050 (size: 0x20)
    FAIFwBTNodePropertyString ListenerKey;                                            // 0x0070 (size: 0x20)
    FAIFwBTNodePropertyInt MinTargetNum;                                              // 0x0090 (size: 0x18)
    FAIFwBTNodePropertyInt MaxTargetNum;                                              // 0x00A8 (size: 0x18)

}; // Size: 0xC0

class USBHTNModifyState_AnimationMovement : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString Command;                                                // 0x0030 (size: 0x20)

}; // Size: 0x50

class USBHTNModifyState_Assigned : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString MemberKey;                                              // 0x0030 (size: 0x20)

}; // Size: 0x50

class USBHTNModifyState_Combo : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString PrevActionKey;                                          // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyString Command;                                                // 0x0050 (size: 0x20)

}; // Size: 0x70

class USBHTNModifyState_CommandAction : public UAIFwHTNNode
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBHTNModifyState_MoveForAttack : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString AttackSkill;                                            // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyBool bMoveToTarget;                                            // 0x0050 (size: 0x18)

}; // Size: 0x68

class USBHTNModifyState_ResetSkillTree : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString PrevActionKey;                                          // 0x0030 (size: 0x20)

}; // Size: 0x50

class USBHTNOperator_ActionCategory : public UAIFwHTNOperator
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    void SetCategory(FString Category);
}; // Size: 0x30

class USBHTNOperator_ActionLottery : public UAIFwHTNOperator
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBHTNOperator_CompareState_Bool : public UAIFwHTNOperator
{
    FString Key;                                                                      // 0x0028 (size: 0x10)
    bool bValue;                                                                      // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBHTNOperator_CompareState_Float : public UAIFwHTNOperator
{
    FString Key;                                                                      // 0x0028 (size: 0x10)
    float Value;                                                                      // 0x0038 (size: 0x4)
    ESBHTNStateComparison Comparison;                                                 // 0x003C (size: 0x1)

}; // Size: 0x40

class USBHTNOperator_CompareState_Int : public UAIFwHTNOperator
{
    FString Key;                                                                      // 0x0028 (size: 0x10)
    int32 Value;                                                                      // 0x0038 (size: 0x4)
    ESBHTNStateComparison Comparison;                                                 // 0x003C (size: 0x1)

}; // Size: 0x40

class USBHTNOperator_Constant : public UAIFwHTNOperator
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    void SetValue(float InValue);
}; // Size: 0x30

class USBHTNOperator_Cooldown : public UAIFwHTNOperator
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBHTNOperator_Direction : public UAIFwHTNOperator
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    void SetDirection(float InBestDirectionMin, float InBestDirectionMax, float InBetterDirectionMin, float InBetterDirectionMax);
}; // Size: 0x38

class USBHTNOperator_Distance : public UAIFwHTNOperator
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    void SetRange(float InBestRangeMin, float InBestRangeMax, float InBetterRangeMin, float InBetterRangeMax);
}; // Size: 0x38

class USBHTNOperator_IsIntensiveAttacked : public UAIFwHTNOperator
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    void SetAIController(class AAIController* InController);
}; // Size: 0x30

class USBHTNOperator_NearAttackedPlayerNum : public UAIFwHTNOperator
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    void SetValue(class AAIController* InController, float InMaxDistance, int32 InMinPlayerNum);
}; // Size: 0x38

class USBHTNOperator_PartyStrategy : public UAIFwHTNOperator
{
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0028 (size: 0x8)

    void SetValue(ESBAIPartyStrategy Strategy, float Value);
}; // Size: 0x88

class USBHTNOperator_PassThroughState : public UAIFwHTNOperator
{
    FString Key;                                                                      // 0x0028 (size: 0x10)
    bool bInvert;                                                                     // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBHTNOperator_Random : public UAIFwHTNOperator
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBHTNOperator_Stamina : public UAIFwHTNOperator
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBHTNRemoveState_SpActTargets : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString TupleSpaceKey;                                          // 0x0030 (size: 0x20)
    FAIFwBTNodePropertyString TargetsKey;                                             // 0x0050 (size: 0x20)

}; // Size: 0x70

class USBHTNTakeState_AttackRequest : public UAIFwHTNNode
{
    FAIFwBTNodePropertyString TargetKey;                                              // 0x0030 (size: 0x20)

}; // Size: 0x50

class USBHUDLayoutData : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBHUDLayoutDatas Data;                                                           // 0x0050 (size: 0xF0)
    FString CustomSaveName;                                                           // 0x0140 (size: 0x10)

}; // Size: 0x150

class USBHappyNappoComponent : public UActorComponent
{
    FSBHappyNappoComponentOnInteractAPIDelegate OnInteractAPIDelegate;                // 0x00B8 (size: 0x10)
    void OnInteractAPIDelegate(const int32 RetCode, bool is_new, const TArray<int32>& gained_achievement_ids);
    char padding_0[0x8];                                                              // 0x00C8 (size: 0x8)
    FSBHappyNappoComponentOnInteractHappyNappoDelegate OnInteractHappyNappoDelegate;  // 0x00D0 (size: 0x10)
    void OnInteractHappyNappoDelegate(const int32 RetCode, const TArray<FString>& NappoIds);

    void Server_InteractHappyNappo(FString NappoId);
    void RapGetInteractedHappyNappoIds(bool Result);
    void OnInteractHappyNappoDelegate__DelegateSignature(const int32 RetCode, const TArray<FString>& NappoIds);
    void OnInteractAPIDelegate__DelegateSignature(const int32 RetCode, bool is_new, const TArray<int32>& gained_achievement_ids);
    void InteractNappo(FString NappoId);
    TArray<FString> GetInteractedNapposList();
    int32 GetInteractedHappyNappoIds();
    void Client_InteractHappyNappo(int32 RetCode, bool is_new, const TArray<int32>& gained_achievement_ids);
}; // Size: 0x100

class USBHateAlertWidget : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    void OnIsTrainingBattleState();
    void OnHide();
    void OnFindByEnemy();
    void OnEnemyTarget();
}; // Size: 0x280

class USBHateManagementComponent : public UActorComponent
{
    float InitialHate;                                                                // 0x00B8 (size: 0x4)
    float HateToReinforcement;                                                        // 0x00BC (size: 0x4)
    float IncrementHatePerDamageAmountTaken;                                          // 0x00C0 (size: 0x4)
    float IncrementHatePerDamageRateTaken;                                            // 0x00C4 (size: 0x4)
    float IncrementHatePerRecoveryAmount;                                             // 0x00C8 (size: 0x4)
    float IncrementHatePerRecoveryRate;                                               // 0x00CC (size: 0x4)
    float IncrementHateToHostileBuffEffect;                                           // 0x00D0 (size: 0x4)
    float IncrementHateToNegativeEffect;                                              // 0x00D4 (size: 0x4)
    float DecrementHatePerDamageAmountGiven;                                          // 0x00D8 (size: 0x4)
    float DecrementHateWhenAttakking;                                                 // 0x00DC (size: 0x4)
    float ReleaseRate;                                                                // 0x00E0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00E4 (size: 0x4)
    class AActor* HateTopActor;                                                       // 0x00E8 (size: 0x8)
    TMap<AActor*, float> HateList;                                                    // 0x00F0 (size: 0x50)
    TMap<FName, float> FactionHateList;                                               // 0x0140 (size: 0x50)
    TArray<class AActor*> FixHateActorList;                                           // 0x0190 (size: 0x10)
    FSBHateManagementComponentOnUpdatedFactionHateDelegate OnUpdatedFactionHateDelegate; // 0x01A0 (size: 0x10)
    void SBUpdatedFactionHateDelegate(const FName FactionName, const float Hate);

    void ResetHateByFaction(FName FactionName);
}; // Size: 0x1C0

class USBHintShowStatus : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBHintShowStatusTable Status;                                                    // 0x0050 (size: 0x50)

}; // Size: 0xA0

class USBHoldHandComponent : public UActorComponent
{
    char padding_0[0xD8];                                                             // 0x0000 (size: 0x0)

    bool IsSuspendHoldHand();
    bool IsHoldHandByRightHand();
    bool IsHoldHandAsLead();
    bool IsHoldHandActive();
    FVector GetHoldHandLocation();
}; // Size: 0xD8

class USBHttpQuery : public UObject
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBHttpQueryCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetHttpQueryResponseCallbackDelayTime(FString InURL, const float InDelayTime);
    void ResetHttpQueryResponseCallbackDelayTime(FString InURL);
    void DumpMasterDataStatus();
    void DumpHttpQuery();
}; // Size: 0x28

class USBHttpQueryManager : public UObject
{
    TArray<FSBHttpQueryPool> HttpQueries;                                             // 0x0028 (size: 0x10)

}; // Size: 0x60

class USBIconCaptureToolMenu : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    bool SetupWeapon(TArray<class ASBWeapon*> InWeapons, const int32 InWeaponID);
    void NotifyError(FString InErrorMessage);
    bool LoadCaptureTargetList(TArray<FSBLoadCaptureTargetItem>& OutTargets, const FString InPath);
    void HandleNotifyError(FString InErrorMessage);
    int32 GetCharaPartsFaceType(FString InCharaPartsId);
    bool ExportFromRenderTarget(FString InFilePath, class UTextureRenderTarget2D* InRenderTarget2D);
    bool DeleteDirectory(FString InPath);
    bool CreateDirectory(FString InPath);
    void CaptureWait(FString InFilePath, FVector2D InResolution, const bool bInMaskEnable, const bool bInDumpBufferVisualizationTargets, FLatentActionInfo LatentInfo);
    bool Capture(FString InFilePath, FVector2D InResolution, const bool bInMaskEnable, const bool bInDumpBufferVisualizationTargets);
}; // Size: 0x280

class USBIconInputControl : public UUserWidget
{
    FSBIconInputControlOnValidIconInputDelegate OnValidIconInputDelegate;             // 0x0278 (size: 0x10)
    void OnValidIconInputDelegate();

    void StartIconInputInvalidTimer();
    void SetIconInputInvalidTime(const float InTime);
    void OnValidIconInputDelegate__DelegateSignature();
    bool IsIconInputValid();
}; // Size: 0x290

class USBIdentityGetAccountAuthToken : public UObject
{
    char padding_0[0xA0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xA0

class USBImaginRecepiBase : public USBUserWidget
{
    char padding_0[0x2B0];                                                            // 0x0000 (size: 0x0)

    int32 GetOwnItemExp(const FOwnItemInfo& Info);
}; // Size: 0x2B0

class USBImagineArtsMarkerSkillInfo : public USBImagineArtsSkillInfo
{
    FSBSkillMarkerSetting MarkerSetting;                                              // 0x0300 (size: 0x70)

}; // Size: 0x370

class USBImagineArtsSkillInfo : public USBImagineSkillInfo
{
    FSBPlayerSkillChargeSetting ChargeSkillSetting;                                   // 0x02B8 (size: 0x28)
    char padding_0[0x8];                                                              // 0x02E0 (size: 0x8)
    TArray<class UDataTable*> AppendLoadProjectileList;                               // 0x02E8 (size: 0x10)

}; // Size: 0x2F8

class USBImagineBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsPassiveImagineEquipSlotMatch(int32 InImagineId, ESBPlayerPassiveImagineSlotType SlotType);
    ESBPlayerPassiveImagineSlotType GetPassiveImagineSlotTypeFromCharaEquipType(const ESBCharaEquipType InEquipType, bool& bIsValid);
    FName GetImagineTableRowName(const class ASBPlayerController* Controller, FString InUniqueId);
    int32 GetImagineTableIndex(const class ASBPlayerController* Controller, FString InUniqueId);
    int32 GetImagineRelitiveLevel(int32 InImagineId, int32 InTotalExp, int32& NowExp, int32& NextExp);
    FImagineParameter GetImagineLevelParam(int32 ImagineId, int32 Level);
    FName GetImagineArtsName(const class ASBPlayerController* Controller, FString InUniqueId);
    FSBStackBImagineParam CalcStackBImagineParam(const class USBNetworkDataCache* InNetworkDataCache, FString InUniqueId, int32 InStackBNum, bool bStorageAccess, const ESBStackBEnableType InStackBEnableType);
    FImagineParameter CalcImagineParam(const class USBNetworkDataCache* NetworkDataCache, FString InUniqueId, int32 LevelSyncTarget, bool bStorageAccess, bool DisableStackBCalc, const ESBStackBEnableType InStackBEnableType);
    FImagineParameter CalcDiff(const FImagineParameter& A, const FImagineParameter& B);
}; // Size: 0x28

class USBImagineLabComponent : public USBPlayerRecepiComponentBase
{
    FSBImagineLabComponentOnFinishedImagineCraft OnFinishedImagineCraft;              // 0x00B8 (size: 0x10)
    void OnFinishedImagineCraft(int32 RetCode, FString MakedUID);
    FSBImagineLabComponentOnImagineRecepiUpdated OnImagineRecepiUpdated;              // 0x00C8 (size: 0x10)
    void OnFinishedRecepiUpdated(int32 RetCode);
    FSBImagineLabComponentOnImagineRecepiCraftedUpdate OnImagineRecepiCraftedUpdate;  // 0x00D8 (size: 0x10)
    void OnFinishedRecepiCraftedUpdated(int32 RecepiId);
    TArray<FCharacterCraftRecepi> OwningRecepis;                                      // 0x00E8 (size: 0x10)

    void Server_Request_UnlockImagineRecepis(class ASBPlayerController* InPlayerController, const TArray<int32>& recepiIds);
    void Server_Request_UnlockImagineRecepi(class ASBPlayerController* InPlayerController, int32 RecepiId);
    void Server_Request_ImagineCraft(class ASBPlayerController* InPlayerController, int32 InRecepiId, int32 StorageNo);
    void Request_ImagineCraft(int32 InRecepiId, int32 StorageNo);
    void OnFinishedRecepiUpdated__DelegateSignature(int32 RetCode);
    void OnFinishedRecepiCraftedUpdated__DelegateSignature(int32 RecepiId);
    void OnFinishedImagineCraft__DelegateSignature(int32 RetCode, FString MakedUID);
    bool IsLearned(int32 InId);
    TArray<FMasterImagineRecepi> GetOwningImagineRecepi();
    TArray<FCharacterCraftRecepi> GetHasImagineRecepi();
    FCharacterCraftRecepi FindImagineRecepi(bool& IsExist, const int32 InRecepiId);
    void Client_UpdateRecepis(const int32 RetCode, const TArray<FCharacterCraftRecepi>& Recepis);
    void Client_Request_ImagineCraft(int32 RetCode, const int32 InRecepiId, const TArray<FOwnItemInfo>& InOwnItemInfos, FString MakedUID, int32 Money);
    void Client_ParseRecepi(const TArray<FCharacterCraftRecepi>& Values);
}; // Size: 0xF8

class USBImagineMountSkillInfo : public USBImagineSkillInfo
{
    TSoftClassPtr<ASBMount> MountAsset;                                               // 0x02B0 (size: 0x28)
    FSBSurfaceFootprintSettingList FootprintSettingList;                              // 0x02D8 (size: 0x2B0)
    FSBMountIKParam IKParam;                                                          // 0x0588 (size: 0x30)
    FName AttachSocketName;                                                           // 0x05B8 (size: 0x8)
    FVector AttachLocation;                                                           // 0x05C0 (size: 0xC)
    FRotator AttachRotator;                                                           // 0x05CC (size: 0xC)
    float AttachHeightOffset;                                                         // 0x05D8 (size: 0x4)
    float NamePlateHeightOffset;                                                      // 0x05DC (size: 0x4)
    float TargetableHeightOffset;                                                     // 0x05E0 (size: 0x4)
    float PlayerCapsuleHeightOffset;                                                  // 0x05E4 (size: 0x4)
    float MountCapusuleHalfHeight;                                                    // 0x05E8 (size: 0x4)
    float SummonPositionHeight;                                                       // 0x05EC (size: 0x4)
    FVector CalculatedPlayerCapsuleAttachPos;                                         // 0x05F0 (size: 0xC)
    float MountOffsetStopDistWithFollow;                                              // 0x05FC (size: 0x4)
    float MountTargetHeightWithFollow;                                                // 0x0600 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0604 (size: 0x4)
    FString MountCameraID;                                                            // 0x0608 (size: 0x10)
    FString MountFollowCameraID;                                                      // 0x0618 (size: 0x10)
    float EnergyDamageIntervalTime;                                                   // 0x0628 (size: 0x4)
    float EnergyDamageRateByTimeMove;                                                 // 0x062C (size: 0x4)
    float EnergyDamageRateByTimeStop;                                                 // 0x0630 (size: 0x4)
    float EnergyDamageRateByPerLv;                                                    // 0x0634 (size: 0x4)
    int32 MinAttentionEnemyLevelDiff;                                                 // 0x0638 (size: 0x4)
    int32 MaxAttentionEnemyLevelDiff;                                                 // 0x063C (size: 0x4)
    int32 ThresholdAttentionEnemyLevelDiff;                                           // 0x0640 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0644 (size: 0x4)
    TArray<float> AttentionEnemyLevelDiffMaxRate;                                     // 0x0648 (size: 0x10)
    float EnergyDamageByOverlapBase;                                                  // 0x0658 (size: 0x4)
    float EnergyDamageByOverlapPerLv;                                                 // 0x065C (size: 0x4)
    int32 MinOverlapLevelDiff;                                                        // 0x0660 (size: 0x4)
    int32 MaxOverlapLevelDiff;                                                        // 0x0664 (size: 0x4)
    int32 ThresholdOverlapLevelDiff;                                                  // 0x0668 (size: 0x4)
    char padding_2[0x4];                                                              // 0x066C (size: 0x4)
    TArray<float> OverlapLevelDiffMaxRate;                                            // 0x0670 (size: 0x10)
    float MountSummonPosOffsetFront;                                                  // 0x0680 (size: 0x4)
    float MountSummonPosOffsetFrontMinimum;                                           // 0x0684 (size: 0x4)
    FVector MountJumpOnVelocity;                                                      // 0x0688 (size: 0xC)
    FVector MountJumpOffVelocity;                                                     // 0x0694 (size: 0xC)
    float MountJumpOnMaxHeightOffset;                                                 // 0x06A0 (size: 0x4)

}; // Size: 0x6A8

class USBImagineSkillInfo : public USBSkillInfoClass
{
    FString CameraID;                                                                 // 0x02A0 (size: 0x10)

}; // Size: 0x2B0

class USBIndoorLightScheduleComponent : public UActorComponent
{
    TMap<class UMaterialInterface*, class UMaterialInstanceDynamic*> MaterialInstanceDynamics; // 0x00B8 (size: 0x50)
    TArray<class ULightComponent*> LightComponents;                                   // 0x0108 (size: 0x10)

    void UpdateEditorPreview(float TimeRate, bool sw);
    void SetupMaterialInstances(TArray<class UMeshComponent*> MeshComponents, bool sw);
    void SetupLightComponents(FName InTargetLightTag, bool sw);
}; // Size: 0x118

class USBInfluenceSourceComponent : public UActorComponent
{
    FString LayerName;                                                                // 0x00B8 (size: 0x10)
    float UpdateInterval;                                                             // 0x00C8 (size: 0x4)
    float Radius;                                                                     // 0x00CC (size: 0x4)
    float Value;                                                                      // 0x00D0 (size: 0x4)
    ESBInfluencePropagationType PropagationType;                                      // 0x00D4 (size: 0x1)

}; // Size: 0xD8

class USBInstanceBattleProviderComponent : public UActorComponent
{
    class ASBInstanceBattleProvider* OwnerProvider;                                   // 0x00B8 (size: 0x8)
    class ASBPlayerCharacter* TargetPlayerCharacter;                                  // 0x00C0 (size: 0x8)

    void Provide(class ASBPlayerCharacter* InTargetPlayerCharacter);
    void HandleEnableProvider(class ASBInstanceBattleProvider* InOwner);
    void HandleDisableProvider(class ASBInstanceBattleProvider* InOwner);
    FName GetInstanceBattleId();
}; // Size: 0xD0

class USBIntParam : public UObject
{
    int32 Value;                                                                      // 0x0028 (size: 0x4)

    class USBIntParam* SetValue(int32 InValue);
}; // Size: 0x30

class USBInteractionMoveComponent : public USceneComponent
{
    bool bTurnOnly;                                                                   // 0x0208 (size: 0x1)
    bool bTurnFront;                                                                  // 0x0209 (size: 0x1)
    char padding_0[0x2];                                                              // 0x020A (size: 0x2)
    float MoveEndDistance;                                                            // 0x020C (size: 0x4)

    void SetTargetRotation(FRotator TargetRotation);
    void SetTargetLocation(FVector TargetLocation);
    FRotator GetTargetRotation();
    FVector GetTargetLocation();
}; // Size: 0x230

class USBInteractionTargetAuthorComponent : public USceneComponent
{
    char padding_0[0x220];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x220

class USBInteractionTargetComponent : public USceneComponent
{
    bool bIsInteractionActive;                                                        // 0x0208 (size: 0x1)
    EInteractionTargetType Type;                                                      // 0x0209 (size: 0x1)
    char padding_0[0x2];                                                              // 0x020A (size: 0x2)
    int32 InteractNameID;                                                             // 0x020C (size: 0x4)
    FName SelectCursorAttachBoneName;                                                 // 0x0210 (size: 0x8)
    FVector SelectCursorLocationOffset;                                               // 0x0218 (size: 0xC)
    FName LookAtLocationBoneName;                                                     // 0x0224 (size: 0x8)
    FVector LookAtLocationOffset;                                                     // 0x022C (size: 0xC)
    float ReachableDistance;                                                          // 0x0238 (size: 0x4)
    float ReachableAnglePitch;                                                        // 0x023C (size: 0x4)
    float ReachableAngleYaw;                                                          // 0x0240 (size: 0x4)
    float HoldTime;                                                                   // 0x0244 (size: 0x4)
    bool bIsHideShowObjectCursor;                                                     // 0x0248 (size: 0x1)
    bool bCanOccupied;                                                                // 0x0249 (size: 0x1)
    bool bShouldSheathe;                                                              // 0x024A (size: 0x1)
    bool bShouldNoBattle;                                                             // 0x024B (size: 0x1)
    bool bNotShouldMount;                                                             // 0x024C (size: 0x1)
    bool bNotShouldEmote;                                                             // 0x024D (size: 0x1)
    bool bAllowCarrying;                                                              // 0x024E (size: 0x1)
    bool bAllowFreeArranging;                                                         // 0x024F (size: 0x1)
    FName AnimCommand;                                                                // 0x0250 (size: 0x8)
    float InteractionActionDeltaTime;                                                 // 0x0258 (size: 0x4)
    FName ProfileDataId;                                                              // 0x025C (size: 0x8)
    char padding_1[0x4];                                                              // 0x0264 (size: 0x4)
    FSBInteractionTargetComponentOnInteractionDelegate OnInteractionDelegate;         // 0x0268 (size: 0x10)
    void SBInteractionDelegate(class AActor* InOtherActor, const FRotator& ViewRotation);

    void SetNamePlate(class USBNamePlateWidget* NamePlate);
    void SetInteractionActive(bool Flag);
    bool IsInteractionActive();
    FVector GetSelectCursorLocation();
    FName GetProfileDataId();
    FVector GetLookAtLocation();
}; // Size: 0x290

class USBInterruptQuestManager : public UObject
{
    FSBInterruptQuestManagerOnStartInterruptQuestDelegete OnStartInterruptQuestDelegete; // 0x00A0 (size: 0x10)
    void OnStartInterruptQuestDelegete(const class ASBInterruptQuestInstance* InInstance);
    FSBInterruptQuestManagerOnEndInterruptQuestDelegete OnEndInterruptQuestDelegete;  // 0x00B0 (size: 0x10)
    void OnEndInterruptQuestDelegete(const class ASBInterruptQuestInstance* InInstance);
    FSBInterruptQuestManagerOnStartCheckInterruptQuestDelegete OnStartCheckInterruptQuestDelegete; // 0x00C0 (size: 0x10)
    void OnStartCheckInterruptQuestDelegete(bool Start);

    int32 GetInterruptQuestInstanceNum();
    class ASBInterruptQuestInstance* GetInterruptQuestInstance(const int32 InIndex);
    bool CheckInteractionObjectAppeared(const FName& InProfileDataId);
}; // Size: 0xD0

class USBItemAppraisalResultWidget : public USBUserWidget
{
    EItemAppraisalResultPhase NowPhase;                                               // 0x02B0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x02B1 (size: 0x7)
    class USBOwnItemListContainer* MovedAppraisedItems;                               // 0x02B8 (size: 0x8)
    class USBOwnItemListContainer* MovedUnidentifiedItems;                            // 0x02C0 (size: 0x8)
    class USBOwnItemListContainer* Saleitems;                                         // 0x02C8 (size: 0x8)
    int32 SalePrice;                                                                  // 0x02D0 (size: 0x4)
    char padding_1[0x4];                                                              // 0x02D4 (size: 0x4)
    class USBOwnItemListContainer* MoveditemsAll;                                     // 0x02D8 (size: 0x8)
    FSBItemAppraisalResultWidgetOnClose OnClose;                                      // 0x02E0 (size: 0x10)
    void OnCloseItemAppraisalResult();

    void SetAppraisalItems(class USBOwnItemListContainer* InMovedUnidentifiedItems, class USBOwnItemListContainer* InMovedAppraisedItems, class USBOwnItemListContainer* InSaleUnidentifiedItems, class USBOwnItemListContainer* InSaleAppraisedItems, int32 InSalePrice);
    void OnCloseItemAppraisalResult__DelegateSignature();
}; // Size: 0x2F0

class USBItemBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool WeaponPerkNotEquals(const FSBCharacterWeaponPerkData& Lhs, const FSBCharacterWeaponPerkData& rhs);
    bool WeaponPerkEquals(const FSBCharacterWeaponPerkData& Lhs, const FSBCharacterWeaponPerkData& rhs);
    void SortFilter(class UObject* InWorldContextObject, class USBOwnItemListContainer* Container, TEnumAsByte<ESBItemSortType::Type> SortType, const TArray<FFilterGroup>& Filters);
    bool IsWeaponPerkEqual(const FSBWeaponItemData& Prev, const FSBWeaponItemData& After, int32 SlotNo);
    bool IsValidOwnItem(const FOwnItemInfo& Info);
    bool IsSlotOpenable(const FOwnItemInfo& Info);
    bool IsProtectorCategoryAccessory(const EProtectorCategory InProtectorCategory);
    bool IsInvalidFusionItem(const FOwnItemInfo& Weapon, const int32 FusionItemId);
    bool IsFusionAbleWeapon(const FOwnItemInfo& Info);
    bool IsFusionAbleItem(const FOwnItemInfo& Weapon, const int32 FusionItemId);
    bool IsCompositWearCostumeByMasterData(const FSBMasterCostume& InCostumeMaster);
    bool IsCompositWearCostume(int32 InCostumeId);
    bool IsBPPtExchangable(const FOwnItemInfo& Info);
    bool IsBilling(const FOwnItemInfo& Info);
    bool IsActiveEfficacyType(class UObject* InWorldContextObject, const EItemEfficacyType InEfficacyType);
    bool HasConditionItem(const int32 ItemId, const EItemType ItemType);
    int32 GetWeaponStatus(class UObject* InWorldContextObject, const FOwnItemInfo& item, ESBWeaponStatus Status, bool bLevelSync);
    int32 GetStackBNum(const FOwnItemInfo& Info);
    ESBRarity GetItemRarity(const EItemType InItemType, const int32 InItemIndex);
    bool GetItemName(EItemType InType, int32 InIndex, FString& OutName);
    int32 GetItemLevel(const FOwnItemInfo& Info);
    int32 GetItemDefaultOrderInt(class UObject* InWorldContextObject, const FString InUniqueId, const int32 StorageNumber);
    FImagineParameter GetImagineStatus(class UObject* InWorldContextObject, const FOwnItemInfo& item, bool bLevelSync);
    int32 GetConvertExp(const FOwnItemInfo& Info);
    FTimespan GetConditionLimit(const int32 ItemId, const EItemType ItemType);
    int32 GetAllStoragesAmount(class UObject* InWorldContextObject, EItemType ItemType, int32 ItemIndex);
    bool FindCharacterStorageEquipment(class UObject* InWorldContextObject, FOwnItemInfo& OutResult, const FString InUniqueId, const int32 InStorageId);
    FOwnItemInfo FindCharacterEquipmentItem(class UObject* InWorldContextObject, bool& bIsValid, ESBCharaEquipType EquipType);
    bool FindCharacterEquipment(class UObject* InWorldContextObject, FOwnItemInfo& OutResult, FString InUniqueId, const bool bInSearchStorage);
    FSBActiveItemData FindActiveItemByEfficacyType(class UObject* InWorldContextObject, const EItemEfficacyType InEfficacyType, bool& bOutExist);
    void DumpOwnItemData(const FOwnItemInfo& Info);
    class USBTemporallyStorage* CreateCombinedBox(class USBOwnItemListContainer* ContainerLhs, class USBOwnItemListContainer* ContainerRhs);
    bool ContainsLockedItem(const class USBTemporallyStorage* Storage);
    bool ContainsBattleSetItem(class UObject* InWorldContextObject, const class USBTemporallyStorage* Storage);
    void CheckOwnItemEquips(class UObject* InWorldContextObject, class USBOwnItemListContainer* Container);
    ESBItemUseStatus CanPlayerUseCheerfulItem(class UObject* InWorldContextObject);
}; // Size: 0x28

class USBItemFilterWidgetBase : public UUserWidget
{
    FFilterGroup Filters;                                                             // 0x0278 (size: 0x10)

    void UnRegisterFilterType(TEnumAsByte<EItemFilterType::Type> Type);
    void ResetAllFilter();
    void ResetAll();
    void RegisterFilterType(TEnumAsByte<EItemFilterType::Type> Type);
    FFilterGroup GetFilters();
}; // Size: 0x288

class USBItemSelector : public UUserWidget
{
    class UWidgetSwitcher* Switcher;                                                  // 0x0278 (size: 0x8)
    class USBItemSelectorList* ItemIconList;                                          // 0x0280 (size: 0x8)
    class USBItemSelectorArrow* ArrowLeft;                                            // 0x0288 (size: 0x8)
    class USBItemSelectorArrow* ArrowRight;                                           // 0x0290 (size: 0x8)
    class USBItemSelectorNamePlate* SelectItemNamePlate;                              // 0x0298 (size: 0x8)
    ESBUIKeyConfigAction KeyUse;                                                      // 0x02A0 (size: 0x1)
    ESBUIKeyConfigAction KeyLeft;                                                     // 0x02A1 (size: 0x1)
    ESBUIKeyConfigAction KeyRight;                                                    // 0x02A2 (size: 0x1)
    char padding_0[0x1];                                                              // 0x02A3 (size: 0x1)
    FLinearColor ColorActive;                                                         // 0x02A4 (size: 0x10)
    FLinearColor ColorInactive;                                                       // 0x02B4 (size: 0x10)

    void Use();
    void UpdateList(bool IsSetup);
    void SetupList();
    void SetupKeyTextUse();
    void SetupKeyTextRight();
    void SetupKeyTextLeft();
    void SetOptionEditMode(bool IsOptionEditMode);
    void SetEnable(bool Flag);
    void OnUnbind();
    void OnTerminate();
    void OnShowCoolTime();
    void OnPlaySESelect();
    void OnPlaySECanNotUse(ESBItemUseStatus InUseStatus);
    void OnInitialize();
    void OnHiddenCoolTime();
    void OnBind();
    void Move(bool IsLeft);
    bool IsSetupList();
    bool IsRegistItemForInventoryData(const FOwnItemInfo& InItemInfo);
    bool IsRegistItem(int32 InItemIndex, bool IsCanUse);
    bool IsEnable();
    void HiddenCoolTime();
    FText GetCurrentItemName();
}; // Size: 0x2E0

class USBItemSelectorArrow : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void PlayAnim();
}; // Size: 0x278

class USBItemSelectorIcon : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void Setup(int32 InItemIndex, int32 InAmount);
    void PlayAnimationScaleUp();
    void PlayAnimationScaleDown();
    void PlayAnimationRight();
    void PlayAnimationLeft();
    void Empty();
}; // Size: 0x278

class USBItemSelectorList : public UUserWidget
{
    class UHorizontalBox* HBItemIconList;                                             // 0x0278 (size: 0x8)

}; // Size: 0x280

class USBItemSelectorNamePlate : public UUserWidget
{
    class UTextBlock* TextItemName;                                                   // 0x0278 (size: 0x8)

}; // Size: 0x280

class USBJointGestureComponent : public USBPlayerPropertyComponent
{
    FSBJointGestureComponentOnUpdateJointGestureStatusDelegate OnUpdateJointGestureStatusDelegate; // 0x00B8 (size: 0x10)
    void OnUpdateGestureDelegate();
    FSBPlayerJointGestureInfo JointGestureInfo;                                       // 0x00C8 (size: 0x14)
    TWeakObjectPtr<class ASBPlayerCharacter> JointPlayerCharacter;                    // 0x00DC (size: 0x8)

    void SetStatusType(TEnumAsByte<ESBJointGestureStatusType> Type);
    void SetJankenUI(bool Visible);
    void SetJankenHandType(TEnumAsByte<ESBJankenHandType> InHandType);
    void Server_UpdateJointGestureInfo(const FSBPlayerJointGestureInfo& Info, bool ResetJointPlayer, bool RequestSameForJointPlayer);
    void Server_SetStatusType(TEnumAsByte<ESBJointGestureStatusType> Type);
    void Server_SetJointPlayerCharacterAndStatusType(class ASBPlayerCharacter* TargetPlayerCharacter, TEnumAsByte<ESBJointGestureStatusType> Type);
    void Server_SetJointGestureInfo(const FName& EmoteName, const class ASBPlayerCharacter* TargetPlayer);
    void Server_RequestJankenWaitStart(class ASBPlayerCharacter* Player, class ASBPlayerCharacter* TargetPlayer);
    void Server_RequestJankenStart(class ASBPlayerCharacter* TargetPlayer);
    void Server_RequestHandHoldingWaitStart(class ASBPlayerCharacter* Player, class ASBPlayerCharacter* TargetPlayer);
    void Server_RequestHandHoldingStart(class ASBPlayerCharacter* TargetPlayer);
    void ResetJointPlayerCharacter(bool RequestSameForJointPlayer);
    void RequestJankenWaitStart(const class UObject* WorldContextObject, class ASBPlayerCharacter* TargetPlayerCharacter);
    void RequestHandHoldingWaitStart(const class UObject* WorldContextObject, class ASBPlayerCharacter* TargetPlayerCharacter);
    void PushSystemLog(const FString Message);
    void OnUpdateGestureDelegate__DelegateSignature();
    void OnRep_JointPlayerCharacter();
    void OnRep_JointGestureInfo();
    void Multicast_UpdateJointGestureInfo(const FSBPlayerJointGestureInfo& Info, bool ResetJointPlayer, bool RequestSameForJointPlayer);
    void Multicast_SetStatusType(TEnumAsByte<ESBJointGestureStatusType> Type);
    void Multicast_SetJointPlayerCharacterAndStatusType(class ASBPlayerCharacter* TargetPlayerCharacter, TEnumAsByte<ESBJointGestureStatusType> Type);
    bool IsJankenWait();
    bool IsJankenUI();
    bool IsHandHoldingWait();
    bool IsHandHolding();
    class ASBPlayerCharacter* GetTargetJointGestureInfo(FSBPlayerJointGestureInfo& OutTargetInfo);
    TEnumAsByte<ESBJointGestureStatusType> GetStatusType();
    TEnumAsByte<ESBJankenHandType> GetResultHandType(bool IsTargetPlayer);
    FSBPlayerJointGestureInfo GetJointGestureInfo();
    void Client_SetResultTargetHandType(TEnumAsByte<ESBJankenHandType> Type);
    void Client_SetResultHandType(TEnumAsByte<ESBJankenHandType> Type);
}; // Size: 0xF0

class USBKeyConfigData : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBKeyConfigDatas Data;                                                           // 0x0050 (size: 0x10)

}; // Size: 0x60

class USBKeyGuideHUDWidget : public UUserWidget
{
    bool bIsOpen;                                                                     // 0x0278 (size: 0x1)

    void OnReset();
    void OnPlayAnim(bool bOpen);
    void OnInit();
    bool IsPlayAnimation();
}; // Size: 0x280

class USBLancerChangeDamageReactionAtErasedLancerMarkPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<int32> ConditionList;                                                      // 0x0040 (size: 0x10)
    float DamageReactionValue;                                                        // 0x0050 (size: 0x4)

}; // Size: 0x58

class USBLancerElementDamageAtErasedLancerMarkPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<int32> ConditionList;                                                      // 0x0040 (size: 0x10)
    TArray<FSBConditionCheckIntParam> ElementDamageList;                              // 0x0050 (size: 0x10)

}; // Size: 0x60

class USBLancerEscapeJumpSkill : public USBLancerSkillInfo
{
    char padding_0[0x2A8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2A8

class USBLancerMainActionSkill : public USBLancerSkillInfo
{
    float ChargeAttackInputTime;                                                      // 0x02A8 (size: 0x4)
    float ChargeAttackRecastTime;                                                     // 0x02AC (size: 0x4)
    TArray<FSBEffectAsset> ChargeEffectList;                                          // 0x02B0 (size: 0x10)
    TArray<FSBEffectAsset> ChargingEffectList;                                        // 0x02C0 (size: 0x10)

    bool IsInputChargeMainAttack(class ASBPlayerCharacter* PlayerCharacter);
}; // Size: 0x2D0

class USBLancerPrepareStyleSkill : public USBLancerSkillInfo
{
    TArray<FSBStatusAilmentHandle> MarkCountStatusAilmentList;                        // 0x02A8 (size: 0x10)
    TArray<FSBConditionCheckFloatParam> MarkCountStatusTimeModifyList;                // 0x02B8 (size: 0x10)
    TArray<FSBLancerPrepareStyleMarkCountSetting> MarkCountSettingList;               // 0x02C8 (size: 0x10)
    float AttackUpTime;                                                               // 0x02D8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02DC (size: 0x4)
    TArray<FSBConditionCheckFloatParam> AttackUpTimeModifyList;                       // 0x02E0 (size: 0x10)

}; // Size: 0x2F0

class USBLancerResonanceSpearSkill : public USBLancerSkillInfo
{
    FSBAttackID AttackID;                                                             // 0x02A8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02AC (size: 0x4)
    FDataTableRowHandle LancerMarkSpreadProjectileHandle;                             // 0x02B0 (size: 0x10)
    FSBEffectAsset SpreadHitEffect;                                                   // 0x02C0 (size: 0x1A8)
    TArray<FSBLancerResonanceSpearLancerMarkSpreadSetting> LancerMarkSpreadSettingList; // 0x0468 (size: 0x10)
    TArray<FSBLancerResonanceSpearMaxNumSpreadCharacterSetting> MaxNumSpreadCharacterSettingList; // 0x0478 (size: 0x10)
    TArray<FSBConditionCheckParam> SpreadDamageUpRateConditionList;                   // 0x0488 (size: 0x10)
    FSBAttackID SpreadDamageAttackID;                                                 // 0x0498 (size: 0x4)
    float SpreadDamageUpRate;                                                         // 0x049C (size: 0x4)
    TArray<FSBConditionCheckParam> ResetLancerMarkRemainTimeConditionList;            // 0x04A0 (size: 0x10)

}; // Size: 0x4B0

class USBLancerSkillInfo : public USBSkillInfoClass
{
    bool bCorrespondToPrepareStyle;                                                   // 0x02A0 (size: 0x1)
    bool bHideSpearByLaunchProjectile;                                                // 0x02A1 (size: 0x1)

}; // Size: 0x2A8

class USBLancerThunderThrustSkill : public USBLancerSkillInfo
{
    FSBPlayerSkillChargeSetting ChargeSkillSetting;                                   // 0x02B0 (size: 0x28)

}; // Size: 0x2D8

class USBLargeShieldCollisionComponent : public UASCollisionBoxComponent
{
    char padding_0[0x4B0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x4B0

class USBLayoutWindowSizeData : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBHUDLayoutWindowSizeDatas Data;                                                 // 0x0050 (size: 0x50)

}; // Size: 0xA0

class USBLayoutableHUD : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    class USBWholeMap* GetWholemapWidget();
    class USBShortcutRingWidget* GetShortcutRing();
    class USBPlayerGaugeBaseWidget* GetPlayerGaugeBaseWidget();
    class USBStepList* GetNewStepListWidget();
    class USBMiniMapWidget* GetMinimapWidget();
}; // Size: 0x278

class USBLevelBuddyVoiceComponent : public USceneComponent
{
    char padding_0[0x210];                                                            // 0x0000 (size: 0x0)

    void NotifyConditionId(ESBLevelBuddyVoiceCondition Condition);
}; // Size: 0x210

class USBLevelEditorPlaySettings : public UObject
{
    int32 MaxPlayers;                                                                 // 0x0028 (size: 0x4)
    bool bConnectOtherHost;                                                           // 0x002C (size: 0x1)
    char padding_0[0x3];                                                              // 0x002D (size: 0x3)
    FString HostIpAddress;                                                            // 0x0030 (size: 0x10)
    int32 HostPortNumber;                                                             // 0x0040 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0044 (size: 0x4)
    FString AdditionalOptions;                                                        // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBLevelNavModifyControl : public UBillboardComponent
{
    bool bEditable;                                                                   // 0x0489 (size: 0x1)
    bool bShowAlways;                                                                 // 0x048A (size: 0x1)
    bool bShowThisLevel;                                                              // 0x048B (size: 0x1)
    char padding_0[0x4];                                                              // 0x048C (size: 0x4)
    TArray<FName> UseSublevelName;                                                    // 0x0490 (size: 0x10)

    void UpdateVisibilityStatus();
    void UpdateShowHideInLevel();
    void ToggleShowAlways();
    void ShowInTheSublevel();
    bool ShowInSublevel(FName SublevelId);
    void SetShowAlways(bool sw);
    void ResetShowHideInLevel(FName CurrentName);
    void HideInTheSublevel();
    bool HideInSublevel(FName SublevelId);
}; // Size: 0x4A0

class USBLevelSequencePlayer : public ULevelSequencePlayer
{
    char padding_0[0x608];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x608

class USBLevelupBase : public USBUserWidget
{
    FSBLevelupBaseOnFinished OnFinished;                                              // 0x02B0 (size: 0x10)
    void OnFinishedLevelUp(const class USBLevelupBase* Target);

    void PlayLevelUp();
    void OnFinishedLevelUp__DelegateSignature(const class USBLevelupBase* Target);
    void FinishLevelUp();
}; // Size: 0x2C0

class USBLibraryBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    TArray<FSBTutorialHelpData> SortTutorialHelpDataArray(TArray<FSBTutorialHelpData>& TutorialHelpList, const TMap<class FName, class FName>& RowNameMap, const TArray<FName>& ReadList);
    void SetupLibraryEnemyModel(class ASBEnemyCharacter* EnemyActor, class ASBLibraryEnemyLoadCheck* OnLoadFunction);
    void SetLibraryEnemyPartsBreakState(class ASBEnemyCharacter* EnemyActor, TArray<FSBLibraryEnemyPartsBreakData>& TargetPartsList, bool IsBreak);
    void SetLibraryEnemyId(class ASBEnemyCharacter* EnemyActor, FString EnemyId);
    void Request_LibraryWeaponObtainedIdList(class ASBPlayerController* PlayerController, class UObject* CallbackObject, bool InIsStartSequence);
    void Request_LibraryItemObtainedIdList(class ASBPlayerController* PlayerController, class UObject* CallbackObject, bool InIsStartSequence);
    void Request_LibraryEnhanceImagineObtainedIdList(class ASBPlayerController* PlayerController, class UObject* CallbackObject, bool InIsStartSequence);
    void Request_LibraryBattleImagineObtainedIdList(class ASBPlayerController* PlayerController, class UObject* CallbackObject, bool InIsStartSequence);
    void LibraryEnemyModelLoadRequest(FName EnemyId, class ASBLibraryEnemyLoadCheck* OnCompleteFunc, bool& Result);
    bool IsUnreadEnableBookmarkCategory(ESBTutorialHelpCategoryType InCategoryType);
    bool IsReadWeaponData(class UObject* InWorldContextObject, FString CharacterId, int32 WeaponID);
    bool IsReadNameList(TArray<FName> CheckList, TArray<FName> ReadList);
    bool IsReadName(FName CheckName, TArray<FName> ReadList);
    bool IsReadList(TArray<int32> CheckList, TArray<int32> ReadList);
    bool IsReadItemData(class UObject* InWorldContextObject, FString CharacterId, int32 ItemId);
    bool IsReadImagineData(class UObject* InWorldContextObject, FString CharacterId, int32 ImagineId, ELibraryImagineType ImagineType);
    bool IsRead(int32 CheckNum, TArray<int32> ReadList);
    bool IsNotUnreadBookmark(FName RowName);
    bool IsNewInformationEnemyLibrary(class UObject* WorldContextObject, const class UDataTable* EnemyDataTable);
    bool IsNewInformationAwardLibrary(class UObject* WorldContextObject);
    bool IsNewInformationAchievementLibrary(class UObject* WorldContextObject);
    bool IsNewInformatioAddLibraryPic(class UObject* WorldContextObject, FString CharacterId);
    bool IsExistActiveLoginBonus(class APlayerController* PlayerController);
    bool IsAllReadDefaultBookmark(FString CharacterId, class USBCharactersLogComponent* CharacterComponent, const class UDataTable* DataTable);
    bool IsAllReadBookmark(FString CharacterId, class USBCharactersLogComponent* CharacterComponent);
    TArray<FSBWeaponMasterData> GetWeaponList(class ASBPlayerController* PlayerController);
    TArray<bool> GetReadWeaponCategoryList(class UObject* InWorldContextObject, FString CharacterId, const TArray<ESBClassType>& ClassTypeList);
    TArray<bool> GetReadItemCategoryList(class UObject* InWorldContextObject, FString CharacterId);
    TArray<bool> GetReadImagineCategoryList(class UObject* InWorldContextObject, FString CharacterId, ELibraryImagineType ImagineType, const TArray<FName>& CategoryList);
    TArray<FName> GetNotUnreadBookmarkList();
    void GetLibraryEnemyTypeData(FName ModelId, FSBEnemyTypeData& OutData, bool& IsValid);
    void GetLibraryEnemySize(class ASBEnemyCharacter* EnemyActor, FVector& Size, FVector2D& SideBottom);
    void GetLibraryEnemyResistElement(class ASBPlayerController* PlayerController, FName EnemyId, TArray<int32>& OutList);
    void GetLibraryEnemyRaceIndexList(const FSBTextTableHash& RaceId, TArray<FSBLibraryEnemyData>& InList, TArray<int32>& IndexList);
    void GetLibraryEnemyPartsBreakData(class ASBEnemyCharacter* EnemyActor, TArray<FSBLibraryEnemyPartsBreakData>& OutPartsData);
    void GetLibraryEnemyModelPath(FName ModelId, FSoftObjectPath& OutData, bool& IsValid);
    void GetLibraryEnemyList(class ASBPlayerController* PlayerController, TArray<FSBLibraryEnemyData>& EnemyList, const class UDataTable* DataTable);
    void GetLibraryEnemyKillCount(FName EnemyId, FSBLibraryEnemyData& InData, int32& OutTargetCount, int32& OutSumCount);
    void GetLibraryEnemyDropIconTypeMulti(int32 DropId, TArray<ESBLibraryEnemyDropItemIconType>& IconTypes, TArray<int32>& ItemIds);
    void GetLibraryEnemyDropIconType(int32 DropId, int32 LotIndex, ESBLibraryEnemyDropItemIconType& IconType, int32& ItemId);
    void GetLibraryEnemyDebugModelID(FName EnemyId, FString& ID);
    void GetLibraryEnemyDebugFlag(class ASBPlayerController* PlayerController, bool& Flag);
    void GetLibraryEnemyAttribute(int32 AttributeData, TArray<int32>& OutList);
    TArray<int32> GetItemMakeList(class UObject* InWorldContextObject, int32 ItemId);
    TArray<FItemMasterData> GetItemList(class ASBPlayerController* PlayerController);
    FMasterImagineRecepi GetImagineRecepiDataByImagineId(const int32 ImagineId);
    TArray<FEnemyParamMasterData> GetEnemyList(class ASBPlayerController* PlayerController);
    int32 GetEnemyHPRank(FString EnemyId, int32 Level);
    int32 GetEnemyAttackRank(FString EnemyId, int32 Level);
    FCraftMasterData GetCraftMasterDataByWeaponId(const int32 WeaponID);
    bool ForceReadNewInformationEnemyLibrary(class UObject* WorldContextObject, const class UDataTable* EnemyDataTable);
    bool ForceNewInformationTheatreLibrary(class UObject* WorldContextObject);
    bool ForceNewInformationAwardLibrary(class UObject* WorldContextObject);
    bool ForceNewInformationAchievementLibrary(class UObject* WorldContextObject);
    bool ForceNewAllReadBookmark(class UObject* WorldContextObject, const class UDataTable* DataTable);
}; // Size: 0x28

class USBLibraryMenuItemList : public USBCommandMenuChildBase
{
    char padding_0[0x2A8];                                                            // 0x0000 (size: 0x0)

    void GetWeaponList(TArray<FSBWeaponMasterData>& OutList);
    void GetMountImagineList(TArray<FSBMasterMountImagine>& OutList);
    void GetItemList(TArray<FItemMasterData>& OutList);
    void GetImagineList(TArray<FSBMasterImagine>& OutList);
    void GetEnemyList(TArray<FEnemyParamMasterData>& OutList);
}; // Size: 0x2A8

class USBLibrarySaveGame : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBLibrarySaveData Data;                                                          // 0x0050 (size: 0x218)

    bool SaveLibraryData();
    bool LoadLibraryData();
}; // Size: 0x268

class USBLibrarySaveManager : public UObject
{
    char padding_0[0x248];                                                            // 0x0000 (size: 0x0)

    void SetTheaterModeInfo_SelectedIndex(int32 CategoryId, int32 ListId, float CategoryOffset, float ListOffset);
    void SetTheaterModeInfo_IsPlayDemo(bool IsPlayDemo);
    void SetReadWeaponList(FString CharacterId, const FSBLibraryWeaponSaveData WeaponSaveData);
    void SetReadMountImagineIdList(const TArray<int32>& ReadList);
    void SetReadMonsterList(const TArray<FSBLibraryEnemyReadData>& ReadList);
    void SetReadMonsterIdList(const TArray<FName>& ReadList);
    void SetReadMonsterDataCount(FName ID, int32 Index, int32 Count);
    void SetReadMonsterData(FSBLibraryEnemyReadData ReadData);
    void SetReadMonsterAreaIdList(FName ID, const TArray<FName>& IDList);
    void SetReadItemList(FString CharacterId, const FSBLibraryItemSaveData ItemSaveData);
    void SetReadImagineList(FString CharacterId, const FSBLibraryImagineSaveData ImagineSaveData, ELibraryImagineType ImagineType);
    void SetReadDemoIdList(const TArray<FName>& ReadList);
    void SetReadBookmarkList(FString CharacterId, const TArray<FName>& ReadList);
    void SetReadAwardIdList(const TArray<int32>& ReadList);
    void SetReadAchievementIdList(const TArray<int32>& ReadList);
    bool SaveLibraryData(FString PlayerId);
    FSBLibrarySaveData LoadLibraryData(FString PlayerId);
    bool IsLoadedLibraryData();
    FSBTheaterModeInfo GetTheaterModeInfo();
    TArray<FSBReadLibraryWeaponData> GetReadWeaponList(FString CharacterId);
    FSBReadLibraryWeaponData GetReadWeapon(FString CharacterId, const int32 WeaponID);
    TArray<int32> GetReadMountImagineIdList();
    void GetReadMonsterList(TArray<FSBLibraryEnemyReadData>& ReadList);
    TArray<FName> GetReadMonsterIdList();
    void GetReadMonsterDataCount(FName ID, int32 Index, int32& Count);
    void GetReadMonsterData(FName ID, FSBLibraryEnemyReadData& ReadData);
    void GetReadMonsterAreaIdList(FName ID, TArray<FName>& IDList);
    void GetReadItemMakeList(FString CharacterId, const int32 ItemId, TArray<int32>& OutReadMakeList);
    TArray<FSBReadLibraryItemData> GetReadItemList(FString CharacterId);
    FSBReadLibraryItemData GetReadItem(FString CharacterId, const int32 ItemId);
    TArray<FSBReadLibraryImagineData> GetReadImagineList(FString CharacterId, ELibraryImagineType ImagineType);
    FSBReadLibraryImagineData GetReadImagine(FString CharacterId, const int32 ImagineId, ELibraryImagineType ImagineType);
    TArray<FName> GetReadDemoIdList();
    TArray<FName> GetReadBookmarkList(FString CharacterId);
    TArray<int32> GetReadAwardIdList();
    TArray<int32> GetReadAchievementIdList();
    bool FindReadMonsterIdList(FName EnemyId);
    void AddReadWeaponList(FString CharacterId, const FSBReadLibraryWeaponData& WeaponData);
    void AddReadMountImagineIdList(const int32& ID);
    void AddReadMonsterIdList(const FName& ID);
    void AddReadMonsterData(FSBLibraryEnemyReadData ReadData);
    void AddReadItemList(FString CharacterId, const FSBReadLibraryItemData& ItemData);
    void AddReadImagineList(FString CharacterId, const FSBReadLibraryImagineData& ImagineData, ELibraryImagineType ImagineType);
    void AddReadDemoIdList(const FName& DemoId);
    void AddReadBookmarkList(FString CharacterId, const FName& BookmarkName);
    void AddReadAwardIdList(const int32& Index);
    void AddReadAchievementIdList(const int32& Index);
}; // Size: 0x248

class USBLightScheduleComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)

    void UpdateAllLightComponents(float Rate, TMap<ULightComponent*, float> LightComponents, TArray<FSBLightMaterialSchedule> Materials);
    int32 GetNowHourMinInteger(class ASBSkySphere* InDynamicSky, int32 DefaultTime);
    bool EditorPreview(float TimeRate, bool sw);
    bool CheckTimeFadeStatus(float InFadeDuration, int32 InCurrentTime, const TArray<int32>& InLightOnTime, const TArray<int32>& InLightOffTime, int32& OutLastTime, float& OutFadeRate);
    int32 AddIntGameTime(int32 InGameTime, int32 InAddTime);
}; // Size: 0xB8

class USBLineOfSightComponent : public USceneComponent
{
    float Pupil_X;                                                                    // 0x0210 (size: 0x4)
    float Pupil_Y;                                                                    // 0x0214 (size: 0x4)

    void AttachTarget(class USceneComponent* InParent);
}; // Size: 0x220

class USBLineSoundComponent : public USBShapeSoundBaseComponent
{
    bool bIsRelative;                                                                 // 0x0418 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0419 (size: 0x7)
    TArray<FSBLineSoundData> LineDataArray;                                           // 0x0420 (size: 0x10)

    void SetLine(bool InIsRelative, FVector StartPoint, FVector EndPoint);
}; // Size: 0x430

class USBListBox : public UScrollBox
{
    bool bLoop;                                                                       // 0x08A8 (size: 0x1)
    bool bInputEnable;                                                                // 0x08A9 (size: 0x1)
    char padding_0[0x2];                                                              // 0x08AA (size: 0x2)
    int32 SelectItem;                                                                 // 0x08AC (size: 0x4)
    FSBListBoxOnChangeSelectItemDelegate OnChangeSelectItemDelegate;                  // 0x08B0 (size: 0x10)
    void OnChangeSelectItemDelegate(int32 PrevWidget, int32 NewWidget);
    FSBListBoxOnPressOkItemDelegate OnPressOkItemDelegate;                            // 0x08C0 (size: 0x10)
    void OnPressOkItemDelegate(int32 SelectItem);

    void SetSelectItemAt(int32 InIndex);
    void SetSelectItem(class UWidget* InWidget);
}; // Size: 0x8D0

class USBLoadingBase : public USBUserWidget
{
    ELoadingType LoadingType;                                                         // 0x02B4 (size: 0x1)
    char padding_0[0x3];                                                              // 0x02B5 (size: 0x3)
    FName GameContentId;                                                              // 0x02B8 (size: 0x8)

    void Show();
    void SetLoadingType(ELoadingType Type);
    void SetGameContentID(FName GameContentId);
    class UTexture2D* LoadFromPath(const FString InPath);
    class UObject* LoadFromDungeonID();
    int32 GetRandomRange(int32 Min, int32 Max, bool bBeforeOverlap);
    ELoadingType GetLoadingType();
    FName GetGameContentID();
}; // Size: 0x2C0

class USBLocalPlayer : public ULocalPlayer
{
    char padding_0[0x368];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x368

class USBLocationAnchorRenderingComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBLocationInfoManager : public UObject
{
    TArray<class UDataTable*> LocationInfoArray;                                      // 0x0028 (size: 0x10)

    FSBLocationInfo BP_Find(const FName InLocationID, bool& bOutExist);
}; // Size: 0x38

class USBLoggerBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void LogMetricsResetBattleArea(const class AActor* BattleArea);
}; // Size: 0x28

class USBLoginBonusWindow : public USBUserWidget
{
    FSBLoginBonusWindowFinishDelegate FinishDelegate;                                 // 0x02B0 (size: 0x10)
    void FinishDelegate();
    FSBLoginBonusWindowNoticeCheckCompleteDelegate NoticeCheckCompleteDelegate;       // 0x02C0 (size: 0x10)
    void NoticeCheckCompleteDelegate(int32 DataCount);

    void NoticeCheckCompleteDelegate__DelegateSignature(int32 DataCount);
    void GetTypeCount(int32& Count);
    void GetLoginBonusData(int32 Index, FSBLoginBonusWindowData& LoginBonusData, bool& Valid);
    void GetLoginBonusAllData(int32 Index, TArray<FSBLoginBonusWindowData>& LoginBonusData, bool& Valid);
    void GetDetail_Callback(const bool bWasSuccessful, const int32 ErrorCode);
    void GetActiveList_Callback(const bool bWasSuccessful, const int32 ErrorCode);
    void FinishDelegate__DelegateSignature();
    void CheckLoginData_Callback(const bool bWasSuccessful, const int32 ErrorCode);
    void CheckLoginBonusNotice();
    void CheckLoginBonusData();
    void CallFinishEvent();
}; // Size: 0x2F8

class USBLoginSaveGame : public USaveGame
{
    FString EMail;                                                                    // 0x0028 (size: 0x10)
    FString Password;                                                                 // 0x0038 (size: 0x10)
    bool bRemenberMe;                                                                 // 0x0048 (size: 0x1)

}; // Size: 0x50

class USBLoginWidget : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    void OnLoginSuccess();
    void OnLoginFailure(const int32 InRetCode);
    void OnCheckMaintenanceComplete(const bool bCheckSucess, const bool bIsMaintenance);
    void Login(FString EMail, FString Password);
    FString GetUrl(FString InURLName);
    void CheckMaintenance();
    void BNOLauncherLogin(FString AuthToken);
    void BNIDLogin(FString ApiToken);
}; // Size: 0x280

class USBLookAtComponent : public UActorComponent
{
    class USceneComponent* AimArrowComp;                                              // 0x00B8 (size: 0x8)
    FSBCacheBonePosition RootBone;                                                    // 0x00C0 (size: 0x40)
    FSBCacheBonePosition RotateBone;                                                  // 0x0100 (size: 0x40)
    FSBCacheBonePosition AimBone;                                                     // 0x0140 (size: 0x40)
    FAxis AimBoneDirection;                                                           // 0x0180 (size: 0x10)
    FAxis UpBoneDirection;                                                            // 0x0190 (size: 0x10)
    FVector ComponentCurrentTargetLocation;                                           // 0x01A0 (size: 0xC)
    FRotator SpeedMultipleValue;                                                      // 0x01AC (size: 0xC)
    FRotator PowValue;                                                                // 0x01B8 (size: 0xC)
    char padding_0[0x4];                                                              // 0x01C4 (size: 0x4)
    class USceneComponent* AimComponent;                                              // 0x01C8 (size: 0x8)

}; // Size: 0x210

class USBMachineCache : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FSBMachineCacheData Data;                                                         // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBMagicianChargeMagicSkillInfo : public USBMagicianSkillInfo
{
    FSBPlayerSkillChargeSetting ChargeSkillSetting;                                   // 0x02D8 (size: 0x28)

}; // Size: 0x300

class USBMagicianDodgeSkill : public USBDodgeSkillInfo
{
    TArray<FSBConditionCheckFloatParam> CastMPChangeList;                             // 0x02E0 (size: 0x10)

}; // Size: 0x2F0

class USBMagicianElementAmpSkill : public USBSkillInfoClass
{
    TArray<FSBElementAmpOptionLocationSetting> OptionLocationList;                    // 0x02A0 (size: 0x10)
    FSBEffectAsset IdlingEffect;                                                      // 0x02B0 (size: 0x1A8)
    TArray<FSBElementAmpOptionElementSetting> ElementSettingList;                     // 0x0458 (size: 0x10)
    float OptionLocationInterpSpeed;                                                  // 0x0468 (size: 0x4)
    float BackToIdlingEffectTime;                                                     // 0x046C (size: 0x4)

}; // Size: 0x470

class USBMagicianFireBallSkill : public USBMagicianChargeMagicSkillInfo
{
    char padding_0[0x300];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x300

class USBMagicianFireBurnerSkill : public USBMagicianSkillInfo
{
    TArray<FSBConditionCheckFloatParam> ActiveTimeMPChangeList;                       // 0x02D8 (size: 0x10)
    float FiringCameraRotationSpeedLimit;                                             // 0x02E8 (size: 0x4)
    float FireShotRotationSpeedLimitYaw;                                              // 0x02EC (size: 0x4)
    float FireShotRotationDelayDegreeLimitYaw;                                        // 0x02F0 (size: 0x4)
    float FireShotRotationSpeedLimitPitch;                                            // 0x02F4 (size: 0x4)
    float FireShotRotationDelayDegreeLimitPitch;                                      // 0x02F8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02FC (size: 0x4)
    FSBEffectAsset FireShotEffect;                                                    // 0x0300 (size: 0x1A8)
    FSBEffectAsset FireStringEffect;                                                  // 0x04A8 (size: 0x1A8)
    float FireShotLaunchCycle;                                                        // 0x0650 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0654 (size: 0x4)
    TSoftObjectPtr<UCurveFloat> FireShotMoveCurve;                                    // 0x0658 (size: 0x28)
    float FireShotDeactiveTimeRatio;                                                  // 0x0680 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0684 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> ReceiveDamageDownRateSettingList;             // 0x0688 (size: 0x10)

}; // Size: 0x698

class USBMagicianHPDownMPUpPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FMagicianModifyMaxHPMP> ModifyMaxHPMPList;                                 // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBMagicianHailSkill : public USBMagicianChargeMagicSkillInfo
{
    FSBSkillMarkerSetting MarkerSetting;                                              // 0x0308 (size: 0x70)

}; // Size: 0x378

class USBMagicianHealingAreaSkill : public USBMagicianChargeMagicSkillInfo
{
    FSBSkillMarkerSetting MarkerSetting;                                              // 0x0308 (size: 0x70)

}; // Size: 0x378

class USBMagicianMagicBulletSkill : public USBMagicianChargeMagicSkillInfo
{
    char padding_0[0x300];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x300

class USBMagicianMaxMPUpWhileBattleEffectPassiveSkill : public USBPlayerPassiveSkill
{
    ESBAbilityFlags AbilityFlag;                                                      // 0x0040 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0041 (size: 0x3)
    float ModifyAddMaxMP;                                                             // 0x0044 (size: 0x4)

}; // Size: 0x48

class USBMagicianMeteorSkill : public USBMagicianSkillInfo
{
    FSBSkillMarkerSetting MarkerSetting;                                              // 0x02D8 (size: 0x70)

}; // Size: 0x348

class USBMagicianReloadSkill : public USBMagicianSkillInfo
{
    float MPRecoverySpeed;                                                            // 0x02D0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02D4 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> MPRecoverySpeedModifySettingList;             // 0x02D8 (size: 0x10)
    float MPRecoveryAmount;                                                           // 0x02E8 (size: 0x4)
    char padding_1[0x4];                                                              // 0x02EC (size: 0x4)
    TArray<FSBConditionCheckFloatParam> MPRecoveryAmountModifySettingList;            // 0x02F0 (size: 0x10)

}; // Size: 0x300

class USBMagicianSkillInfo : public USBSkillInfoClass
{
    float MagicPoint;                                                                 // 0x02A0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02A4 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> MPCostModifyRateSettingList;                  // 0x02A8 (size: 0x10)
    TArray<FSBConditionCheckFloatParam> MPCostModifyAmountSettingList;                // 0x02B8 (size: 0x10)
    bool EnableElementAmp;                                                            // 0x02C8 (size: 0x1)

}; // Size: 0x2D0

class USBMagicianSubActionReceiveDamageDownPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBConditionCheckFloatParam> ReceiveDamageDownRateSettingList;             // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBMagicianThunderBeamSkill : public USBMagicianChargeMagicSkillInfo
{
    TArray<FSBMagicianShotProjectileLevelSetting> ProjectileLevelSettingList;         // 0x0300 (size: 0x10)

}; // Size: 0x310

class USBMagicianThunderCloudSkill : public USBMagicianSkillInfo
{
    FVector LocationOffset;                                                           // 0x02D0 (size: 0xC)
    char padding_0[0x4];                                                              // 0x02DC (size: 0x4)
    FSBEffectAsset IdlingEffect;                                                      // 0x02E0 (size: 0x1A8)
    float OptionLocationInterpSpeed;                                                  // 0x0488 (size: 0x4)
    char padding_1[0x4];                                                              // 0x048C (size: 0x4)
    TArray<FSBConditionCheckRowHandleParam> LaunchProjectileList;                     // 0x0490 (size: 0x10)
    float LaunchProjectileCycle;                                                      // 0x04A0 (size: 0x4)
    char padding_2[0x4];                                                              // 0x04A4 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> LaunchProjectileCycleModifyList;              // 0x04A8 (size: 0x10)
    float AttackRangeH;                                                               // 0x04B8 (size: 0x4)
    char padding_3[0x4];                                                              // 0x04BC (size: 0x4)
    TArray<FSBConditionCheckFloatParam> AttackRangeHModifyList;                       // 0x04C0 (size: 0x10)
    float AttackRangeV;                                                               // 0x04D0 (size: 0x4)

}; // Size: 0x4D8

class USBMagicianThunderMineSkill : public USBMagicianChargeMagicSkillInfo
{
    TArray<FSBMagicianShotProjectileLevelSetting> ProjectileLevelSettingList;         // 0x0300 (size: 0x10)

}; // Size: 0x310

class USBMagnetMovementComponent : public USBProjectileMovementBaseComponent
{
    class USBProjectileChainMovementParamMovementMagnet* MagnetParam;                 // 0x0140 (size: 0x8)

}; // Size: 0x150

class USBMailAttachmentAcceptBase : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    bool IsVanishment(const TArray<FSBMailData>& MailData);
    bool IsTransferMail(const TArray<FSBMailData>& MailData);
    bool IsPurchaseTokenVanishment(const TArray<FSBMailData>& MailData);
    bool IsOverflow(const TArray<FSBMailData>& MailData);
    bool IsContainsVanishmentItems(const TArray<FSBMailData>& MailData);
    bool IsBagCapacityOver(const TArray<FSBMailData>& MailData, int32& OverType);
    bool IsAccountTypeMail(const TArray<FSBMailData>& MailData);
    void GetOverflowIconStatus(const TArray<FSBMailData>& MailData, TArray<int32>& IconStatus, int32& MarkFlag);
}; // Size: 0x278

class USBMailBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void MailRewardDuplicateCheck(class ASBPlayerController* InPlayerController, ESBRewardItemType RewardType, int32 ID, bool& IsDuplicate);
    bool IsPlayerCharacterItemBagCapacityOverFromMailData(const class UObject* InWorldContextObject, const TArray<FSBMailData>& MailData, int32& OverType);
    bool IsNeedMailAcceptResult(FSBMailRewardData& MailRewardData, class ASBPlayerController* PlayerController);
    bool IsAcceptableMailAttachments(class UObject* InWorldContextObject, const TArray<FSBMailData>& Mails, class ASBPlayerController* InPlayerController);
    TArray<FSBMailData> FilterCoinConvertableMails(TArray<FSBMailData>& Mails);
    int32 ConvertMail2SkyCoin(const TArray<FSBMailData>& Mails);
    bool CheckMailRewardAdventureBoardGet(FSBMailRewardData& MailRewardData, class ASBPlayerController* PlayerController);
    bool CheckMailReadStatus(int32 Status, ESBMailReadStatus Flag);
    int32 CalcMailOverflowAttachmentsItemSaleValue(class UObject* InWorldContextObject, const TArray<FSBMailData>& Mails, class ASBPlayerController* InPlayerController);
}; // Size: 0x28

class USBMailHistory : public USBUserWidget
{
    char padding_0[0x2B0];                                                            // 0x0000 (size: 0x0)

    void Request_History(class ASBPlayerController* InPlayerController);
    void OnCompleted_History(int32 RetCode, const TArray<FSBMailData>& MailData);
}; // Size: 0x2B0

class USBMakeupManager : public UObject
{
    class UDataTable* MakeupDB;                                                       // 0x0028 (size: 0x8)
    class UDataTable* CustomTextureDB;                                                // 0x0030 (size: 0x8)

    class UTexture2D* GetMaskTexture(ESBCharacterGender Gender, ESBMakeupType Type, int32 Index);
}; // Size: 0x60

class USBMap : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    FVector GetTargetWorldLocation(const FName& InTargetId, bool& IsTargetExists);
    FString GetTargetLevelName(const FName& InTargetId, bool& IsTargetExists);
    bool GetQuestTargetWorldLocation(const int32 InQuestIndex, const EQuestStatus InQuestStatus, FString& QuestName, TArray<FName>& OutLocatedLevelNames, TArray<FVector>& OutWorldLocations);
    void GetPartyMember(TArray<class USBPartyMemberState*>& OutPartyMembers, TArray<class ASBPlayerState*>& OutInterruptQuestMembers);
    void GetOccurringInterruptQuestInfos(bool& IsQuestInfoValid, TArray<FMapInterruptQuestInfo>& OutQuestInfos);
    FMapInterruptQuestInfo GetCurrentJoinedInterruptQuestInfo(bool& IsQuestJoined);
}; // Size: 0x278

class USBMapAreaIcon : public USBMapIcon
{
    class UWidgetSwitcher* Root;                                                      // 0x0298 (size: 0x8)
    class UImage* IconInterrupt;                                                      // 0x02A0 (size: 0x8)
    class UImage* AreaInterrupt;                                                      // 0x02A8 (size: 0x8)
    class UImage* AreaQuest;                                                          // 0x02B0 (size: 0x8)

    void Setup(bool InIsInterrupt, const FVector& InLocation, float InRange, const FLinearColor& InColor);
    void SetRange(float InRange);
    void SetQuestInstance(class ASBInterruptQuestInstance* InQuestInstance);
    void SetAreaSize(const FVector2D& InSize);
    float GetRange();
    class ASBInterruptQuestInstance* GetQuestInstance();
    FVector2D GetAreaSize();
}; // Size: 0x2C8

class USBMapBuddyIcon : public USBMapIcon
{
    class UWidgetSwitcher* Root;                                                      // 0x0298 (size: 0x8)
    class UWidgetSwitcher* InSideSwitcher;                                            // 0x02A0 (size: 0x8)
    class UWidgetSwitcher* OutSideSwitcher;                                           // 0x02A8 (size: 0x8)
    class AActor* Buddy;                                                              // 0x02B0 (size: 0x8)

    void Setup(class AActor* InBuddy);
    void SetDead(bool IsDead);
}; // Size: 0x2B8

class USBMapBuffIcon : public USBMapIcon
{
    class UWidgetSwitcher* Root;                                                      // 0x0298 (size: 0x8)
    class UWidgetSwitcher* BuffNPCSwitcher;                                           // 0x02A0 (size: 0x8)
    class UWidgetSwitcher* BuffObjSwitcher;                                           // 0x02A8 (size: 0x8)
    class ASBFieldActorFreeBuffPoint* BuffPoint;                                      // 0x02B0 (size: 0x8)

    void Setup(class ASBFieldActorFreeBuffPoint* InBuffPoint);
}; // Size: 0x2B8

class USBMapCampIcon : public USBMapIcon
{
    char padding_0[0x298];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x298

class USBMapCarryBaseIcon : public USBMapIcon
{
    class UWidgetSwitcher* IconSwitcher;                                              // 0x0298 (size: 0x8)

    void UpdateIcon(int32 MinimapIconParam);
}; // Size: 0x2A0

class USBMapClimbIcon : public USBMapIcon
{
    char padding_0[0x298];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x298

class USBMapEnemyIcon : public USBMapIcon
{
    class UWidgetSwitcher* IconSwitcher;                                              // 0x0298 (size: 0x8)

}; // Size: 0x2A0

class USBMapEngramCannonIcon : public USBMapIcon
{
    class UWidgetSwitcher* IconSwitcher;                                              // 0x0298 (size: 0x8)
    class ASBEngramCannon* EngramCannon;                                              // 0x02A0 (size: 0x8)

    void Setup(class ASBEngramCannon* InEngramCannon);
    class ASBEngramCannon* GetEngramCannon();
}; // Size: 0x2B0

class USBMapFacilityIcon : public USBMapIcon
{
    char padding_0[0x2F0];                                                            // 0x0000 (size: 0x0)

    void Setup(const FName& InNpcProfileID, ESBFacilityType InFacilityType, const FSBCharacterProfileLocationData& InLocationData);
    void OnSetup();
    FName GetNpcProfileID();
    FSBCharacterProfileLocationData GetLocationData();
    ESBFacilityType GetFacilityType();
}; // Size: 0x2F0

class USBMapFishingIcon : public USBMapIcon
{
    char padding_0[0x298];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x298

class USBMapIDIcon : public USBMapIcon
{
    char padding_0[0x2F0];                                                            // 0x0000 (size: 0x0)

    void Setup(const FSBLocationInfo& InLocationInfo, const FName& InLocationID);
}; // Size: 0x2F0

class USBMapIcon : public UUserWidget
{
    class UWidget* IconSize;                                                          // 0x0278 (size: 0x8)
    FVector2D DefaultSize;                                                            // 0x0280 (size: 0x8)
    FVector WorldPosition;                                                            // 0x0288 (size: 0xC)

    void SetWorldPosition(const FVector& InWorldPosition);
    void SetVisible(bool InVisible);
    void SetSizeScale(float InScale);
    void SetSize(const FVector2D& InSize);
    void SetPosition(const FVector2D& InPosition);
    void SetInside(bool IsInSide);
    void SetAngle(float InAngle);
    void OnSetInside(bool IsInSide);
    void OnSetAngle(float InAngle);
    FVector GetWorldPosition();
    FVector2D GetSize();
    FVector2D GetPosition();
}; // Size: 0x298

class USBMapNamedEnemyIcon : public USBMapIcon
{
    char padding_0[0x2A8];                                                            // 0x0000 (size: 0x0)

    void Setup(FString InNamedEnemyID);
    FString GetEnemyId();
}; // Size: 0x2A8

class USBMapPartyMemberIcon : public USBMapIcon
{
    FSBMapPartyMemberIconOnDeadDelegate OnDeadDelegate;                               // 0x0298 (size: 0x10)
    void OnDead(class USBMapPartyMemberIcon* InPartyMemberIcon, bool IsDead);
    class UWidgetSwitcher* Root;                                                      // 0x02A8 (size: 0x8)
    class UWidgetSwitcher* InSideSwitcher;                                            // 0x02B0 (size: 0x8)
    class UWidgetSwitcher* OutSideSwitcher;                                           // 0x02B8 (size: 0x8)
    class ASBPlayerState* PlayerState;                                                // 0x02C0 (size: 0x8)
    class USBPartyMemberState* PartyMemberState;                                      // 0x02C8 (size: 0x8)
    TArray<class ASBCarry*> CarryList;                                                // 0x02D0 (size: 0x10)

    void Setup2(class ASBPlayerState* State);
    void Setup(class USBPartyMemberState* State);
    void SetDeadFlag(bool Flag);
    void SetCarryVisibleFlag(bool Flag);
    void SetCarryingFlag(bool Flag);
    void OnDead__DelegateSignature(class USBMapPartyMemberIcon* InPartyMemberIcon, bool IsDead);
    bool IsPlayerValidHP();
    bool IsPlayerAlive();
    bool IsDeadFlag();
    bool IsCarryVisibleFlag();
    bool IsCarryingFlag();
    FVector GetPlayerPosition();
    void DebugPrint();
}; // Size: 0x2E8

class USBMapPinIcon : public USBMapIcon
{
    class USBTextBoxBase* SBTextBox;                                                  // 0x0298 (size: 0x8)
    FMapPinInfo PinInfo;                                                              // 0x02A0 (size: 0x40)

    void Setup(const FMapPinInfo& InPinInfo, const FVector& InWorldPosition);
    void SetCommentVisible(bool IsVisible);
    void OnSetup();
    FMapPinInfo GetPinInfo();
}; // Size: 0x2E0

class USBMapPlayerIcon : public USBMapIcon
{
    class UImage* CameraDirectionIcon;                                                // 0x0298 (size: 0x8)
    class UWidgetSwitcher* IconSwitcher;                                              // 0x02A0 (size: 0x8)

}; // Size: 0x2A8

class USBMapQuestIcon : public USBMapIcon
{
    char padding_0[0x2A8];                                                            // 0x0000 (size: 0x0)

    void Setup(int32 QuestIndex);
    TArray<int32> GetQuestIndexList();
    void AddQuestIndex(int32 InQuestIndex);
}; // Size: 0x2A8

class USBMapShortPinIcon : public USBMapIcon
{
    class UWidgetSwitcher* InSideSwitcher;                                            // 0x0298 (size: 0x8)
    class UWidgetSwitcher* OutSideSwitcher;                                           // 0x02A0 (size: 0x8)
    FSBShortPinInfo ShortPinInfo;                                                     // 0x02A8 (size: 0x48)

    void Setup(const FSBShortPinInfo& InPinInfo);
    void SetPinInfo(const FSBShortPinInfo& InPinInfo);
    void ResetPinInfo();
    bool GetPinInfo(FSBShortPinInfo& PinInfo);
}; // Size: 0x2F0

class USBMapUpdraftIcon : public USBMapIcon
{
    char padding_0[0x298];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x298

class USBMapWarpIcon : public USBMapIcon
{
    class UImage* Icon;                                                               // 0x0298 (size: 0x8)

    void Setup(FString InLevelName, const FName& InWarpPointId);
}; // Size: 0x2E0

class USBMapWarpIconDungeon : public USBMapIcon
{
    class UImage* Icon;                                                               // 0x0298 (size: 0x8)

    void SetupDungeon(FString InLevelName, const FName& InWarpPointId);
}; // Size: 0x2C0

class USBMapWarpIconEx : public USBMapIcon
{
    class UImage* Icon;                                                               // 0x0298 (size: 0x8)

    void SetupEx(FString InLevelName, const FName& InWarpPointId);
}; // Size: 0x2C0

class USBMapWidgetCloud : public UUserWidget
{
    FSBMapWidgetCloudOnCloudReachedLeftEdgeOfTheScreenDelegate OnCloudReachedLeftEdgeOfTheScreenDelegate; // 0x0278 (size: 0x10)
    void OnCloudReachedLeftEdgeOfTheScreenDelegate();

    void SetLeftEdgePosDiff(const float InLeftEdgePosDiff);
    void SetCloudMoveSpeed(const float InMoveSpped);
    void ResetCloud(const FVector2D& InPosition, const FVector2D& InRenderScale, const float InMoveSpped);
    void OnCloudReachedLeftEdgeOfTheScreenDelegate__DelegateSignature();
    float GetCloudMoveSpeed();
}; // Size: 0x290

class USBMasterDataManager : public UObject
{
    FSBMasterDataStatusList StatusList;                                               // 0x0068 (size: 0x10)

    void OnLocalOverrideAttackMasterDatatableChanged();
    void OnDataAvailableDelegate__DelegateSignature();
    bool IsNamedEnemy(FString EnemyId);
    bool IsFeatureSettingEenabled(const FName& FeatureId);
    bool IsExistImagineRecepi(int32 InRecepiId);
    bool IsExistCraft(int32 InRecepiId);
    bool IsBossEnemy(FString EnemyId);
    TMap<int32, FSBWeaponMasterData> GetWeaponMasterMap();
    FSBWeaponMasterData GetWeaponMasterData(int32 WeaponID, bool& IsExists);
    int32 GetWeaponLevel(const int32 InWeaponID);
    TMap<class FName, class FSBMasterWarpPoint> GetWarpPointMasterMap();
    FSBMasterWarpPoint GetWarpPointMasterData(const FName& ID, bool& IsExists);
    int32 GetTokenRatio(int32 TokenID);
    void GetTacticalAbilitySkillIds(const int32 InSkillId, TArray<int32>& OutTackticalAbilitySkillIdList);
    FSBStackBWeaponParam GetStackBWeaponParamByWeaponId(int32 WeaponID, int32 stackb_num, bool& IsValid);
    FSBStackBImagineParam GetStackBImagineParamByImagineId(int32 ImagineId, int32 stackb_num, bool& IsValid);
    FSBSkillMasteryParam GetSkillMasteryParam(int32 SkillId, int32 Level, bool& IsExists);
    int32 GetSkillLevelMax(int32 SkillId);
    int32 GetSkillLevelFromClassLevel(const int32 InSkillId, const int32 InClassLevel);
    int32 GetShopItemNum(const FName InShopItemTableName);
    int32 GetShopItemItemIndex(const FName InShopItemTableName, const int32 InId);
    FShopItemInfo GetShopItemInfo(const FName InShopItemTableName, const int32 InId);
    FQuestMasterData GetQuestMasterDataByLongId(const FName& InLongId, bool& IsExists);
    FQuestMasterData GetQuestMasterData(int32 Index, bool& IsExists);
    FSBOutGameBuffMasterData GetOutGameBuffMasterData(const EOutGameBuffType InBuffType);
    TArray<FSBHappyNappo> GetNappoMasterData();
    TArray<FMasterTokenUse> GetMasterTokenUseArray();
    TArray<FMasterToken> GetMasterTokenArray();
    TArray<FSBMasterDungeonReward> GetMasterDungeonRewardArray(const FName& DungeonRewardId);
    TArray<FSBMasterDungeonRankedReward> GetMasterDungeonRankedRewardArray(const FName& MapId, const ESBClassType ClassType);
    TArray<FDigitalSignageMasterData> GetMasterDigitalSignageDataList();
    TArray<FDigitalSignageMasterData> GetMasterDigitalSignageArray(FString GroupId);
    TMap<class FName, class FSBMapInfo> GetMapInfoMap();
    FSBMapInfo GetMapInfoByMapName(FString MapName, bool& IsExists);
    FSBMapInfo GetMapInfo(const FName& MapId, bool& IsExists);
    int32 GetLuckyChanceNum(int32 StackBNum);
    TArray<FSBLiquidMemoryAccumulateTokenInfo> GetLiquidMemoryAccumulateTokenInfoMaster();
    TArray<int32> GetItemMasterWeaponIDList();
    TArray<int32> GetItemMasterItemIdListFromEfficacyType(const EItemEfficacyType InEfficacyType);
    TArray<int32> GetItemMasterItemIDList();
    int32 GetItemMasterItemIdFromEfficacyTypeAndValue(const EItemEfficacyType InEfficacyType, const int32 InValue, const bool InIsAccounting);
    TArray<int32> GetItemMasterItemCostumeList();
    FItemMasterData GetItemMasterData(int32 Index, bool& IsExists);
    FItemEfficacyTypeMasterData GetItemEfficacyTypeMasterData(int32 Index, bool& IsExists);
    FSBMasterItemBox GetItemBoxMasterData(int32 InId);
    TArray<int32> GetImagineMasterItemIDList();
    FEnemyParamMasterData GetEnemyParamMasterData(FString EnemyId, bool& IsExists);
    TArray<int32> GetCraftTokenArray(ESBCraftTokenType InTokenType);
    void GetCraftAllRecepi(TArray<FCraftMasterData>& MasterData);
    int32 GetCounterStopClassLevel();
    int32 GetClassSharedAbilityUsableSlotNum(const ESBClassType InClassType, const int32 InLevel);
    int32 GetClassSharedAbilitySlotUsableLevel(const ESBClassType InClassType, const int32 InSlotId);
    TArray<int32> GetBranchingSkillID(int32 SkillId, int32 SkillLV);
    TArray<FMasterImagineRecepi> GetAllMasterImagineRecepi();
    bool GetAdventureBoardPanelList(int32 InBoardId, TArray<FSBAdventureBoardPanelParamMasterData>& OutPanelList);
    int32 GetAchievementNum();
    FAchievementMasterData GetAchievementMasterDataByNoId(int32 NoId, bool& IsExists);
    FAchievementMasterData GetAchievementMasterData(int32 Index, bool& IsExists);
    FSBAbilityMasterData GetAbilityMasterDataByEffectId(int32 EffectId, bool& IsExists);
    FSBAbilityMasterData GetAbilityMasterData(int32 PerkId, bool& IsExists);
    bool FindWarpPointPortalByGameContentId(const FString GameContentId, TArray<FString>& PortalNameList, bool bOstensiblyExist);
    FSBStampCategoryMasterData FindStampMasterDataByStampId(int32 StampId, bool& IsExists);
    FSBStampCategoryMasterData FindStampMasterData(int32 CategoryId, bool& IsExists);
    FSBStampMasterData FindStampDataByStampId(int32 StampId, bool& IsExists);
    FSBStackBTicketData FindStackBTicketData(const int32 token_id);
    FSBStackBMasterData FindStackBData(FString StackBId, int32 StackBNum);
    FSBSkillDataMasterData FindSkillDataDataBySkillId(int32 SkillId, bool& IsExists);
    FSBMasterAwardsData FindSBMasterAwardsDataForBP(const int32 ID, bool& IsExists);
    FSBMasterAdventureCardDecoration FindSBMasterAdventureCardDecorationDataForBP(const int32 ID, bool& bIsExists);
    FSBGameSettingsMasterData FindSBGameSettingsMasterDataForBP(const ESBGameSettingsType ID, bool& IsExists);
    FRecipeSetMasterData FindRecipeSetMasterData(int32 InRecipeSetId, bool& IsExists);
    TArray<FSBRecipeReleaseConditionMasterData> FindRecipeReleaseConditionMasterData_RecipeID(int32 RecipeId, ESBRecipeType RecipeType);
    FSBRecipeReleaseConditionMasterData FindRecipeReleaseConditionMasterData(int32 ID, bool& IsExists);
    TArray<FRankingRewardData> FindRankingRewardDataList(FName InRankingID, FName InContentId, ESBClassType InClassType);
    FRankingRewardData FindRankingRewardData(int32 InRankingRewardID);
    FSBMasterTreasure FindMasterTreasureForBP(int32 ID, bool& IsExists);
    int32 FindMasterTokenUseID(const ESBTokenPlaceToConsumeType InPlaceToConsumeType);
    FSBSupplyMasterData FindMasterSupplyForBP(FString ID, bool& IsExists);
    FSBMasterReward FindMasterReward(const FName& RewardId, bool& IsExists);
    FRandomTreasureBoxChest FindMasterRandomTreasureForBP(FString Tag, bool& IsExists);
    FMasterImagineRecepi FindMasterImagineRecepi(bool& InExists, int32 InImagineId);
    FMasterImaginePerkTable FindMasterImaginePerk(const FSBMasterImagine& InImagineMaster);
    FImagineParameter FindMasterImagineParameter(const FSBMasterImagine& InImagineMaster, int32 InLevel);
    FSBMasterImagine FindMasterImagineData(bool& IsExists, const int32 InId);
    FSBMasterImagine FindMasterImagineByArtsName(const FName ImagineArtsName);
    FSBMasterImagine FindMasterImagine(const int32 InId);
    FSBMasterFreeBuffPoint FindMasterFreeBuffPointForBP(int32 ID, bool& IsExists);
    FSBMasterDungeonRankedReward FindMasterDungeonRankedReward(const FName& MapId, const ESBClassType ClassType, const ESBDungeonEvaluation Evaluation, bool& IsExists);
    FSBLiquidMemoryAccumulateTokenInfo FindLiquidMemoryAccumulateTokenInfo(int32 InId, bool& IsExists);
    FSBFangTokenMasterData FindFangTokenMasterDataBP(const int32 ID, bool& bExists);
    FSBEmoteMasterData FindEmoteData(int32 EmoteId, bool& IsExists);
    FCraftMasterData FindCraftMasterData(int32 InRecepiId, bool& IsExists);
    FSBAdventurerRankMasterData FindAdventurerRankDataByRank(int32 Rank, bool& IsExists);
    FSBAdventureBoardPanelParamMasterData FindAdventureBoardPanel(int32 InBoardId, int32 InPanelId, bool& IsExists);
    FSBAdventureBoardMissionParamMasterData FindAdventureBoardMission(FString MissionId, bool& IsExists);
    FSBAdventureBoardParamMasterData FindAdventureBoard(int32 InBoardId, bool& IsExists);
    bool ExistsMapInfoEntryConditionForEquip(const class UObject* WorldContextObject, ESBDungeonEntryConditionItemType ItemType, int32 ItemIndex, FSBMapInfo& OutFoundData);
    bool ExistsEventEnemyDropEntryConditionForEquip(const class UObject* WorldContextObject, ESBDungeonEntryConditionItemType ItemType, int32 ItemIndex, FSBEventEnemyDropMasterData& OutFoundData);
    bool ExistsChallengeQuestDropEntryConditionForEquip(const class UObject* WorldContextObject, ESBDungeonEntryConditionItemType ItemType, int32 ItemIndex, FSBMasterEventChallengeQuestDrop& OutFoundData);
    int32 CalculateClassLevel(const ESBClassType InClassType, const int32 InExp, const int32 InAdventurerRank);
    void BuildAttackMasterDatas();
    FSBWeaponLevelStatusMasterData BP_GetWeaponLevelStatusMasterDataFromExp(const int32 InWeaponID, bool& bOutExist);
    FSBWeaponLevelStatusMasterData BP_GetWeaponLevelStatusMasterDataByLevel(const int32 InWeaponID, const int32 InLevel, bool& bOutExist);
    FSBWeaponLevelStatusMasterData BP_GetWeaponLevelStatusMasterData(const int32 InWeaponID, bool& bOutExist);
    TArray<FSBWeaponKillerPerkPickMasterData> BP_GetWeaponKillerPerkPickMasterData(FName InTableId, bool& IsExists);
    void BP_GetUsableExtraColorMasterDataList(const class UObject* WorldContextObject, const int32 InCostumeId, class USBEventScheduler* InEventScheduler, TArray<FSBCostumeExtraColorMasterData>& OutUsableExtraColorMasterDataList);
    int32 BP_GetStackBMax(FString StackBId);
    FSBFlatShopItemSetMasterData BP_GetShopItemSetMasterByShopItemId(int32 Index, bool& IsExists);
    FSBFlatShopItemSetMasterData BP_GetShopItemSetMasterById(int32 Index, bool& IsExists);
    TArray<FSBFlatShopItemSetMasterData> BP_GetShopItemSetMaster();
    FSBSeasonPassShopPurchaseLimitMasterData BP_GetSeasonPassShopPurchaseLimitMasterByLimitId(int32 Index, bool& IsExists);
    FSBSeasonPassShopPurchaseLimitMasterData BP_GetSeasonPassShopPurchaseLimitMasterById(int32 Index, bool& IsExists);
    TArray<FSBSeasonPassShopPurchaseLimitMasterData> BP_GetSeasonPassShopPurchaseLimitMaster();
    FSBSeasonPassShopItemMasterData BP_GetSeasonPassShopItemMasterById(int32 Index, bool& IsExists);
    TArray<FSBSeasonPassShopItemMasterData> BP_GetSeasonPassShopItemMaster();
    int32 BP_GetRoSPurchaseShopRibbonByItemId(int32 Index);
    TArray<FSBRoseOrbShopItemMasterData> BP_GetRoSPurchaseShopMaster();
    FSBRmShopMasterData BP_GetRmShopIdMasterByShopTypeId(int32 Index, bool& IsExists);
    FSBRmShopMasterData BP_GetRmShopIdMasterById(int32 Index, bool& IsExists);
    TArray<FSBRmShopMasterData> BP_GetRmShopIdMaster();
    FSBPurchaseConditionMasterData BP_GetPurchaseConditionMasterById(int32 Index, bool& IsExists);
    TArray<FSBPurchaseConditionMasterData> BP_GetPurchaseConditionMaster();
    TArray<FSBPaymentLimitMasterData> BP_GetPaymentLimitMaster();
    FSBNetworkCafeBuffsMasterData BP_GetNetworkCafeBuffsMasterById(int32 Index, bool& IsExists);
    TArray<FSBNetworkCafeBuffsMasterData> BP_GetNetworkCafeBuffsMaster();
    TMap<class FName, class FSBMasterSeasonPassReward> BP_GetMasterSeasonPassRewardMap();
    TArray<FSBMasterSeasonPass> BP_GetMasterSeasonPassList();
    TMap<int32, FSBMasterSeason> BP_GetMasterSeasonMap();
    TArray<FSBRaidBattleMasterData> BP_GetMasterRaidBattle();
    FSBMasterEventChallengeQuestDrop BP_GetMasterEventChallengeQuestDropById(FString ID, bool& IsExists);
    TArray<FSBMasterEventChallengeQuestDrop> BP_GetMasterEventChallengeQuestDrop();
    TArray<FSBLiquidMemoryMasterData> BP_GetLiquidMemoryMasterDataArray();
    float BP_GetLiquidMemoryEfficacyValue(const int32 InLiquidMemoryId, const int32 InLiquidMemoryLevel, int32 InClassLevel);
    TArray<FGuildRankUnlockMaster> BP_GetGuildRankUnLockMaster();
    int32 BP_GetGuildRankFromExp(int32 InExp, int32& RemainExp, int32& NeedExp);
    FSBEventShopRealGoodsMasterData BP_GetEventShopRealGoodsMasterById(int32 Index, bool& IsExists);
    TArray<FSBEventShopRealGoodsMasterData> BP_GetEventShopRealGoodsMaster();
    FSBEventShopMasterData BP_GetEventShopMasterById(int32 Index, bool& IsExists);
    TArray<FSBEventShopMasterData> BP_GetEventShopMaster();
    FSBEventShopItemSetMasterData BP_GetEventShopItemSetMasterById(int32 Index, bool& IsExists);
    TArray<FSBEventShopItemSetMasterData> BP_GetEventShopItemSetMaster();
    FSBEventShopItemMasterData BP_GetEventShopItemMasterById(int32 Index, bool& IsExists);
    TArray<FSBEventShopItemMasterData> BP_GetEventShopItemMaster();
    FSBEventEnemyDropMasterData BP_GetEventEnemyDropMasterById(int32 Index, bool& IsExists);
    TArray<FSBEventEnemyDropMasterData> BP_GetEventEnemyDropMaster();
    FSBCurrencyShopPurchaseLimitMasterData BP_GetCurrencyShopPurchaseLimitMasterByLimitId(int32 Index, bool& IsExists);
    FSBCurrencyShopPurchaseLimitMasterData BP_GetCurrencyShopPurchaseLimitMasterById(int32 Index, bool& IsExists);
    TArray<FSBCurrencyShopPurchaseLimitMasterData> BP_GetCurrencyShopPurchaseLimitMaster();
    FSBCurrencyShopItemMasterData BP_GetCurrencyShopItemMasterById(int32 Index, bool& IsExists);
    TArray<FSBCurrencyShopItemMasterData> BP_GetCurrencyShopItemMaster();
    FSBCouponMasterData BP_GetCouponMasterByTargetId(int32 Index, bool& IsExists);
    TArray<FSBCouponMasterData> BP_GetCouponMaster();
    FSBCountryConfigMasterData BP_GetCountryConfigMasterById(int32 InId);
    TArray<FSBCountryConfigMasterData> BP_GetCountryConfigMaster();
    bool BP_GetCostumeOccupiedSubLocations(const int32 InCostumeId, TArray<ECharaPartsLocation>& OutSubLocationList);
    TArray<FSBMasterCostume> BP_GetCostumeMasterArray();
    TArray<FSBCostumeExtraColorMasterData> BP_GetCostumeExtraColorMasterDataArray();
    FSBBPPtShopPurchaseLimitMasterData BP_GetBPPtShopPurchaseLimitMasterByLimitId(int32 Index, bool& IsExists);
    FSBBPPtShopPurchaseLimitMasterData BP_GetBPPtShopPurchaseLimitMasterById(int32 Index, bool& IsExists);
    TArray<FSBBPPtShopPurchaseLimitMasterData> BP_GetBPPtShopPurchaseLimitMaster();
    FSBBPPtShopItemMasterData BP_GetBPPtShopItemMasterById(int32 Index, bool& IsExists);
    TArray<FSBBPPtShopItemMasterData> BP_GetBPPtShopItemMaster();
    FSBBPPtExchangeMasterData BP_GetBPPtExchangeMasterByItemId(ESBRewardItemType ItemType, int32 ItemId, bool& IsExists);
    TArray<FSBBPPtExchangeMasterData> BP_GetBPPtExchangeMaster();
    TArray<FSBAestheShopPartsMasterData> BP_GetAestheShopPartsMasterDataArray();
    TArray<FSBAestheShopCourseMasterData> BP_GetAestheShopCourseMasterDataArray();
    TArray<FSBAestheShopCharaParamRestrictionMasterData> BP_GetAestheShopCharaParamRestrictionMasterDataArray();
    FSBAbilityEffectMasterData BP_GetAbilityEffectMasterData(int32 ID, bool& IsExists);
    FSBSyntheAbilityPickUp BP_FindSyntheAbilityPickupMasterData(bool& IsExists, int32 ID);
    FSBWarehouseAbilityZoneMasterData BP_FindMasterWarehouseAbilityZoneByRecepiId(const int32 RecepiId, bool& bExists);
    FSBWarehouseAbilityZoneMasterData BP_FindMasterWarehouseAbilityZone(const int32 ID, bool& bExists);
    FSBWarehouseAbilityTokenMasterData BP_FindMasterWarehouseAbilityToken(const int32 ID, bool& bExists);
    FSBWarehouseAbilityStoringMasterData BP_FindMasterWarehouseAbilityStoringByRecepiId(const int32 RecepiId, bool& bExists);
    FSBWarehouseAbilityStoringMasterData BP_FindMasterWarehouseAbilityStoring(const int32 ID, bool& bExists);
    FSBWarehouseAbilityRecipeMasterData BP_FindMasterWarehouseAbilityRecipe(const int32 ID, bool& bExists);
    FSBWarehouseAbilityProductionMasterData BP_FindMasterWarehouseAbilityProductionByRecepiId(const int32 RecepiId, bool& bExists);
    FSBWarehouseAbilityProductionMasterData BP_FindMasterWarehouseAbilityProduction(const int32 ID, bool& bExists);
    FSBWarehouseAbilityMissionMasterData BP_FindMasterWarehouseAbilityMissionByRecepiId(const int32 RecepiId, bool& bExists);
    FSBWarehouseAbilityMissionMasterData BP_FindMasterWarehouseAbilityMission(const int32 ID, bool& bExists);
    FSBWarehouseAbilityCollectionMasterData BP_FindMasterWarehouseAbilityCollectionByRecepiId(const int32 RecepiId, bool& bExists);
    FSBWarehouseAbilityCollectionMasterData BP_FindMasterWarehouseAbilityCollection(const int32 ID, bool& bExists);
    FMasterTokenUse BP_FindMasterTokenUse(bool& bIsValid, const int32 InTokenId);
    FMasterToken BP_FindMasterToken(bool& bIsValid, const int32 InTokenId);
    FSBMasterSeasonPassReward BP_FindMasterSeasonPassReward(FName ID, bool& bExists);
    FSBMasterSeasonPass BP_FindMasterSeasonPass(int32 SeasonId, ESBSeasonPassPlanState Type, bool& bExists);
    FSBMasterSeason BP_FindMasterSeason(int32 ID, bool& bExists);
    FSBMasterRewardLotteryGroups BP_FindMasterRewardLotteryGroups(const int32 InId, bool& bExists);
    FSBRewardBoostMissionMasterData BP_FindMasterRewardBoostMission(const int32 ID, bool& bExists);
    FSBRewardBoostLiquidMemoryMasterData BP_FindMasterRewardBoostLiquidMemory(const int32 ID, bool& bExists);
    FSBResearchTeamMasterData_CostTime BP_FindMasterResearchTeam_CostTime(FString MapId, bool& bExists);
    FSBResearchTeamMasterData_Buff BP_FindMasterResearchTeam_BuffByRecipeId(const int32 InRecipeId, bool& bExists);
    FSBResearchTeamMasterData_Buff BP_FindMasterResearchTeam_Buff(FString MapId, bool& bExists);
    FSBRaidBattleMasterData BP_FindMasterRaidBattle(FString InRaidId, bool& bExists);
    FSBMasterMountImagine BP_FindMasterMountImagineData(const int32 InId, bool& bOutExist);
    FSBInterruptQuestDestructibleObjectMasterData BP_FindMasterInterruptQuestDestructibleObject(const FName& InId, bool& bExists);
    FSBInterruptQuestMasterData BP_FindMasterInterruptQuest(FString QuestID, bool& bExists);
    FSBMasterFusionItem BP_FindMasterFusionItem(const int32 Index, bool& Exists);
    FSBEventTermsMasterData BP_FindMasterEventTerms(FString TermId, bool& IsExists);
    FSBMasterEquipmentSeries BP_FindMasterEquipmentSeries(const int32 ID, bool& Exists);
    FSBDungeonEntryConditionMasterData BP_FindMasterDungeonEntryCondition(int32 ID, bool& bExists);
    FSBLiquidMemoryMasterData BP_FindLiquidMemoryMaster(const int32 InId, bool& IsExists);
    FGuildRank BP_FindGuildRankData(int32 Rank);
    FSBMasterCostume BP_FindCostumeMasterByPartsNameAndEquipableGender(bool& IsExist, FString InCostumePartsName, const EEquipableGender InEquipableGender);
    FSBMasterCostume BP_FindCostumeMasterByPartsName(bool& IsExist, FString InCostumePartsName);
    FSBMasterCostume BP_FindCostumeMaster(bool& IsExist, int32 CostumeId);
    TArray<FSBCostumeExtraColorMasterData> BP_FindCostumeExtraColorMastersFromCostumeId(const int32 InCostumeId);
    FSBCostumeExtraColorMasterData BP_FindCostumeExtraColorMaster(const int32 InId, bool& IsExists);
    FSBAestheShopPartsMasterData BP_FindAestheShopPartsMasterByIconId(FString InIconId, bool& IsExists);
    FSBAestheShopPartsMasterData BP_FindAestheShopPartsMasterByAssetId(FString InAssetId, bool& IsExists);
    FSBAestheShopPartsMasterData BP_FindAestheShopPartsMaster(const int32 InId, bool& IsExists);
    FSBAestheShopCourseMasterData BP_FindAestheShopCourseMaster(const int32 InId, bool& IsExists);
    FSBAestheShopCharaParamRestrictionMasterData BP_FindAestheShopCharaParamRestrictionMaster(const FString InId, bool& IsExists);
}; // Size: 0x1C68

class USBMasterWeaponUtil : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    int32 GetLevelStatus(const int32 InWeaponID, const int32 InLevel, const ESBWeaponStatus InWeaponStatus);
}; // Size: 0x28

class USBMatchCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetMatchingDebugLogEnable(const int32 InLogSpan);
    void RescueMode(bool B);
    void RequestRescue();
    void RequestMatching(FString InContentId, const bool bInUnlimit);
    void DumpMatchingState();
}; // Size: 0x28

class USBMatchingBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void RequestMatchingDirect(class UObject* WorldContextObject, const FSBMapInfo& MapInfo, bool bUnlimit, bool bBackfill);
    bool IsAbleToTravel(class UObject* WorldContextObject);
    void GetRequestGameContentIds(class UObject* WorldContextObject, TArray<FName>& OutIds, bool& bExists);
    class USBMatchingGameState* GetMatchedState(class UObject* WorldContextObject, bool& bExists);
    class USBMatchingGameState* GetCurrentMatchmakingState(class UObject* WorldContextObject, bool& bExists);
    void ForceMatchingDirect(class UObject* WorldContextObject);
    bool CheckEquipItemOr(class UObject* WorldContextObject, const int32 EntryConditionId);
    void CancelMatchingDirect(class UObject* WorldContextObject);
}; // Size: 0x28

class USBMatchingGameState : public UObject
{
    char padding_0[0xD8];                                                             // 0x0000 (size: 0x0)

    void JoinMatchingGame();
    bool IsWaitServer();
    bool IsUnlimit();
    bool IsMatched();
    bool IsJoinable();
    bool IsGathered();
    bool IsConfirmed();
    bool IsBackfill_Result();
    bool IsBackfill_Request();
    int32 GetRemainingTime();
    int32 GetRegularNumber();
    int32 GetParticipantNumber();
    int32 GetNeedParticipantNumber();
    FName GetGameContentID();
    float GetConfirmLimitTime();
    int32 GetConfirmedParticipantNumber();
    void CancelMatchingGame();
}; // Size: 0xD8

class USBMatchingManager : public UObject
{
    FSBMatchingManagerOnGetPenaltyInfoDelegate OnGetPenaltyInfoDelegate;              // 0x0028 (size: 0x10)
    void OnGetPenaltyInfo(bool bWasSuccessful, int32 PenaltyLiftedAt, int32 LeftBeforePenalty);
    FSBMatchingManagerOnPartyRequestMatchmakingDelegate OnPartyRequestMatchmakingDelegate; // 0x0038 (size: 0x10)
    void OnPartyRequestMatchmaking();
    FSBMatchingManagerOnNoticeButtonUpdateDelegate OnNoticeButtonUpdateDelegate;      // 0x0048 (size: 0x10)
    void OnNoticeButtonUpdate(int32 RetCode);
    char padding_0[0x4];                                                              // 0x0058 (size: 0x4)
    float DefaultConfirmLimit;                                                        // 0x005C (size: 0x4)

    void OnTryConnectNextServer();
    void OnPartyRequestMatchmaking__DelegateSignature();
    void OnNoticeButtonUpdate__DelegateSignature(int32 RetCode);
    void OnGetPenaltyInfo__DelegateSignature(bool bWasSuccessful, int32 PenaltyLiftedAt, int32 LeftBeforePenalty);
    bool GetPenaltyInfo(class ASBPlayerController* InPlayerController);
    FDateTime GetMatchingStartTime();
}; // Size: 0x150

class USBMatchingMenu : public USBCommandMenuChildBase
{
    char padding_0[0x2B0];                                                            // 0x0000 (size: 0x0)

    ESBMatchingMenuStartMatchResult StartMatchmaking(const TArray<FSBMapInfo>& DungeonMapInfoArray, bool bUnlimit, bool bBackfill);
    void SetDungeonId(const FName& InDungeonId);
    FName GetDungeonId();
    ESBMatchingMenuCancelMatchResult CancelMatchmaking();
}; // Size: 0x2B0

class USBMatchingRescueRequester : public UObject
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBMeshClimbingComponent : public USBPlayerActorComponent
{
    FSBMeshClimbingComponentOnSetClimbingDelegate OnSetClimbingDelegate;              // 0x00D0 (size: 0x10)
    void OnSetClimbingDelegate();
    TArray<FSBMeshClimbingHandsOffset> HandsOffsetList;                               // 0x00E0 (size: 0x10)
    float SearchClimbingComponentDistance;                                            // 0x00F0 (size: 0x4)
    float SearchClimbingPointDistance_LandingXY;                                      // 0x00F4 (size: 0x4)
    float SearchClimbingPointDistance_LandingZ;                                       // 0x00F8 (size: 0x4)
    float SearchClimbingPointDistance_Flying;                                         // 0x00FC (size: 0x4)
    float ClimbingMoveSpeed;                                                          // 0x0100 (size: 0x4)
    float ClimbingMoveLimitTime;                                                      // 0x0104 (size: 0x4)
    float ClimbingReachedTargetPointLength;                                           // 0x0108 (size: 0x4)
    float CheckPrevClimbAnimAngle;                                                    // 0x010C (size: 0x4)
    float ClimbingFallMoveScale;                                                      // 0x0110 (size: 0x4)
    float ClimbingMoveInputThreshold;                                                 // 0x0114 (size: 0x4)
    float SurfaceTraceLength;                                                         // 0x0118 (size: 0x4)
    float SurfaceTraceRadius;                                                         // 0x011C (size: 0x4)
    int32 ClimbingTargetPointID;                                                      // 0x0120 (size: 0x4)
    FVector ClimbingPointUILocation;                                                  // 0x0124 (size: 0xC)
    bool IsSetClimbingPointUILocation;                                                // 0x0130 (size: 0x1)

    void OnSetClimbingDelegate__DelegateSignature();
    bool IsClimbing();
    class AActor* GetClimbingTargetActor();
    FVector GetAtPointVelocity();
}; // Size: 0x178

class USBMiniMapBG : public UUserWidget
{
    class UWidgetSwitcher* Switcher;                                                  // 0x0278 (size: 0x8)
    class UImage* BG;                                                                 // 0x0280 (size: 0x8)

}; // Size: 0x298

class USBMiniMapIconArea : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(bool InIsInterrupt, const FVector& InLocation, float InRange, const FVector2D& InAreaSize, const FLinearColor& InColor);
    void SetQuestInstance(class ASBInterruptQuestInstance* InQuestInstance);
    class ASBInterruptQuestInstance* GetQuestInstance();
}; // Size: 0x290

class USBMiniMapIconBase : public UUserWidget
{
    class AActor* Actor;                                                              // 0x0278 (size: 0x8)
    class USBMapIcon* MapIcon;                                                        // 0x0280 (size: 0x8)
    float Radius;                                                                     // 0x0288 (size: 0x4)

    void SetVisibleOutside(bool InFlag);
    void SetVisible(bool Visible);
    void SetFixedArrow(bool InFlag);
    void OnSetInside(bool IsInSide);
    void OnSetAngle(float InAngle);
}; // Size: 0x290

class USBMiniMapIconBuddy : public USBMiniMapIconBase
{
    char padding_0[0x298];                                                            // 0x0000 (size: 0x0)

    void Setup();
}; // Size: 0x298

class USBMiniMapIconBuffNpcObj : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup();
    class ASBFieldActorFreeBuffPoint* GetBuffPoint();
}; // Size: 0x290

class USBMiniMapIconCamp : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(const FVector& InLocation);
}; // Size: 0x290

class USBMiniMapIconCarry : public USBMiniMapIconBase
{
    class UCanvasPanel* CanvasPanel_0;                                                // 0x0290 (size: 0x8)

}; // Size: 0x298

class USBMiniMapIconCarryBase : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x290

class USBMiniMapIconChallengeQuest : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(const FVector& InLocation);
}; // Size: 0x290

class USBMiniMapIconClimb : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(const FVector& InLocation);
}; // Size: 0x290

class USBMiniMapIconEnemy : public USBMiniMapIconBase
{
    float HeightMin;                                                                  // 0x0290 (size: 0x4)
    float HeightMax;                                                                  // 0x0294 (size: 0x4)
    float HeightOpacity;                                                              // 0x0298 (size: 0x4)

}; // Size: 0x2A0

class USBMiniMapIconEngramCannon : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup();
}; // Size: 0x290

class USBMiniMapIconFacility : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(const FName& InNpcProfileID, ESBFacilityType InFacilityType, const FSBCharacterProfileLocationData& InLocationData, const FVector& InLocation);
}; // Size: 0x290

class USBMiniMapIconFishing : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(const FVector& InLocation);
}; // Size: 0x290

class USBMiniMapIconID : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(const FSBLocationInfo& InLocationInfo, const FVector& InLocation, const FName& InLocationID);
}; // Size: 0x290

class USBMiniMapIconNamedEnemy : public USBMiniMapIconBase
{
    float HeightMin;                                                                  // 0x0290 (size: 0x4)
    float HeightMax;                                                                  // 0x0294 (size: 0x4)
    float HeightOpacity;                                                              // 0x0298 (size: 0x4)

    void Setup(FString InNamedEnemyID);
    FString GetEnemyId();
}; // Size: 0x2A0

class USBMiniMapIconPartyMember : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup2(class ASBPlayerState* State);
    void Setup(class USBPartyMemberState* State);
}; // Size: 0x290

class USBMiniMapIconPin : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(const FMapPinInfo& InPinInfo, const FVector& InWorldPosition);
}; // Size: 0x290

class USBMiniMapIconQuest : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(int32 QuestIndex, const FVector& InLocation);
    TArray<int32> GetQuestIndexList();
    void AddQuestIndex(int32 InQuestIndex);
}; // Size: 0x290

class USBMiniMapIconShortPin : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(const FSBShortPinInfo& InPinInfo);
    bool GetPinInfo(FSBShortPinInfo& InPinInfo);
}; // Size: 0x290

class USBMiniMapIconUpdraft : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x290

class USBMiniMapIconWarp : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void Setup(FString InLevelName, const FName& InWarpPointId);
}; // Size: 0x290

class USBMiniMapIconWarpDungeon : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void SetupDungeon(FString InLevelName, const FName& InWarpPointId);
}; // Size: 0x290

class USBMiniMapIconWarpEx : public USBMiniMapIconBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)

    void SetupEx(FString InLevelName, const FName& InWarpPointId);
}; // Size: 0x290

class USBMiniMapIcons : public USBMiniMapIconsBase
{
    class USBMapPlayerIcon* PlayerIcon;                                               // 0x02F8 (size: 0x8)
    TArray<class USBMiniMapIconBase*> EnemyIcons;                                     // 0x0300 (size: 0x10)
    TArray<class USBMiniMapIconBase*> BuddyIcons;                                     // 0x0310 (size: 0x10)
    TArray<class USBMiniMapIconBase*> NamedEnemyIcons;                                // 0x0320 (size: 0x10)
    TArray<class USBMiniMapIconBase*> PartyMemberIcons;                               // 0x0330 (size: 0x10)
    TArray<class USBMiniMapIconBase*> FacilityIcons;                                  // 0x0340 (size: 0x10)
    TArray<class USBMiniMapIconBase*> BuffNPCIcons;                                   // 0x0350 (size: 0x10)
    TArray<class USBMiniMapIconBase*> QuestIconS;                                     // 0x0360 (size: 0x10)
    TArray<class USBMiniMapIconBase*> QuestNpcIcons;                                  // 0x0370 (size: 0x10)
    TArray<class USBMiniMapIconBase*> QuestAreaIcons;                                 // 0x0380 (size: 0x10)
    TArray<class USBMiniMapIconBase*> QuestInterruptIcons;                            // 0x0390 (size: 0x10)
    TArray<class USBMiniMapIconBase*> QuestChallengeIcons;                            // 0x03A0 (size: 0x10)
    TArray<class USBMiniMapIconBase*> WarpPointIcons;                                 // 0x03B0 (size: 0x10)
    TArray<class USBMiniMapIconBase*> WarpPointIconsDungeon;                          // 0x03C0 (size: 0x10)
    TArray<class USBMiniMapIconBase*> IDIcons;                                        // 0x03D0 (size: 0x10)
    TArray<class USBMiniMapIconBase*> EngramCannonIcons;                              // 0x03E0 (size: 0x10)
    TArray<class USBMiniMapIconBase*> CampIcons;                                      // 0x03F0 (size: 0x10)
    TArray<class USBMiniMapIconBase*> FishingIcons;                                   // 0x0400 (size: 0x10)
    TArray<class USBMiniMapIconBase*> ClimbIcons;                                     // 0x0410 (size: 0x10)
    TArray<class USBMiniMapIconBase*> UpdraftIcons;                                   // 0x0420 (size: 0x10)
    TArray<class USBMiniMapIconBase*> PinIcons;                                       // 0x0430 (size: 0x10)
    TArray<class USBMiniMapIconBase*> ShortPinIcons;                                  // 0x0440 (size: 0x10)
    TArray<class USBMiniMapIconBase*> CarryIcons;                                     // 0x0450 (size: 0x10)
    TArray<class USBMiniMapIconBase*> CarryBaseIcons;                                 // 0x0460 (size: 0x10)
    TArray<class USBMiniMapIconBase*> DxBattleSupplierIcons;                          // 0x0470 (size: 0x10)
    TArray<class USBMiniMapIconBase*> EnemyGateIcons;                                 // 0x0480 (size: 0x10)
    TArray<class USBMiniMapIconBase*> DxBattleGateBarrierIcons;                       // 0x0490 (size: 0x10)

    class USBMiniMapIconQuest* IsTypeQuestIcon(const EQuestIconType InQuestType, const FVector& InLocation);
    void DeleteEnemyIcon(class USBMiniMapIconBase* InIcon);
    void DeleteEnemyGateIcon(const class AActor* InActor);
    void DeleteDxBattleSupplierIcon(const class AActor* InActor);
    class USBMiniMapIconBase* CreateEnemyIcon(class AActor* InActor);
    class USBMiniMapIconBase* AddNamedEnemyIcon(class ASBEnemyCharacter* InEnemyCharacter);
    class USBMiniMapIconBase* AddEnemyIcon(class ASBEnemyCharacter* InEnemyCharacter);
    class USBMiniMapIconBase* AddBuddyIcon(class ASBEnemyCharacter* InEnemyCharacter);
}; // Size: 0x4A0

class USBMiniMapIconsBase : public UUserWidget
{
    class UDataTable* CharacterProfileDB;                                             // 0x0278 (size: 0x8)
    class UDataTable* LocationDB;                                                     // 0x0280 (size: 0x8)
    class UDataTable* QuestAreaConfigDB;                                              // 0x0288 (size: 0x8)
    class UCanvasPanel* Icons;                                                        // 0x0290 (size: 0x8)

    void StartTimerEventUpdateQuest();
    bool RemoveIcon(class UWidget* InIcon);
    void OnUnbind();
    void OnStartInterruptQuest(const class ASBInterruptQuestInstance* InInstance);
    void OnRepUpdateInterruptQuestNpcDelegete(const TArray<FSBInterruptQuestNpcData>& InNpcDataList);
    void OnRepUpdateInterruptQuestGimmickObjectDelegete(const TArray<FSBInterruptQuestGimmickObjectData>& InGimmickObjectList);
    void OnRepUpdateInterruptQuesteDestructibleObjectDelgete(const TArray<FSBInterruptQuestDestructibleObjectData>& InDestructibleObjectDataList);
    void OnFreeBuffPointChangeStateNPC();
    void OnEndInterruptQuest(const class ASBInterruptQuestInstance* InInstance);
    void OnDungeonAddActivate(FName DungeonId);
    void OnDeletePartyMemberIcon();
    void OnCreateWarpPointIcon(FString LevelName, FString PortalName);
    void OnCreateWarpPointExIcon(FString LevelName, FString PortalName);
    void OnCreateWarpPointDungeonIcon(FString LevelName, FString PortalName);
    void OnCreateUpdraftIcon(const class ASBUpdraft* InUpdraft);
    void OnCreateShortPin();
    void OnCreateRaidIcon(const FSBLocationInfo& LocationInfo, const FVector& InLocation);
    void OnCreateQuestNPCIcon(int32 QuestID, EQuestIconType QuestType, EQuestCategory2 QuestCategory, const FVector& Location);
    void OnCreateQuestIcon();
    void OnCreateQuestChallenge(TEnumAsByte<ESBMiniMapIconType> IconType, const FVector& InLocation);
    void OnCreateQuestAreaIcon(const FVector& InLocation, float InRange, const FVector2D& InAreaSize, const FLinearColor& InColor);
    void OnCreatePublicDungeonIcon(const FSBLocationInfo& LocationInfo, const FName& RowName, const FVector& InLocation);
    void OnCreatePin(const FMapPinInfo& MapPinInfo, const FVector& InWorldPosition);
    void OnCreatePartyMemberIcon();
    void OnCreateFishingIcon(const FVector& InLocation);
    void OnCreateFacilityIcon(const FName InProfileId, ESBFacilityType InType, const FSBCharacterProfileLocationData& InLocationData, const FVector& InLocation);
    void OnCreateEngramCannon(const class ASBEngramCannon* EngramCannon);
    void OnCreateEnemyGate(const class AActor* InActor);
    void OnCreateDxBattleSupplier(const class AActor* InActor);
    void OnCreateDxBattleGateBarrier(const class AActor* InActor);
    void OnCreateDungeonIcon(const FSBLocationInfo& LocationInfo, const FVector& InLocation);
    void OnCreateClimbIcon(const class ASBClimbPoint* InClimbPoint);
    void OnCreateCarrys(const class ASBCarry* InCarry);
    void OnCreateCarryBases(const class AActor* InActor);
    void OnCreateCampIcon(const FVector& InLocation);
    void OnCreateBuffNPCIcon(const class ASBFieldActorFreeBuffPoint* FreeBuffPoint);
    void OnCampFireChangedDataDelegate();
    void OnBind();
    bool IsCreatedQuestIcon(const int32 InQuestId, const FVector& InLocation);
    void CreatePin();
    void CreatePartyMemberIcon();
    void CreateEnemyGate();
    void CreateDxBattleSupplier();
    void AddInterruptQuestIcon(const class ASBInterruptQuestInstance* InInstance, const FVector& InLocation, float InRange, const FVector2D& InAreaSize);
}; // Size: 0x2F8

class USBMiniMapLowerIcons : public USBMiniMapIconsBase
{
    TArray<class USBMiniMapIconBase*> WarpPointIconsEx;                               // 0x02F8 (size: 0x10)

}; // Size: 0x308

class USBMiniMapName : public UUserWidget
{
    class UTextBlock* LabelMapName;                                                   // 0x0278 (size: 0x8)

}; // Size: 0x280

class USBMiniMapTime : public UUserWidget
{
    class UImage* TimeGauge;                                                          // 0x0278 (size: 0x8)
    class UWidgetSwitcher* SwitchTimeIcon;                                            // 0x0280 (size: 0x8)

    void Update(bool IsVisible);
}; // Size: 0x298

class USBMiniMapWidget : public USBMiniMapWidgetBase
{
    class USBMiniMapBG* MiniMapBG;                                                    // 0x0370 (size: 0x8)
    class USBMiniMapTime* MiniMapTime;                                                // 0x0378 (size: 0x8)
    class USBMiniMapName* MiniMapName;                                                // 0x0380 (size: 0x8)
    float OutRadius_;                                                                 // 0x0388 (size: 0x4)
    FVector2D CenterPosition_;                                                        // 0x038C (size: 0x8)

    void SetMapScale(const FVector2D& InMapScale);
    void SetCenterPosition(const FVector2D& InPosition);
}; // Size: 0x3B8

class USBMiniMapWidgetBase : public UUserWidget
{
    class UDataTable* MapConfigDataTable;                                             // 0x0278 (size: 0x8)
    class UWidgetSwitcher* Switcher;                                                  // 0x0280 (size: 0x8)
    class UCanvasPanel* CPRoot;                                                       // 0x0288 (size: 0x8)
    class URetainerBox* RetainerBox;                                                  // 0x0290 (size: 0x8)
    class USBMiniMapIconsBase* Icons;                                                 // 0x0298 (size: 0x8)
    class USBMiniMapIconsBase* LowerIcons;                                            // 0x02A0 (size: 0x8)
    class UTexture2D* MapTexture;                                                     // 0x02A8 (size: 0x8)

    void SetupBGFlag(bool Flag);
    void SetPhaseCount(int32 InPhaseCount);
    void SetOptionEdit(bool Flag);
    void SetOpen(bool Flag);
    void OnUnbind();
    void OnSetOptionEditMode();
    void OnBind();
    void LoadComplateBG(class UTexture2D* InBGTexture);
    void LoadBG();
    bool IsSetupBGFlag();
    bool IsOptionEdit();
    bool IsOpen();
    class UWidgetSwitcher* GetSwitcher();
    class UCanvasPanel* GetRoot();
    class URetainerBox* GetRetainerBox();
    FVector2D GetMapSize();
    class USBMiniMapIconsBase* GetLowerIcons();
    class USBMiniMapIconsBase* GetIcons();
    FVector2D GetBGTextureSize();
    FName GetBGConfigRowName();
    FSBMapBGConfigTableRow GetBGConfig();
}; // Size: 0x370

class USBMissionQuestFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void MissionQuestUpdateCond_TreasureGet(class ASBPlayerController* InPlayerController);
    void MissionQuestUpdateCond_SupplierUse(class ASBPlayerController* InPlayerController);
    void MissionQuest_UpdateWishListEntryCheck(class UObject* InWorldContextObject);
    void MissionQuest_UpdateWeaponShopCheck(class UObject* InWorldContextObject);
    void MissionQuest_UpdateStorageCheck(class UObject* InWorldContextObject);
    void MissionQuest_UpdateStamp(class UObject* InWorldContextObject, int32 InStampId);
    void MissionQuest_UpdateRankingBoardCheck(class UObject* InWorldContextObject);
    void MissionQuest_UpdateItemUse(class UObject* InWorldContextObject, int32 InItemID);
    void MissionQuest_UpdateItemShopCheck(class UObject* InWorldContextObject);
    void MissionQuest_UpdateExchangeShopCheck(class UObject* InWorldContextObject);
    void MissionQuest_ConditionCheck_String(class UObject* InWorldContextObject, ESBMissionQuestType ConditionId, int32 InValue, FString String, int32 InCount);
    void MissionQuest_ConditionCheck(class UObject* InWorldContextObject, ESBMissionQuestType ConditionId, int32 InValue_1, int32 InValue_2, int32 InCount);
    void MissionQuest_AutoMessageEntryCheck(class UObject* InWorldContextObject);
    bool IsMissionPlayCondition(ESBMissionQuestType InType);
    int32 GetProgressCount(const ESBMissionQuestType& InType, int32 InProgressCount, int32 InCompleteCount, bool IsClear);
    int32 GetEquipItemStackBNum_ServerSide(class ASBPlayerController* InPlayerController, const ESBCharaEquipType InEquipType, FString InItemUniqueId);
    int32 GetEquipItemStackBNum(class UObject* InWorldContextObject, const ESBCharaEquipType InEquipType);
    int32 GetCompleteCount(const ESBMissionQuestType& InType, int32 InProgressCount, int32 InCompleteCount);
}; // Size: 0x28

class USBMobCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetMobDensityScale(float DensityScale);
    void DumpNpcSpawnPointsInfo();
    void CreateSpawnPoint(ECharaPartsCharacterType CharacterType, int32 IndexOffset, int32 XNum, int32 YNum, float SpaceOffset);
}; // Size: 0x28

class USBMountCapsuleComponent : public UCapsuleComponent
{
    char padding_0[0x490];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x490

class USBMountEffectBaseComponent : public USceneComponent
{
    TArray<FSBMountPlayingEffect> m_PlayingEffectList;                                // 0x0208 (size: 0x10)
    char padding_0[0x8];                                                              // 0x0218 (size: 0x8)
    TArray<FSBMountEffectParams> EffectParams;                                        // 0x0220 (size: 0x10)

    class UParticleSystemComponent* SpawnEmitter(const FSBMountEffectParams& Param);
    class ASBMount* GetMountPlayer();
    ESBMountEffectType GetEffectType(const FSBMountEffectParams& Param);
    TArray<FSBMountEffectParams> GetEffectParams();
    void DeactivateAllEffect();
}; // Size: 0x230

class USBMountPlayerCliffComponent : public USBPlayerActorComponent
{
    float CliffJumpDetectionLength;                                                   // 0x00D4 (size: 0x4)
    char padding_0[0x8];                                                              // 0x00D8 (size: 0x8)
    float CliffJumpCapsuleRadius;                                                     // 0x00E0 (size: 0x4)
    float MinCliffJumpLength;                                                         // 0x00E4 (size: 0x4)
    float MaxCliffJumpLength;                                                         // 0x00E8 (size: 0x4)
    float MinCliffJumpHeight;                                                         // 0x00EC (size: 0x4)
    float MaxCliffJumpHeight;                                                         // 0x00F0 (size: 0x4)

    FVector GetCliffJumpVelocity();
}; // Size: 0x100

class USBMountPlayerMovementComponent : public USBPlayerMovementComponentBase
{
    int32 AnimationFrameWait;                                                         // 0x0E1C (size: 0x4)
    float AnimationTransformWalk;                                                     // 0x0E20 (size: 0x4)
    int32 AnimationFrameWalk;                                                         // 0x0E24 (size: 0x4)
    float AnimationTransformRun;                                                      // 0x0E28 (size: 0x4)
    int32 AnimationFrameRun;                                                          // 0x0E2C (size: 0x4)
    float AnimationPlayRateMax;                                                       // 0x0E30 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0E34 (size: 0x4)
    class UCurveFloat* PlayerBlendXCompCurve;                                         // 0x0E38 (size: 0x8)
    float SpeedMax;                                                                   // 0x0E40 (size: 0x4)
    float WalkSpeedMax;                                                               // 0x0E44 (size: 0x4)
    float CitySpeedMax;                                                               // 0x0E48 (size: 0x4)
    float CityWalkSpeedMax;                                                           // 0x0E4C (size: 0x4)
    float SpeedAddParSec;                                                             // 0x0E50 (size: 0x4)
    float CitySpeedAddParSec;                                                         // 0x0E54 (size: 0x4)
    class UCurveFloat* SpeedAddCurve;                                                 // 0x0E58 (size: 0x8)
    float SpeedSubParSec;                                                             // 0x0E60 (size: 0x4)
    float StopSpeedParSec;                                                            // 0x0E64 (size: 0x4)
    float StopSpeedSubParSec;                                                         // 0x0E68 (size: 0x4)
    float CitySpeedSubParSec;                                                         // 0x0E6C (size: 0x4)
    class UCurveFloat* SpeedSubCurve;                                                 // 0x0E70 (size: 0x8)
    float SpeedSubRateRunToWalk;                                                      // 0x0E78 (size: 0x4)
    float OutOfEnergySpeed;                                                           // 0x0E7C (size: 0x4)
    float RotateDegreeMax;                                                            // 0x0E80 (size: 0x4)
    float CityRotateDegreeMax;                                                        // 0x0E84 (size: 0x4)
    float RotateDegreeAddParSec;                                                      // 0x0E88 (size: 0x4)
    float CityRotateDegreeAddParSec;                                                  // 0x0E8C (size: 0x4)
    class UCurveFloat* RotateDegreeAddCurve;                                          // 0x0E90 (size: 0x8)
    float RotateDegreeSubParSec;                                                      // 0x0E98 (size: 0x4)
    float StartSlowDownRotateDegree;                                                  // 0x0E9C (size: 0x4)
    class UCurveFloat* RunSlowDownCurve;                                              // 0x0EA0 (size: 0x8)
    class UCurveFloat* WalkSlowDownCurve;                                             // 0x0EA8 (size: 0x8)
    class UCurveFloat* RotateAnimReflectCurve;                                        // 0x0EB0 (size: 0x8)
    float DashSpeedMaxScale;                                                          // 0x0EB8 (size: 0x4)
    float CityDashSpeedMaxScale;                                                      // 0x0EBC (size: 0x4)
    float DashSpeedAddScale;                                                          // 0x0EC0 (size: 0x4)
    float CityDashSpeedAddScale;                                                      // 0x0EC4 (size: 0x4)
    float DashRotateMaxScale;                                                         // 0x0EC8 (size: 0x4)
    float BrakeSpeedMaxScale;                                                         // 0x0ECC (size: 0x4)
    float BrakeSpeedSubScale;                                                         // 0x0ED0 (size: 0x4)
    float BrakeRotateMaxScale;                                                        // 0x0ED4 (size: 0x4)
    float BrakeRotateAddScale;                                                        // 0x0ED8 (size: 0x4)
    float BrakeRotateSubScale;                                                        // 0x0EDC (size: 0x4)
    FVector CheckSideCliffDist;                                                       // 0x0EE0 (size: 0xC)
    float CheckSideCliffDepth;                                                        // 0x0EEC (size: 0x4)
    float CheckForwardCliffDist;                                                      // 0x0EF0 (size: 0x4)
    float CheckFrontCliffDepth;                                                       // 0x0EF4 (size: 0x4)
    float CliffTurnMinSpeedSub;                                                       // 0x0EF8 (size: 0x4)
    float CliffTurnMaxSpeedSub;                                                       // 0x0EFC (size: 0x4)
    float StartCliffDeceleDegree;                                                     // 0x0F00 (size: 0x4)
    float StartCliffTurnDegree;                                                       // 0x0F04 (size: 0x4)
    float HitWallConditionSpeedRate;                                                  // 0x0F08 (size: 0x4)
    float HitWallSpeedMaxScale;                                                       // 0x0F0C (size: 0x4)
    float HitWallSpeedSubScale;                                                       // 0x0F10 (size: 0x4)
    bool bActiveScaleAnimation;                                                       // 0x0F14 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0F15 (size: 0x3)
    FVector LocationMove;                                                             // 0x0F18 (size: 0xC)
    float RotationYawMove;                                                            // 0x0F24 (size: 0x4)

    float UpdateFixedCorrectionDirection(float Direction, float InputRotateDelta);
    bool IsWalkSpeedType(ESBPlayerWalkSpeedType WalkSpeedType);
    bool IsRestraint();
    bool IsAir();
    float GetWalkSpeedMax();
    float GetSpeedSubParSec();
    float GetSpeedMax();
    float GetSpeedAddParSec();
    float GetRotateDegreeMax();
    float GetRotateDegreeAddParSec();
    float GetDashSpeedMaxScale();
    float GetDashSpeedAddScale();
    float GetAnimationSpeedWalk();
    float GetAnimationSpeedRun();
    float CheckWideSide(FVector GroundNormal, FVector Dist, float Depth);
    FHitResult CheckRayIsCliff(FVector Start, FVector End);
    bool CheckFrontIsCliff(float ForwardDist, float Depth, FVector GroundNormal);
}; // Size: 0xF30

class USBMoveSpeedSoundComponent : public USceneComponent
{
    TWeakObjectPtr<class UAkComponent> AkComponent;                                   // 0x0208 (size: 0x8)
    char padding_0[0x10];                                                             // 0x0210 (size: 0x10)
    FAkEventVariables MoveStartEvent;                                                 // 0x0220 (size: 0x40)
    FAkEventVariables MoveEndEvent;                                                   // 0x0260 (size: 0x40)
    FAkEventVariables MaxSpeedStartEvent;                                             // 0x02A0 (size: 0x40)
    FAkEventVariables MaxSpeedEndEvent;                                               // 0x02E0 (size: 0x40)

}; // Size: 0x320

class USBMovementPredictComponent : public UActorComponent
{
    float StateNoiseDispersion;                                                       // 0x011C (size: 0x4)
    float ObserveNoiseDispersion;                                                     // 0x0120 (size: 0x4)

}; // Size: 0x128

class USBMovieSceneAudioEventSection : public UMovieSceneAkAudioEventSection
{
    TArray<ESBMovieSceneAkEventSwitchType> MovieSceneAkEventSwitchTypeArray;          // 0x01D0 (size: 0x10)
    ESBFootSESocketType FootSESocketType;                                             // 0x01E0 (size: 0x1)
    bool EnableAkComponentOutputBusVolume;                                            // 0x01E1 (size: 0x1)

}; // Size: 0x1E8

class USBMovieSceneAudioEventTrack : public UMovieSceneAkAudioEventTrack
{
    char padding_0[0xB0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB0

class USBMovieSceneAudioListenerSection : public UMovieSceneSection
{
    FMovieSceneBoolChannel IsOffset;                                                  // 0x00E8 (size: 0x90)
    FMovieSceneFloatChannel Translation;                                              // 0x0178 (size: 0x1E0)

}; // Size: 0x368

class USBMovieSceneAudioListenerTrack : public UMovieSceneNameableTrack
{
    TArray<class UMovieSceneSection*> Sections;                                       // 0x0098 (size: 0x10)

}; // Size: 0xA8

class USBMovieSceneChoiceDialogSection : public UMovieSceneSection
{
    FMovieSceneChoiceDialogSectionData ChoiceDialogData;                              // 0x00E8 (size: 0x88)

}; // Size: 0x170

class USBMovieSceneChoiceDialogTrack : public UMovieSceneNameableTrack
{
    class USBTextTableAsset* TextTable;                                               // 0x0098 (size: 0x8)
    TArray<class UMovieSceneSection*> Sections;                                       // 0x00A0 (size: 0x10)

}; // Size: 0xB0

class USBMovieSceneNotify : public UObject
{
    TWeakObjectPtr<class UObject> CachedObject;                                       // 0x0028 (size: 0x8)
    FFrameNumber StartFrame;                                                          // 0x0030 (size: 0x4)
    FFrameNumber EndFrame;                                                            // 0x0034 (size: 0x4)
    FFrameRate FrameRate;                                                             // 0x0038 (size: 0x8)

    void ReceivStoreState(class UObject* Object);
    void ReceivRestoreState(class UObject* Object);
    void ReceivNotifyTick(class UObject* Object, float Time, float Delta, ESBMovieScenePlayerStatus PlayerStatus);
    float GetTimeSize();
    float GetStartTime();
    FFrameNumber GetStartFrame();
    FString GetNotifyName();
    FFrameRate GetFrameRate();
    float GetEndTime();
    FFrameNumber GetEndFrame();
}; // Size: 0x40

class USBMovieSceneNotifySection : public UMovieSceneSection
{
    class USBMovieSceneNotify* Notify;                                                // 0x00E8 (size: 0x8)

}; // Size: 0xF0

class USBMovieSceneNotifyTrack : public UMovieSceneNameableTrack
{
    ESBFireNotifiesAtPosition NotifyPosition;                                         // 0x0098 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0099 (size: 0x7)
    TArray<class UMovieSceneSection*> Sections;                                       // 0x00A0 (size: 0x10)

}; // Size: 0xB0

class USBMovieSceneSkeletalAnimationSection : public UMovieSceneSkeletalAnimationSection
{
    class UAnimSequenceBase* FemaleAnimation;                                         // 0x0268 (size: 0x8)
    FName AnimationKeyName;                                                           // 0x0270 (size: 0x8)
    ESBRootMotionType RootMotionType;                                                 // 0x0278 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0279 (size: 0x3)
    uint8 bLoop;                                                                      // 0x027C (size: 0x1)

}; // Size: 0x280

class USBMovieSceneSkeletalAnimationTrack : public UMovieSceneSkeletalAnimationTrack
{
    char padding_0[0xE8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xE8

class USBMovieSceneTextWindowSection : public UMovieSceneSection
{
    FName TextIdName;                                                                 // 0x00E8 (size: 0x8)
    int32 TextId;                                                                     // 0x00F0 (size: 0x4)
    ESBMovieSceneTextWindowGender Gender;                                             // 0x00F4 (size: 0x1)
    bool bUseSubtitle;                                                                // 0x00F5 (size: 0x1)

}; // Size: 0xF8

class USBMovieSceneTextWindowTrack : public UMovieSceneNameableTrack
{
    FName SpeakerId;                                                                  // 0x0098 (size: 0x8)
    class USBTextTableAsset* TextTable;                                               // 0x00A0 (size: 0x8)
    TArray<class UMovieSceneSection*> Sections;                                       // 0x00A8 (size: 0x10)
    bool bUseSubtitle;                                                                // 0x00B8 (size: 0x1)

}; // Size: 0xC0

class USBMultipleSelectDialog : public USBUserWidget
{
    FSBMultipleSelectDialogOnDynamicFinishedDelegate OnDynamicFinishedDelegate;       // 0x02B0 (size: 0x10)
    void OnDynamicFinished(int32 Result);

    void OnDynamicFinished__DelegateSignature(int32 Result);
    void InitMultipleSelectDialog(const FText& Message, const TArray<FText>& Selections);
    void HandleInit(const FText& Message, const TArray<FText>& Selections);
    void Finish(const int32 SelectIndex);
}; // Size: 0x2D0

class USBMyCharaPioneerAbilityWidget : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    TMap<class FName, class FPioneerAbilityList> GetPioneerAbilityMap(class USBWarehouseAbilityComponent* InWarehouseAbilityComponent);
}; // Size: 0x278

class USBNPCAITask_TalkEndAction : public UAITask
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)

    void OnChangeStatus();
}; // Size: 0x78

class USBNPCAITask_TalkTurn : public UAITask
{
    class AActor* TargetActor;                                                        // 0x0070 (size: 0x8)

    void OnChangeStatus();
}; // Size: 0xB8

class USBNPCAITask_Turn : public UAITask
{
    class AActor* TargetActor;                                                        // 0x0070 (size: 0x8)

}; // Size: 0xB0

class USBNPCAITask_WanderOnLane : public UAITask
{
    class APawn* OwnerPawn;                                                           // 0x0090 (size: 0x8)
    class UPawnMovementComponent* MovementComp;                                       // 0x0098 (size: 0x8)
    class USplineComponent* SplineComponent;                                          // 0x00A0 (size: 0x8)
    class USBNpcLaneGraph* Graph;                                                     // 0x00A8 (size: 0x8)

}; // Size: 0x128

class USBNaEventComponentUtility : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsNaEventValid(const class UObject* WorldContextObject);
    class USBPlayerNaEventComponent* GetNaEventComponent(const class UObject* WorldContextObject);
}; // Size: 0x28

class USBNameConventionsFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool CheckNameConventions(FString Name, const class UDataTable* NameConventinos);
}; // Size: 0x28

class USBNamePlateComponent2D : public USBWidgetComponent2DNoOSR
{
    FVector2D ClipDistance;                                                           // 0x0270 (size: 0x8)

    void Tick_Npc_Internal(class ASBMobCharacter* InCharacter);
}; // Size: 0x2C0

class USBNamePlateWidget : public UUserWidget
{
    TWeakObjectPtr<class ASBCharacter> Character;                                     // 0x0278 (size: 0x8)
    TWeakObjectPtr<class ASBMobCharacter> NpcCharacter;                               // 0x0280 (size: 0x8)

    void SetTeamNumber(const int32 TeamNumber);
    void SetNpcCharacter_Internal(class ASBMobCharacter* InNpcCharacter);
    void SetNameVisibility(const bool bInVisibility);
    void SetName(FString Name);
    void SetLevel(const int32 Level);
    void SetInteractionTargetVisibility(const bool bInVisibility);
    void SetInitialHpRate(const float HPRate);
    void SetHpRate(const float HPRate);
    void SetHpGaugeWidthRate(const float InWidthRate);
    void SetHpGaugeVisibility(const bool bInVisibility);
    void SetHostility(const ESBHostility Hostility);
    void SetChargeMax();
    void SetCharacter_Internal(class ASBCharacter* InCharacter);
    void SetAchievementSelected(const int32 InAchievementSelected);
    void OnDisplayStart();
    void InteractionComplete();
    void AutoChangeVisible();
    void AutoChangeInvisible();
}; // Size: 0x288

class USBNavArea_AutoPlay : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_BlockDefault : public UNavArea_Null
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_BlockLarge : public UNavArea_Null
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_BlockMedium : public UNavArea_Null
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_BuddyOnly : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_ClimbingWallLink : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_Default : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_Dynamic : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_ExcludeBoss : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_Null : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_SegmentLinkBuddyOnly : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_SegmentLinkDefault : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_TidalArea : public UNavArea
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_TidalArea_Low : public USBNavArea_Default
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavArea_TidalArea_Mid : public USBNavArea_Default
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBNavFilter_ExcludeNavLink : public UNavigationQueryFilter
{
    TMap<class TSubclassOf<UNavigationQueryFilter>, class TSubclassOf<UNavigationQueryFilter>> ExcludeNavLinkFilterConvertList; // 0x0048 (size: 0x50)
    TSubclassOf<class UNavigationQueryFilter> DefaultExcludeNavLinkFilter;            // 0x0098 (size: 0x8)

}; // Size: 0xA0

class USBNavLinkJumpComponent : public UActorComponent
{
    char padding_0[0x120];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x120

class USBNavSeedComponent : public USceneComponent
{
    char padding_0[0x210];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x210

class USBNavigationFunctionLibrary : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBNavigationSystem : public UAIFwNavigationSystem
{
    class USBNpcLaneGraph* LaneGraph;                                                 // 0x1610 (size: 0x8)

    void OnMasterDataAvailable();
    class USBNavigationSystem* GetSBNavigationSystem(class UObject* WorldContextObject);
    void CreateNavLink();
}; // Size: 0x1638

class USBNavigationSystemConfig : public UNavigationSystemModuleConfig
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBNavigationSystemProjectSettings : public UObject
{
    FString TargetNavMeshName;                                                        // 0x0028 (size: 0x10)
    float MaxDistance;                                                                // 0x0038 (size: 0x4)
    float MinPathDistance;                                                            // 0x003C (size: 0x4)
    float MaxHeight;                                                                  // 0x0040 (size: 0x4)
    float MaxOneWayHeight;                                                            // 0x0044 (size: 0x4)
    int32 Division;                                                                   // 0x0048 (size: 0x4)
    float MinimumLinkWidth;                                                           // 0x004C (size: 0x4)
    float AgentJumpHeight;                                                            // 0x0050 (size: 0x4)
    float AgentHeight;                                                                // 0x0054 (size: 0x4)
    float AgentRadius;                                                                // 0x0058 (size: 0x4)
    float AgentMarginRadius;                                                          // 0x005C (size: 0x4)
    float LinkableAngle;                                                              // 0x0060 (size: 0x4)
    bool bCreateClimbingWallLink;                                                     // 0x0064 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0065 (size: 0x3)
    FString ClimbingWallLinkTargetNavMeshName;                                        // 0x0068 (size: 0x10)
    float WallWidthMargin;                                                            // 0x0078 (size: 0x4)
    float MaxEdgeDistanceFromWall;                                                    // 0x007C (size: 0x4)
    bool bAssignDefaultDepthManually;                                                 // 0x0080 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0081 (size: 0x3)
    float DefaultMaxDepth;                                                            // 0x0084 (size: 0x4)
    bool bAssignMediumDepthManually;                                                  // 0x0088 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0089 (size: 0x3)
    float MediumMaxDepth;                                                             // 0x008C (size: 0x4)
    bool bAssignLargeDepthManually;                                                   // 0x0090 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0091 (size: 0x3)
    float LargeMaxDepth;                                                              // 0x0094 (size: 0x4)

}; // Size: 0x98

class USBNetConnection : public UIpConnection
{
    char padding_0[0x1C68];                                                           // 0x0000 (size: 0x0)

    void OnAttachedClientPlayerState(class ASBPlayerController* PC);
}; // Size: 0x1C68

class USBNetDriver : public UIpNetDriver
{
    char padding_0[0x818];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x818

class USBNetworkCafeMessageManager : public UObject
{
    FSBNetworkCafeInfo NetworkCafeInfo;                                               // 0x0050 (size: 0x10)

    bool IsNetworkCafe();
    void GetRewards(TArray<FSBNetworkCafeReward>& OutRewards);
}; // Size: 0x60

class USBNetworkDataCache : public UObject
{
    class USBCharacterData* CharacterData;                                            // 0x0028 (size: 0x8)
    class USBOwnItemList* OwnItemList;                                                // 0x0030 (size: 0x8)
    FSBRecastTimeInfo ItemRecastTime;                                                 // 0x0038 (size: 0x10)
    TArray<FUnlockedQuestInfo> UnlockedQuestInfoList;                                 // 0x0048 (size: 0x10)
    TArray<FAcceptedQuestInfo> AcceptedQuestInfoList;                                 // 0x0058 (size: 0x10)
    int32 ProceedingMainQuestNum;                                                     // 0x0068 (size: 0x4)
    int32 ProceedingSubQuestNum;                                                      // 0x006C (size: 0x4)
    class USBActivatedDungeonList* ActivatedDungeonList;                              // 0x0070 (size: 0x8)
    class USBDungeonRecordList* DungeonRecordList;                                    // 0x0078 (size: 0x8)
    TArray<FSBGatherPointRespawnInfo> GatherPointRespawmInfoList;                     // 0x0080 (size: 0x10)
    TArray<FSBTreasureBoxRespawnInfo> TreasureBoxRespawmInfoList;                     // 0x0090 (size: 0x10)
    TArray<FSBFreeBuffPointRespawnInfo> FreeBuffPointRespawmInfoList;                 // 0x00A0 (size: 0x10)
    TArray<FSBFreeBuffPlayerBuffTimeInfo> FreeBuffPlayerBuffTimeInfoList;             // 0x00B0 (size: 0x10)
    TArray<FSBTreasureBoxOpeningLotResult> TreasureBoxOpeningLotResults;              // 0x00C0 (size: 0x10)
    TArray<FSBAchievementInfo> AchievementInfoList;                                   // 0x00D0 (size: 0x10)
    TArray<int32> PopupNewAchievementList;                                            // 0x00E0 (size: 0x10)
    TArray<int32> AwardIdList;                                                        // 0x00F0 (size: 0x10)
    TArray<int32> CharacterCardDecorationIdList;                                      // 0x0100 (size: 0x10)
    TArray<int32> AdventureCardDecorationIdList;                                      // 0x0110 (size: 0x10)
    TArray<int32> BackGroundColorIdList;                                              // 0x0120 (size: 0x10)
    TArray<FSBLiquidMemoryInfo> LiquidMemoryInfos;                                    // 0x0130 (size: 0x10)
    TArray<FPhotoModeUploadedImageInfo> PhotoModeUploadedImageInfos;                  // 0x0140 (size: 0x10)
    TArray<FString> BlackListedInfos;                                                 // 0x0150 (size: 0x10)
    TArray<FString> SafeListInfos;                                                    // 0x0160 (size: 0x10)
    TArray<FString> PSOnlyDiffListedInfos;                                            // 0x0170 (size: 0x10)
    char padding_0[0x1B0];                                                            // 0x0180 (size: 0x1B0)
    TArray<FSBLoginBonus> LoginBonusCheckData;                                        // 0x0330 (size: 0x10)
    TMap<FString, int32> LoginBonusDayCount;                                          // 0x0340 (size: 0x50)
    FDateTime LoginBonusCheckTime;                                                    // 0x0390 (size: 0x8)
    TArray<FSBLoginBonus> LoginBonusMenuListData;                                     // 0x0398 (size: 0x10)
    FSBFang_expeditionData ExpeditionData;                                            // 0x03A8 (size: 0x38)
    FSBMailRewardData ExpeditionRewardData;                                           // 0x03E0 (size: 0x180)
    TArray<FString> ExpeditionUseIdList;                                              // 0x0560 (size: 0x10)
    TArray<FSBNotificationMenuData> NotificationMenuDataList;                         // 0x0570 (size: 0x10)

    void UpdatePSOnlyDiffListedInfos(FString CharacterId, const bool IsAdd);
    void UpdateProceedingQuestNum();
    void UpdatePartyInfoLeave(FString CharacterId);
    void UpdateBlackListedInfos(FString CharacterId, const bool IsAdd);
    void SortLiquidMemoryInfos(const ESBLiquidMemoryInfoSortType InSortType, TArray<FSBLiquidMemoryInfo>& InLiquidMemoryInfos);
    void SetQuestStatus(const int32 QuestIndex, const EQuestStatus QuestStatus);
    void SaveRecruitPartyInfo(const FSBPartyRecruitData& Info);
    void SaveRecruitmentPartyInfo(const FSBPartyRecruitData& InMyRecruitmentPartyInfo);
    bool IsLiquidMemoryEfficacyActivated_Id(const int32 InLiquidMemoryId);
    bool IsLiquidMemoryEfficacyActivated_CategoryAndEfficacyType(const ESBLiquidMemoryCategory InCategory, const ESBLiquidMemoryEfficacyType InEfficacyType);
    bool IsAllowAcceptQuestByProceedingNum(const int32 QuestIndex);
    bool IsAchievementPossession(const int32 InAchievementIndex);
    int32 GetStorageNumber();
    class USBOwnItemListContainer* GetStorage(const int32 InStorageNumber);
    FSBPartyRecruitData GetRecruitPartyInfo();
    FSBPartyRecruitData GetRecruitmentPartyInfo();
    EQuestStatus GetQuestStatus(const int32 QuestIndex);
    int32 GetProceedingSubQuestNum();
    int32 GetProceedingSubQuestMax();
    int32 GetProceedingMainQuestNum();
    TArray<FPhotoModeUploadedImageInfo> GetPhotoModeUploadedImageInfos();
    int32 GetOwnLiquidMemoryNum();
    class USBOwnItemList* GetOwnItemList();
    float GetOwnActivatedLiquidMemoryEfficacyValue_ByCategoryAndEfficacyType(const ESBLiquidMemoryCategory InCategory, const ESBLiquidMemoryEfficacyType InEfficacyType, bool& OutIsValid);
    float GetOwnActivatedLiquidMemoryEfficacyValue(const FSBLiquidMemoryInfo& InLiquidMemoryInfo, bool& OutIsValid);
    void GetNotificationMenuData(TArray<FSBNotificationMenuData>& DataList);
    void GetLoginBonusActiveIds(TArray<FString>& IDList);
    TArray<FSBLiquidMemoryInfo> GetLiquidMemoryInfos();
    class USBOwnItemListContainer* GetInventory();
    class USBOwnItemListContainer* GetEquipmentBag();
    class USBDungeonRecordList* GetDungeonRecordList();
    class USBCharacterData* GetCharacterData();
    TArray<int32> GetCharacterCardIdList();
    TArray<int32> GetBackGroundColorDecorationIdLIst();
    TArray<int32> GetAwardIdList();
    TArray<int32> GetAdventureCardDecorationIdList();
    class USBActivatedDungeonList* GetActivatedDungeonList();
    TArray<FSBAchievementInfo> GetAchievementList();
    int32 FindUnlockedQuestIndex(const int32 QuestIndex);
    FSBLiquidMemoryInfo FindOwnLiquidMemoryInfo_ByCategoryAndEfficacyType(const ESBLiquidMemoryCategory InCategory, const ESBLiquidMemoryEfficacyType InEfficacyType, bool& OutExists);
    FSBLiquidMemoryInfo FindOwnLiquidMemoryInfo(const int32 InLiquidMemoryId, bool& OutExists);
    int32 FindAcceptedQuestIndex(const int32 QuestIndex);
    FAcceptedQuestInfo FindAcceptedQuestData(const int32 QuestIndex, bool& bExist);
    void DeleteRecruitPartyInfo();
    void DeleteRecruitmentPartyInfo();
    void ClearNotificationData();
    void Clear();
    bool CheckIsSafeListByCharacterId(FString CharacterId);
    bool CheckIsPSOnlyDiffListedByCharacterId(FString CharacterId);
    bool CheckIsBlackListedByCharacterId(FString CharacterId);
    bool CheckIfOneOrMoreLiquidMemoryIsUsable();
    void AddNotificationData(const FSBNotificationMenuData& Data);
    void AddAchievement(const int32 InAchievementIndex);
}; // Size: 0x580

class USBNetworkSmoothMoveComponent : public UActorComponent
{
    char padding_0[0x150];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x150

class USBNewMarkManager : public UObject
{
    TMap<TEnumAsByte<ENewMarkContentType::Type>, FReadedMarkData> ReadedIDDictionary; // 0x0028 (size: 0x50)
    bool bIsModify;                                                                   // 0x0078 (size: 0x1)

    bool IsReadedID(TEnumAsByte<ENewMarkContentType::Type> InContentType, FString InId);
}; // Size: 0x80

class USBNewMarkSaveData : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FSBPlayerReadedData Data;                                                         // 0x0040 (size: 0x60)

}; // Size: 0xA0

class USBNgWordComponent : public UActorComponent
{
    FSBNgWordComponentOnHasNgWord OnHasNgWord;                                        // 0x00C0 (size: 0x10)
    void OnHasNgWord(const bool bHasNgWord);

    bool Request_CheckHasNgWords(FString CheckText);
    void OnHasNgWord_Internal(const bool HasNgWord);
    void OnHasNgWord__DelegateSignature(const bool bHasNgWord);
}; // Size: 0xD0

class USBNiagaraCaptureComponent : public USceneComponent
{
    TArray<TWeakObjectPtr<UNiagaraComponent>> ShowComponents;                         // 0x0208 (size: 0x10)
    TEnumAsByte<ECameraProjectionMode::Type> ProjectionType;                          // 0x0218 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0219 (size: 0x3)
    float FOVAngle;                                                                   // 0x021C (size: 0x4)
    float OrthoWidth;                                                                 // 0x0220 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0224 (size: 0x4)
    class UTextureRenderTarget2D* TextureTarget;                                      // 0x0228 (size: 0x8)

    void ShowComponent(class UNiagaraComponent* InComponent);
    void RemoveShowComponent(class UNiagaraComponent* InComponent);
    void ClearShowComponents();
}; // Size: 0x230

class USBNiagaraSoundComponent : public USceneComponent
{
    class UAkAudioEvent* OneShotSE;                                                   // 0x0208 (size: 0x8)
    class UNiagaraComponent* NiagaraComponent;                                        // 0x0210 (size: 0x8)

    void SetNiagaraComponent(class UNiagaraComponent* InNiagaraComponent);
}; // Size: 0x220

class USBNotificationMenu : public UUserWidget
{
    FSBNotificationMenuFinishDelegateNotification FinishDelegateNotification;         // 0x0278 (size: 0x10)
    void FinishDelegate();

    void SetParameter();
    void GetNotificationMenuAllData(TArray<FSBNotificationMenuData>& OutData, bool& Valid);
    void FinishDelegate__DelegateSignature();
    void CheckDisplayTime(const FSBNotificationMenuData& Data, bool& Valid);
    void CallFinishEvent();
}; // Size: 0x298

class USBNotificationSaveGame : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBNotificationData Data;                                                         // 0x0050 (size: 0x28)

}; // Size: 0x78

class USBNotifyChangedDetector : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBNotifyCompletionExpeditionEventParam : public UObject
{
    FString AreaName;                                                                 // 0x0028 (size: 0x10)

}; // Size: 0x38

class USBNotifySchedulerComponent : public USceneComponent
{
    TArray<FSBTimeNotifyEvent> Notifies;                                              // 0x0228 (size: 0x10)
    char padding_0[0x10];                                                             // 0x0238 (size: 0x10)
    TArray<class USBTimeNotifyEventsData*> SBTimeNotifyEventsDatas;                   // 0x0248 (size: 0x10)

    void ClearNotifyEvents();
    void AddNotifyEventsFromRegisteredAsset(int32 AssetIndex);
    void AddNotifyEventsFromAsset(const class USBTimeNotifyEventsData* NotifyAsset);
}; // Size: 0x260

class USBNpcBPFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBNpcCharacterAnimInstance : public USBCharacterAnimInstance
{
    float TurnSpeed;                                                                  // 0x0FD8 (size: 0x4)
    FVector TargetLocation;                                                           // 0x0FDC (size: 0xC)
    FDateTime TurnStartTime;                                                          // 0x0FE8 (size: 0x8)

}; // Size: 0xFF0

class USBNpcCharacterMovementComponent : public USBCharacterMovementBaseComponent
{
    float MeanWalkSpeed;                                                              // 0x0BD8 (size: 0x4)
    float StandardDeviationWalkSpeed;                                                 // 0x0BDC (size: 0x4)

}; // Size: 0xBE0

class USBNpcControlSettings : public USBPawnControlSettings
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBNpcHoldHandComponent : public USBHoldHandComponent
{
    bool bHoldHandWithLocalPlayer;                                                    // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class USBNpcInteractionTargetComponent : public USBInteractionTargetComponent
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x290

class USBNpcLaneGraph : public UObject
{
    TArray<FSBNpcLaneNode> Nodes;                                                     // 0x0028 (size: 0x10)
    TArray<FSBNpcLaneLink> Links;                                                     // 0x0038 (size: 0x10)

    void OnNavigationGenerationFinished(class ANavigationData* NavData);
}; // Size: 0x50

class USBNpcManager : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    int32 GetNpcNum();
    class AActor* GetNpc(const int32 Index);
}; // Size: 0x38

class USBNpcNavPathRenderingComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBNpcParameterManager : public UObject
{
    class UDataTable* NpcJobDB;                                                       // 0x0028 (size: 0x8)
    class UDataTable* NpcSpawnParameterDB;                                            // 0x0030 (size: 0x8)
    class UDataTable* NpcJobAutoCreateCmnDB;                                          // 0x0038 (size: 0x8)
    class UDataTable* NpcJobAutoCreateR01DB;                                          // 0x0040 (size: 0x8)
    class UDataTable* NpcJobAutoCreateR02DB;                                          // 0x0048 (size: 0x8)
    class UDataTable* NpcJobAutoCreateR03DB;                                          // 0x0050 (size: 0x8)
    class UDataTable* NpcJobAutoCreateR04DB;                                          // 0x0058 (size: 0x8)
    class UDataTable* NpcJobAutoCreateR05DB;                                          // 0x0060 (size: 0x8)

}; // Size: 0x78

class USBNpcPathComponent : public USplineComponent
{
    float PathPointWidth;                                                             // 0x0560 (size: 0x4)
    EPathDirection PathDirection;                                                     // 0x0564 (size: 0x1)
    EPathTarget PathTarget;                                                           // 0x0565 (size: 0x1)

    EPathTarget GetPathTarget();
    float GetPathPointWidth();
    EPathDirection GetPathDirection();
    FVector FindLocationAndDistanceClosestToWorldLocation(const FVector WorldLocation, float& Distance);
}; // Size: 0x570

class USBNpcPathFollowingComponent : public UPathFollowingComponent
{
    char padding_0[0x268];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x268

class USBNpcPerformanceOptimizationComponent : public UActorComponent
{
    class APlayerController* PlayerController;                                        // 0x00B8 (size: 0x8)
    class ASBNpcSpawner* NpcSpawner;                                                  // 0x00C0 (size: 0x8)

}; // Size: 0xD8

class USBNpcPool : public USBPawnPool
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBNpcPreviewComponent : public UChildActorComponent
{
    char padding_0[0x240];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x240

class USBNpcProjectSettings : public UObject
{
    FSoftClassPath NpcClass;                                                          // 0x0028 (size: 0x18)
    FSoftClassPath AnimalClass;                                                       // 0x0040 (size: 0x18)

}; // Size: 0x58

class USBNpcSensorComponent : public UCapsuleComponent
{
    FSBNpcSensorComponentOnSensorInActor OnSensorInActor;                             // 0x0488 (size: 0x10)
    void OnSensorInActor(class AActor* Actor, const bool IsFirstIn);
    FSBNpcSensorComponentOnSensorOutActor OnSensorOutActor;                           // 0x0498 (size: 0x10)
    void OnSensorOutActor(class AActor* Actor, const bool IsLastOut);
    FSBNpcSensorComponentOnSensorNearestActorChange OnSensorNearestActorChange;       // 0x04A8 (size: 0x10)
    void OnSensorNearestActorChange(class AActor* PrevActor, class AActor* NextActor);

    void SetDisableEventNotify(bool bDisable);
    void OnSensorOutActor__DelegateSignature(class AActor* Actor, const bool IsLastOut);
    void OnSensorNearestActorChange__DelegateSignature(class AActor* PrevActor, class AActor* NextActor);
    void OnSensorInActor__DelegateSignature(class AActor* Actor, const bool IsFirstIn);
    bool IsValidInSensorActor(class AActor* Actor);
    bool IsInSensorActor(class AActor* Actor);
    bool IsDisableEventNotify();
    class AActor* GetNearestActor();
    void EndComponentOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    void BeginComponentOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
}; // Size: 0x4E0

class USBNpcStraightLaneRenderingComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBNpcTalkActionComponent : public UActorComponent
{
    float InteractionTurnAngle;                                                       // 0x00C8 (size: 0x4)
    bool IsInteractionLookAt;                                                         // 0x00CC (size: 0x1)
    char padding_0[0x13];                                                             // 0x00CD (size: 0x13)
    FSBNpcTalkActionComponentOnTickComponentDelegate OnTickComponentDelegate;         // 0x00E0 (size: 0x10)
    void SBOnTickComponentDelegate(class ASBMobCharacter* InMobCharacter);
    char padding_1[0x50];                                                             // 0x00F0 (size: 0x50)
    bool bIsTurnAnimationRatioMax;                                                    // 0x0140 (size: 0x1)

    void SetSkipStartWaitSendCommand();
    void SetActorRotationAtTick(FRotator NewRotation);
    bool SendWaitCommand();
    void SBOnTickComponentDelegate__DelegateSignature(class ASBMobCharacter* InMobCharacter);
    void ReserveWaitCommand(const FName& Command);
    bool IsSkipStartWaitSendCommand();
    bool IsEnableNpcTalk();
    void InitializeWaitCommand();
    void FinishWaitCommand();
    void EnableNpcTalk();
    void ClearTalkEndAction();
    void ClearSkipStartWaitSendCommand();
}; // Size: 0x150

class USBNpcWaitParamComponent : public UActorComponent
{
    char padding_0[0x108];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x108

class USBObjectNamePlateComponent2D : public USBNamePlateComponent2D
{
    char padding_0[0x2C0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2C0

class USBOceanRippleCaptureComponent : public USBNiagaraCaptureComponent
{
    class UNiagaraSystem* RippleEffect;                                               // 0x0230 (size: 0x8)
    float CameraHeight;                                                               // 0x0238 (size: 0x4)
    char padding_0[0x4];                                                              // 0x023C (size: 0x4)
    class UMaterialParameterCollection* ParameterCollection;                          // 0x0240 (size: 0x8)
    class AOcean* Ocean;                                                              // 0x0248 (size: 0x8)
    TMap<class ASBPlayerCharacter*, class UNiagaraComponent*> SpawnedEffects;         // 0x0250 (size: 0x50)
    TMap<ASBPlayerCharacter*, int32> OverlappedAreas;                                 // 0x02A0 (size: 0x50)

    void OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
    void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
    void AddOverlapWaterArea(class AActor* WaterArea);
}; // Size: 0x2F0

class USBOnLoadRouteGuideQuestIdEventParam : public UObject
{
    bool bResult;                                                                     // 0x0028 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0029 (size: 0x3)
    FName QuestID;                                                                    // 0x002C (size: 0x8)

}; // Size: 0x38

class USBOnlineBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool TravelToOffGameFromOfflineByGameContentId(class UObject* WorldContextObject, const FName& GameContextId);
    void TravelToOffGameByGameContentId(class UObject* WorldContextObject, class ASBPlayerCharacter* PlayerCharacter, const FName& GameContentId, FString ExtraConfig);
    void TravelToOffGame(class UObject* WorldContextObject, class ASBPlayerCharacter* PlayerCharacter, FString MapName, FString ExtraConfig);
    void StartInstanceBattleFromId(class UObject* WorldContextObject, class ASBPlayerController* PlayerController, const FName& ContentId);
    void StartInstanceBattle(class UObject* WorldContextObject, class ASBPlayerController* PlayerController, const FSBMapInfo& ContentInfo);
    void RejoinGameTravelOption(class UObject* WorldContextObject, const FSBTravelOption& InOption);
    void RejoinGameTravel(class UObject* WorldContextObject, const FName& InGameContentId, FString InGameMode, FString InSpawnPortalName);
    void RejoinGamePreviousMap(class UObject* WorldContextObject);
    void RejoinGame(class UObject* WorldContextObject);
    bool IsTraveling(class UObject* WorldContextObject);
    bool HasAccessTokenLocalPlayer(class UObject* WorldContextObject, FString& OutAccessToken);
    void EndTutorialMap(class UObject* WorldContextObject);
    void BeginTutorialMap(class UObject* WorldContextObject, bool bFirstChallenge);
}; // Size: 0x28

class USBOnlineCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SelfKickConflictPlayer();
    void PrintRepGraphNodePolicies();
    void KickConflictPlayer(FString InUserId);
}; // Size: 0x28

class USBOnlineMessageManager : public UObject
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC8

class USBOnlineMessageSystem : public UObject
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBOnlinePlayer : public UObject
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)

    FString GetPlayerIdString();
    FString GetCharacterName();
    FString GetCharacterIdString();
}; // Size: 0x88

class USBOnlineSessionBase : public UOnlineSession
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBOnlineSessionClient : public USBOnlineSessionBase
{
    FSBPreJoinSessionFirstData FirstData;                                             // 0x0038 (size: 0x30)
    FSBPreJoinSessionDummyClientData DummyClientData;                                 // 0x0068 (size: 0xA8)
    FTimerHandle Handle;                                                              // 0x0110 (size: 0x8)
    char padding_0[0x10];                                                             // 0x0118 (size: 0x10)
    bool bHandlingDisconnect;                                                         // 0x0128 (size: 0x1)

}; // Size: 0x270

class USBOnlineSessionServer : public USBOnlineSessionBase
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBOpenCommandMenu : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBOpenModelessDirectoryDialogScreenBlock : public USBOpenModelessDirectoryDialog
{
    char padding_0[0xA0];                                                             // 0x0000 (size: 0x0)

    class USBOpenModelessDirectoryDialogScreenBlock* SBOpenModelessDirectoryDialogScreenBlock(class UObject* WorldContextObject, FString DialogTitle, FString DefaultPath);
}; // Size: 0xA0

class USBOptionChildBase : public USBUserWidget
{
    char padding_0[0x2B0];                                                            // 0x0000 (size: 0x0)

    void SetTitleMode(bool bTitle);
    void Open();
    void Close();
    void ApplyCursorSpeed(class ASBPlayerController* InPlayerController, int32 Speed);
}; // Size: 0x2B0

class USBOtherMessageComponent : public UActorComponent
{
    int32 RenderTargetSizeX;                                                          // 0x00B8 (size: 0x4)
    int32 RenderTargetSizeY;                                                          // 0x00BC (size: 0x4)
    char padding_0[0xB0];                                                             // 0x00C0 (size: 0xB0)
    TArray<FOtherMessageRenderTarget> RenderTargetList;                               // 0x0170 (size: 0x10)

    bool ShowRequest(class AActor* InSpeaker, FString InText);
    void SetForceShow(bool IsFlag);
    void OnCloseWindow(class USBBalloonWindow* InWindow);
}; // Size: 0x188

class USBOutGameBuffBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    TArray<FSBOwnedBuffItemData> GetOwnedBuffItemData(const class UObject* InWorldContextObject);
    float GetLimitedBuffValue(const EOutGameBuffType InBuffType, const float InCheckValue);
    EOutGameBuffType GetBuffType(const EItemEfficacyType InEfficatyType);
}; // Size: 0x28

class USBOutGameBuffComponent : public UActorComponent
{
    FSBActiveOutGameBuffDataList BuffDataList;                                        // 0x00B8 (size: 0x30)

    float GetBuffValue(const EOutGameBuffType InType);
}; // Size: 0x2F8

class USBOverlay : public UPanelWidget
{
    FLinearColor ContentColorAndOpacity;                                              // 0x0148 (size: 0x10)
    FSBOverlayContentColorAndOpacityDelegate ContentColorAndOpacityDelegate;          // 0x0158 (size: 0x10)
    FLinearColor GetLinearColor();
    bool bBlockInput;                                                                 // 0x0168 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0169 (size: 0x7)
    FSBOverlayOnKeyDown OnKeyDown;                                                    // 0x0170 (size: 0x10)
    void OnOverlayKeyDownEvent(const FKeyEvent& InKeyEvent);
    FSBOverlayOnKeyUp OnKeyUp;                                                        // 0x0180 (size: 0x10)
    void OnOverlayKeyUpEvent(const FKeyEvent& InKeyEvent);
    FSBOverlayOnClicked OnClicked;                                                    // 0x0190 (size: 0x10)
    void OnOverlayClickedEvent();

    void SetContentColorAndOpacity(FLinearColor InContentColorAndOpacity);
    class USBOverlaySlot* AddChildToOverlay(class UWidget* Content);
}; // Size: 0x1A0

class USBOverlaySlot : public UPanelSlot
{
    FMargin Padding;                                                                  // 0x0038 (size: 0x10)
    TEnumAsByte<EHorizontalAlignment> HorizontalAlignment;                            // 0x0048 (size: 0x1)
    TEnumAsByte<EVerticalAlignment> VerticalAlignment;                                // 0x0049 (size: 0x1)

    void SetVerticalAlignment(TEnumAsByte<EVerticalAlignment> InVerticalAlignment);
    void SetPadding(FMargin InPadding);
    void SetHorizontalAlignment(TEnumAsByte<EHorizontalAlignment> InHorizontalAlignment);
}; // Size: 0x58

class USBOwnItemList : public UObject
{
    class USBOwnItemListContainer* Inventory;                                         // 0x0028 (size: 0x8)
    class USBOwnItemListContainer* EquipmentBag;                                      // 0x0030 (size: 0x8)
    TArray<class USBOwnItemListContainer*> Storages;                                  // 0x0038 (size: 0x10)
    class USBOwnItemListContainer* UnpossessedItems;                                  // 0x0048 (size: 0x8)
    char padding_0[0x8];                                                              // 0x0050 (size: 0x8)
    FSBOwnItemListOwnItemChangeAmountDelegate OwnItemChangeAmountDelegate;            // 0x0058 (size: 0x10)
    void OwnItemChangeAmountDelegate(const FSBChangeItemAmountParam& InParam);
    FSBOwnItemListOwnItemPostUpdateItemsDelegate OwnItemPostUpdateItemsDelegate;      // 0x0068 (size: 0x10)
    void OwnItemPostUpdateItemsDelegate();
    class USBOwnItemListContainer* Identified_Appraised;                              // 0x0078 (size: 0x8)
    class USBOwnItemListContainer* Identified_Unidentified;                           // 0x0080 (size: 0x8)
    class USBOwnItemListContainer* Deleted_Appraised;                                 // 0x0088 (size: 0x8)
    class USBOwnItemListContainer* Deleted_Unidentified;                              // 0x0090 (size: 0x8)
    int32 SaleProfits;                                                                // 0x0098 (size: 0x4)

    void OwnItemPostUpdateItemsDelegate__DelegateSignature();
    void OwnItemChangeAmountDelegate__DelegateSignature(const FSBChangeItemAmountParam& InParam);
    void NotifyWishList();
    bool IsMoveditemsData();
    class USBOwnItemListContainer* GetUnpossessedItems();
    int32 GetStorageNumber();
    class USBOwnItemListContainer* GetStorage(const int32 InStorageNumber);
    int32 GetSaleProfits();
    class USBOwnItemListContainer* GetMoveditems_Unidentified();
    class USBOwnItemListContainer* GetMoveditems_Appraised();
    class USBOwnItemListContainer* GetItemBag();
    class USBOwnItemListContainer* GetInventory();
    class USBOwnItemListContainer* GetEquipmentBag();
    class USBOwnItemListContainer* GetDeletedtems_Unidentified();
    class USBOwnItemListContainer* GetDeletedtems_Appraised();
    class USBOwnItemListContainer* GetCharacterStorage();
    FOwnItemInfo BP_FindItemByAllStorage(FString InUniqueId, bool& bOutExist);
}; // Size: 0xA0

class USBOwnItemListContainer : public UObject
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)

    void Sort(const TEnumAsByte<ESBItemSortType::Type> SortType);
    void SetItemLock(FString InUniqueId, const bool InLock);
    void ResetSort();
    EAddItemOpResult QueryAddItem(const EItemType InItemType, const int32 InItemIndex, const int32 InAmount);
    bool IsValidIndex(const int32 InIndex);
    bool IsItemLock(FString InUniqueId);
    bool IsItemInventory();
    bool IsInventory();
    bool IsEquipInventory();
    bool IsBppIrredeemable(FString InUniqueId);
    int32 GetUseBlockNum();
    class USBTemporallyStorage* GetTemporallyStorage();
    int32 GetStackableNum(class ASBPlayerController* PlayerController, const EItemType InItemType, const int32 InItemIndex, const bool bInInventory);
    int32 GetSotedIndexNum();
    TArray<FOwnItemInfo> GetSortFilterItem(const TEnumAsByte<ESBItemSortType::Type> InSortType, const FFilterGroup& InFilter, const TArray<FFilterGroup>& InFilterBox);
    int32 GetSlackNum(const EItemType InItemType, const int32 InItemIndex);
    int32 GetItemTypeNum(EItemType InItemType);
    EItemType GetItemType(const int32 InItemIndex);
    int32 GetItemsNum();
    int32 GetItemAmount_ByUniqueId(const FString InUniqueId);
    bool GetIsBoostCapacity();
    int32 GetFreeBlockNum();
    TArray<FString> GetCollectItemsUniqueID(const int32 InItemIndex, const int32 InAmount);
    int32 GetCapacity();
    int32 GetBoostCapacitySum();
    int32 GetBoostCapacity();
    int32 FindSortedIndexByUniqueId(FString UniqueId);
    void Filter(const FFilterGroup& Filter);
    bool ContainsByUniqueId(FString UniqueId);
    FOwnItemInfo BP_GetSortedItemAt(const int32 InIndex);
    int32 BP_GetItemAmount_ByItemIndex(const EItemType InItemType, const int32 InItemIndex, const bool bInCalcUnidentifiedItem);
    FOwnItemInfo BP_GetItem(const int32 InIndex);
    FOwnItemInfo BP_FindItem_ByUniqueId(FString InUniqueId, bool& bOutExist);
    FOwnItemInfo BP_FindItem_ByItemIndex(const EItemType InItemType, const int32 ItemIndex, bool& bOutExist);
}; // Size: 0x68

class USBP020_CountIcon_PartsWidget : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void OnSetONOFF(bool bOn);
}; // Size: 0x278

class USBP020_MarkEnemy : public UUserWidget
{
    class UCanvasPanel* CanvasPanel_0;                                                // 0x0278 (size: 0x8)
    class USBP020_MarkIcon* MarkA;                                                    // 0x0280 (size: 0x8)
    class USBP020_MarkIcon* MarkB;                                                    // 0x0288 (size: 0x8)
    class USBP020_MarkIcon* MarkC;                                                    // 0x0290 (size: 0x8)

    void Update(bool bVisible, bool bMarkA, bool bMarkB, bool bMarkC);
}; // Size: 0x298

class USBP020_MarkIcon : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    void ShowIcon(bool bVisible);
    void OnIconVisibilityStart();
    void OnIconVisibilityEnd();
}; // Size: 0x280

class USBPCBerserkerComponent : public USBPCClassComponentBase
{
    FSBBerserkerComboSettings ComboSetting;                                           // 0x0180 (size: 0x60)
    char padding_0[0xA0];                                                             // 0x01E0 (size: 0xA0)
    float ComboGaugeResetHPRate;                                                      // 0x0280 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0284 (size: 0x4)
    TArray<FSBConditionCheckParam> ComboGaugeNoResetConditionList;                    // 0x0288 (size: 0x10)
    char padding_2[0x48];                                                             // 0x0298 (size: 0x48)
    float RampageRecastTimeRate;                                                      // 0x02E0 (size: 0x4)
    float RampageMaxHitPointRate;                                                     // 0x02E4 (size: 0x4)

    void ServerUpdateConsumeComboParam(float ComboGaugeAmount, bool bCanConsumeComboAttack, uint8 SkillPosition);
    void ServerSetComboGaugeAmount(float Amount);
    float GetComboGaugeRate();
    float GetComboDamageUpRate();
}; // Size: 0x2E8

class USBPCBlasterComponent : public USBPCClassComponentBase
{
    TArray<FSBBlasterHitDistanceDamageModifySetting> HitDistanceDamageModifySettingList; // 0x0180 (size: 0x10)
    char padding_0[0x60];                                                             // 0x0190 (size: 0x60)
    FSBWeaponAnimationPlayParam m_DefaultBowAnimationParam;                           // 0x01F0 (size: 0x10)
    char padding_1[0x10];                                                             // 0x0200 (size: 0x10)
    TArray<FSBEffectShaderParameter> m_WeaponEmissiveShaderParamList;                 // 0x0210 (size: 0x10)

    void OnCharacterServerTakeDamageBeforeCalcDamageAttacker(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst, bool bInvincible);
    int32 GetReflectMirageNum();
    class AActor* GetReflectMirage(int32 Index);
}; // Size: 0x220

class USBPCClassComponentBase : public USBPlayerActorComponent
{
    TArray<class USBPlayerPassiveSkill*> m_EquippedPassiveArtsInfoList;               // 0x0120 (size: 0x10)
    FSBPCClassComponentBasePassiveSkillChangeNotify PassiveSkillChangeNotify;         // 0x0130 (size: 0x10)
    void OnPassiveSkillChangeNotify();
    char padding_0[0x30];                                                             // 0x0140 (size: 0x30)
    TArray<FSBPlayerAttackHitLaunchProjectile> AttackLaunchProjectileList;            // 0x0170 (size: 0x10)

    void ServerChangeEquipPassiveArts(const FSBPassiveSkillID& PassiveArtsID, bool bSetEquipped, int32 SlotIndex);
    void RequestUnequipPassiveSkillAll();
    bool RequestUnequipPassiveSkill(const int32& PassiveSkillID, int32 SlotIndex);
    bool RequestEquipPassiveSkill(const int32& PassiveSkillID, int32 SlotIndex);
    void RequestAimAssist(const FSBPlayerAimAssistSetting& AimAssistSetting);
    void OnPassiveSkillChangeNotify__DelegateSignature();
    void MulticastChangeEquipPassiveArts(const int32& PassiveArtsID, bool bSetEquipped, int32 SlotIndex);
    bool IsPassiveSkillEquipped(const int32& PassiveSkillID);
    int32 GetPassiveSkillEquippedSlotIndex(const int32& PassiveSkillID);
    bool GetEquippedPassiveSkillByIndex(const int32 Index, int32& OutSkillId, int32& OutSlotIndex);
    int32 GetEquippedPassiveSkill(int32 SlotIndex);
}; // Size: 0x180

class USBPCLancerComponent : public USBPCClassComponentBase
{
    FSBPCLancerComponentOnStartIntervalDesire OnStartIntervalDesire;                  // 0x0188 (size: 0x10)
    void OnStartIntervalDesire();
    FSBPCLancerComponentOnEndIntervalDesire OnEndIntervalDesire;                      // 0x0198 (size: 0x10)
    void OnEndIntervalDesire();

    void OnUpdateErasedMarkList(FSBServerDamageEvent& DamageEvent, class AActor* DamageCauser, class AActor* DamageDst, bool bInvincible);
    void OnStartIntervalDesire__DelegateSignature();
    void OnEndIntervalDesire__DelegateSignature();
    float GetDesireIntervalRemainingTimeRate();
    float GetDesireIntervalRemainingTime();
    bool CanDesire();
}; // Size: 0x1C0

class USBPCMagicianComponent : public USBPCClassComponentBase
{
    float MaxMagicPoint;                                                              // 0x0198 (size: 0x4)
    char padding_0[0x4];                                                              // 0x019C (size: 0x4)
    TArray<FSBConditionCheckFloatParam> m_ModifyMaxMPSettingList;                     // 0x01A0 (size: 0x10)
    char padding_1[0x38];                                                             // 0x01B0 (size: 0x38)
    float m_NoBattleMPRecoveryCycle;                                                  // 0x01E8 (size: 0x4)
    float m_NoBattleMPRecoveryAmount;                                                 // 0x01EC (size: 0x4)
    FSBConditionCheckParam CancelSameSkillCondition;                                  // 0x01F0 (size: 0x60)
    FSBConditionCheckParam CancelDifferentSkillCondition;                             // 0x0250 (size: 0x60)

    void SetInfiniteMP(bool bEnable);
    void SetCurrentMagicPoint(float InMagicPoint);
    void ServerStopThunderCloudInfo();
    void ServerStartThunderCloudInfo();
    void ServerSetSubAction(bool bSubAction);
    void ServerLaunchThunder();
    void ServerCheckThunderMineInfo(int32 SkillId, int16 SkillLevel, int16 LaunchNum);
    void ServerCheckReduceMagicPoint(int32 SkillId, float PreValue, float AftValue, float MaxValue);
    bool IsStackMEnable();
    float GetStackMAccumulationSec();
    float GetStackMAccumulationElapedTime();
    float GetMaxMagicPoint();
    float GetMagicPointRate();
    int32 GetCurrentStackM();
    float GetCurrentMagicPoint();
    void AdjustCurrentMagicPoint(const float AddValue);
}; // Size: 0x2B8

class USBPCRebellionComponent : public USBPCClassComponentBase
{
    bool m_bBarrierActive;                                                            // 0x01B0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x01B1 (size: 0x3)
    float m_BarrierCurrentHP;                                                         // 0x01B4 (size: 0x4)
    FSBPlayingEffect m_BarrierEffect;                                                 // 0x01B8 (size: 0xC8)
    FSBPCRebellionComponentOnStartIntervalDependent OnStartIntervalDependent;         // 0x0280 (size: 0x10)
    void OnStartIntervalDependent();
    FSBPCRebellionComponentOnEndIntervalDependent OnEndIntervalDependent;             // 0x0290 (size: 0x10)
    void OnEndIntervalDependent();

    void ServerSetShieldCounterCondition(bool bActive);
    void ServerCounterBarrierActive(bool bActive);
    void OnStartIntervalDependent__DelegateSignature();
    void OnRep_BarrierActive();
    void OnEndIntervalDependent__DelegateSignature();
    void NotifyShieldCounterPosture();
    void NotifyCounterBarrierChange(bool bActive);
    bool IsCounterBarrierActive();
    class USBRebellionGuardSkill* GetRebellionGuardSkill();
    float GetDependentIntervalRemainingTime();
    float GetCounterBarrierMaxHP();
    float GetCounterBarrierHP();
    bool CanDependent();
}; // Size: 0x2A0

class USBPCSmasherComponent : public USBPCClassComponentBase
{
    float MaxBoostCartridge;                                                          // 0x0200 (size: 0x4)
    float InitialBoostCartridge;                                                      // 0x0204 (size: 0x4)
    FSBSmasherReloadSettingGroup ReloadSetting;                                       // 0x0208 (size: 0x20)
    float MaxReloadBonusBoostCartridge;                                               // 0x0228 (size: 0x4)
    char padding_0[0x38];                                                             // 0x022C (size: 0x38)
    FSBWeaponAnimationPlayParam m_WeaponSheatheAnimationParam;                        // 0x0264 (size: 0x10)
    FSBWeaponAnimationPlayParam m_WeaponUnsheatheAnimationParam;                      // 0x0274 (size: 0x10)

    void SetBoostCartridgeReloadType(ESBSmasherReloadType InType);
    void ServerSetSwingRushAttackLevel(int32 NewAttackLevel);
    void ServerSetPowerReloadConsumeAllCartridgeSkillPosition(uint8 SkillPosition);
    void ServerSetLastSetupConsumeBoostCartridgeAmount(float NewConsumeAmount);
    void ServerSetDustStormAttackLevel(int32 NewAttackLevel);
    void NotifySendStatusAilmentByQuickShotBuffCharge();
    bool IsStoneBodyActive();
    bool IsPowerReloadActive();
    bool IsHealBulletActive();
    bool IsBallShooting();
    bool IsBallShootHitToTarget(ESkillActionPosition Position);
    bool IsBallShootBallReturning(ESkillActionPosition Position);
    bool IsApplyBallShootHitDamage(ESkillActionPosition Position);
    void InterruptBallShootAll(bool bImmediatelyBallReturn);
    void InterruptBallShoot(ESkillActionPosition Position, bool bImmediatelyBallReturn);
    int32 GetSwingRushAttackLevel();
    float GetMaxBoostCartridge();
    float GetLastSetupConsumeBoostCartridgeAmount();
    int32 GetDustStormAttackLevel();
    float GetCurrentBoostCartridge();
    float GetBoostCartridgeQuickReloadAmount();
    bool CanStartBallShootTypeSkill(bool bNotification, ESkillActionPosition Position);
}; // Size: 0x560

class USBPTCriterionPawns : public UAIFwPTCriterionSquadMember
{
    bool IsDetectHostile;                                                             // 0x0048 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0049 (size: 0x3)
    float MinHostileLevel;                                                            // 0x004C (size: 0x4)
    bool IsDetectNeutral;                                                             // 0x0050 (size: 0x1)
    bool IsDetectFriendly;                                                            // 0x0051 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0052 (size: 0x2)
    float MinFriendlyLevel;                                                           // 0x0054 (size: 0x4)
    bool IgnoreDied;                                                                  // 0x0058 (size: 0x1)

}; // Size: 0x60

class USBPTCriterionSquadMember : public UAIFwPTCriterionSquadMember
{
    bool IgnoreDied;                                                                  // 0x0048 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0049 (size: 0x7)
    TSubclassOf<class USBAIRoleBase> RoleClass;                                       // 0x0050 (size: 0x8)

}; // Size: 0x58

class USBPTCriterionSquadMemberDestinations : public UAIFwPTCriterionSquadMemberDestinations
{
    bool IgnoreDied;                                                                  // 0x0048 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0049 (size: 0x7)
    TSubclassOf<class USBAIRoleBase> RoleClass;                                       // 0x0050 (size: 0x8)

}; // Size: 0x58

class USBPTEvaluationActionArea : public UAIFwPTEvaluationNode
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBPTEvaluationAngle : public UAIFwPTEvaluationNodeUseCriterion
{
    bool Vector1_UseFromDirection;                                                    // 0x0050 (size: 0x1)
    EPTCriterionSlot Vector1_From;                                                    // 0x0051 (size: 0x1)
    EPTCriterionSlot Vector1_To;                                                      // 0x0052 (size: 0x1)
    bool Vector2_UseFromDirection;                                                    // 0x0053 (size: 0x1)
    EPTCriterionSlot Vector2_From;                                                    // 0x0054 (size: 0x1)
    EPTCriterionSlot Vector2_To;                                                      // 0x0055 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0056 (size: 0x2)
    FAIFwBTNodePropertyBool Is2D;                                                     // 0x0058 (size: 0x18)
    FAIFwBTNodePropertyFloat AngleMin;                                                // 0x0070 (size: 0x18)
    FAIFwBTNodePropertyFloat AngleMax;                                                // 0x0088 (size: 0x18)
    bool UseNegativeAngle;                                                            // 0x00A0 (size: 0x1)

}; // Size: 0xA8

class USBPTEvaluationCanHitAttack : public UAIFwPTEvaluationNode
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBPTEvaluationComponent : public UAIFwPTEvaluationNode
{
    TSubclassOf<class UActorComponent> ComponentClass;                                // 0x0048 (size: 0x8)

}; // Size: 0x50

class USBPTEvaluationDistance : public UAIFwPTEvaluationNodeUseCriterion
{
    FAIFwBTNodePropertyBool b2D;                                                      // 0x0050 (size: 0x18)
    FAIFwBTNodePropertyFloat BaseDistance;                                            // 0x0068 (size: 0x18)
    FAIFwBTNodePropertyFloat MinDistance;                                             // 0x0080 (size: 0x18)
    FAIFwBTNodePropertyFloat MaxDistance;                                             // 0x0098 (size: 0x18)

}; // Size: 0xB0

class USBPTEvaluationDistanceFromBattleRange : public UAIFwPTEvaluationNode
{
    FAIFwBTNodePropertyFloat MinDistance;                                             // 0x0048 (size: 0x18)
    FAIFwBTNodePropertyFloat MaxDistance;                                             // 0x0060 (size: 0x18)

}; // Size: 0x78

class USBPTEvaluationDistanceToNavWall : public UAIFwPTEvaluationNode
{
    FAIFwBTNodePropertyFloat MinDistance;                                             // 0x0048 (size: 0x18)
    FAIFwBTNodePropertyFloat MaxDistance;                                             // 0x0060 (size: 0x18)

}; // Size: 0x78

class USBPTEvaluationEnemyDensity : public UAIFwPTEvaluationNode
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBPTEvaluationHP : public UAIFwPTEvaluationNode
{
    FAIFwBTNodePropertyFloat FilterHPMin;                                             // 0x0048 (size: 0x18)
    FAIFwBTNodePropertyFloat FilterHPMax;                                             // 0x0060 (size: 0x18)
    FAIFwBTNodePropertyBool bEvalByHPRate;                                            // 0x0078 (size: 0x18)

}; // Size: 0x90

class USBPTEvaluationHate : public UAIFwPTEvaluationNode
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBPTEvaluationHeightDifference : public UAIFwPTEvaluationNodeUseCriterion
{
    FAIFwBTNodePropertyFloat MinHeight;                                               // 0x0050 (size: 0x18)
    FAIFwBTNodePropertyFloat MaxHeight;                                               // 0x0068 (size: 0x18)

}; // Size: 0x80

class USBPTEvaluationItemScore : public UAIFwPTEvaluationNode
{
    FAIFwBTNodePropertyFloat MinScore;                                                // 0x0048 (size: 0x18)
    FAIFwBTNodePropertyFloat MaxScore;                                                // 0x0060 (size: 0x18)

}; // Size: 0x78

class USBPTEvaluationOverNavMesh : public UAIFwPTEvaluationNode
{
    FAIFwBTNodePropertyFloat ProjectDown;                                             // 0x0048 (size: 0x18)
    FAIFwBTNodePropertyFloat Extent;                                                  // 0x0060 (size: 0x18)
    FAIFwBTNodePropertyBool Acceptance;                                               // 0x0078 (size: 0x18)

}; // Size: 0x90

class USBPTEvaluationOverlapVolume : public UAIFwPTEvaluationNode
{
    TSubclassOf<class AVolume> VolumeClass;                                           // 0x0048 (size: 0x8)

}; // Size: 0x50

class USBPTEvaluationRandom : public UAIFwPTEvaluationNode
{
    FAIFwBTNodePropertyFloat MaxValue;                                                // 0x0048 (size: 0x18)

}; // Size: 0x60

class USBPTEvaluationRandomByAction : public UAIFwPTEvaluationNode
{
    FAIFwBTNodePropertyFloat MaxValue;                                                // 0x0048 (size: 0x18)

}; // Size: 0x60

class USBPTEvaluationRole : public UAIFwPTEvaluationNode
{
    ESBRoleType RoleType;                                                             // 0x0048 (size: 0x1)

}; // Size: 0x50

class USBPTEvaluationSquadIMap : public UAIFwPTEvaluationNode
{
    FString LayerName;                                                                // 0x0048 (size: 0x10)
    float MinValue;                                                                   // 0x0058 (size: 0x4)
    float MaxValue;                                                                   // 0x005C (size: 0x4)

}; // Size: 0x60

class USBPTEvaluationTargetRate : public UAIFwPTEvaluationNode
{
    FAIFwBTNodePropertyFloat MinRate;                                                 // 0x0048 (size: 0x18)
    FAIFwBTNodePropertyFloat MaxRate;                                                 // 0x0060 (size: 0x18)

}; // Size: 0x78

class USBPTEvaluationTrace_UnderFoot : public UAIFwPTEvaluationTrace
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBPTGenerationCriterion : public UAIFwPTGenerationNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPTGenerationFieldSpawnPoint : public UAIFwPTGenerationNode
{
    FAIFwBTNodePropertyFloat Range;                                                   // 0x0040 (size: 0x18)
    FAIFwBTNodePropertyFloat ElavationAngle;                                          // 0x0058 (size: 0x18)
    FAIFwBTNodePropertyFloat ElavationHeight;                                         // 0x0070 (size: 0x18)

}; // Size: 0x88

class USBPTGenerationLocationAnchors : public UAIFwPTGenerationNode
{
    FAIFwBTNodePropertyInt MinimumAnchorIndex;                                        // 0x0040 (size: 0x18)
    FAIFwBTNodePropertyInt MaximumAnchorIndex;                                        // 0x0058 (size: 0x18)

}; // Size: 0x70

class USBPTGenerationNonOverlappingCirclesRandom : public UAIFwPTGenerationNode
{
    FAIFwBTNodePropertyInt MaxCount;                                                  // 0x0040 (size: 0x18)
    FAIFwBTNodePropertyFloat CircleRadius;                                            // 0x0058 (size: 0x18)

}; // Size: 0x70

class USBPTGenerationPointInSpawnArea : public UAIFwPTGenerationNode
{
    FString BlackboardKey;                                                            // 0x0040 (size: 0x10)
    float SearchRadius;                                                               // 0x0050 (size: 0x4)

}; // Size: 0x58

class USBPTGenerationPointsCylinder : public UAIFwPTGenerationNode
{
    FAIFwBTNodePropertyFloat Radius;                                                  // 0x0040 (size: 0x18)
    FAIFwBTNodePropertyFloat HoleRadius;                                              // 0x0058 (size: 0x18)
    FAIFwBTNodePropertyFloat HeightOffsetMin;                                         // 0x0070 (size: 0x18)
    FAIFwBTNodePropertyFloat HeightOffsetMax;                                         // 0x0088 (size: 0x18)
    FAIFwBTNodePropertyFloat StepWidth;                                               // 0x00A0 (size: 0x18)
    FAIFwBTNodePropertyFloat StepHeight;                                              // 0x00B8 (size: 0x18)

}; // Size: 0xD0

class USBPTGenerationPointsFrontOfActor : public UAIFwPTGenerationNode
{
    FAIFwBTNodePropertyFloat Radius;                                                  // 0x0040 (size: 0x18)
    FAIFwBTNodePropertyFloat HoleRadius;                                              // 0x0058 (size: 0x18)
    FAIFwBTNodePropertyFloat StepWidth;                                               // 0x0070 (size: 0x18)
    FAIFwBTNodePropertyFloat StepDepth;                                               // 0x0088 (size: 0x18)

}; // Size: 0xA0

class USBPTGenerationPointsSphere : public UAIFwPTGenerationNode
{
    FAIFwBTNodePropertyFloat OuterRadius;                                             // 0x0040 (size: 0x18)
    FAIFwBTNodePropertyFloat InnerRadius;                                             // 0x0058 (size: 0x18)
    FAIFwBTNodePropertyFloat StepWidth;                                               // 0x0070 (size: 0x18)
    FAIFwBTNodePropertyFloat StepDepth;                                               // 0x0088 (size: 0x18)

}; // Size: 0xA0

class USBPTGenerationSensedEnemy : public UAIFwPTGenerationNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPTGenerationSpawnArea : public UAIFwPTGenerationNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPTSenseAddedSensor : public UAIFwPTSenseNode
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBPTSenseEncounter : public UAIFwPTSenseNode
{
    float SensingRangeToTarget;                                                       // 0x0060 (size: 0x4)
    float SignalSpeed;                                                                // 0x0064 (size: 0x4)
    float MinDelay;                                                                   // 0x0068 (size: 0x4)

}; // Size: 0x70

class USBPTSenseFilterAppearingBlindness : public UAIFwPTSenseFilterNode
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPTSenseFilterDistanceAccordingToLevelDifference : public UAIFwPTSenseFilterNode
{
    FAIFwBTNodePropertyFloat RangeToLowLevel;                                         // 0x0030 (size: 0x18)
    FAIFwBTNodePropertyInt LowLevel;                                                  // 0x0048 (size: 0x18)
    FAIFwBTNodePropertyFloat RangeToHighLevel;                                        // 0x0060 (size: 0x18)
    FAIFwBTNodePropertyInt HighLevel;                                                 // 0x0078 (size: 0x18)

}; // Size: 0x90

class USBPTSenseFilterSamePartyAsSensedTarget : public UAIFwPTSenseFilterNode
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPTSenseFilterSenseChanger : public UAIFwPTSenseFilterNode
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPTSenseFilterTerritory : public UAIFwPTSenseFilterNode
{
    FAIFwBTNodePropertyFloat OffsetRadius;                                            // 0x0030 (size: 0x18)

}; // Size: 0x48

class USBPTSenseMasterEnemy : public UAIFwPTSenseNode
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBPTSenseSupport : public UAIFwPTSenseNode
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBParabolaMovementComponent : public USBProjectileMovementHomingComponent
{
    FSBParabolaMovementComponentOnSbProjectileBounce OnSbProjectileBounce;            // 0x0218 (size: 0x10)
    void OnProjectileBounceDelegate(const FHitResult& ImpactResult, const FVector& ImpactVelocity);
    FSBParabolaMovementComponentOnSbProjectileStop OnSbProjectileStop;                // 0x0228 (size: 0x10)
    void OnProjectileStopDelegate(const FHitResult& ImpactResult);
    uint8 bIsSliding;                                                                 // 0x0238 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0239 (size: 0x3)
    float PreviousHitTime;                                                            // 0x023C (size: 0x4)
    FVector PreviousHitNormal;                                                        // 0x0240 (size: 0xC)
    FSBParabolaMoveParameter ParabolaParam;                                           // 0x024C (size: 0x34)

}; // Size: 0x280

class USBParticleSystemComponent : public UParticleSystemComponent
{
    ESBEffectVisibleType EffectVisibleType;                                           // 0x0700 (size: 0x1)
    bool bVisibleByHiddenSourceActor;                                                 // 0x0701 (size: 0x1)
    char padding_0[0x6];                                                              // 0x0702 (size: 0x6)
    FAkEventVariables PlayAkEvent;                                                    // 0x0708 (size: 0x40)
    FAkEventVariables StopAkEvent;                                                    // 0x0748 (size: 0x40)

}; // Size: 0x790

class USBPartyBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UpdateMemberCharacterInfo(class UObject* WorldContextObject);
    void SendInvitation(class UObject* WorldContextObject, TScriptInterface<class ISBOnlinePlayerState> RecipientPlayer);
    void PostProcessingByCancelRecruitRegistration(class UObject* WorldContextObject);
    void LeaveParty(class UObject* WorldContextObject);
    bool IsNeedShowPartyList(const class UObject* WorldContextObject);
    bool IsCurrentPartyLeader(const class UObject* WorldContextObject, class ASBPlayerState* Player);
    bool GetSomeOfPartyMemberIsInMissionResult(const class UObject* WorldContextObject, const FName& InGameContentId);
    bool GetPendingInviteInfo(const class UObject* WorldContextObject, FSBInviteInfo& OutInviteInfo);
    class USBPartyMemberState* GetPartyMemberParticipatingInMission(const class UObject* WorldContextObject);
    int32 GetPartyListIndex();
    bool GetInstantParty(const class UObject* WorldContextObject, class USBPartyGameState*& OutPartyState);
    float GetGameLimitTimeOfMissionInWhichPartyMemberIsParticipating(const class UObject* WorldContextObject);
    FName GetGameContentIdPartyMemberIsParticipatingIn(const class UObject* WorldContextObject);
    int32 GetDefaultPartyMaxSize(const class UObject* WorldContextObject);
    bool GetCurrentRaidPartyMember(const class UObject* WorldContextObject, TArray<class USBPartyMemberState*>& OutPersistentMembers, TArray<class USBPartyMemberState*>& OutInstantMembers, const bool bInExcludeLocalPlayer);
    bool GetCurrentPersistantPartyMember(const class UObject* WorldContextObject, TArray<class USBPartyMemberState*>& OutPartyMembers);
    class USBPartyMemberState* GetCurrentPartyMemberStateFromId(const class UObject* WorldContextObject, FString CharacterId);
    class USBPartyMemberState* GetCurrentPartyMemberState(const class UObject* WorldContextObject, class ASBPlayerState* Player);
    bool GetCurrentPartyMember(const class UObject* WorldContextObject, TArray<class USBPartyMemberState*>& OutPartyMembers);
    bool GetCurrentParty(const class UObject* WorldContextObject, class USBPartyGameState*& OutPartyState);
    bool CheckInDungeon(class UObject* WorldContextObject);
    bool CanSendInvitation(const class UObject* WorldContextObject, TScriptInterface<class ISBOnlinePlayerState> RecipientPlayer);
    bool CanRecruitRegistration(class UObject* WorldContextObject);
    bool CancelInvitation(class UObject* WorldContextObject, class USBPartyMemberState* MemberState);
}; // Size: 0x28

class USBPartyChainWidget : public UUserWidget
{
    class UWidgetSwitcher* WidgetSwitcher;                                            // 0x0278 (size: 0x8)
    class UCanvasPanel* ChainActiveGrp;                                               // 0x0280 (size: 0x8)
    class UCanvasPanel* ChainCooldownGrp;                                             // 0x0288 (size: 0x8)
    class UCanvasPanel* ChainOutofRangeGrp;                                           // 0x0290 (size: 0x8)
    class UTextBlock* ComboText;                                                      // 0x0298 (size: 0x8)
    class UTextBlock* DamageRateText;                                                 // 0x02A0 (size: 0x8)
    class UImage* ComboGauge;                                                         // 0x02A8 (size: 0x8)
    class UTextBlock* ComboTimerText;                                                 // 0x02B0 (size: 0x8)
    class UMaterialInstanceDynamic* ComboGaugeMat;                                    // 0x02B8 (size: 0x8)
    class UTextBlock* CooldownTimeText;                                               // 0x02C0 (size: 0x8)
    class UMaterialInstanceDynamic* CooldownGaugeMat;                                 // 0x02C8 (size: 0x8)

    void OnPlayBonusEffect();
}; // Size: 0x2D8

class USBPartyCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void Party_SetSimplycityMatchingRangeSecStepAll(int32 NewRangeStepSecL, int32 NewRangeStepSecM);
    void Party_SetSimplycityMatchingRadiusStepAll(float NewRadiusStepL, float NewRadiusStepM, float NewRadiusStepH);
    void Party_Release();
    void Party_Create_Template(int32 TypeNumber, int32 MemberCount);
    void Party_Create_Invite_Send();
}; // Size: 0x28

class USBPartyGameState : public UObject
{
    class UScriptStruct* PartyStateRefDef;                                            // 0x0028 (size: 0x8)
    char padding_0[0x8];                                                              // 0x0030 (size: 0x8)
    FUniqueNetIdRepl OwningUserId;                                                    // 0x0038 (size: 0x28)
    char padding_1[0x38];                                                             // 0x0060 (size: 0x38)
    TSubclassOf<class USBPartyMemberState> PartyMemberStateClass;                     // 0x0098 (size: 0x8)
    char padding_2[0x68];                                                             // 0x00A0 (size: 0x68)
    FSBPartyGameStatePartyMemberPlayerStateChanged PartyMemberPlayerStateChanged;     // 0x0108 (size: 0x10)
    void OnPartyMemberPlayerStateChanged(class USBPartyMemberState* MemberState);

    void OnPartyMemberPlayerStateChanged__DelegateSignature(class USBPartyMemberState* MemberState);
    bool IsSolo();
    bool IsPartyFull();
    bool IsLocalPartyLeader();
    int32 GetRealPartySize();
    ESBPartyType GetPartyType();
    int32 GetPartySize();
    int32 GetPartyMaxSize();
    FText GetPartyLeaderName();
    class USBPartyMemberState* GetPartyLeaderMember();
    void GetJoinedPartyMembers(TArray<class USBPartyMemberState*>& PartyMembers);
    void GetAllPartyMembers(TArray<class USBPartyMemberState*>& PartyMembers);
}; // Size: 0x148

class USBPartyGameStateGeneral : public USBPartyGameState
{
    char padding_0[0x1E0];                                                            // 0x0000 (size: 0x0)

    void SwitchSimplycityPartyOn(bool InSimplycityPartyOn);
    void StartRecruiting();
    void StartConvocation();
    void SetMigrationResponseCode(ESBMigrationInfoRequestResult InMigrationResponseCode);
    bool RunMigration(const bool bNeedCancel);
    void OnMapLevelInfoLoadCompleted();
    bool IsSimplycityPartyOn();
    bool IsRetireGame();
    bool IsRecruiting();
    bool IsExistNonMigrationMember();
    bool IsExecuteMigration();
    bool HasConvocation();
    FString GetMigrationSessionId();
    int32 GetMigrationResponseCode();
    void CancelRecruiting();
    void CancelConvocationByLeader();
    void CancelConvocation();
}; // Size: 0x1E0

class USBPartyManager : public UObject
{
    int32 DefaultMaxPartySize;                                                        // 0x0078 (size: 0x4)
    float DefaultInviteResponseTimeLimit;                                             // 0x007C (size: 0x4)

}; // Size: 0x420

class USBPartyMemberNormalHPGaugeWidget : public UUserWidget
{
    bool EnableBlinkAnim;                                                             // 0x0278 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0279 (size: 0x7)
    class UWidgetSwitcher* BGWidgetSwitcher;                                          // 0x0280 (size: 0x8)
    class UCanvasPanel* HPGaugeSize;                                                  // 0x0288 (size: 0x8)
    class UWidgetSwitcher* IconWidgetSwitcher;                                        // 0x0290 (size: 0x8)

    void SetVisibleIcon(bool Visible);
    void SetRespawn(bool IsRespawn);
    void SetOnline(bool IsOnline);
    void SetEnableBlinkAnim(bool enable);
    void OnUpdateAnim(class USBPlayerCharacterParameterComponent* ParameterComponent, int32 InTeamId);
    void OnUpdate(class USBPlayerCharacterParameterComponent* ParameterComponent, int32 InTeamId);
}; // Size: 0x298

class USBPartyMemberNormalPlayerStatusWidget : public UUserWidget
{
    class UWidgetSwitcher* WS_Status;                                                 // 0x0278 (size: 0x8)
    class UTextBlock* MapName;                                                        // 0x0280 (size: 0x8)

    void SetModeIndex(int32 ModeIndex, FString InMapName);
}; // Size: 0x288

class USBPartyMemberNormalWidget : public UUserWidget
{
    class USBPartyMemberState* PartyMemberState;                                      // 0x0278 (size: 0x8)
    FSBGameModeInfo PlayerOwnGameModeInfo;                                            // 0x0280 (size: 0x30)
    class UWidgetSwitcher* SwitchState;                                               // 0x02B0 (size: 0x8)
    class UWidgetSwitcher* SwitchMapStatus;                                           // 0x02B8 (size: 0x8)
    class USBPartyMemberNormalHPGaugeWidget* HPGauge;                                 // 0x02C0 (size: 0x8)
    class USBPartyMemberNormalPlayerStatusWidget* PartyMemberInfo_PlayerStatus;       // 0x02C8 (size: 0x8)
    class UImage* IconChannel;                                                        // 0x02D0 (size: 0x8)
    class USBClassIcon* ClassIcon1;                                                   // 0x02D8 (size: 0x8)
    class USBClassIcon* ClassIconShadow;                                              // 0x02E0 (size: 0x8)
    class UTextBlock* TB_ClassLevel;                                                  // 0x02E8 (size: 0x8)
    class USBPartyMemberPlayerNameWidget* PlayerName;                                 // 0x02F0 (size: 0x8)
    FLinearColor BorderMemberkaColor_SameMap;                                         // 0x02F8 (size: 0x10)
    FLinearColor BorderMemberkaColor_NotSameMap;                                      // 0x0308 (size: 0x10)
    class USBBattleStatusComponent* BattleStatusComponent;                            // 0x0318 (size: 0x8)

    void SetPartyMemberInfo(int32 InTeamId);
    void SetCurrentMapMode();
    bool OwnerPlayerIsInMission();
    void OnSetColorIcon(bool bSetColor);
    void OnSetBufIcon();
    void OnChangeSameMap(bool InSameMap);
}; // Size: 0x338

class USBPartyMemberPlayerNameWidget : public UUserWidget
{
    FText CacheCharacterName;                                                         // 0x0278 (size: 0x18)

    void OnSetPlayerName(const FText& InCacheCharacterName);
}; // Size: 0x290

class USBPartyMemberState : public UObject
{
    FUniqueNetIdRepl UniqueId;                                                        // 0x0030 (size: 0x28)
    FText DisplayName;                                                                // 0x0058 (size: 0x18)
    class ASBPlayerState* PlayerState;                                                // 0x0070 (size: 0x8)
    bool bIsInvited;                                                                  // 0x0078 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0079 (size: 0x7)
    class UScriptStruct* MemberStateRefDef;                                           // 0x0080 (size: 0x8)
    char padding_1[0x10];                                                             // 0x0088 (size: 0x10)
    bool bHasAnnouncedJoin;                                                           // 0x0098 (size: 0x1)
    bool bExistingMember;                                                             // 0x0099 (size: 0x1)

    bool IsSameMap();
    bool IsPartyLeader();
    bool IsNeedRejoin();
    bool IsLocalPlayer();
    bool IsEnableRejoinTime();
    int32 GetTotalPower();
    class USBPartyGameState* GetParty();
    float GetEnableRejoinRemainingTime();
    ESBClassType GetClassType();
    int32 GetClassLevel();
}; // Size: 0xA0

class USBPartyMemberStateGeneral : public USBPartyMemberState
{
    FSBPartyMemberStateGeneralOnChangeConvocationDelegate OnChangeConvocationDelegate; // 0x00A0 (size: 0x10)
    void OnChangeConvocationDelegate(const bool bConvocation);

    void SetMigrationInfos(const bool bConvocationSet, const bool bAgreeToMigrationSet, const bool Force);
    void OnChangeConvocationDelegate__DelegateSignature(const bool bConvocation);
    bool IsInDungeon();
    bool IsConvocation();
    bool IsActivatedDungeon(FName DungeonId);
    bool HasAgreeToMigration();
    void GetMemberMapName(FString& OutMapName);
}; // Size: 0x130

class USBPartyMemberWidget : public UUserWidget
{
    class USBPartyMemberState* PartyMemberState;                                      // 0x0278 (size: 0x8)
    bool bShowBattleStatus;                                                           // 0x0280 (size: 0x1)
    bool bShouldDisplayInfoUpdate;                                                    // 0x0281 (size: 0x1)
    bool bSameMap;                                                                    // 0x0282 (size: 0x1)
    char padding_0[0x1];                                                              // 0x0283 (size: 0x1)
    float HitPoint;                                                                   // 0x0284 (size: 0x4)
    bool bUpdateBattleStatus;                                                         // 0x0288 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0289 (size: 0x7)
    TArray<FSBStatusAilmentIconConfig> StatusAilments;                                // 0x0290 (size: 0x10)

    void UpdateDisplayInfo();
    void Setup(class USBPartyMemberState* InPartyMemberState);
    void OnUpdateDisplayInfoFinish();
}; // Size: 0x2A8

class USBPartyMenu : public UUserWidget
{
    char padding_0[0x318];                                                            // 0x0000 (size: 0x0)

    void ReleaseParty();
    void ReceivePromotePartyMemberComplete(bool bWasSuccessful, FString PromoteRecipientsCharacterName, ESBPartySystemTextType ResultTextType);
    void ReceiveLeavePersistentPartyComplete(bool bWasSuccessful);
    void ReceiveKickPartyMemberComplete(bool bWasSuccessful, FString KickRecipientsCharacterName, ESBPartySystemTextType ResultTextType);
    void PromoteMember(class USBPartyMemberState* MemberState);
    void NotifyInvalidParty();
    void LeavePersistentParty();
    void KickMember(class USBPartyMemberState* MemberState);
    void CancelInvitation(class USBPartyMemberState* MemberState);
}; // Size: 0x318

class USBPartyRecruitComponent : public USBPlayerPropertyComponent
{
    FSBPartyRecruitComponentOnIsGetPartyRecruitListDelegate OnIsGetPartyRecruitListDelegate; // 0x00B8 (size: 0x10)
    void OnIsGetPartyRecruitListDelegate(const bool bWasSuccessful, const TArray<FSBPartyRecruitData>& PartyRecruitListData);
    FSBPartyRecruitComponentOnIsRecruitPartyDelegate OnIsRecruitPartyDelegate;        // 0x00C8 (size: 0x10)
    void OnIsRecruitPartyDelegate(const bool bWasSuccessful, const int32 iRetCode);
    FSBPartyRecruitComponentOnIsUpdateRecruitInfoDelegate OnIsUpdateRecruitInfoDelegate; // 0x00D8 (size: 0x10)
    void OnIsUpdateRecruitInfoDelegate(const bool bWasSuccessful);
    FSBPartyRecruitComponentOnIsCancelRecruitDelegate OnIsCancelRecruitDelegate;      // 0x00E8 (size: 0x10)
    void OnIsCancelRecruitDelegate(const bool bWasSuccessful, const int32 iRetCode);
    FSBPartyRecruitComponentOnIsGetListDetailInfoDelegate OnIsGetListDetailInfoDelegate; // 0x00F8 (size: 0x10)
    void OnIsGetListDetailInfoDelegate(const bool bWasSuccessful, const FSBPartyRecruitData& ListDetailInfo);
    FSBPartyRecruitComponentOnIsJoinPartyDelegate OnIsJoinPartyDelegate;              // 0x0108 (size: 0x10)
    void OnIsJoinPartyDelegate(const bool bWasSuccessful);
    FSBPartyRecruitComponentOnIsLeavePartyDelegate OnIsLeavePartyDelegate;            // 0x0118 (size: 0x10)
    void OnIsLeavePartyDelegate(const bool bWasSuccessful);
    FSBPartyRecruitComponentOnIsGetPrevInfoDelegate OnIsGetPrevInfoDelegate;          // 0x0128 (size: 0x10)
    void OnIsGetPrevInfoDelegate(const bool bWasSuccessful, const FSBPartyRecruitData& PrevInfo);

    void UpdateRecruitPartyMemberWebAPI(class ASBPlayerController* InPlayerController, FString CharacterId, FString UpdatedCharacterId, const int32& UpdatedCharacterClassIndex, const int32& UpdatedCharacterTotalPower);
    FString RemoveReturnCode(FString Input);
    void RecruitPartyWebAPI(class ASBPlayerController* InPlayerController, const FSBPartyRecruitData& RecruitData);
    void OnIsUpdateRecruitInfoDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnIsRecruitPartyDelegate__DelegateSignature(const bool bWasSuccessful, const int32 iRetCode);
    void OnIsLeavePartyDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnIsJoinPartyDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnIsGetPrevInfoDelegate__DelegateSignature(const bool bWasSuccessful, const FSBPartyRecruitData& PrevInfo);
    void OnIsGetPartyRecruitListDelegate__DelegateSignature(const bool bWasSuccessful, const TArray<FSBPartyRecruitData>& PartyRecruitListData);
    void OnIsGetListDetailInfoDelegate__DelegateSignature(const bool bWasSuccessful, const FSBPartyRecruitData& ListDetailInfo);
    void OnIsCancelRecruitDelegate__DelegateSignature(const bool bWasSuccessful, const int32 iRetCode);
    void LeavePartyWebAPI(class ASBPlayerController* InPlayerController, FString CharacterId, FString LeavedCharacterId);
    void JoinPartyWebAPI(class ASBPlayerController* InPlayerController, FString CharacterId, FString JoinedCharacterId, const int32& JoinedCharacterClassIndex, const int32& JoinedCharacterTotalPower);
    void GetPrevInfoWebAPI(class ASBPlayerController* InPlayerController, FString CharacterId);
    void GetPartyRecruitListWebAPIBySearchId(class ASBPlayerController* InPlayerController, FString SearchId);
    void GetPartyRecruitListWebAPI(class ASBPlayerController* InPlayerController, const int32& PageNumber, const bool& bTargetAnyone, const bool& bTargetFriend, const bool& bTargetTeam);
    void GetListDetailInfoWebAPI(class ASBPlayerController* InPlayerController, FString CharacterId);
    void CancelRecruitWebAPI(class ASBPlayerController* InPlayerController, FString CharacterId, const bool bEstablished);
}; // Size: 0x138

class USBPawnControlAxisAction : public UObject
{
    class APawn* Pawn;                                                                // 0x0028 (size: 0x8)

    class APawn* GetPawn();
    class APlayerController* GetController();
}; // Size: 0x30

class USBPawnControlAxisAction_AddPitchInput : public USBPawnControlAxisAction
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPawnControlAxisAction_AddYawInput : public USBPawnControlAxisAction
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPawnControlAxisAction_MoveCameraForward : public USBPawnControlAxisAction
{
    float CameraSpeed;                                                                // 0x0030 (size: 0x4)

}; // Size: 0x38

class USBPawnControlAxisAction_MoveForward : public USBPawnControlAxisAction
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPawnControlAxisAction_MoveRight : public USBPawnControlAxisAction
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPawnControlKeyAction : public UObject
{
    class APawn* Pawn;                                                                // 0x0028 (size: 0x8)

    class APawn* GetPawn();
    class APlayerController* GetController();
}; // Size: 0x38

class USBPawnControlKeyAction_AnimCommand : public USBPawnControlKeyAction
{
    FName PressCommand;                                                               // 0x0038 (size: 0x8)
    FName ReleaseCommand;                                                             // 0x0040 (size: 0x8)

}; // Size: 0x48

class USBPawnControlKeyAction_BlueprintBase : public USBPawnControlKeyAction
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    void ReceiveTick(float DeltaTime);
    void ReceiveInvokeReleased();
    void ReceiveInvoke();
}; // Size: 0x38

class USBPawnControlKeyAction_ResetCamera : public USBPawnControlKeyAction
{
    FVector CameraOffset;                                                             // 0x0038 (size: 0xC)

}; // Size: 0x48

class USBPawnControlSettings : public UObject
{
    TSubclassOf<class USBPawnControlSettings> ParentClass;                            // 0x0028 (size: 0x8)
    TArray<FSBPawnControlKeyMapping> KeyMappings;                                     // 0x0030 (size: 0x10)
    TArray<FSBPawnControlAxisMapping> AxisMappings;                                   // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBPawnControlSettingsComponent : public UActorComponent
{
    TSubclassOf<class USBPawnControlSettings> ControlSettingsClass;                   // 0x00B8 (size: 0x8)

}; // Size: 0xC0

class USBPawnPool : public USBActorPool
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBPerformanceCheckCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ShowServerFrameTime();
    void SetInfiniteSkill(bool Flag);
    void SetEnableUI(bool enable);
    void SetCameraRotation(float Pitch, float Yaw, float Roll);
    void PerformanceCheckStop();
    void PerformanceCheckStartHeight(int32 Height);
    void PerformanceCheckStart();
    void PerformanceCheckSplitNum(int32 Num);
    void PerformanceCheckShow();
    void PerformanceCheckSetTargetMap(FString Map);
    void PerformanceCheckSetStartTime(float Time, int32 diff);
    void PerformanceCheckSetSkillDelay(float Delay);
    void PerformanceCheckSetScreenShot(bool enable);
    void PerformanceCheckSetQuickTimer(bool enable);
    void PerformanceCheckSetOffset(float X, float Y, float Z);
    void PerformanceCheckSetMultiPlayerMode(bool enable);
    void PerformanceCheckSetLongLoopTime(float LoopTime);
    void PerformanceCheckSetLocationCheckOnly(bool enable);
    void PerformanceCheckSetCustomLocation(bool isCustomLocation);
    void PerformanceCheckSetCSVDelay(float csvDelay);
    void PerformanceCheckSetCenter(float X, float Y);
    void PerformanceCheckSetCameraWaitTime(float Time);
    void PerformanceCheckSetBotMode(bool isBotMode);
    void PerformanceCheckSetAction(FString Action);
    void PerformanceCheckNo(int32 no);
    void PerformanceCheckMultiInit();
    void PerformanceCheckFallWaitTime(int32 WaitTime);
    void PerformanceCheckDistance(int32 Distance);
}; // Size: 0x28

class USBPerformanceCheckComponent : public USBPlayerControllerComponentBase
{
    bool bRunning;                                                                    // 0x00B8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00B9 (size: 0x3)
    int32 StartHeight;                                                                // 0x00BC (size: 0x4)
    int32 Distance;                                                                   // 0x00C0 (size: 0x4)
    int32 FallWaitTime;                                                               // 0x00C4 (size: 0x4)
    int32 SplitNum;                                                                   // 0x00C8 (size: 0x4)
    int32 CurrentNo;                                                                  // 0x00CC (size: 0x4)
    FVector Center;                                                                   // 0x00D0 (size: 0xC)
    FVector Location;                                                                 // 0x00DC (size: 0xC)
    FString LevelName;                                                                // 0x00E8 (size: 0x10)
    FString TargetMap;                                                                // 0x00F8 (size: 0x10)
    float LoopTime;                                                                   // 0x0108 (size: 0x4)
    EGameInput ActionInput;                                                           // 0x010C (size: 0x1)
    char padding_1[0x3];                                                              // 0x010D (size: 0x3)
    float SkillDelay;                                                                 // 0x0110 (size: 0x4)
    bool bBotMode;                                                                    // 0x0114 (size: 0x1)
    bool bCustomLocation;                                                             // 0x0115 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0116 (size: 0x2)
    FVector LocationOffset;                                                           // 0x0118 (size: 0xC)
    float csvDelay;                                                                   // 0x0124 (size: 0x4)
    int32 TimeDiff;                                                                   // 0x0128 (size: 0x4)
    bool bScreenShot;                                                                 // 0x012C (size: 0x1)
    bool bQuickTimer;                                                                 // 0x012D (size: 0x1)
    bool bLocationCheckOnly;                                                          // 0x012E (size: 0x1)
    bool bMultiPlayerMode;                                                            // 0x012F (size: 0x1)
    int32 ActionReleaseCount;                                                         // 0x0130 (size: 0x4)
    int32 StartTime;                                                                  // 0x0134 (size: 0x4)
    float LongLoopTime;                                                               // 0x0138 (size: 0x4)
    float CameraWaitTime;                                                             // 0x013C (size: 0x4)

    void TeleportToOffsetLocation(float deg);
    void TeleportToLocation();
    void SaveGroundLocation();
    void PerformanceCheckAction();
    void OnPerformanceCheckStop();
    void OnPerformanceCheckStart();
    void CalcLocation();
}; // Size: 0x140

class USBPhotoModeBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsPhotoModeImageUploadNumMax(class UObject* InWorldContextObject);
    bool IsPhotoModeImageLockNumMax(class UObject* InWorldContextObject);
    void GetPhotoModeUploadedImageURLList(const TArray<FPhotoModeUploadedImageInfo>& InImageInfos, TArray<FString>& OutImageURLs);
    FString GetPhotoModeUploadedImageURL(const FString InImagePath);
    void GetPhotoModeUploadedImageThumbnailURLList(const TArray<FPhotoModeUploadedImageInfo>& InImageInfos, TArray<FString>& OutImageThumbURLs);
    FString GetPhotoModeUploadedImageThumbnailURL(const FString InImagePath);
}; // Size: 0x28

class USBPhotoModeImageComponent : public UActorComponent
{
    FSBPhotoModeImageComponentOnUploadPhotoModeImageDelegate OnUploadPhotoModeImageDelegate; // 0x00B8 (size: 0x10)
    void OnUploadPhotoModeImageDelegate(const bool bResult);
    FSBPhotoModeImageComponentOnLoadUploadedImageInfoDelegate OnLoadUploadedImageInfoDelegate; // 0x00C8 (size: 0x10)
    void OnLoadUploadedImageInfoDelegate(const bool Result);
    FSBPhotoModeImageComponentOnSetUploadedImageLockFlagDelegate OnSetUploadedImageLockFlagDelegate; // 0x00D8 (size: 0x10)
    void OnLoadUploadedImageInfoDelegate(const bool Result);
    FSBPhotoModeImageComponentOnUploadImageEditInfoDelegate OnUploadImageEditInfoDelegate; // 0x00E8 (size: 0x10)
    void OnLoadUploadedImageInfoDelegate(const bool Result);
    char padding_0[0x8];                                                              // 0x00F8 (size: 0x8)
    TArray<FPhotoModeSaveUploadImage> SaveUploadImage;                                // 0x0100 (size: 0x10)

    bool UploadImageEditInfo_Request(const FPlayerProfileBgImageInfo& InImageInfos);
    bool UploadImage_Request(FString InCharacterId, const TArray<uint8>& InPNGData);
    bool SetUploadedImageLockFlags_Request(FString InCharacterId, const TArray<FPhotoModeUploadedImageInfo>& InImageInfos);
    bool SetSaveUploadImage(int32 ImageCount, class UTexture2DDynamic* UploadTexture, TArray<uint8> InPNGData);
    void Server_UploadImageEditInfo(const FPlayerProfileBgImageInfo& InImageInfos);
    void Server_SetUploadedImageLockFlags(FString InCharacterId, const TArray<FPhotoModeUploadedImageInfo>& InImageInfos);
    void Server_OnUploadImageEditInfo(bool Result);
    void Server_OnSetUploadedImageLockFlags(bool Result, const TArray<FPhotoModeUploadedImageInfo>& ImageInfos);
    void Server_OnLoadUploadedImageInfo(bool Result, const TArray<FPhotoModeUploadedImageInfo>& ImageInfos);
    void Server_LoadUploadedImageInfo(FString InCharacterId);
    void OnUploadPhotoModeImageDelegate__DelegateSignature(const bool bResult);
    void OnUploadImageEditInfoDelegate__DelegateSignature(const bool Result);
    void OnSetUploadedImageLockFlagDelegate__DelegateSignature(const bool Result);
    void OnLoadUploadedImageInfoDelegate__DelegateSignature(const bool Result);
    bool LoadUploadedImageInfo_Request(FString InCharacterId);
    bool IsSaveUploadImage();
    bool IsPhotoModeUploadedImageLoadedFromDB();
    void InitSaveUploadImage(int32 ImageCount);
    TArray<class UTexture2DDynamic*> GetSaveUploadImageTextureAll();
    TArray<FPhotoModeSaveUploadImage> GetSaveUploadImageAll();
    FPhotoModeSaveUploadImage GetSaveUploadImage(int32 ImageCount);
    void Client_UploadImageEditInfo(bool Result);
    void Client_SetUploadedImageLockFlags(bool Result, const TArray<FPhotoModeUploadedImageInfo>& ImageInfos);
    void Client_LoadUploadedImageInfo(bool Result, const TArray<FPhotoModeUploadedImageInfo>& ImageInfos);
}; // Size: 0x110

class USBPhotoModePawnMovementComponent : public USpectatorPawnMovement
{
    FSBPhotoModePawnMovementComponentOnOverLimitDistanceDelegate OnOverLimitDistanceDelegate; // 0x0160 (size: 0x10)
    void OnOverLimitDistanceDelegate();
    float DistanceLimitXY;                                                            // 0x0170 (size: 0x4)
    float DistanceLimitZ;                                                             // 0x0174 (size: 0x4)
    float DistanceOverLimitMagine;                                                    // 0x0178 (size: 0x4)
    bool bInitializedOwnerLocation;                                                   // 0x017C (size: 0x1)
    char padding_0[0x3];                                                              // 0x017D (size: 0x3)
    FVector PrevOwnerLocation;                                                        // 0x0180 (size: 0xC)
    char padding_1[0x4];                                                              // 0x018C (size: 0x4)
    float MaxSpeedOfAngleMove;                                                        // 0x0190 (size: 0x4)
    bool bDontOverOverhead;                                                           // 0x0194 (size: 0x1)
    bool bDontPassThrough;                                                            // 0x0195 (size: 0x1)
    char padding_2[0x2];                                                              // 0x0196 (size: 0x2)
    float NearDistanceLimitOfLookAtPlayer;                                            // 0x0198 (size: 0x4)

    void SetLookAtPlayer(bool bValue);
    void OnOverLimitDistanceDelegate__DelegateSignature();
}; // Size: 0x1A0

class USBPhotoModePlayerControlData : public UObject
{
    class ASBPlayerState* Target;                                                     // 0x0050 (size: 0x8)
    char padding_0[0x68];                                                             // 0x0058 (size: 0x68)
    class ASBCharaCreateCharacter* __CloneCharacter;                                  // 0x00C0 (size: 0x8)

    void ToggleLookAtEyeActive();
    void ToggleLookAtActive();
    void ToggleFixHead();
    void ToggleFixEye();
    void SetWeaponVisibility(bool bValue);
    void SetVisibility(bool bValue);
    void SetPlayerVisibility(bool bValue);
    void SetPale(float Value);
    void SetMotionStop(bool bValue);
    void SetLookAtEyeActive(bool bValue);
    void SetLookAtActive(bool bValue);
    void SetLipSyncType(ESBLipSyncType Value);
    void SetLastEmoteName(FString EmoteStateName);
    void SetFixHead(bool bValue);
    void SetFixEye(bool bValue);
    void SetFacialType(const ESBFacialType Value);
    void SetEnableFacial(bool bValue);
    void SetCopyPose(bool bValue);
    void SetCloseEyes(bool bValue);
    void SetCloneCharacter(class ASBCharaCreateCharacter* Value);
    void SetBlush(float Value);
    void ResetLookAt();
    void RequestEmoteByEmoteName(const FName& EmoteName);
    void RequestEmote(const FName& EmoteId);
    bool IsVisible();
    bool IsValidRequestEmoteName();
    bool IsValidLastEmoteName();
    bool IsValidData();
    bool IsValidCloneCharacter();
    bool IsPlayerVisible();
    bool IsOriginalPlayerData();
    bool IsMotionStop();
    bool IsLookAtEyeActive();
    bool IsLookAtActive();
    bool IsFixHead();
    bool IsFixEye();
    bool IsEnableFacial();
    bool IsEnabledLookAtEyeActive();
    bool IsEnabledLookActive();
    bool IsCopyPose();
    bool IsCloseEyes();
    bool GetWeaponVisibility();
    class ASBCreationCharacter* GetTargetCharacter();
    class ASBPlayerState* GetTarget();
    class ASBPlayerCharacter* GetPlayerCharacter();
    float GetPale();
    ESBLipSyncType GetLipSyncType();
    FName GetLastEmoteName();
    ESBFacialType GetFacialType();
    class ASBCharaCreateCharacter* GetCloneCharacter();
    FString GetCharacterName();
    FName GetCharacterId();
    float GetBlush();
    void DestroyCloneCharacter();
    void CreateOrDestroyCloneCharacter(bool bInCreate, class UObject* InParent, bool bInCopyPose);
    bool CanControlVisibility();
    bool CanControlMotionStop();
    bool CanControlClone();
    void BP_OnChangeWeaponVisibility();
    void BP_CreateCloneCharacter(class UObject* InParent, bool bInCopyPose);
}; // Size: 0xD8

class USBPhotoModePlayerList : public UUserWidget
{
    TSubclassOf<class USBPhotoModePlayerListItem> ListItemClass;                      // 0x0278 (size: 0x8)
    class USBPhotoModePlayerListItem* AllPlayerItem;                                  // 0x0280 (size: 0x8)
    class UVerticalBox* PlayerList;                                                   // 0x0288 (size: 0x8)
    TArray<class USBPhotoModePlayerListItem*> PlayerListItemList;                     // 0x0290 (size: 0x10)

    void OnUpdatePlayerControlDataList();
    void OnUpdatePlayerControlData(class UObject* Sender, class UObject* Param);
    void BP_OnUpdatePlayerControlData();
}; // Size: 0x2A0

class USBPhotoModePlayerListItem : public UUserWidget
{
    class USBPhotoModePlayerControlData* Data;                                        // 0x0278 (size: 0x8)

    void SetHeaderData(class USBPhotoModePlayerControlData* InData);
    void OnUpdateData();
    void BP_SetData(class USBPhotoModePlayerControlData* InData);
    void BP_OnUpdateData();
}; // Size: 0x280

class USBPhotoModeThumbnailData : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    bool SetThumbnailTexture_Cpp(class UTexture2DDynamic* Texture, const TArray<uint8>& InImagePNGData);
    bool SetThumbnailTexture_Bp(class UTexture2DDynamic* Texture, const TArray<uint8>& InImagePNGData);
    void SetIsUpload_Cpp(bool bIsUpload);
    void SetIsUpload_Bp(bool bIsUpload);
    void Reset_Cpp();
    void Reset_Bp();
    class UTexture2DDynamic* GetThumbnailTexture_Cpp();
    class UTexture2DDynamic* GetThumbnailTexture_Bp();
    bool GetIsUpload_Cpp();
    bool GetIsUpload_Bp();
    void GetImagePNGData_Cpp(TArray<uint8>& OutImagePngData);
    void GetImagePNGData_Bp(TArray<uint8>& OutImagePngData);
    int32 GetDebugValue();
}; // Size: 0x280

class USBPhotoModeUploadList : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    void UploadWidgetSwitcher_Cpp(uint8 InMode);
    void UploadWidgetSwitcher_Bp(uint8 InMode);
    void SetUploadThumbnail_Cpp(const TArray<class UTexture2DDynamic*>& InThumbnailImage);
    void SetUploadThumbnail_Bp(const TArray<class UTexture2DDynamic*>& InThumbnailImage);
    void ScreenshotCapturedEvent_Cpp(const TArray<class UTexture2DDynamic*>& InThumbnailImage);
    void ScreenshotCapturedEvent_Bp(const TArray<class UTexture2DDynamic*>& InThumbnailImage);
    int32 GetDebugValue();
}; // Size: 0x280

class USBPhotoModeUploadListSlot : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    void SetTexture_Cpp(class UTexture2DDynamic* InTexture);
    void SetTexture_Bp(class UTexture2DDynamic* InTexture);
    int32 GetDebugValue();
}; // Size: 0x280

class USBPhotoModeUploadWindowMenu : public UUserWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    void SetThumbnailTexture2D_Cpp();
    void SetThumbnailTexture2D_Bp();
    void Reset_Cpp();
    void Reset_Bp();
    int32 GetDebugValue();
}; // Size: 0x280

class USBPhysicsAnimInstance : public USBAnimInstance
{
    bool bActive;                                                                     // 0x0470 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0471 (size: 0x3)
    FVector Acceralation;                                                             // 0x0474 (size: 0xC)
    FVector AcceralationAngle;                                                        // 0x0480 (size: 0xC)
    float StiffnessScale;                                                             // 0x048C (size: 0x4)
    float DampingScale;                                                               // 0x0490 (size: 0x4)
    float MassScale;                                                                  // 0x0494 (size: 0x4)

}; // Size: 0x4A0

class USBPhysicsWaterVolumeRenderComp : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBPineVillageComponent : public UActorComponent
{
    FSBPineVillageComponentOnRequestRankingsCompleteDelegate OnRequestRankingsCompleteDelegate; // 0x00B8 (size: 0x10)
    void OnRankingsDelegate();
    FSBPineVillageComponentOnRequestLeagueCompleteDelegate OnRequestLeagueCompleteDelegate; // 0x00C8 (size: 0x10)
    void OnLeagueDelegate();
    FSBPineVillageComponentOnRequestRankingRewardsCompleteDelegate OnRequestRankingRewardsCompleteDelegate; // 0x00D8 (size: 0x10)
    void OnRankingRewardsDelegate();
    FSBPineVillageComponentOnRequestLeagueRewardsCompleteDelegate OnRequestLeagueRewardsCompleteDelegate; // 0x00E8 (size: 0x10)
    void OnLeagueRewardsDelegate();

    void Server_RequestRankings(const int32 Page);
    void Server_RequestRankingRewards();
    void Server_RequestLeagueRewards();
    void Server_RequestLeague();
    void RequestRankings(const int32 Page);
    void RequestRankingRewards();
    void RequestLeagueRewards();
    void RequestLeague();
    void OnRankingsDelegate__DelegateSignature();
    void OnRankingRewardsDelegate__DelegateSignature();
    void OnLeagueRewardsDelegate__DelegateSignature();
    void OnLeagueDelegate__DelegateSignature();
    FSBPineVillageRankingsData GetRankingsData();
    FSBPineVillageLeagueData GetLeagueData();
    void Client_RequestRankingsComplete(int32 RetCode, const FSBPineVillageRankingsData& Data);
    void Client_RequestRankingRewardsComplete(int32 RetCode);
    void Client_RequestLeagueRewardsComplete(int32 RetCode);
    void Client_RequestLeagueComplete(int32 RetCode, const FSBPineVillageLeagueData& Data);
}; // Size: 0x1D0

class USBPlayRateTransmission : public UObject
{
    char padding_0[0xD8];                                                             // 0x0000 (size: 0x0)

    float UpdateCurrent(float InDeltaTime);
    bool SwitchTarget(const ESBPlayRateSwitch InTarget);
    bool SetVariableTarget(const float InVariableTarget);
    void SetStateTarget(FString InState, const ESBPlayRateSwitch InTarget, float InAnimRate);
    bool SetAcceleration(const float InAcceleration);
    bool IsVariableTarget();
    bool Initialize(const float InCurrent, const float InVariableTarget, const bool InEnableVariable, const float InAcceleration);
    float GetVariableTarget();
    float GetTarget();
    float GetCurrent();
    float GetAcceleration();
    bool EnableVariableTarget(const bool InVariable);
    bool ChangeState(const FString& InState);
}; // Size: 0xD8

class USBPlayerAcEventComponent : public USBPlayerControllerComponentBase
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBPlayerAchievementComponent : public UActorComponent
{
    FSBPlayerAchievementComponentOnLoadAchievementDelegate OnLoadAchievementDelegate; // 0x00B8 (size: 0x10)
    void OnLoadAchievementDelegate(const bool Result, const TArray<FSBAchievementInfo>& AchievementList);
    FSBPlayerAchievementComponentOnSaveAchievementDelegate OnSaveAchievementDelegate; // 0x00C8 (size: 0x10)
    void OnSaveAchievementDelegate(const bool Result);
    FSBPlayerAchievementComponentOnSaveAchievementSelectedDelegate OnSaveAchievementSelectedDelegate; // 0x00D8 (size: 0x10)
    void OnSaveAchievementSelectedDelegate(const bool Result);
    FSBPlayerAchievementComponentOnAchievementGainedDelegate OnAchievementGainedDelegate; // 0x00E8 (size: 0x10)
    void OnAchievementGainedDelegate(const TArray<int32>& GainedAchievementIdList);
    FSBPlayerAchievementComponentOnLoadAchievementDataDelegate OnLoadAchievementDataDelegate; // 0x00F8 (size: 0x10)
    void OnLoadAchievementDataDelegate(const bool Result, const int32 RetCode);
    FSBPlayerAchievementComponentOnGetAchievementRewardsDelegate OnGetAchievementRewardsDelegate; // 0x0108 (size: 0x10)
    void OnGetAchievementRewardsDelegate(const bool Result, const int32 RetCode, const FSBAchievementRewardData AchievementRewardData);
    char padding_0[0x1];                                                              // 0x0118 (size: 0x1)
    bool bRunRequiredDataInfoList;                                                    // 0x0119 (size: 0x1)
    bool bRequiredDataInfoListCache;                                                  // 0x011A (size: 0x1)
    char padding_1[0x5];                                                              // 0x011B (size: 0x5)
    TArray<FSBCharacterAchievementDataInfo> DataInfoListCache;                        // 0x0120 (size: 0x10)
    FSBAchievementSelectCategory AchievementSelectCategory;                           // 0x0130 (size: 0xC)
    char padding_2[0x4];                                                              // 0x013C (size: 0x4)
    TArray<int32> PopupNewGainedAchievement;                                          // 0x0140 (size: 0x10)

    void SetCharacterAchievementData(const int32 InFindAchievementId, const FSBCharacterAchievementDataInfo InInfo);
    void SetAchievementSelected(int32 AchievementId);
    void SetAchievementId(const int32 InAchievementId);
    void SetAchievementCategory(int32 InLargeCategory, int32 InMidiumCategory);
    void Server_SaveAchievementSelected(const int32 AchievementId);
    void Server_SaveAchievement(const TArray<FSBAchievementInfo>& AchievementList);
    void Server_OnUpdateAchievementData(const TArray<FSBCharacterAchievementDataInfo>& InAchievementDataInfoList);
    void Server_OnSaveAchievementSelected(bool Result, const int32 AchievementId);
    void Server_OnSaveAchievement(bool Result, const TArray<FSBAchievementInfo>& AchievementList);
    void Server_OnLoadAchievementData(bool Result, int32 InRetCode, const TArray<FSBCharacterAchievementDataInfo>& InAchievementDataInfoList);
    void Server_OnLoadAchievement(bool Result, const TArray<FSBAchievementInfo>& AchievementList);
    void Server_OnGetAchievementRewards(bool Result, int32 InRetCode, const FSBAchievementRewardData AchievementRewardData, const bool InOpenCommandMenuFlag);
    void Server_OnAchievementGained(const TArray<int32>& GainedAchievementIdList);
    void Server_LoadAchievementData();
    void Server_LoadAchievement();
    void Server_GetAchievementRewards(const TArray<int32>& AchievementId, const bool IsOverflowLimitDiscard, const bool IsOverflowLimitSell);
    void Request_SaveAchievementSelected(const int32 AchievementId);
    void Request_SaveAchievement(const TArray<FSBAchievementInfo>& AchievementList);
    void Request_LoadAchievementData();
    void Request_LoadAchievement();
    void Request_GetAchievementRewards(const TArray<int32>& AchievementId, const bool IsOverflowLimitDiscard, const bool IsOverflowLimitSell);
    void OnSaveAchievementSelectedDelegate__DelegateSignature(const bool Result);
    void OnSaveAchievementDelegate__DelegateSignature(const bool Result);
    void OnLoadAchievementDelegate__DelegateSignature(const bool Result, const TArray<FSBAchievementInfo>& AchievementList);
    void OnLoadAchievementDataDelegate__DelegateSignature(const bool Result, const int32 RetCode);
    void OnGetAchievementRewardsDelegate__DelegateSignature(const bool Result, const int32 RetCode, const FSBAchievementRewardData AchievementRewardData);
    void OnAchievementGainedDelegate__DelegateSignature(const TArray<int32>& GainedAchievementIdList);
    void NotifyPopupNewAchievemet();
    bool IsValidCharacterAchievementID(const int32 InFindAchievementId);
    bool IsRunRequiredDataInfoList();
    bool IsRequiredDataInfoListCache();
    bool IsAchievementsLoadedFromDB();
    TArray<FSBCharacterAchievementDataInfo> GetDataInfoListCache();
    void GetAdventureBoardCompleteAchievement(TArray<FSBCharacterAchievementDataInfo>& OutData);
    int32 GetAchievemetProgress(int32 InObjectNum, int32 InProgressNum);
    FSBAchievementSelectCategory GetAchievementCategory();
    FSBCharacterAchievementDataInfo FindCharacterAchievementData(const int32 InFindAchievementId);
    void DisableSelectCategory();
    void Client_SetPopupNewAchievement(const TArray<int32>& GainedAchievementIdList);
    void Client_SaveAchievementSelected(bool Result, const int32 AchievementId);
    void Client_SaveAchievement(bool Result, const TArray<FSBAchievementInfo>& AchievementList);
    void Client_OnUpdateAchievementData(const TArray<FSBCharacterAchievementDataInfo>& InAchievementDataInfoList);
    void Client_LoadAchievementData(bool Result, int32 InRetCode, const TArray<FSBCharacterAchievementDataInfo>& InAchievementDataInfoList);
    void Client_LoadAchievement(bool Result, const TArray<FSBAchievementInfo>& AchievementList);
    void Client_GetAchievementRewards(bool Result, int32 InRetCode, FSBAchievementRewardData AchievementRewardData, const bool InOpenCommandMenuFlag);
    void Client_AchievementGained(const TArray<int32>& GainedAchievementIdList);
    void CheckAdventureBoardCompleteAchievement(const TArray<FSBCharacterAchievementDataInfo>& InData, ESBAchievementAdventureBoardCompleteStatus& OutStatus, int32& OutNextCount);
}; // Size: 0x150

class USBPlayerActivityComponent : public USBPlayerPropertyComponent
{
    TMap<class USBHttpQuery*, class FSBActivityData> SaveRequests;                    // 0x00B8 (size: 0x50)
    FSBPlayerActivityComponentOnGetActivityCompleteDelegate OnGetActivityCompleteDelegate; // 0x0108 (size: 0x10)
    void OnGetActivityCompleteDelegate(const bool bResult, const TArray<FSBActivityData>& InActivities);

    void SaveActivityRequest(const FSBActivityData& InActivityData);
    bool GetActivityRequest(FString InCharacterId, const int32 InStart, const int32 InCount);
}; // Size: 0x118

class USBPlayerActorComponent : public UActorComponent
{
    char padding_0[0xD0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xD0

class USBPlayerAdminComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerAdminComponentAdminCommandCallbeck AdminCommandCallbeck;                 // 0x00B8 (size: 0x10)
    void AdminCommandCallbeck(ESBAdminCommandCallbackRequest Request);
    TSubclassOf<class UUserWidget> GotoBookmarkWindowAsset;                           // 0x00C8 (size: 0x8)
    TArray<FString> EnableCommandList;                                                // 0x00D0 (size: 0x10)
    char padding_0[0x10];                                                             // 0x00E0 (size: 0x10)
    FString MacroFileName;                                                            // 0x00F0 (size: 0x10)
    bool bMacroRunningClient;                                                         // 0x0100 (size: 0x1)
    bool bMacroRunningServer;                                                         // 0x0101 (size: 0x1)
    char padding_1[0x6];                                                              // 0x0102 (size: 0x6)
    TArray<FString> MacroContents;                                                    // 0x0108 (size: 0x10)
    FString MacroDebugFlag;                                                           // 0x0118 (size: 0x10)
    float MacroProcessIntervalSetting;                                                // 0x0128 (size: 0x4)
    float MacroProcessInterval;                                                       // 0x012C (size: 0x4)
    class USBAdminBookmarkMisc* BookmarkMisc;                                         // 0x0130 (size: 0x8)
    bool bDebugForceEnable;                                                           // 0x0138 (size: 0x1)
    char padding_2[0x8];                                                              // 0x0139 (size: 0x8)
    bool bNoLog;                                                                      // 0x0141 (size: 0x1)

    void WarpPlayerByMapClick_Internal(FVector WorldLocation);
    void WarpPlayerByMapClick(FVector2D WorldLocation2d);
    void TravelMapToCharacter_Internal(const FPlayerProfileMenuDetailData& TargetProfileData);
    void TravelMapToCharacter(FString CharacterId);
    void SetGotoPosCommandString(FVector WorldLocation, bool bSetToInputField);
    void SetConsoleOutputFieldText(FString Text);
    void Server_StartMacro(const TArray<FString>& InMacroContents, FString DebugFlag);
    void Server_LogWarpPlayer(const FVector& WorldLocation, bool bSucceeded);
    void Server_ExecuteAdminCommandFromBeforeAuth(FString InputText, class UObject* Param);
    void Server_ExecuteAdminCommand(FString InputText, class UObject* Param);
    void Server_DirectApplyMoveSpeed(float Speed);
    void OutputPlayerInfo(FVector WorldLocation, FString CharacterId, FString CharacterShortId, FString MapId, FString CharacterName, FString MapName);
    void OutputFoundPlayerInfoByScreenClick();
    void OutputFoundPlayerInfo(FString CharacterId, FVector WorldLocation);
    bool IsAdminFuncUnlocked();
    class USBPlayerAdminComponent* GetSBPlayerAdminComponent(const class UObject* WorldContextObject);
    class USBAdminBookmarkMisc* GetBookmarkMisc();
    class ASBPlayerCharacter* FindPlayerCharacter(FString CharacterId);
    void ExecuteGotoBookmarkSub(class USBAdminGotoBookmarkItem* BookmarkData);
    void ExecuteAdminCommandFromBeforeAuth(FString ChatMessage);
    void ExecuteAdminCommand(FString InputText);
    void DisableAdminAuthority();
    void Client_WireFrame(bool bFlag);
    void Client_WarpToGatherPoint();
    void Client_WarpPlayer(const FVector& WorldLocation);
    void Client_VisibleNamePlate();
    void Client_VisibleDamageLog();
    void Client_VisibleBattleHud();
    void Client_VerifyAdminAuthority();
    void Client_TravelMapToCharacter(FString CharacterId, FString DebugFlag);
    void Client_TravelMapPlayer(FString MapId, FString SpawnPortal);
    void Client_TogglePlayerThrough(float DistanceLimit, FString DebugFlag);
    void Client_TogglePlayerSHide(bool bFlag);
    void Client_TogglePlayerHide(bool bFlag);
    void Client_ShowHelp(const TArray<FString>& HelpList);
    void Client_SetWorldTimeDilation(float NewTimeDilation);
    void Client_SetDebugForceEnable(bool bFlag);
    void Client_SetConsoleOutputFieldText(FString Text);
    void Client_RunFile(FString Filename, FString DebugFlag);
    void Client_RemoveAuthority(const TArray<FString>& RemovedAuthority);
    void Client_ReceiveRecall(const FVector& WorldLocation);
    void Client_ReceiveKick(FString DebugFlag);
    void Client_RecallCharacter(bool bValid, FString TargetCharacterId, FString TargetCharacterName);
    void Client_PushSystemLogArray(const TArray<FString>& MessageList);
    void Client_PushSystemLog(FString Message);
    void Client_PushSystemDebugLog(FString Message);
    void Client_PlayerList(const TArray<FString>& PlayerInfoList, FString DebugFlag);
    void Client_PlayerInvincible();
    void Client_PlayerInfiniteStamina();
    void Client_PlayerInfiniteSkill();
    void Client_PlayerInfiniteImagine();
    void Client_PlayerInfiniteHP();
    void Client_OutputCharacterLocation(FString CharacterId, const FVector& WorldLocation, FString DebugFlag);
    void Client_NoLog(bool bFlag);
    void Client_KillTarget(const FVector& KillTargetLocation, FString DebugFlag);
    void Client_KillDist(const TArray<FVector>& KillTargetLocationList);
    void Client_Kill(const FVector& KillTargetLocation);
    void Client_Kick(FString CharacterId, FString DebugFlag);
    void Client_InteractionTargetList(const TArray<FString>& PlayerInfoList, FString DebugFlag);
    void Client_InteractionTargetAuthorList(const TArray<FString>& InfoList, FString DebugFlag);
    void Client_IdWarp(const TArray<FString>& BookmarkStringDataList);
    void Client_FinishMacro(FString DebugFlag);
    void Client_FinishForDontHaveAuthority();
    void Client_FinishCommand();
    void Client_FinishByUndefinedCommand(FString Command);
    void Client_FinishByOutputMessage(FString Text);
    void Client_EnemyInfo(FString Info);
    void Client_DisableAdminAuthority();
    void Client_ConfirmAuthority(const TArray<FString>& InEnableCommandList);
    void Client_CheckApplyPreviousAdminCommandParameter();
    void Client_ChangeMoveSpeed(float Speed);
    void Client_BookmarkList();
    void AdminCommandCallbeck__DelegateSignature(ESBAdminCommandCallbackRequest Request);
}; // Size: 0x150

class USBPlayerAdminFuncComponent : public USBPlayerActorComponent
{
    uint8 bHide;                                                                      // 0x00D0 (size: 0x1)
    uint8 bSHide;                                                                     // 0x00D0 (size: 0x1)

    void OnRep_Command_Hide();
    void Multicast_CommandSHide(bool Hide);
    void Multicast_CommandHide(bool Hide);
}; // Size: 0xF0

class USBPlayerAdventureBoardComponent : public USBPlayerPropertyComponent
{
    FSBPlayerAdventureBoardComponentOnUpdateAdventureBoardDelegete OnUpdateAdventureBoardDelegete; // 0x00B8 (size: 0x10)
    void OnUpdateAdventureBoardDelegete(int32 RetCode);
    FSBPlayerAdventureBoardComponentOnClearAdventureBoardDelegete OnClearAdventureBoardDelegete; // 0x00C8 (size: 0x10)
    void OnClearAdventureBoardDelegete(ESBAdventureBoardClearStatus ClearType);
    FSBPlayerAdventureBoardComponentOnLoadAdventureBoardDelegete OnLoadAdventureBoardDelegete; // 0x00D8 (size: 0x10)
    void OnLoadAdventureBoardDelegete(int32 RetCode);
    FSBPlayerAdventureBoardComponentOnAchievementedAdventureBoardPanelDelegete OnAchievementedAdventureBoardPanelDelegete; // 0x00E8 (size: 0x10)
    void OnAchievementedAdventureBoardPanelDelegete(const TArray<FSBAdventureBoardPanelParam>& PanelList, int32 InPanelId, int32 RetCode);
    FSBPlayerAdventureBoardComponentOnAchievementedAdventureBoardPanelListDelegete OnAchievementedAdventureBoardPanelListDelegete; // 0x00F8 (size: 0x10)
    void OnAchievementedAdventureBoardPanelListDelegete(const TArray<FSBAdventureBoardPanelParam>& PanelList, int32 RetCode);
    FSBPlayerAdventureBoardComponentOnCompleteAdventureBoardDelegete OnCompleteAdventureBoardDelegete; // 0x0108 (size: 0x10)
    void OnCompleteAdventureBoardDelegete(const TArray<FSBAdventureBoardParam>& InBoardParamList, const FSBMailRewardData& InRewardDataList, int32 InRetCode);
    FSBPlayerAdventureBoardComponentOnCompleteAdventureBoardNotificationDelegete OnCompleteAdventureBoardNotificationDelegete; // 0x0118 (size: 0x10)
    void OnCompleteAdventureBoardNotificationDelegete();
    FSBPlayerAdventureBoardComponentOnChangeActiveAdventureBoardDelegete OnChangeActiveAdventureBoardDelegete; // 0x0128 (size: 0x10)
    void OnChangeActiveAdventureBoardDelegete(const TArray<FSBAdventureBoardParam>& InBoardParamList, int32 InRetCode);
    FSBPlayerAdventureBoardComponentOnChangeFavoriteAdventureBoardDelegete OnChangeFavoriteAdventureBoardDelegete; // 0x0138 (size: 0x10)
    void OnChangeFavoriteAdventureBoardDelegete(const TArray<FSBAdventureBoardParam>& InBoardParamList, int32 InRetCode);
    FSBPlayerAdventureBoardComponentOnChangeHudDrawAdventureBoardDelegete OnChangeHudDrawAdventureBoardDelegete; // 0x0148 (size: 0x10)
    void OnChangeHudDrawAdventureBoardDelegete(const FSBAdventureBoardParam& InBoardParam, int32 InRetCode);
    FSBPlayerAdventureBoardComponentOnGetRewardAdventureBoardPanelDelegete OnGetRewardAdventureBoardPanelDelegete; // 0x0158 (size: 0x10)
    void OnGetRewardAdventureBoardPanelDelegete(const TArray<FSBAdventureBoardParam>& InBoardParamList, const FSBMailRewardData& InRewardDataList, int32 InRetCode);
    FSBPlayerAdventureBoardComponentOnGetRewardAdventureBoardAllPanelDelegete OnGetRewardAdventureBoardAllPanelDelegete; // 0x0168 (size: 0x10)
    void OnGetRewardAdventureBoardAllPanelDelegete(const TArray<FSBAdventureBoardParam>& InBoardParamList, const FSBMailRewardData& InRewardDataList, int32 InRetCode);
    FSBPlayerAdventureBoardComponentOnPopupNewVaildAdventureBoardCompleteDelegete OnPopupNewVaildAdventureBoardCompleteDelegete; // 0x0178 (size: 0x10)
    void OnPopupNewVaildAdventureBoardCompleteDelegete(int32 InRetCode);
    TArray<FSBAdventureBoardParam> BoardParamList;                                    // 0x0188 (size: 0x10)
    TArray<int32> PopupNewValidBoardIdList;                                           // 0x0198 (size: 0x10)
    bool ClearRequested;                                                              // 0x01A8 (size: 0x1)

    void SetNewClearPanelAll();
    void SetClearRequested(bool RequestFlag);
    void Server_UpdatePanelList_BoardParam(const TArray<FSBAdventureBoardParam>& InBoardParamList, int32 RetCode, bool InForceNotifyNextMap);
    void Server_UpdatePanelList(const TArray<FSBAdventureBoardUpdateData>& InUpdateBoardDataList, const TArray<FSBAdventureBoardPanelUpdateData>& InUpdatePanelDataList, int32 RetCode, bool InForceNotifyNextMap);
    void Server_UpdateBoardList(const TArray<FSBAdventureBoardParam>& InBoardList, int32 RetCode);
    void Server_SetFavoriteBoard(const TArray<FSBAdventureBoardParam>& InBoardList, int32 InRetCode);
    void Server_SetBoardList(const TArray<FSBAdventureBoardParam>& InBoardList, int32 RetCode);
    void Server_SetActiveBoard(const TArray<FSBAdventureBoardParam>& InBoardList, int32 InRetCode);
    void Server_SetAchievementedPanelList(const TArray<FSBAdventureBoardPanelParam>& InPanelList, int32 InBoardId, int32 InRetCode);
    void Server_SetAchievementedPanel(const TArray<FSBAdventureBoardPanelParam>& InPanelList, int32 InBoardId, int32 InPanelId, int32 InRetCode);
    void Server_NotifyPopupNewVaildBoard();
    void Server_LoadBoardListSet(const TArray<FSBAdventureBoardParam>& InBoardList, int32 InRetCode);
    void Server_LoadBoardList();
    void Server_GetRewardBoardPanel(int32 InBoardId, int32 InPanelId, bool bOverflowDiscard, bool bOverflowSell);
    void Server_GetRewardBoardAllPanel(int32 InBoardId, bool bOverflowDiscard, bool bOverflowSell);
    void Server_FreePanelCleared(int32 InBoardId);
    void Server_DebugAdvanceAdventureBoard(int32 InBoardId);
    void Server_CompleteBoard(int32 InBoardId, bool bOverflowDiscard, bool bOverflowSell);
    void Server_Cleared(int32 InBoardId, int32 InPanelId);
    void Server_ChangeHudDraw(int32 InBoardId, bool InHudDraw);
    void Server_ChangeFavoriteBoard(int32 InBoardId, bool InFavorite);
    void Server_ChangeActiveBoard(int32 InBoardId);
    void Request_NotifyPopupNewVaildBoard();
    void Request_LoadBoardList();
    void Request_GetRewardBoardPanel(int32 InBoardId, int32 InPanelId, bool bOverflowDiscard, bool bOverflowSell);
    void Request_GetRewardBoardAllPanel(int32 InBoardId, bool bOverflowDiscard, bool bOverflowSell);
    void Request_FreePanelCleared(int32 InBoardId);
    void Request_CompleteBoard(int32 InBoardId, bool bOverflowDiscard, bool bOverflowSell);
    void Request_Cleared(int32 InBoardId, int32 InPanelId);
    void Request_ChangeHudDraw(int32 InBoardId, bool InHudDraw);
    void Request_ChangeFavoriteBoard(int32 InBoardId, bool InFavorite);
    void Request_ChangeActiveBoard(int32 InBoardId);
    void RemovePopupNewValidBoardIdList();
    bool IsClearRequested();
    int32 GetRewardCount(int32 InBoardId);
    void GetReward_MailData(int32 InBoardId, int32 InPanelId, TArray<FSBMailData>& OutMailData, bool IsInit);
    TArray<int32> GetPopupNewValidBoardIdList();
    void GetConnectPanel(const int32 InBoardId, const int32 InPanelId, TArray<int32>& OutConnectPanelIdList, bool CheckRoute);
    void GetCompleteReward_MailData(int32 InBoardId, TArray<FSBMailData>& OutMailData, bool IsInit);
    void GetClearFreePanelList(int32 InBoardId, TArray<int32>& OutFreePanelIdList);
    void GetBoardParamList_VersionCheck(TArray<FSBAdventureBoardParam>& OutBoardList);
    TArray<FSBAdventureBoardParam> GetBoardParamList();
    void GetAllReward_MailData(int32 InBoardId, TArray<FSBMailData>& OutMailData);
    void GetActiveBoardList(TArray<FSBAdventureBoardParam>& OutList);
    int32 GetAcquiredRankupBoardId(const TArray<int32>& InBoardIdList);
    void Client_UpdatePanelList_BoardParam(const TArray<FSBAdventureBoardParam>& InBoardParamList, int32 RetCode, bool InForceNotifyNextMap);
    void Client_UpdatePanelList(const TArray<FSBAdventureBoardUpdateData>& InUpdateBoardDataList, const TArray<FSBAdventureBoardPanelUpdateData>& InUpdatePanelDataList, int32 RetCode, bool InForceNotifyNextMap);
    void Client_UpdateBoardList(const TArray<FSBAdventureBoardParam>& InBoardList, int32 InRetCode);
    void Client_SetPopupNewValidBoardIdList(const TArray<int32>& InBoardIdList);
    void Client_SetFavoriteBoard(const TArray<FSBAdventureBoardParam>& InBoardList, int32 InRetCode);
    void Client_SetBoardList(const TArray<FSBAdventureBoardParam>& InBoardList, int32 InRetCode);
    void Client_SetActiveBoard(const TArray<FSBAdventureBoardParam>& InBoardList, int32 InRetCode);
    void Client_SetAchievementedPanelList(const TArray<FSBAdventureBoardPanelParam>& InPanelList, int32 InBoardId, int32 RetCode);
    void Client_SetAchievementedPanel(const TArray<FSBAdventureBoardPanelParam>& InPanelList, int32 InBoardId, int32 InPanelId, int32 RetCode);
    void Client_NotifyPopupNewVaildBoard(int32 InRetCode);
    void Client_LoadBoardListSet(const TArray<FSBAdventureBoardParam>& InBoardList, int32 InRetCode);
    void Client_GetRewardBoardPanel(const TArray<FSBAdventureBoardParam>& InBoardParamList, const FSBMailRewardData& InRewardData, int32 InBoardId, int32 InRetCode, const bool InOpenCommandMenuFlag);
    void Client_GetRewardBoardAllPanel(const TArray<FSBAdventureBoardParam>& InBoardParamList, const FSBMailRewardData& InRewardData, int32 InRetCode, const bool InOpenCommandMenuFlag);
    void Client_DebugAdvanceAdventureBoard(int32 InBoardId, int32 InRetCode, FString InErrorMsg);
    void Client_CompleteBoard(const TArray<FSBAdventureBoardParam>& InBoardParamList, const FSBMailRewardData& InRewardData, int32 RetCode, const bool InOpenCommandMenuFlag);
    void Client_ChangeHudDraw(int32 InBoardId, bool InIsHudDraw, int32 InRetCode);
    bool ChangeHudDraw(int32 InBoardId, bool InHudDraw);
    bool BP_GetBoardParam(FSBAdventureBoardParam& OutOBoardParam, int32 InBoardId);
    bool BP_GetBoardPanelParam(FSBAdventureBoardPanelParam& OutBoardPanelParam, int32 InBoardId, int32 InPanelId);
}; // Size: 0x1B0

class USBPlayerAdventurerComponent : public USBPlayerPropertyComponent
{
    FSBPlayerAdventurerComponentOnAdventurerRankChangeDelegate OnAdventurerRankChangeDelegate; // 0x00B8 (size: 0x10)
    void OnAdventurerRankChangeDelegate(const int32 InRetCode);
    FSBPlayerAdventurerComponentOnAdventurerRankupFlagChangeDelegate OnAdventurerRankupFlagChangeDelegate; // 0x00C8 (size: 0x10)
    void OnAdventurerRankupFlagChangeDelegate(const int32 InRetCode);
    FSBPlayerAdventurerComponentOnAdventurerRankFlagChangeDelegate OnAdventurerRankFlagChangeDelegate; // 0x00D8 (size: 0x10)
    void OnAdventurerRankFlagChangeDelegate(const int32 InRetCode, ESBPlayerPassiveImagineSlotType Slot);
    char padding_0[0x4];                                                              // 0x00E8 (size: 0x4)
    bool AdventurerRankFlag;                                                          // 0x00EC (size: 0x1)

    void SetAutoSelectBoardId(int32 BoardId);
    void SetAdventurerRankFlag(bool Flag);
    void Server_SaveAdventurerRank(const int32 Rank);
    void Server_OnAdventurerRankCommon(int32 InRetCode, int32 Rank, const bool InAdventurerRankFlag, bool OpenMenuFlag);
    void Server_AdventurerRankUp();
    void Server_AdventurerRankFlagUnlock();
    void Request_SaveAdventurerRank(const int32 Rank);
    void Request_AdventurerRankUp();
    void Request_AdventurerRankFlagUnlock();
    void OnRep_AdventurerRank();
    void OnAdventurerRankupFlagChangeDelegate__DelegateSignature(const int32 InRetCode);
    void OnAdventurerRankFlagChangeDelegate__DelegateSignature(const int32 InRetCode, ESBPlayerPassiveImagineSlotType Slot);
    void OnAdventurerRankChangeDelegate__DelegateSignature(const int32 InRetCode);
    bool IsSoloBattleStart();
    bool IsRankupBoardClear();
    void GetBoardGoalReward(TArray<FSBMasterReward>& OutRewardList, int32 InBoardId);
    int32 GetAutoSelectBoardId();
    bool GetAdventurerRankFlag();
    void Client_AdventurerRankCommon(int32 InRetCode, int32 Rank, const bool InAdventurerRankFlag, bool OpenMenuFlag);
}; // Size: 0xF0

class USBPlayerAerialSkillController : public USBPlayerSkillController
{
    char padding_0[0x138];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x138

class USBPlayerAerialSkillInfo : public USBSkillInfoClass
{
    float TakeBonusHeight;                                                            // 0x02A0 (size: 0x4)
    float NeedHeight;                                                                 // 0x02A4 (size: 0x4)
    float FloatingTime;                                                               // 0x02A8 (size: 0x4)
    float FallSpeed;                                                                  // 0x02AC (size: 0x4)

}; // Size: 0x2B0

class USBPlayerAimHUDComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBPlayerAppearEffectComponent : public USBPlayerActorComponent
{
    class UParticleSystemComponent* m_WarpSphere;                                     // 0x00F8 (size: 0x8)

    void ServerPlayDisappearEffect(ESBDisappearEffectType Type);
    void ServerPlayAppearEffectForLocalWarp(const FVector& NewLocation);
    void MulticastPlayDisappearEffect(ESBDisappearEffectType Type);
    void MulticastPlayAppearEffectForLocalWarp(const FVector& NewLocation);
    bool IsDispRespawnFadeInEffect();
}; // Size: 0x120

class USBPlayerArtsComponent : public UActorComponent
{
    FSBPlayerArtsComponentOnSaveEquippedActiveArtsDelegate OnSaveEquippedActiveArtsDelegate; // 0x00B8 (size: 0x10)
    void OnSaveEquippedActiveArtsDelegate(const int32 RetCode, const bool IsArtsAssetLoadRequested);
    FSBPlayerArtsComponentOnSaveEquippedPassiveArtsDelegate OnSaveEquippedPassiveArtsDelegate; // 0x00C8 (size: 0x10)
    void OnSaveEquippedPassiveArtsDelegate(const int32 RetCode);
    FSBPlayerArtsComponentOnChangeEquippedArtsDelegate OnChangeEquippedArtsDelegate;  // 0x00D8 (size: 0x10)
    void OnChangeEquippedArtsDelegate();

    void Server_OnSaveEquipedArts_Passive(int32 RetCode, const TArray<FEquipedArtsInfo>& EquipedArtsInfoList, const bool InSetEquipped, const int32 UnequipArtsId);
    void Server_OnSaveEquipedArts_Active(int32 RetCode, const TArray<FEquipedArtsInfo>& EquipedArtsInfoList, const bool LoadAssetRequest);
    void OnSaveEquippedPassiveArtsDelegate__DelegateSignature(const int32 RetCode);
    void OnSaveEquippedActiveArtsDelegate__DelegateSignature(const int32 RetCode, const bool IsArtsAssetLoadRequested);
    void OnChangeEquippedArtsDelegate__DelegateSignature();
    void Client_SaveEquipedArts_Passive(int32 RetCode, const TArray<FEquipedArtsInfo>& EquipedArtsInfoList, const bool InSetEquipped, const int32 UnequipArtsId);
    void Client_SaveEquipedArts_Active(int32 RetCode, const TArray<FEquipedArtsInfo>& EquipedArtsInfoList, const bool LoadAssetRequest);
    void Client_DoOnSaveEquipedArtsDelegate_Passive(int32 RetCode);
    void Client_DoOnSaveEquipedArtsDelegate_Active(int32 RetCode, const bool IsAssetLoadRequested);
    void ApplyResult_Server(const TArray<FEquipedArtsInfo>& EquipArtsInfo);
    void ApplyResult_Client(const TArray<FEquipedArtsInfo>& EquipArtsInfo);
}; // Size: 0xE8

class USBPlayerAttachableObjectComponent : public USBPlayerActorComponent
{
    TArray<FSBProjectileMasterInfo> ThrowProjectileDataTable;                         // 0x00E0 (size: 0x10)

    void Server_UpdateObjectLocation(FVector Location, FRotator Rotation);
    void Server_SetAttachableObjectEnable(bool enable);
    void Server_SetAttachableObject(class AActor* AttachableObject);
    void Server_RequestEndObjectAction(class AActor* AttachableObject);
    void Server_ReleaseAttachableObject(bool IsObjectDestroy);
    void Client_SetAttachableObjectEnable(bool enable);
    void Client_SetAttachableObject(class AActor* AttachableObject);
    void Client_RequestEndObjectAction(class AActor* AttachableObject);
}; // Size: 0xF0

class USBPlayerAttackCollisionLevelPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBPassiveLevelAttackCollisionSetting> SettingList;                        // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBPlayerAttackCollisionPassiveSkill : public USBPlayerPassiveSkill
{
    float CollisionScale;                                                             // 0x0048 (size: 0x4)

}; // Size: 0x50

class USBPlayerAutoDeliveryQuestComponent : public USBPlayerPropertyComponent
{
    FSBPlayerAutoDeliveryQuestComponentOnAutoDeliveryQuestAllDataDelegete OnAutoDeliveryQuestAllDataDelegete; // 0x00B8 (size: 0x10)
    void OnAutoDeliveryQuestAllDataDelegete(int32 ReturnCode);
    FSBPlayerAutoDeliveryQuestComponentOnUpdateSeasonGeneralDataDelegete OnUpdateSeasonGeneralDataDelegete; // 0x00C8 (size: 0x10)
    void OnUpdateSeasonGeneralDataDelegete();
    FSBPlayerAutoDeliveryQuestComponentOnReloadSeasonPassQuestDelegete OnReloadSeasonPassQuestDelegete; // 0x00D8 (size: 0x10)
    void OnReloadSeasonPassQuest(const FSBSeasonPassQuestItemData& QuestData, ESBAutoDeliveryQuestReloadType Type, bool Success, int32 ReturnCode);
    FSBPlayerAutoDeliveryQuestComponentOnUpdateAutoDeliveryQuestDataDelegete OnUpdateAutoDeliveryQuestDataDelegete; // 0x00E8 (size: 0x10)
    void OnUpdateAutoDeliveryQuestDataDelegete(int32 ReturnCode);
    FSBPlayerAutoDeliveryQuestComponentOnCompleteAutoDeliveryQuestDataDelegete OnCompleteAutoDeliveryQuestDataDelegete; // 0x00F8 (size: 0x10)
    void OnCompleteAutoDeliveryQuestDataDelegete(const FSBSeasonPassQuestListManager& InQuestManager, ESBAutoDeliveryRewardStatus RewardStatus, int32 ReturnCode);
    FSBPlayerAutoDeliveryQuestComponentOnAchievementedAutoDeliveryQuestDelegete OnAchievementedAutoDeliveryQuestDelegete; // 0x0108 (size: 0x10)
    void OnAchievementedAutoDeliveryQuestDelegete(const ESBSeasonPassQuestCycleType CycleType, FString QuestID);
    FSBPlayerAutoDeliveryQuestComponentOnUpdateAutoDeliveryQuest_DailyWeeklyDelegete OnUpdateAutoDeliveryQuest_DailyWeeklyDelegete; // 0x0118 (size: 0x10)
    void OnUpdateAutoDeliveryQuest_DailyWeeklyDelegete(int32 ReturnCode);
    FSBPlayerAutoDeliveryQuestComponentOnUpdateAutoDeliveryQuest_SeasonDelegete OnUpdateAutoDeliveryQuest_SeasonDelegete; // 0x0128 (size: 0x10)
    void OnUpdateAutoDeliveryQuest_SeasonDelegete(const ESBAutoDeliveryQuestUpdateType InType);
    FSBSeasonPassQuestInfo QuestInfo;                                                 // 0x0138 (size: 0x8)
    FSBSeasonPassQuestListManager QuestListManager;                                   // 0x0140 (size: 0x10)
    ESBAutoDeliveryQuestUpdateStatus UpdateStatus;                                    // 0x0150 (size: 0x1)

    void SetQuestListManager(const FSBSeasonPassQuestListManager& InQuestListManager);
    void SetQuestItemData(const FSBSeasonPassQuestItemData& InQuestItemData);
    void SetQuestInfo(const FSBSeasonPassQuestInfo& InQuestInfo);
    void Server_UpdateQuestListAll();
    void Server_SetQuestInfo(const FSBSeasonPassQuestInfo& InQuestInfo);
    void Server_ReloadSeasonPassQuest(FString InQuestId, FString InGroupId);
    void Server_FreeReloadSeasonPassQuest(FString InQuestId, FString InGroupId);
    void Server_CompleteQuest(FString InQuestId, FString InGroupId, bool IsPayUse);
    void Server_AddQuest(FString InQuestId);
    bool SearchItemDataBP_QuestId(FString InQuestId, FString InGroupId, FSBSeasonPassQuestItemData& OutQuestData);
    bool SearchItemDataBP(FString InQuestId, FSBSeasonPassQuestItemData& OutQuestData);
    void ResetUpdateStatus();
    void Request_UpdateQuestListAll();
    void Request_SetQuestList(const ESBSeasonPassQuestCycleType CycleType, const FSBSeasonPassQuestListData& InList);
    void Request_ReloadSeasonPassQuest(FString InQuestId, FString InGroupId);
    void Request_QuestUpdateLogPutParse(FSBSeasonPassQuestListManager InSeasonPassQuestListManager, FString InMsg);
    void Request_FreeReloadSeasonPassQuest(FString InQuestId, FString InGroupId);
    void Request_CompleteQuest(FString InQuestId, FString InGroupId, bool IsPayUse);
    void Request_AddQuest(FString InQuestId);
    ESBAutoDeliveryQuestUpdateStatus GetUpdateStatus();
    FSBSeasonPassQuestListManager GetQuestListManagerConst();
    FSBSeasonPassQuestListManager GetQuestListManager();
    FSBSeasonPassQuestInfo GetQuestInfoConst();
    FSBSeasonPassQuestInfo GetQuestInfo();
    void Client_UpdateQuestListManager(const FSBSeasonPassQuestListManager& InQuestListManager, bool InIsNotifyProgressAchievemented, bool InIsBackup);
    void Client_UpdateQuestListComplete(const int32 InRetCode);
    void Client_UpdateQuestListAll(const FSBSeasonPassQuestListManager& InQuestListManager, const int32 InType);
    void Client_UpdateQuestList(const FSBSeasonPassQuestListData& InQuestList);
    void Client_UpdateQuestAllData(const FSBSeasonPassQuestInfo& InQuestInfo, const FSBSeasonPassQuestListManager& InQuestListManager, int32 InRetCode);
    void Client_SetQuestListManager(const FSBSeasonPassQuestListManager& InQuestInfo);
    void Client_SetQuestList(const ESBSeasonPassQuestCycleType CycleType, const FSBSeasonPassQuestListData& InList);
    void Client_SetQuestInfo(const FSBSeasonPassQuestInfo& InQuestInfo);
    void Client_ResetQuestList();
    void Client_ReloadSeasonPassQuest(FString InPrevQuestId, FString InPrevGroupId, const FSBSeasonPassQuestItemData& InNewQuestData, const ESBAutoDeliveryQuestReloadType InReloadType, const bool InSuccess, const int32 ReturnCode, const FSBSeasonPassQuestInfo& InQuestInfo);
    void Client_QuestUpdateLogPutParse(FSBSeasonPassQuestListManager InSeasonPassQuestListManager, FString InMsg);
    void Client_QuestAchievemented(const ESBSeasonPassQuestCycleType CycleType, const TArray<FSBTextTableHash>& InQuestListData);
    void Client_CompleteQuest(const FSBSeasonPassQuestListManager& InQuestManager, ESBAutoDeliveryRewardStatus RewardStatus, const int32 ReturnCode, const FSBAutoQuestComponentData& AutoQuestData, const bool InOpenCommandMenuFlag);
    void Client_AddQuestItemData(const ESBSeasonPassQuestCycleType CycleType, const TArray<FSBSeasonPassQuestItemData>& InItemList, int32 InListMax);
}; // Size: 0x158

class USBPlayerAwardComponent : public USBPlayerPropertyComponent
{
    FSBPlayerAwardComponentOnAwardsDelegate OnAwardsDelegate;                         // 0x00B8 (size: 0x10)
    void OnAwardsDelegate(const bool Result, const int32 RetCode, const TArray<FPlayerAwardData>& AwardIdList);

    void SetSortData(TArray<FPlayerAwardData>& InAwardData, const TEnumAsByte<ESBAwardSortType::Type> InSortType);
    void Server_AddAwardIdList(const TArray<int32>& InAwardIdList);
    void Request_LoadAwardList();
    void OnAwardsDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FPlayerAwardData>& AwardIdList);
    void Client_SetAwardIdList(const TArray<int32>& AwardIdList);
    void Client_AddAwardIdList(const TArray<int32>& InAwardIdList);
}; // Size: 0xC8

class USBPlayerBPFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool SetRouteGuideDestination(class UObject* WorldContextObject, FName DestinationId);
    void SetHideSpawnEffect(bool IsHideSpwanEffect, bool IsHideFadeInEffect);
    bool SetDefaultPlayCharacter(class UObject* WorldContextObject, FString CharacterId);
    void PlayerCharcterAutoMoveStop(class UObject* WorldContextObject);
    bool IsPlayerClassRedistered(ESBClassType ClassType);
    bool IsPlayAnimationSit(const class ASBPlayerCharacter* PlayerCharacter);
    bool IsBlockResponseWithPlayerPawn(const class UPrimitiveComponent* HitComponent);
    float GetPointDistToCameraPlayerSegment(const class UObject* WorldContextObject, const FVector& Point);
    FString GetPlayerName(const class UObject* WorldContextObject);
    FString GetPlayerId(const class UObject* WorldContextObject);
    float GetPlayerHeightScale(const class ASBPlayerCharacter* PlayerCharacter, float StandardHeight);
    FString GetLogedInPlayerName(const class UObject* WorldContextObject);
    bool GetLogedInPlayerCharactersCharaCreateParameter(const class UObject* WorldContextObject, TArray<FSBCharaCreateParameter>& OutCharaCreateParameters);
    bool GetLogedInPlayerCharacters(const class UObject* WorldContextObject, TArray<FSBUserOnlineAccountCharacter>& OutCharacters, bool bUseScenarioData);
    ESBLoginBanType GetLogedInPlayerBanType(const class UObject* WorldContextObject);
    FSBPlayerBanFinishedTimeInfo GetLogedInPlayerBanFinishedAt(const class UObject* WorldContextObject);
    ESBLoginBanDurationType GetLogedInPlayerBanDurationType(const class UObject* WorldContextObject);
    bool GetDefaultPlayCharacter(const class UObject* WorldContextObject, FSBUserOnlineAccountCharacter& OutCharacter);
    bool GetContentLock(const class UObject* WorldContextObject, const ESBContentLockType InContentLockType);
    ESBRewardBoostStackBItemType ConvertRewardBoostType(const EItemType ItemType, int32 ItemId);
    void AddMovementInput(class ASBPlayerCharacter* PlayerCharacter, FVector WorldDirection, float ScaleValue, bool bForce);
    void AddActorWorldOffset(class ASBPlayerCharacter* PlayerCharacter, FVector DeltaLocation, bool bSweep, bool bTeleport);
}; // Size: 0x28

class USBPlayerBehaviorHistoryLogComponent : public USBPlayerActorComponent
{
    char padding_0[0x168];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x168

class USBPlayerBookMarks : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FSBBookMarkSaveData Data;                                                         // 0x0040 (size: 0x60)

}; // Size: 0xA0

class USBPlayerBuddyVoiceComponent : public USBPlayerActorComponent
{
    float HitPointThresholdPar;                                                       // 0x00D8 (size: 0x4)
    float TreasureBoxDistance;                                                        // 0x00DC (size: 0x4)

}; // Size: 0xE0

class USBPlayerBurstBonusAttackAndElementModifyPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBPlayerBurstBonusAttackAndElementModifySetting> ModifySettingList;       // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBPlayerCacheComponent : public USBPlayerPropertyComponent
{
    char padding_0[0x110];                                                            // 0x0000 (size: 0x0)

    void ServerPushCacheProperty(const FSBClientManagedProperty ClientProperty);
    void ClientPushCacheProperty();
}; // Size: 0x110

class USBPlayerCameraComponent : public USBPlayerSceneComponent
{
    class USBSpringArmComponent* CameraArmComponent;                                  // 0x0220 (size: 0x8)
    class UCameraComponent* CameraComponent;                                          // 0x0228 (size: 0x8)
    char padding_0[0x28];                                                             // 0x0230 (size: 0x28)
    float CameraArmSweepCollisionShapeSize;                                           // 0x0258 (size: 0x4)
    float CameraArmImpactNormalScale;                                                 // 0x025C (size: 0x4)
    float CameraInWaterOffsetScale;                                                   // 0x0260 (size: 0x4)
    float ComponentLocationOffsetDeltaTime;                                           // 0x0264 (size: 0x4)
    char padding_1[0x10];                                                             // 0x0268 (size: 0x10)
    TArray<class UDataTable*> BaseGameplayCameraSettingsDataTable;                    // 0x0278 (size: 0x10)
    TArray<class UDataTable*> ClassGameplayCameraSettingsDataTable;                   // 0x0288 (size: 0x10)
    char padding_2[0x10];                                                             // 0x0298 (size: 0x10)
    FSBCameraDistanceTransparentParam CameraDistanceTransparentParam;                 // 0x02A8 (size: 0xC)
    char padding_3[0x14];                                                             // 0x02B4 (size: 0x14)
    FPlayerCameraData CurrentCameraData;                                              // 0x02C8 (size: 0x178)
    char padding_4[0x534];                                                            // 0x0440 (size: 0x534)
    bool ChangeCameraSpeedNearTarget;                                                 // 0x0974 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0975 (size: 0x3)
    float NearTargetCameraAngle;                                                      // 0x0978 (size: 0x4)
    char padding_6[0x4];                                                              // 0x097C (size: 0x4)
    TSoftObjectPtr<UCurveFloat> NearTargetCameraSpeedCurve;                           // 0x0980 (size: 0x28)
    bool CameraFollowTarget;                                                          // 0x09A8 (size: 0x1)
    char padding_7[0x3];                                                              // 0x09A9 (size: 0x3)
    float FollowTargetAngleRange;                                                     // 0x09AC (size: 0x4)
    TSoftObjectPtr<UCurveFloat> NearTargetCameraFollowCurve;                          // 0x09B0 (size: 0x28)
    char padding_8[0x8];                                                              // 0x09D8 (size: 0x8)
    float KeepAimNearLimitLength;                                                     // 0x09E0 (size: 0x4)
    char padding_9[0x2C];                                                             // 0x09E4 (size: 0x2C)
    float SwimCameraUpperLocationOffsetZ;                                             // 0x0A10 (size: 0x4)
    float SwimCameraPlayerHiddenPitch;                                                // 0x0A14 (size: 0x4)
    class UDataTable* LockOnCameraSettingsDataTable;                                  // 0x0A18 (size: 0x8)
    char padding_10[0xC4];                                                            // 0x0A20 (size: 0xC4)
    FVector DebugSocketOffset;                                                        // 0x0AE4 (size: 0xC)
    bool IsUseDebugSocketOffset;                                                      // 0x0AF0 (size: 0x1)

    void SetZoomLevelByArmLength(float ArmLengthData);
    void SetDebugSocketOffsetEnable(bool IsEnable);
    void SetActorLocationToDebugCamreraLocation();
    void ResetCameraRotation(float BlendTime);
    bool RequestCameraQueue(FString CameraID, bool IsAdd);
    FRotator GetPlayerControllerRotation();
    class ASBPlayerCharacter* GetOwnerPlayer();
    FRotator GetCameraRotation();
    float GetCameraFov();
    class UCameraComponent* GetCameraComponent();
    float GetCameraArmLength();
    class USBSpringArmComponent* GetCameraArmComponent();
    void DebugSetPlayerControllerRotation(bool isSetPitch, float Pitch, bool isSetYaw, float Yaw, bool isSetRoll, float Roll);
    void DebugSetMainCameraFov(float FOV);
    void DebugSetCurrentCameraRotationSpeed(bool isSetYaw, float Yaw, bool isSetPitch, float Pitch, bool isSetMouseYaw, float MouseYaw, bool isSetMousePitch, float MousePitch);
    void DebugSetCameraArmLength(float ArmLength);
    void DebugCameraReset();
    void DebugCameraMoveUp(float Val);
    void DebugCameraMoveRight(float Val);
    void DebugCameraMoveForward(float Val);
    void DebugCameraLookUp(float Val);
    void DebugCameraLookRight(float Val);
    void ClearCameraQueue();
}; // Size: 0xB00

class USBPlayerCharacterAnimInstance : public USBCharacterAnimInstance
{
    float AimBody_Pitch;                                                              // 0x0FD8 (size: 0x4)
    float AimBody_Yaw;                                                                // 0x0FDC (size: 0x4)
    float AimBody_BlendRate;                                                          // 0x0FE0 (size: 0x4)
    float m_AimBodyBlendRateTime;                                                     // 0x0FE4 (size: 0x4)
    bool bFullAimBody;                                                                // 0x0FE8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0FE9 (size: 0x3)
    float BlendSpace_Air;                                                             // 0x0FEC (size: 0x4)
    char padding_1[0x1];                                                              // 0x0FF0 (size: 0x1)
    bool bAdditiveLandingRequested;                                                   // 0x0FF1 (size: 0x1)
    char padding_2[0x2E];                                                             // 0x0FF2 (size: 0x2E)
    float SlopeChange;                                                                // 0x1020 (size: 0x4)
    float SlopeChangeThreshold;                                                       // 0x1024 (size: 0x4)
    class UCurveFloat* SlopeChangeCurve;                                              // 0x1028 (size: 0x8)
    class UCurveFloat* SlopeSpeedChangeCurve;                                         // 0x1030 (size: 0x8)
    class UCurveFloat* SlopeAngleChangeCurve;                                         // 0x1038 (size: 0x8)
    class UCurveFloat* DestinationSlopeAngleCurve;                                    // 0x1040 (size: 0x8)
    char padding_3[0x4];                                                              // 0x1048 (size: 0x4)
    float BlendSpace_Gender;                                                          // 0x104C (size: 0x4)
    TArray<FSBLimbIKUpdateParam> LimbIKUpdateParamArray;                              // 0x1050 (size: 0x10)

}; // Size: 0x1060

class USBPlayerCharacterCommonComponent : public USBPlayerPropertyComponent
{
    FSBPlayerCharacterCommonComponentOnCharacterJoinExtDelegate OnCharacterJoinExtDelegate; // 0x00B8 (size: 0x10)
    void OnCharacterJoinExtDelegate(const int32 InRetCode);
    FSBPlayerCharacterCommonComponentOnSaveKeyValueDelegate OnSaveKeyValueDelegate;   // 0x00C8 (size: 0x10)
    void OnSaveKeyValueDelegate(const bool bWasSuccessful);
    FSBPlayerCharacterCommonComponentOnSetKeyValueDelegate OnSetKeyValueDelegate;     // 0x00D8 (size: 0x10)
    void OnSetKeyValueDelegate(bool Result);
    FSBPlayerCharacterCommonComponentOnSetContentLockDelegate OnSetContentLockDelegate; // 0x00E8 (size: 0x10)
    void OnSetContentLockDelegate(bool Result);
    FSBPlayerCharacterCommonComponentOnSaveQuestCheckListDelegate OnSaveQuestCheckListDelegate; // 0x00F8 (size: 0x10)
    void OnSaveQuestCheckListDelegate(const bool bWasSuccessful);
    FSBPlayerCharacterCommonComponentOnSaveMoneyDelegate OnSaveMoneyDelegate;         // 0x0108 (size: 0x10)
    void OnSaveMoneyDelegate(const bool Result);
    char padding_0[0x18];                                                             // 0x0118 (size: 0x18)
    FSBPlayerCharacterCommonComponentOnChangeOpenCommandMenuFlagDelegate OnChangeOpenCommandMenuFlagDelegate; // 0x0130 (size: 0x10)
    void OnChangeOpenCommandMenuFlagDelegate(const bool Result);
    FSBPlayerCharacterCommonComponentOnCharaSkillMasteryOthersInfoDelegate OnCharaSkillMasteryOthersInfoDelegate; // 0x0140 (size: 0x10)
    void OnCharaSkillMasteryOthersInfoDelegate(const int32 RetCode);
    FSBPlayerCharacterCommonComponentOnAddTraverseDelegate OnAddTraverseDelegate;     // 0x0150 (size: 0x10)
    void OnChangeTraverseDelegate(const int32 RetCode);
    FSBPlayerCharacterCommonComponentOnSaveCommandMenuPlayerAvatarPoseIdDelegate OnSaveCommandMenuPlayerAvatarPoseIdDelegate; // 0x0160 (size: 0x10)
    void OnSaveCommandMenuPlayerAvatarPoseIdDelegate(const int32 InRetCode, const int32 AvatarPoseId);
    FSBPlayerCharacterCommonComponentOnSaveCharaCostumeMultipleEquipsDelegate OnSaveCharaCostumeMultipleEquipsDelegate; // 0x0170 (size: 0x10)
    void OnSaveCharaCostumeMultipleEquipsDelegate(int32 RetCode, const FSBExpiredEquipmentData& InExpiredEquipmentData);
    FSBPlayerCharacterCommonComponentOnCommandMenuGetDelegate OnCommandMenuGetDelegate; // 0x0180 (size: 0x10)
    void OnCommandMenuGetDelegate(const int32 RetCode);
    FSBPlayerCharacterCommonComponentOnNotificationMenuListLoadedDelegete OnNotificationMenuListLoadedDelegete; // 0x0190 (size: 0x10)
    void SBOnNotificationMenuListLoadedDelegete(bool Result);

    void UpdateNotificationData(bool& IsValid);
    void TraverseSet_Server(const TArray<FString>& TraversedList);
    void TraverseSet_Client(const TArray<FString>& TraversedList);
    void Server_SetKeyValue(const TArray<FSBKeyPair>& InKeyValues);
    void Server_SaveAddMoneyDebug(const int32 AddMoney);
    void Server_RequestTraversePoint(FString TraversedPoint);
    void Server_RequestSaveCommandMenuPlayerAvatarPoseId(const int32 InAvatarPoseId);
    void Server_RequestSaveCharaCostumeMultipleEquips(class ASBPlayerController* InPlayerController, const TArray<FCharaEquipItemInfo>& InEquipItemInfos, const TArray<FCharaEquipItemCharaCreateInfo>& InEquipItemCharaCreateInfos, const TArray<ESBCharaEquipType>& InEquipTypes);
    void Server_OnSetKeyValue(bool InResult, const TArray<FSBKeyPair>& InKeyValues);
    void Server_OnSaveCharaCostumeMultipleEquips(int32 RetCode, const TArray<ESBCharaEquipType>& DirtyEquipTypes, const TArray<FCharaEquipItemInfo>& DirtyEquipItemInfos, const TArray<ESBCharaEquipType>& EquipTypes, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void Server_ClearKeyValue();
    void SBOnNotificationMenuListLoadedDelegete__DelegateSignature(bool Result);
    void RequestTraversePoint(FString TraversedPoint);
    void RequestSaveCommandMenuPlayerAvatarPoseId(const int32 InAvatarPoseId);
    void RequestSaveCharaCostumeMultipleEquips(class ASBPlayerController* InPlayerController, const TArray<FCharaEquipItemInfo>& InEquipItemInfos, const TArray<FCharaEquipItemCharaCreateInfo>& InEquipItemCharaCreateInfos, const TArray<ESBCharaEquipType>& InEquipTypes);
    void RequestNotificationData();
    bool RequestCharaSkillMasteryOthers(ESBClassType InClassType);
    bool RequestCharacterJoinExt();
    bool Request_SetKeyValue(const TArray<FSBKeyPair>& InKeyValues);
    bool Request_SetContentLock(ESBContentLockType InContentLockType, bool bInLock);
    bool RemoveQuestCheckList(const int32 InQuestIndex);
    void OnSetKeyValueDelegate__DelegateSignature(bool Result);
    void OnSetContentLockDelegate__DelegateSignature(bool Result);
    void OnSaveQuestCheckListDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnSaveMoneyDelegate__DelegateSignature(const bool Result);
    void OnSaveKeyValueDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnSaveCommandMenuPlayerAvatarPoseIdDelegate__DelegateSignature(const int32 InRetCode, const int32 AvatarPoseId);
    void OnSaveCharaCostumeMultipleEquipsDelegate__DelegateSignature(int32 RetCode, const FSBExpiredEquipmentData& InExpiredEquipmentData);
    void OnCommandMenuGetDelegate__DelegateSignature(const int32 RetCode);
    void OnCharaSkillMasteryOthersInfoDelegate__DelegateSignature(const int32 RetCode);
    void OnCharacterJoinExtDelegate__DelegateSignature(const int32 InRetCode);
    void OnChangeTraverseDelegate__DelegateSignature(const int32 RetCode);
    void OnChangeOpenCommandMenuFlagDelegate__DelegateSignature(const bool Result);
    bool IsTraverse(FString TraversedPoint);
    bool CommandMenuGet();
    void ClientOnShowRetMessage(int32 InRetCode);
    void Client_SetKeyValue(bool InResult, const TArray<FSBKeyPair>& InKeyValues);
    void Client_SetContentLock(bool InResult);
    void Client_SaveMoney(bool Result, const int32 Money);
    void Client_OnTraversePoint(int32 RetCode, FString TraversedPoint);
    void Client_OnSetCommandMenuPlayerAvatarPoseId(const int32 InAvatarPoseId);
    void Client_OnSaveCommandMenuPlayerAvatarPoseId(const int32 InRetCode, const int32 InAvatarPoseId);
    void Client_OnSaveCharaCostumeMultipleEquips(int32 RetCode, const TArray<ESBCharaEquipType>& DirtyEquipTypes, const TArray<FCharaEquipItemInfo>& DirtyEquipItemInfos, const TArray<ESBCharaEquipType>& EquipTypes, const FSBExpiredEquipmentData& InDirtyExpiredEquipmentData);
    void Client_ClearKeyValue(const bool bInWasSuccessful);
    bool ClearQuestCheckList();
    bool ClearKeyValue();
    void ApplyResult_Server(const TArray<FCharaSkillMasteryInfo>& InSkillMasteryInfo);
    void ApplyResult_Client(const TArray<FCharaSkillMasteryInfo>& InSkillMasteryInfo);
    bool AddQuestCheckList(const int32 InQuestIndex);
}; // Size: 0x1A0

class USBPlayerCharacterLevelSyncComponent : public UActorComponent
{
    int32 LevelSyncTarget;                                                            // 0x00B8 (size: 0x4)
    int32 Level;                                                                      // 0x00BC (size: 0x4)

    void Client_ReplicateStatusParameter(const FSBCharacterStatus& Status);
}; // Size: 0x870

class USBPlayerCharacterParameterComponent : public USBPlayerPropertyComponent
{
    FVector_NetQuantize Location;                                                     // 0x00C0 (size: 0xC)
    float MaxHitPoint;                                                                // 0x00CC (size: 0x4)
    float MaxHitPointWithoutResurrectionAdjust;                                       // 0x00D0 (size: 0x4)
    float CurrentHitPoint;                                                            // 0x00D4 (size: 0x4)
    float CurrentDiedCountDown;                                                       // 0x00D8 (size: 0x4)
    float MaxHitPointLoss;                                                            // 0x00DC (size: 0x4)
    TArray<FSBPlayerNamedEnemyParam> NamedEnemyParamList;                             // 0x00E0 (size: 0x10)

    void UpdateNamedEnemyData();
    bool IsReplicateAfter();
    float GetMaxHitPointWithoutResurrectionAdjust();
    float GetMaxHitPointLoss();
    float GetCurrentDiedCountDown();
    FVector_NetQuantize GetCharacterLocation();
    TArray<FSBPlayerNamedEnemyParam> BP_GetNamedEnemyParamList();
}; // Size: 0xF0

class USBPlayerChargeSkillController : public USBPlayerSkillController
{
    TArray<FSBPlayingEffect> m_PlayingSkillChargeLevelEffectList;                     // 0x0078 (size: 0x10)

}; // Size: 0x88

class USBPlayerChatComponent : public USBPlayerPropertyComponent
{
    char padding_0[0x170];                                                            // 0x0000 (size: 0x0)

    void Server_Check(FString MsgBody, const ESBChatLogType ChatLogType, const class ASBPlayerCharacter* OtherPlayerCharacter, const bool IsPhotoMode);
    void RequestCheckOnlineStatus(FString ToCharacterId);
    void Multicast_SendSystemMessage(const FName& InSystemLogId);
    void Client_SetSendRestrictionSec(const float sec);
    void Client_CheckResult(FString MsgBody, const ESBChatLogType ChatLogType);
    void Client_CheckError(ESBSystemMessageFlag Flag);
    void Client_CheckEmoteResult(FString MsgBody, const ESBChatLogType ChatLogType, const class ASBPlayerCharacter* OtherPlayerCharacter);
}; // Size: 0x170

class USBPlayerCheatCommand : public UObject
{
    char padding_0[0x3F0];                                                            // 0x0000 (size: 0x0)

    void UseCheerfulItem(ESBCheerfulItemType ItemType, int32 ItemIndex, int32 Time);
    void UnPossessPlayerCharacter();
    void UnequipClassPassiveSkillAll();
    void UnequipClassPassiveSkill(FName SkillName);
    void TriggerAbility(int32 ID, int32 Parts1Value1, int32 Parts1Value2, int32 Parts2Value1, int32 Parts2Value2, int32 Time, bool Passive, ESBAbilityRequestSource RequestType);
    void TravelToWarpPoint(const FName& InWarpPointId);
    void TravelToOffGame(FString InGameContentId);
    void ToggleGameplayDebugger();
    void ToggleGamePauseSB();
    void TakeDamage(FString CharacterName, float Damage);
    void SuspendPlayerClothing();
    void SubClassExp(const int32 Exp);
    void StartMountToAllPlayer(FName MountName);
    void StartMountDirect(FName ImagineName);
    void StartMount(FName MountName);
    void SkipLevelStartSequence();
    void ShowPlayerClothing(bool sw);
    void ShowLogIsPushModelEnabled();
    void ShowCharaCreateClothing(bool sw, int32 ID);
    void ShieldDamage(const float DamageValue);
    void SetTargetHitPointPar(float HitPointPar);
    void SetTargetHitPoint(float HitPoint);
    void SetStamina(float Stamina);
    void SetSelfToDebugTargetActor();
    void SetSelfHitPointPar(float HitPointPar);
    void SetSelfHitPoint(float HitPoint);
    void SetRecastTimeZero();
    void SetPlayerStopMotion(bool bMotionStop);
    void SetPlayerMovementTick(bool bEnable);
    void SetPlayerForcedLOD(int32 InLod);
    void SetPlayerDefaultElementValue(FName ElementTypeName, int32 Value);
    void SetPlayerDefaultElementDamage(FName ElementTypeName, int32 Damage);
    void SetPlayerAnimationTick(bool bEnable);
    void SetPlayerAlwaysRefreshBones(bool bEnable);
    void SetPlayerAbility(int32 InAbilityID, int32 InTime);
    void SetPartyMemberNum(const int32 InPersistentMemberNum, const int32 InInstantMemberNum);
    void SetMeshClimbingHandsOffset(float X, float Y, float Z);
    void SetFacial(const ESBFacialType InFacialType);
    void SetClassSubActionGaugeValue(float SetValue);
    void SetClassLevel(const int32 Level);
    void SetClassExp(const int32 Exp);
    void SetClassExExp(const int32 Exp);
    void SetCharaPartsByPartsName(FString InPartsName);
    void SetCharaPartsByCostumeID(const int32& InCostumeId);
    void SetCharaCreatePartsDivide(bool bDivide);
    void SetCharaCreateParameter(FString InAssetName, const int32 CharaCreateParameterMode);
    void SessionTravelTo(FString InSessionName);
    void SendMaterialParamAroundPlayer(FName MaterialParamName, float Value, float Radius);
    void SendGatherPlayerStateMachine();
    void SendGatherPlayerParameter();
    void SendGatherAroundPlayerParameter(float Radius);
    void SendClientGatherPlayerParameter();
    void SendClientGatherAroundPlayerParameter(float Radius);
    void SendBurdeningDummyRPC(int32 dummySendMulticastNum, int32 dummySendRepeatNum, float dummySendIntervalMsec);
    void SendAnimCommandToAllSimulatedPlayer(FName Command);
    void SendAnimCommand(FName Command);
    void SelfStunDamage(float StunDamage, ESBStunDirection StunDirection);
    void SelfRespawn();
    void SelfElementDamage(ESBAttribute ElementType, float ElementDamage);
    void SelfDamage(const float DamageValue);
    void ResumePlayerClothing();
    void ResponseChecker();
    void ResetPlayerDefaultElementDamage();
    void ResetMountRemoteDirectToAllPlayer();
    void ResetMountLocalDirect();
    void ResetGatherPointActor();
    void ResetGatherParam();
    void ResetForDemo();
    void ResetCharaParts();
    void RequestHoldHand();
    void RequestCameraQueue(FString CameraID, bool IsAdd);
    void ReloadPlayerAssets();
    void ReloadCameraSettings();
    void RejoinGame();
    void RecreatePlayerClothing();
    void RecepiBroker();
    void PrintBattleEffective();
    void PrintAllPartyInfo();
    void PlayerRadiusDamage(const float DamageValue, const float Radius);
    void OutputDispPingCheckData();
    void OpenDbgMenu();
    void KillTarget();
    void KillPlayerController();
    void ItemSupplyer();
    void InitAnim();
    void GetStamp(const int32 StampId);
    TArray<FSBDebugRespawnPointData> GetRespawnPointList();
    void GetEmote(const FName& EmoteName);
    void ForceSyncInitialParametersLoadCompleted();
    void ForceSyncClientReady();
    void ForceAFKKick();
    void Follow();
    void FinishMountDirect();
    void FinishMount();
    void FieldTravelTo(FString TravelFieldMapName, FString SpawnPortal);
    void EquipPassiveImagine(FString UniqueId, ESBPlayerPassiveImagineSlotType Slot);
    void EquipClassPassiveSkill(FName SkillName);
    void DumpFacialList();
    void DumpEmoteList();
    void DumpDisableInput();
    void DoEmote(const FName& EmoteName);
    void DispPartyState();
    void DelayConfigSave(float DelayTime);
    void Debug_SetMailRestrictFlags(bool bIsSendRestriction, bool bIsOrganize);
    void Debug_SetMailAlertFlag(bool bIsAleat);
    void CharacterList();
    void CharaCreateCompDebugPrint(int32 I);
    void ChangePlayerSkillByID(const int32 SkillIndex, const int32 SkillId);
    void ChangePlayerSkill(const int32 SkillIndex, const FName SkillName);
    void ChangePlayerFaction(const FName& NewFaction);
    void ChangePingCheckMode(bool bIsEnable);
    void ChangeImagineArts2(const FName& ImagineName);
    void ChangeImagineArts1(const FName& ImagineName);
    void CauseInfiniteLoopFreeze();
    void CallSpecialAtSame(const float DelayTime, const uint8 LimitType);
    void CallSkillArtsAtSame(const int32 SkillIndex, const float DelayTime, const uint8 LimitType);
    void CallImagineArtsAtSame(const int32 imagineArtsIndex, const float DelayTime, const uint8 LimitType);
    void BeforeNextLevelClassExp();
    void AttackMasterClearServerOnlyParameter();
    void AddVoltageGauge(const float Amount);
    void AddMeshClimbingHandsOffset(float X, float Y, float Z);
    void AddComboGauge(const int32 Amount);
    void AddClassExpLocal(const int32 AddExp);
    void AddClassExp(const int32 AddExp);
    void AddBuffShotGauge(const float Amount);
}; // Size: 0x3F0

class USBPlayerCheerfulItemComponent : public USBPlayerActorComponent
{
    TSoftObjectPtr<UDataTable> CheerfulItemDataTable;                                 // 0x00D8 (size: 0x28)
    char padding_0[0x34];                                                             // 0x0100 (size: 0x34)
    int32 m_ReplicatedApplyingAttachmentTypeItemId;                                   // 0x0134 (size: 0x4)

    void ServerStartUseCheerfulItem(bool bMulticast);
    void ServerStartAdditionalEffectCheerfulItem(bool bMulticast);
    void ServerNotifyCheerfulItemConsumeTiming();
    void ServerNotifyApplyCheerfulItemEfficacy(const int32 ItemId, EItemEfficacyType EfficacyType, int32 EfficacyIndex, float EfficacyTime, bool bImmediately);
    void ServerEndUseCheerfulItem(bool bMulticast);
    void OnRep_ApplyingAttachmentTypeItemId();
    void NotifyToServerAndStartUseCheerfulItem();
    void NotifyToServerAndStartAdditionalEffectCheerfulItem();
    void NotifyToServerAndEndUseCheerfulItem();
    void NotifyCheerfulItemConsumeTiming();
    void MulticastStartUseCheerfulItem();
    void MulticastStartAdditionalEffectCheerfulItem();
    void MulticastNotifyApplyCheerfulItemEfficacy(const int32 ItemId, EItemEfficacyType EfficacyType, int32 EfficacyIndex, float EfficacyTime, bool bImmediately);
    void MulticastEndUseCheerfulItem();
    void DebugUseCheerfulItem(ESBCheerfulItemType ItemType, int32 ItemIndex, int32 Time);
}; // Size: 0x158

class USBPlayerCliffComponent : public USBPlayerActorComponent
{
    float CliffStopDetectionLength;                                                   // 0x00D4 (size: 0x4)
    float CliffStopDetectionHeight;                                                   // 0x00D8 (size: 0x4)
    float CliffStopCapsuleHalfHeight;                                                 // 0x00DC (size: 0x4)
    float CliffStopCapsuleRadius;                                                     // 0x00E0 (size: 0x4)
    float CliffStopSearchLength;                                                      // 0x00E4 (size: 0x4)
    bool CliffStopDebugDrawCapsule;                                                   // 0x00E8 (size: 0x1)
    char padding_0[0x3];                                                              // 0x00E9 (size: 0x3)
    float CliffJumpDetectionLength;                                                   // 0x00EC (size: 0x4)
    float CliffJumpDetectionHeight;                                                   // 0x00F0 (size: 0x4)
    float CliffJumpCapsuleHalfHeight;                                                 // 0x00F4 (size: 0x4)
    float CliffJumpCapsuleRadius;                                                     // 0x00F8 (size: 0x4)
    bool CliffJumpDebugDrawCapsule;                                                   // 0x00FC (size: 0x1)
    char padding_1[0x3];                                                              // 0x00FD (size: 0x3)
    float CliffJumpLength;                                                            // 0x0100 (size: 0x4)
    float CliffJumpHeight;                                                            // 0x0104 (size: 0x4)
    char padding_2[0xC4];                                                             // 0x0108 (size: 0xC4)
    float ClimbFrontWallCheckDistance;                                                // 0x01CC (size: 0x4)
    float ClimbJumpUpCheckDistance;                                                   // 0x01D0 (size: 0x4)
    float ClimbJumpFrontCheckDistance;                                                // 0x01D4 (size: 0x4)
    float ClimbJumpFloorOffset;                                                       // 0x01D8 (size: 0x4)

    FVector GetCliffJumpVelocity();
}; // Size: 0x1E0

class USBPlayerCommunicateSettingsComponent : public USBPlayerPropertyComponent
{
    ESBTensionTagType TensionTagId;                                                   // 0x00B8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00B9 (size: 0x7)
    FSBPlayerCommunicateSettingsComponentOnTensionTagChanged OnTensionTagChanged;     // 0x00C0 (size: 0x10)
    void OnTensionTagChanged(const ESBTensionTagType TensionTag);
    FSBPlayerCommunicateSettingsComponentOnLoadedCommunicateSettings OnLoadedCommunicateSettings; // 0x00D0 (size: 0x10)
    void OnLoadedCommunicateSettingsDelegate(const bool Result, const FCommunicateSettingInfo Info);
    FSBPlayerCommunicateSettingsComponentOnSavedCommunicateSettings OnSavedCommunicateSettings; // 0x00E0 (size: 0x10)
    void OnSavedCommunicateSettingsDelegate(const bool Result, const int32 Reason);
    FSBPlayerCommunicateSettingsComponentOnResetPhotoImageDelegate OnResetPhotoImageDelegate; // 0x00F0 (size: 0x10)
    void OnResetPhotoImageDelegate(const bool Result);
    FSBPlayerCommunicateSettingsComponentOnUpdatePhotoImageDelegate OnUpdatePhotoImageDelegate; // 0x0100 (size: 0x10)
    void OnUpdatePhotoImageDelegate(const bool Result);
    FSBPlayerCommunicateSettingsComponentOnAlbumAllImageDelegate OnAlbumAllImageDelegate; // 0x0110 (size: 0x10)
    void OnAlbumAllImageDelegate(const bool Result, const TArray<FAlbumImageInfoData>& AlbumAllImageData);

    FCommunicateSettingInfo SetDataChange(const FCommunicateSettingInfo& CommunicateSettingInfo, FString InChangeComment, const TArray<int32> InAwardIdList, const ESBTensionTagType InTensionTagType, const int32 InAdventureCardFrameId, const int32 InFaceFrameId, const int32 InBackGroundColorFrameId, const bool InIsAwardChange);
    void SetAchievementSelected(int32 AchievementId);
    void Server_UpdatePhotoImage(class ASBPlayerState* InPlayerState, EPhotoType Type, FString PhotoModeImageId, float Scale, FVector2D TrimmingCoordinate);
    void Server_SetTensionTag(const ESBTensionTagType TensionTag);
    void Server_SaveCommunicateSetting(const FCommunicateSettingInfo& CommunicateSettingInfo);
    void Server_ResetPhotoImage(class ASBPlayerState* InPlayerState, EPhotoType Type);
    void Server_OnUpdatePhotoImage(bool Result);
    void Server_OnSaveCommunicateSetting(const bool Result, const int32 Reason);
    void Server_OnResetPhotoImage(bool Result);
    void Request_UpdatePhotoImage(EPhotoType Type, FString PhotoModeImageId, float Scale, FVector2D TrimmingCoordinate);
    void Request_SaveCommunicateSetting(const FCommunicateSettingInfo& CommunicateSettingInfo);
    void Request_ResetPhotoImage(EPhotoType Type);
    void Request_LoadCommunicateSetting();
    void Request_AlbumAllImage();
    void OnUpdatePhotoImageDelegate__DelegateSignature(const bool Result);
    void OnTensionTagReplicated();
    void OnTensionTagChanged__DelegateSignature(const ESBTensionTagType TensionTag);
    void OnSavedCommunicateSettingsDelegate__DelegateSignature(const bool Result, const int32 Reason);
    void OnResetPhotoImageDelegate__DelegateSignature(const bool Result);
    void OnLoadedCommunicateSettingsDelegate__DelegateSignature(const bool Result, const FCommunicateSettingInfo Info);
    void OnAlbumAllImageDelegate__DelegateSignature(const bool Result, const TArray<FAlbumImageInfoData>& AlbumAllImageData);
    ESBTensionTagType GetTensionTag();
    void Client_UpdatePhotoImage(bool Result);
    void Client_SetTensionTag(const ESBTensionTagType TensionTag);
    void Client_SaveCommunicateSetting(const bool Result, const int32 Reason);
    void Client_ResetPhotoImage(bool Result);
}; // Size: 0x120

class USBPlayerConcernedList : public USBPlayerPropertyComponent
{
    FSBPlayerConcernedListOnIsGetFriendListDelegate OnIsGetFriendListDelegate;        // 0x00B8 (size: 0x10)
    void OnIsGetFriendListDelegate(const bool bWasSuccessful, const TArray<FPlayerProfileSummaryData>& FriendListData, const int32 MaxCount);
    FSBPlayerConcernedListOnIsGetPlayerSearchListDelegate OnIsGetPlayerSearchListDelegate; // 0x00C8 (size: 0x10)
    void OnIsGetPlayerSearchListDelegate(const bool bWasSuccessful, const TArray<FPlayerProfileSummaryData>& PlayerSearchListData, bool bIsOver, const int32 RetCode);
    FSBPlayerConcernedListOnIsGetPlayerProfileDetailMenuDataDelegate OnIsGetPlayerProfileDetailMenuDataDelegate; // 0x00D8 (size: 0x10)
    void OnIsGetPlayerProfileDetailMenuDataDelegate(const bool bWasSuccessful, const FPlayerProfileMenuDetailData& PlayerProfileDetailMenuData, const int32 RetCode);
    FSBPlayerConcernedListOnIsGetPlayerShortIdDelegate OnIsGetPlayerShortIdDelegate;  // 0x00E8 (size: 0x10)
    void OnIsGetPlayerShortIdDelegate(const bool bWasSuccessful, FString shortId, const int32 RetCode);
    FSBPlayerConcernedListOnCheckTalkPermissionWebAPI OnCheckTalkPermissionWebAPI;    // 0x00F8 (size: 0x10)
    void OnCheckTalkPermissionWebAPI(const bool bWasSuccessful, const int32 RetCode, const bool TalkSuccess);
    FSBPlayerConcernedListOnIsGetContactListDelegate OnIsGetContactListDelegate;      // 0x0108 (size: 0x10)
    void OnIsGetContactListDelegate(const bool bWasSuccessful, const TArray<FContactListData>& ItemListData, const int32 totalPageNum, const int32 currentPageNum);
    FSBPlayerConcernedListOnIsGetConsentListDelegate OnIsGetConsentListDelegate;      // 0x0118 (size: 0x10)
    void OnIsGetConsentListDelegate(const bool bWasSuccessful, const int32 ApprovalMax, const bool bNoOverride, const TArray<FContactListData>& ItemListData, const int32 RetCode);
    FSBPlayerConcernedListOnCharactersAdventurerCardSendDelegate OnCharactersAdventurerCardSendDelegate; // 0x0128 (size: 0x10)
    void OnCharactersAdventurerCardSendDelegate(const bool bWasSuccessful, const FSendAdventureCardResult SendAdventureCardResult);
    FSBPlayerConcernedListOnRemoveFriendDelegate OnRemoveFriendDelegate;              // 0x0138 (size: 0x10)
    void OnRemoveFriendDelegate(const bool bWasSuccessful);
    FSBPlayerConcernedListOnSendLikeDelegate OnSendLikeDelegate;                      // 0x0148 (size: 0x10)
    void OnSendLikeDelegate(const bool bWasSuccessful, const int32 RetCode, const int32 Warning);
    FSBPlayerConcernedListOnSendableLikeDelegate OnSendableLikeDelegate;              // 0x0158 (size: 0x10)
    void OnSendableLikeDelegate(const bool bWasSuccessful, const int32 RetCode, const bool IsSendableLike);
    FSBPlayerConcernedListOnRequestCharactersAdventurerCardUpdateDelegate OnRequestCharactersAdventurerCardUpdateDelegate; // 0x0168 (size: 0x10)
    void OnRequestCharactersAdventurerCardUpdateDelegate(const bool bWasSuccessful, const int32 RetCode);
    FSBPlayerConcernedListOnIsGetPlayerProfileSummaryDataListDelegate OnIsGetPlayerProfileSummaryDataListDelegate; // 0x0178 (size: 0x10)
    void OnIsGetPlayerProfileSummaryDataListDelegate(const bool bWasSuccessful, const TArray<FPlayerProfileSummaryData>& PlayerProfileSummaryData);
    TArray<FPlayerProfileSummaryData> FriendList;                                     // 0x0188 (size: 0x10)
    TArray<FSendableLikePlayer> SendablePlayerList;                                   // 0x0198 (size: 0x10)
    int32 ConcentListNum;                                                             // 0x01A8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x01AC (size: 0x4)
    FSBPlayerConcernedListOnUpdateFriendListDelegate OnUpdateFriendListDelegate;      // 0x01B0 (size: 0x10)
    void OnUpdateFriendListDelegate(const TArray<FPlayerProfileSummaryData>& PlayerProfileSummaryData);
    FSBPlayerConcernedListOnGetEquipItemsForCharactersDelegate OnGetEquipItemsForCharactersDelegate; // 0x01C0 (size: 0x10)
    void OnGetEquipItemsForCharactersDelegate(const bool bWasSuccessful, const int32 RetCode, const TArray<FBattleMemberLevelSyncInfo>& BattleMemberLevelSyncInfos);
    FSBPlayerConcernedListOnGetCharacterCardInfosDelegate OnGetCharacterCardInfosDelegate; // 0x01D0 (size: 0x10)
    void OnGetCharacterCardInfosDelegate(const bool bWasSuccessful, const int32 RetCode, const TArray<FSBPlayerCharacterCardData>& PlayerCharacterCardDatas);
    char padding_1[0x8];                                                              // 0x01E0 (size: 0x8)
    TArray<FPlayerProfileSummaryData> PlayerSearchResultList;                         // 0x01E8 (size: 0x10)
    bool isOver;                                                                      // 0x01F8 (size: 0x1)
    bool isSearchResult;                                                              // 0x01F9 (size: 0x1)

    void UpdateAdventurerCardWebAPI(const FUpdateCardData& UpdateCardData);
    TArray<FPlayerProfileSummaryData> SortFriendList(TArray<FPlayerProfileSummaryData>& FriendList, ESBFriendListSortType SortType);
    TArray<FContactListData> SortContactList(TArray<FContactListData>& ContactList, ESBContactListSortType SortType, bool IsAOrder);
    TArray<FContactListData> SortConsentList(TArray<FContactListData>& ContactList, ESBConsentListSortType SortType);
    void SetSendableLikePlayerList(const FString CharacterId);
    void SetPlayerSearchResultData(const TArray<FPlayerProfileSummaryData> InPlayerSearchResultData, const bool inIsOver);
    void SetFriendList(const TArray<FPlayerProfileSummaryData>& ArrayFriendList);
    void ServerUpdateAdventurerCardWebAPI(const FUpdateCardData& UpdateCardData);
    void ServerRemoveFriendSend(FString ToPlayerId, FString ToCharacterId);
    void ServerCharactersAdventurerCardSend(FString ToPlayerId, FString ToCharacterId);
    void Server_SendLike(const TArray<FLikeSend>& SendLikeList);
    void Server_OnSendLike(const bool bWasSuccessful, const int32 RetCode, FString CharacterName, const int32 Warning);
    void Server_OnIsSendLike(const bool bWasSuccessful, const int32 RetCode, const TArray<FSendableLikePlayer>& SendableLikePlayerList, const bool IsSendableLike);
    void Server_OnGetEquipItemsForCharacters(const bool bWasSuccessful, const int32 RetCode, const TArray<FBattleMemberLevelSyncInfo>& BattleMemberLevelSyncInfos);
    void Server_IsSendLike(const TArray<FSendableLikePlayer>& SendableLikePlayerList);
    void Server_GetEquipItemsForCharacters(const TArray<FBattleMemberInfoSend>& BattleMemberInfoSendList);
    void Server_AddAdventurerCardDecorationIdList(const TArray<int32>& InAdventurerCardDecorationIdList);
    void RequestRemoveFriend(FString ToPlayerId, FString ToCharacterId);
    bool RequestGetCharacterCardInfos(const TArray<FString>& InTargetCharacterIds);
    void RequestCharactersAdventurerCardSend(FString ToPlayerId, FString ToCharacterId);
    void Request_SendLike(const TArray<FLikeSend>& SendLikeList);
    void Request_IsSendLike(const TArray<FSendableLikePlayer>& SendableLikePlayerList);
    void PlayerSearchResultDelete();
    void OnUpdateFriendListDelegate__DelegateSignature(const TArray<FPlayerProfileSummaryData>& PlayerProfileSummaryData);
    void OnSendLikeDelegate__DelegateSignature(const bool bWasSuccessful, const int32 RetCode, const int32 Warning);
    void OnSendableLikeDelegate__DelegateSignature(const bool bWasSuccessful, const int32 RetCode, const bool IsSendableLike);
    void OnRequestCharactersAdventurerCardUpdateDelegate__DelegateSignature(const bool bWasSuccessful, const int32 RetCode);
    void OnRemoveFriendDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnIsGetPlayerShortIdDelegate__DelegateSignature(const bool bWasSuccessful, FString shortId, const int32 RetCode);
    void OnIsGetPlayerSearchListDelegate__DelegateSignature(const bool bWasSuccessful, const TArray<FPlayerProfileSummaryData>& PlayerSearchListData, bool bIsOver, const int32 RetCode);
    void OnIsGetPlayerProfileSummaryDataListDelegate__DelegateSignature(const bool bWasSuccessful, const TArray<FPlayerProfileSummaryData>& PlayerProfileSummaryData);
    void OnIsGetPlayerProfileDetailMenuDataDelegate__DelegateSignature(const bool bWasSuccessful, const FPlayerProfileMenuDetailData& PlayerProfileDetailMenuData, const int32 RetCode);
    void OnIsGetFriendListDelegate__DelegateSignature(const bool bWasSuccessful, const TArray<FPlayerProfileSummaryData>& FriendListData, const int32 MaxCount);
    void OnIsGetContactListDelegate__DelegateSignature(const bool bWasSuccessful, const TArray<FContactListData>& ItemListData, const int32 totalPageNum, const int32 currentPageNum);
    void OnIsGetConsentListDelegate__DelegateSignature(const bool bWasSuccessful, const int32 ApprovalMax, const bool bNoOverride, const TArray<FContactListData>& ItemListData, const int32 RetCode);
    void OnGetEquipItemsForCharactersDelegate__DelegateSignature(const bool bWasSuccessful, const int32 RetCode, const TArray<FBattleMemberLevelSyncInfo>& BattleMemberLevelSyncInfos);
    void OnGetCharacterCardInfosDelegate__DelegateSignature(const bool bWasSuccessful, const int32 RetCode, const TArray<FSBPlayerCharacterCardData>& PlayerCharacterCardDatas);
    void OnCheckTalkPermissionWebAPI__DelegateSignature(const bool bWasSuccessful, const int32 RetCode, const bool TalkSuccess);
    void OnCharactersAdventurerCardSendDelegate__DelegateSignature(const bool bWasSuccessful, const FSendAdventureCardResult SendAdventureCardResult);
    bool IsFriendsToCharacterId(FString CharacterId, const TArray<FPlayerProfileSummaryData>& InFriendList);
    bool IsConcentList();
    TArray<FSendableLikePlayer> GetSendableLikePlayerList();
    void GetPlayerShortIdWebAPI(class ASBPlayerController* InPlayerController, FString InTargetCharacterId);
    TArray<FPlayerProfileSummaryData> GetPlayerSearchResultData_PlayerList();
    bool GetPlayerSearchResultData_IsOver();
    bool GetPlayerSearchResultData();
    void GetPlayerSearchListWebAPI(class ASBPlayerController* InPlayerController, FString PlayerName, FString TargetCharacterShortId, const bool& IsOnlineOnly, const TArray<ESBClassType>& ClassTypeList, const TArray<int32>& TensionTagList);
    void GetPlayerProfileSummaryDataList(class ASBPlayerController* InPlayerController, const TArray<FString>& InTargetCharacterId);
    void GetPlayerProfileDetailMenuDataWebAPI(class ASBPlayerController* InPlayerController, FString InTargetCharacterId);
    FPlayerProfileClassData GetPlayerProfileClassData(FPlayerProfileClassListData ClassListData, const ESBClassType Type);
    bool GetFriendListWebAPI(class ASBPlayerController* InPlayerController);
    TArray<FPlayerProfileSummaryData> GetFriendList();
    void GetEquipItemsForCharacters(const TArray<FBattleMemberInfoSend>& BattleMemberInfoSendList);
    bool GetContactListWebAPI(class ASBPlayerController* InPlayerController, const int32 Page);
    void GetConsentListWebAPI(class ASBPlayerController* InPlayerController);
    void ClientUpdateAdventurerCardComplete(const bool bWasSuccessful, const int32& RetCode);
    void ClientRemoveFriendSend(bool bResult);
    void ClientCharactersAdventurerCardSendComplete(bool bResult, const TArray<FPlayerProfileSummaryData>& InFriendList, FSendAdventureCardResult InSendAdventureCardResult);
    void Client_SendLike(const bool bWasSuccessful, const int32 RetCode, FString CharacterName, const int32 Warning);
    void Client_IsSendLike(const bool bWasSuccessful, const int32 RetCode, const TArray<FSendableLikePlayer>& outSendableLikePlayerList, const bool IsSendableLike);
    void Client_GetEquipItemsForCharacters(const bool bWasSuccessful, const int32 RetCode, const TArray<FBattleMemberLevelSyncInfo>& BattleMemberLevelSyncInfos);
    void Client_AddAdventurerCardDecorationIdList(const TArray<int32>& InAdventurerCardDecorationIdList);
    void CheckTalkPermissionWebAPI(class ASBPlayerController* InPlayerController, FString InTargetUserId, FString InTargetCharacterId);
}; // Size: 0x200

class USBPlayerConditionParamPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBConditionCheckFloatParam> ConditionParamList;                           // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBPlayerConsumeComboAttackSkillController : public USBPlayerSkillController
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBPlayerControllerComponentBase : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)

    FString GetUserId();
    class ASBPlayerState* GetOwningPlayerState();
    class ASBPlayerController* GetOwningPlayerController();
    class ASBPlayerCharacter* GetOwningPlayerCharacter();
    class USBNetworkDataCache* GetNetworkDataCache();
    FString GetCharacterId();
}; // Size: 0xB8

class USBPlayerCraftComponent : public USBPlayerRecepiComponentBase
{
    FSBPlayerCraftComponentOnCompleted_PlayerCraftRequest OnCompleted_PlayerCraftRequest; // 0x00B8 (size: 0x10)
    void OnCompleted_PCCraftRequest(int32 ErrorCode, const bool IsSuccess, const bool IsCritical, FString ItemUniqueId, const int32 TotalAmount, const int32 SaleAmount, const int32 SaleProfits);
    FSBPlayerCraftComponentOnCompleted_MultiCraftRequest OnCompleted_MultiCraftRequest; // 0x00C8 (size: 0x10)
    void OnCompleted_MultiCraft(int32 ErrorCode, const bool IsCritical, const TArray<FString>& ItemUniqueids, int32 CriticalNum, bool isFail, int32 TotalAmount, const TArray<bool>& Criticals, const int32 SaleAmount, const int32 SaleProfits);
    FSBPlayerCraftComponentOnCompleted_RecepiUpdate OnCompleted_RecepiUpdate;         // 0x00D8 (size: 0x10)
    void OnCompleted_RecepiUpdate(int32 RecepiId);
    FSBPlayerCraftComponentOnCompleted_RecepiUnlocked OnCompleted_RecepiUnlocked;     // 0x00E8 (size: 0x10)
    void OnCompleted_UnlockRecepi(int32 ErrorCode, const TArray<FCharacterCraftRecepi>& UnlockedRecepis);

    void SyncUnlockRecipeSet();
    void SyncUnlockRecepi();
    void Server_UnLockRecepis(class ASBPlayerController* InPlayerController, const TArray<int32>& recepiIds);
    void Server_UnLockRecepi(class ASBPlayerController* InPlayerController, const int32 RecepiId);
    void Server_RequestMultiCraft(class ASBPlayerController* InPlayerController, int32 InRecepiId, int32 ConstructionNum, const TArray<int32>& UseToken, int32 StorageNo);
    void Server_PlayerCraftRequest(class ASBPlayerController* InPlayerController, int32 InRecepiId, const TArray<int32>& UseToken, int32 StorageNo);
    void Server_OnCompleteUnlockRecipeSet(const int32 ErrorCode, const TArray<int32>& InAddRecipeSets);
    void Server_OnCompleteUnlockRecepi(const int32 ErrorCode, const TArray<FCharacterCraftRecepi>& InAddRecepi);
    void Server_OnCompletedPlayerCraft(int32 ErrorCode, int32 InRecepiId, const TArray<FOwnItemInfo>& InOutItems, const TArray<FOwnItemInfo>& UsedMaterials, bool IsCritical, const int32 Money, const int32 TotalAmount, const TArray<FSBCharacterToken>& ConsumedTokens, const FOwnItemInfo& SallItem, const int32 SaleProfits);
    void Server_OnCompleted_MultiCraft(int32 ErrorCode, int32 InRecepiId, const TArray<FMultiCraftData>& CraftData, int32 CriticalNum, bool isFail, const int32 Money, const int32 TotalAmount, const TArray<FSBCharacterToken>& ConsumedTokens, const TArray<FOwnItemInfo>& SallItems, const int32 SaleProfits);
    void Recepis_UnlockRequest(const TArray<int32>& InRecepiIds);
    void Recepi_UnlockRequest(const int32 InRecepiId);
    void OnCompleted_UnlockRecepi__DelegateSignature(int32 ErrorCode, const TArray<FCharacterCraftRecepi>& UnlockedRecepis);
    void OnCompleted_RecepiUpdate__DelegateSignature(int32 RecepiId);
    void OnCompleted_PCCraftRequest__DelegateSignature(int32 ErrorCode, const bool IsSuccess, const bool IsCritical, FString ItemUniqueId, const int32 TotalAmount, const int32 SaleAmount, const int32 SaleProfits);
    void OnCompleted_MultiCraft__DelegateSignature(int32 ErrorCode, const bool IsCritical, const TArray<FString>& ItemUniqueids, int32 CriticalNum, bool isFail, int32 TotalAmount, const TArray<bool>& Criticals, const int32 SaleAmount, const int32 SaleProfits);
    bool IsLearnedRecipeSet(int32 InId);
    bool IsLearned(int32 InId);
    TArray<int32> GetPlayerRecipeSetList();
    TArray<FCharacterCraftRecepi> GetPlayerRecepi();
    FCharacterCraftRecepi FindPlayerRecepi(bool& IsExist, const int32 InRecepiId);
    void Craft_RequestPlayerCraft(int32 InRecepiId, const TArray<int32>& UseToken, int32 StorageNo);
    void Craft_RequestMultiCraft(int32 InRecepiId, int32 InConstructionNum, const TArray<int32>& UseToken, int32 StorageNo);
    void Client_SyncRecipeSet(const TArray<int32>& InAddRecipeSet);
    void Client_SyncRecepi(const TArray<FCharacterCraftRecepi>& InAddRecepi);
    void Client_OnCompleteUnlockRecipeSet(const int32 ErrorCode, const TArray<int32>& InAddRecipeSets);
    void Client_OnCompleteUnlockRecepi(const int32 ErrorCode, const TArray<FCharacterCraftRecepi>& InAddRecepi);
    void Client_OnCompletedPlayerCraft(int32 ErrorCode, int32 InRecepiId, const TArray<FOwnItemInfo>& InOutItems, const TArray<FOwnItemInfo>& UsedMaterials, bool IsCritical, const int32 Money, const int32 TotalAmount, const TArray<FSBCharacterToken>& ConsumedTokens, const FOwnItemInfo& SallItem, const int32 SaleProfits);
    void Client_OnCompleted_MultiCraft(int32 ErrorCode, int32 InRecepiId, const TArray<FMultiCraftData>& CraftData, int32 CriticalNum, bool isFail, const int32 Money, const int32 TotalAmount, const TArray<FSBCharacterToken>& ConsumedTokens, const TArray<FOwnItemInfo>& SallItems, const int32 SaleProfits);
}; // Size: 0x118

class USBPlayerDebugComponent : public USBPlayerActorComponent
{
    TWeakObjectPtr<class AActor> Firework;                                            // 0x00D0 (size: 0x8)
    bool bDebugDraw;                                                                  // 0x00D8 (size: 0x1)
    char padding_0[0x5F];                                                             // 0x00D9 (size: 0x5F)
    TArray<FSBDxBattleGameScore> DebugPlayerTotalScoreList;                           // 0x0138 (size: 0x10)
    int32 EnemyGateDestructNum;                                                       // 0x0148 (size: 0x4)
    int32 EnemyBufferDestructNum;                                                     // 0x014C (size: 0x4)

    void SetFirework(class AActor* FireworkPtr);
    void ServerUpdateDebugParam(uint8 ParamType, FSBBattleDebugParam Value);
    void ServerSetDefaultAttackElement(ESBAttribute ElementType, int32 ElementValue, int32 ElementDamage);
    void ServerSendBuildTime(int64 BuildTime);
    void SendClientServerPlayerCollision(const TArray<FVector_NetQuantize>& VecList);
    void SendClientAroundPlayerAndEnemyLocation(const TArray<FVector_NetQuantize>& VecList);
    void RequestSendServerPlayerCollision(const TArray<FName>& SocketNameList);
    void RequestSendServerAroundPlayerAndEnemyLocation(float Radius);
    void RequestPrintBattleEffective();
    class AActor* GetFirework();
    void DbgSendClientServerPlayerStateChange(FString STR);
    void ClientUpdateDebugParam(uint8 ParamType, FSBBattleDebugParam Value);
}; // Size: 0x150

class USBPlayerDecorationComponent : public USBPlayerPropertyComponent
{
    FSBPlayerDecorationComponentOnDecorationDelegate OnDecorationDelegate;            // 0x00B8 (size: 0x10)
    void OnDecorationDelegate(const bool Result, const int32 RetCode);

    TArray<int32> SortIds(const TArray<int32>& DecorationIdList, ESBDecorationListSortType SortType);
    void Request_LoadDecorationList();
    void OnDecorationDelegate__DelegateSignature(const bool Result, const int32 RetCode);
    TArray<int32> GetDecorationList(const ESBAdventureCardDecorationType InDecorationType, const TArray<int32> InHaveList, ESBDecorationListSortType SortType);
    void Client_SetDecorationIdList(const TArray<int32>& InDecorationIdList);
}; // Size: 0xC8

class USBPlayerDefeatEnemyComponent : public USBPlayerPropertyComponent
{
    class USBHttpQuery* HttpQuery;                                                    // 0x00C0 (size: 0x8)
    char padding_0[0x18];                                                             // 0x00C8 (size: 0x18)
    FSBPlayerDefeatEnemyComponentOnSendDefeatEnemyCompleteDelegate OnSendDefeatEnemyCompleteDelegate; // 0x00E0 (size: 0x10)
    void OnSendDefeatEnemyCompleteDelegate(const int32 RetCode, const TArray<FEnemyDeadNotifyInfo>& InInfos);

    void NotifyDefeatEnemy(const FEnemyDeadNotifyInfo& InInfo);
    void ClientOnDefeatEnemy(const TArray<FEnemyDeadNotifyInfo>& InInfos, const TArray<FSBLiquidMemoryInfo>& InLiquidMemoryInfos, bool InIsLiquidMemoryInfoValid, const FSBExtraExpParse& ClassExtraExp, const bool InOpenCommandMenuFlag);
}; // Size: 0xF0

class USBPlayerDodgeSkillController : public USBPlayerSkillController
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBPlayerDungeonComponent : public USBPlayerPropertyComponent
{
    FSBPlayerDungeonComponentOnGetActivateDungeonsDelegate OnGetActivateDungeonsDelegate; // 0x00B8 (size: 0x10)
    void OnGetActivateDungeonsDelegate(const TArray<FName>& OutArray);
    FSBPlayerDungeonComponentOnGetActivatedPublicDungeonsDelegate OnGetActivatedPublicDungeonsDelegate; // 0x00C8 (size: 0x10)
    void OnGetActivatedPublicDungeonsDelegate(const int32 RetCode, const TArray<FString>& OutArray);
    FSBPlayerDungeonComponentOnAddActivatedPublicDungeonsDelegate OnAddActivatedPublicDungeonsDelegate; // 0x00D8 (size: 0x10)
    void OnAddActivatedPublicDungeonsDelegate(const int32 RetCode, bool Result);
    char padding_0[0x18];                                                             // 0x00E8 (size: 0x18)
    FSBPlayerDungeonComponentOnAddActivate OnAddActivate;                             // 0x0100 (size: 0x10)
    void OnAddActivate(FName DungeonId);
    FSBPlayerDungeonComponentOnDungeonClearDelegate OnDungeonClearDelegate;           // 0x0110 (size: 0x10)
    void OnDungeonClearDelegate(const int32 RetCode);
    char padding_1[0x8];                                                              // 0x0120 (size: 0x8)
    FSBPlayerDungeonComponentOnDungeonFailedDelegate OnDungeonFailedDelegate;         // 0x0128 (size: 0x10)
    void OnDungeonFailedDelegate(const int32 RetCode, const ESBGameOver InGameOverType);
    FSBPlayerDungeonComponentOnSelectPendingRewardsDelegate OnSelectPendingRewardsDelegate; // 0x0138 (size: 0x10)
    void OnSelectPendingRewardsDelegate(const int32 RetCode, bool isAccept);
    FSBPlayerDungeonComponentOnAutoLikeSendDelegate OnAutoLikeSendDelegate;           // 0x0148 (size: 0x10)
    void OnAutoLikeSendDelegate(const int32 RetCode);

    void SetNeedNotifyDungeonActivated();
    void ServerSelectPendingRewards(bool acceptBoostReward);
    void ServerOnSelectPendingRewards(int32 InRetCode, bool isAccept, const FSBDungeonClearRewardInfo& DungeonClearRewardInfo, const bool InOpenCommandMenuFlag);
    void ServerOnResponseLog(FString Response);
    void ServerOnDungeonFailedComplete(int32 InRetCode, const FSBDungeonClearRewardInfo& DungeonClearRewardInfo, const ESBGameOver& InGameOverType, const bool InOpenCommandMenuFlag);
    void ServerOnDungeonClearComplete(int32 InRetCode, const FSBDungeonClearRewardInfo& DungeonClearRewardInfo, const bool InOpenCommandMenuFlag);
    void ServerOnAutoLikeSend(int32 InRetCode);
    void ServerDungeonFailed(const ESBGameOver& InGameOverType);
    void ServerDungeonClear(bool IsPartyCheck);
    void ServerAutoLikeSend(const TArray<FSBDungeonClearPartyMemberData>& InPartyMember);
    void ServerAddComplete(const FName& DungeonId, bool bIncomplete);
    void ServerAddActivatedPublicDungeons(const TArray<FString>& ActivatedDungeonIds);
    void ServerAddActivate(const TArray<FName>& DungeonIds, bool bRemove);
    void ServerActivateFromInstanceBattleProvider(class ASBInstanceBattleProvider* InProvider);
    void ServerActivateDungeons();
    void ServerActivatedPublicDungeons();
    void RequestSelectPendingRewards(bool acceptBoostReward);
    void RequestDungeonFailed(const ESBGameOver& InGameOverType);
    void RequestDungeonClear();
    void RequestAutoLikeSend();
    void RequestActivateDungeon(const TArray<FName>& DungeonIds, bool bRemove);
    void OnSelectPendingRewardsDelegate__DelegateSignature(const int32 RetCode, bool isAccept);
    void OnGetActivateDungeonsDelegate__DelegateSignature(const TArray<FName>& OutArray);
    void OnGetActivatedPublicDungeonsDelegate__DelegateSignature(const int32 RetCode, const TArray<FString>& OutArray);
    void OnDungeonFailedDelegate__DelegateSignature(const int32 RetCode, const ESBGameOver InGameOverType);
    void OnDungeonClearDelegate__DelegateSignature(const int32 RetCode);
    void OnClearConditionComplete(const FName& InDungeonName);
    void OnClearConditionChangeStep(const int32 InStepNum);
    void OnAutoLikeSendDelegate__DelegateSignature(const int32 RetCode);
    void OnAddActivatedPublicDungeonsDelegate__DelegateSignature(const int32 RetCode, bool Result);
    void OnAddActivate__DelegateSignature(FName DungeonId);
    bool IsCompletedDungeon(FName DungeonId);
    bool IsActivatedDungeon(FName DungeonId);
    int32 GetPassageStep(FName DungeonId);
    ESBDungeonCompleteType GetCompleteStateType(FName DungeonId);
    int32 GetCompleteNum(FName DungeonId);
    void GetActivateMapsOnDungeonComplete(const FName& MapId, TArray<FName>& MapIdList);
    void GetActivateDungeonList(TArray<FName>& OutArray);
    void GetActivatedPublicDungeons();
    void ClientOnSelectPendingRewards(int32 InRetCode, bool isAccept, const FSBDungeonClearRewardInfo& DungeonClearRewardInfo, const bool InOpenCommandMenuFlag);
    void ClientOnSaveComplete(const TArray<FSBDungeonCompleteState>& InCompleteStates);
    void ClientOnResponseLog(FString Response);
    void ClientOnDungeonFailedComplete(int32 InRetCode, const FSBDungeonClearRewardInfo& DungeonClearRewardInfo, const ESBGameOver& InGameOverType, const bool InOpenCommandMenuFlag);
    void ClientOnDungeonClearComplete(int32 InRetCode, const FSBDungeonClearRewardInfo& DungeonClearRewardInfo, const bool InOpenCommandMenuFlag);
    void ClientOnAutoLikeSend(int32 InRetCode);
    void ClientGetActivatedPublicDungeons(int32 RetCode, const TArray<FString>& DngIds);
    void ClientAddActivatedPublicDungeons(int32 RetCode, bool Result);
    void ClientActivateDungeons(const TArray<FName>& DungeonIds);
    void AddActivatedPublicDungeons(const TArray<FString>& ActivatedDungeonIds);
    void ActivateDungeons();
}; // Size: 0x1B8

class USBPlayerDxBattleComponent : public USBPlayerPropertyComponent
{
    FSBPlayerDxBattleComponentOnPlayerDxBattleOccurringDelegete OnPlayerDxBattleOccurringDelegete; // 0x00B8 (size: 0x10)
    void OnPlayerDxBattleOccurringDelegete(FString InMapId, FString InQuestName);

    void Request_DxBattleOccurringInfo(FString InMapId, FString InQuestName);
    void OnPlayerDxBattleOccurringDelegete__DelegateSignature(FString InMapId, FString InQuestName);
    void Client_DxBattleOccurringInfo(FString InMapId, FString InQuestName);
}; // Size: 0xC8

class USBPlayerEGaugeWidget : public USBPlayerGaugeBaseWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)

    void OnUpdate();
}; // Size: 0x280

class USBPlayerEmoteComponent : public USBPlayerPropertyComponent
{
    FSBPlayerEmoteComponentOnUnlockEmoteDelegate OnUnlockEmoteDelegate;               // 0x00B8 (size: 0x10)
    void OnUnlockEmoteDelegate(const bool bWasSuccessful);
    FSBPlayerEmoteComponentOnValidEmoteDelegate OnValidEmoteDelegate;                 // 0x00C8 (size: 0x10)
    void OnValidEmoteDelegate(bool bValid, int32 EmoteId);
    TArray<FString> UnlockEmoteList;                                                  // 0x00D8 (size: 0x10)

    void Server_RequestUnlockEmote(const TArray<int32>& EmoteIds);
    void Server_CheckValidEmote(int32 EmoteId);
    void RequestUnlockEmote(const TArray<int32>& EmoteIds);
    void OnValidEmoteDelegate__DelegateSignature(bool bValid, int32 EmoteId);
    void OnUnlockEmoteDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnRep_UnlockEmoteData();
    bool IsPlayerEmotePossession(int32 EmoteId);
    bool IsLimitedTimeEmote(int32 EmoteId);
    TArray<FString> GetUnlockEmoteData_LimitedTimeOnly(int32 GroupId);
    TArray<FString> GetUnlockEmoteData_LimitedTimeExcluding();
    TArray<FString> GetUnlockEmoteData();
    TArray<FSBLimitedTimeGroupInfo> GetLimitedTimeGroupInfo();
    void Client_CheckValidEmoteResult(bool IsValid, const int32 EmoteId);
    void CheckValidEmote(int32 EmoteId);
}; // Size: 0xE8

class USBPlayerEnemyStepJumpSkillController : public USBPlayerSkillController
{
    char padding_0[0xA8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xA8

class USBPlayerEnemyStepJumpSkillInfo : public USBSkillInfoClass
{
    float XYLaunchAmount;                                                             // 0x02A0 (size: 0x4)
    float SheatheZLaunchAmount;                                                       // 0x02A4 (size: 0x4)
    float UnsheatheZLaunchAmount;                                                     // 0x02A8 (size: 0x4)
    float OverrideGravityScale;                                                       // 0x02AC (size: 0x4)
    float OverrideAirControl;                                                         // 0x02B0 (size: 0x4)
    float OverrideAirControlBoostMultiplier;                                          // 0x02B4 (size: 0x4)
    float ConsumeStaminaAmount;                                                       // 0x02B8 (size: 0x4)

}; // Size: 0x2C0

class USBPlayerEngramCannonComponent : public USBPlayerActorComponent
{
    FVector GetOnLocationOffset;                                                      // 0x00D4 (size: 0xC)
    FVector GetOffLocation;                                                           // 0x00E0 (size: 0xC)
    float MouseInputThreshold;                                                        // 0x00EC (size: 0x4)
    float EngramCannonRotateThreshold;                                                // 0x00F0 (size: 0x4)
    char padding_0[0x14];                                                             // 0x00F4 (size: 0x14)
    float PlayGetOnEffectWait;                                                        // 0x0108 (size: 0x4)
    float PlayGetOffEffectWait_Shot;                                                  // 0x010C (size: 0x4)
    float PlayGetOffEffectWait_NonShot;                                               // 0x0110 (size: 0x4)
    float GetOnEffectTime;                                                            // 0x0114 (size: 0x4)
    float GetOffEffectTime;                                                           // 0x0118 (size: 0x4)
    char padding_1[0xC];                                                              // 0x011C (size: 0xC)
    TSubclassOf<class UCameraShakeBase> DamageCameraShake;                            // 0x0128 (size: 0x8)
    FSBPlayerEngramCannonComponentOnTakeDamageDelegate OnTakeDamageDelegate;          // 0x0130 (size: 0x10)
    void OnTakeDamageDelegate();
    FSBPlayerEngramCannonComponentOnShotDelegate OnShotDelegate;                      // 0x0140 (size: 0x10)
    void OnShotDelegate();
    FVector NamePlateRelativeLocation;                                                // 0x0150 (size: 0xC)

    void SetEngramCannonRotate_Server(FRotator InEngramCannonRotate);
    void SetEngramCannonRotate_Multicast(FRotator InEngramCannonRotate);
    void RequestShot_Server(FRotator InEngramCannonRotate);
    void RequestShot_Multicast(FRotator InEngramCannonRotate);
    void RequestGetOn_Server(class ASBEngramCannon* InEngramCannonActor);
    void RequestGetOn_Multicast(class ASBEngramCannon* InEngramCannonActor);
    void RequestGetOn(class ASBEngramCannon* InEngramCannonActor);
    void RequestGetOff_Server(bool bSuccessed);
    void RequestGetOff_Multicast(bool bSuccessed, ESBEngramCannonStatus EngramCannonStatus);
    void RequestGetOff(bool bSuccessed);
    void OnTakeDamageDelegate__DelegateSignature();
    void OnShotDelegate__DelegateSignature();
    void OnDelegated_RequestGetOff();
    bool IsShot();
    bool IsRotateLimit(ESBEngramCannonRotateDirection Direction, float Tolerance);
    void InitOnBoard_BP();
    void InitGetOff_BP();
}; // Size: 0x160

class USBPlayerExpeditionComponent : public USBPlayerPropertyComponent
{
    FSBPlayerExpeditionComponentOnCompleted_GetListRequest OnCompleted_GetListRequest; // 0x00B8 (size: 0x10)
    void OnCompleted_Default(bool WasSuccessful, int32 ErrorCode);
    FSBPlayerExpeditionComponentOnCompleted_ExpeditionStartRequest OnCompleted_ExpeditionStartRequest; // 0x00C8 (size: 0x10)
    void OnCompleted_Default(bool WasSuccessful, int32 ErrorCode);
    FSBPlayerExpeditionComponentOnCompleted_ExpeditionImmediateRequest OnCompleted_ExpeditionImmediateRequest; // 0x00D8 (size: 0x10)
    void OnCompleted_Default(bool WasSuccessful, int32 ErrorCode);
    FSBPlayerExpeditionComponentOnCompleted_ExpeditionGetRewardRequest OnCompleted_ExpeditionGetRewardRequest; // 0x00E8 (size: 0x10)
    void OnCompleted_Default(bool WasSuccessful, int32 ErrorCode);
    FSBPlayerExpeditionComponentOnCompleted_ExpeditionOpenRareRequest OnCompleted_ExpeditionOpenRareRequest; // 0x00F8 (size: 0x10)
    void OnCompleted_Default(bool WasSuccessful, int32 ErrorCode);
    FSBPlayerExpeditionComponentOnCompleted_ExpeditionCheckRewardRequest OnCompleted_ExpeditionCheckRewardRequest; // 0x0108 (size: 0x10)
    void OnCompleted_Default(bool WasSuccessful, int32 ErrorCode);
    FSBPlayerExpeditionComponentOnCompleted_ExpeditionEndCheckRequest OnCompleted_ExpeditionEndCheckRequest; // 0x0118 (size: 0x10)
    void OnCompleted_EndCheck(bool WasSuccessful, int32 ErrorCode, int32 IdCount);
    TArray<FString> TempIdList;                                                       // 0x0128 (size: 0x10)
    TArray<FString> TempNameList;                                                     // 0x0138 (size: 0x10)
    int32 AreaDataSplitCount;                                                         // 0x0148 (size: 0x4)
    char padding_0[0x4];                                                              // 0x014C (size: 0x4)
    TArray<FSBFang_expeditionSplitData> AreaDataSplitData;                            // 0x0150 (size: 0x10)

    void UpdateUsingFangList();
    void Server_OnCompleted_GetListRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, const TArray<FSBFang_expeditionSplitData>& SplitData);
    void Server_OnCompleted_ExpeditionStartRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, const TArray<int32>& UseTokenIds);
    void Server_OnCompleted_ExpeditionOpenRareRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, const TArray<FSBFang_expeditionSplitData>& SplitData);
    void Server_OnCompleted_ExpeditionImmediateRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, FString AreaId);
    void Server_OnCompleted_ExpeditionGetRewardRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, const FSBMailRewardData& RewardData, const TArray<FSBFang_expeditionSplitData>& SplitData);
    void Server_OnCompleted_ExpeditionEndCheckRequest(int32 ReturnCode, bool bWasSuccessful, const TArray<FString>& IDList, const TArray<FString>& NameList);
    void Server_OnCompleted_ExpeditionCheckRewardRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, const TArray<FSBFang_expeditionSplitData>& SplitData);
    void Server_GetListRequest(class ASBPlayerController* InPlayerController);
    void Server_ExpeditionStartRequest(class ASBPlayerController* InPlayerController, FString AreaId, const TArray<FString>& MountUniqueIds, FString TimeId, const TArray<int32>& UseTokenIds);
    void Server_ExpeditionOpenRareRequest(class ASBPlayerController* InPlayerController);
    void Server_ExpeditionImmediateRequest(class ASBPlayerController* InPlayerController, FString AreaId, bool UseToken);
    void Server_ExpeditionGetRewardRequest(class ASBPlayerController* InPlayerController, FString AreaId);
    void Server_ExpeditionEndCheckRequest(class ASBPlayerController* InPlayerController);
    void Server_ExpeditionCheckRewardRequest(class ASBPlayerController* InPlayerController, FString ExpeditionId);
    void PushLogMessage(const FText& Message);
    void OnCompleted_EndCheck__DelegateSignature(bool WasSuccessful, int32 ErrorCode, int32 IdCount);
    void OnCompleted_Default__DelegateSignature(bool WasSuccessful, int32 ErrorCode);
    void GetListRequest();
    void GetExpeditionRewardData(FSBMailRewardData& RewardData);
    void GetExpeditionData(FSBFang_expeditionData& OutData);
    void GetEndCheckData(TArray<FString>& IDList, TArray<FString>& NameList);
    void ExpeditionStartRequest(FString AreaId, TArray<FString> MountUniqueIds, FString TimeId, TArray<int32> UseTokenIds);
    void ExpeditionOpenRareRequest();
    void ExpeditionImmediateRequest(FString AreaId, bool UseToken);
    void ExpeditionGetRewardRequest(FString AreaId);
    void ExpeditionEndCheckRequest();
    void ExpeditionCheckRewardRequest(FString ExpeditionId);
    void Client_OnCompleted_GetListRequest_Split(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionSplitData& SplitData);
    void Client_OnCompleted_GetListRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, int32 SplitCount);
    void Client_OnCompleted_ExpeditionStartRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, const TArray<int32>& UseTokenIds);
    void Client_OnCompleted_ExpeditionOpenRareRequest_Split(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionSplitData& SplitData);
    void Client_OnCompleted_ExpeditionOpenRareRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, int32 SplitCount);
    void Client_OnCompleted_ExpeditionImmediateRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, FString AreaId);
    void Client_OnCompleted_ExpeditionGetRewardRequest_Split(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionSplitData& SplitData);
    void Client_OnCompleted_ExpeditionGetRewardRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, const FSBMailRewardData& RewardData, int32 SplitCount);
    void Client_OnCompleted_ExpeditionEndCheckRequest(int32 ReturnCode, bool bWasSuccessful, const TArray<FString>& IDList, const TArray<FString>& NameList);
    void Client_OnCompleted_ExpeditionCheckRewardRequest_Split(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionSplitData& SplitData);
    void Client_OnCompleted_ExpeditionCheckRewardRequest(int32 ReturnCode, bool bWasSuccessful, const FSBFang_expeditionData& Fang_expeditionData, int32 SplitCount);
}; // Size: 0x160

class USBPlayerFacialAnimInstance : public USBFacialAnimInstance
{
    class UASAnimationSet* AST_M000;                                                  // 0x0638 (size: 0x8)
    class UASAnimationSet* AST_F000;                                                  // 0x0640 (size: 0x8)
    TMap<class FName, class UPoseAsset*> PA_M000_Mouth;                               // 0x0648 (size: 0x50)
    TMap<class FName, class UPoseAsset*> PA_M000_Brow;                                // 0x0698 (size: 0x50)
    TMap<class FName, class UPoseAsset*> PA_M000_Eye;                                 // 0x06E8 (size: 0x50)
    TMap<class FName, class UPoseAsset*> PA_F000_Mouth;                               // 0x0738 (size: 0x50)
    TMap<class FName, class UPoseAsset*> PA_F000_Brow;                                // 0x0788 (size: 0x50)
    TMap<class FName, class UPoseAsset*> PA_F000_Eye;                                 // 0x07D8 (size: 0x50)
    TArray<class UPoseAsset*> PA_Adj;                                                 // 0x0828 (size: 0x10)
    TArray<class UPoseAsset*> PA_Eyelid;                                              // 0x0838 (size: 0x10)

}; // Size: 0x850

class USBPlayerFieldActorPickupComponent : public USBPlayerPropertyComponent
{
    class USBHttpQuery* HttpQuery;                                                    // 0x00C0 (size: 0x8)
    char padding_0[0x48];                                                             // 0x00C8 (size: 0x48)
    FSBPlayerFieldActorPickupComponentOnSendFieldActorPickupCompleteDelegate OnSendFieldActorPickupCompleteDelegate; // 0x0110 (size: 0x10)
    void OnSendFieldActorPickupCompleteDelegate(const int32 RetCode, const FFieldActorPickupNotifyInfo& InInfos);
    FSBPlayerFieldActorPickupComponentOnSendSaveBuffPointCompleteDelegate OnSendSaveBuffPointCompleteDelegate; // 0x0120 (size: 0x10)
    void OnSendSaveBuffPointCompleteDelegate(const int32 RetCode, const FFieldActorBuffPointNotifyInfo& InInfos);

    void NotifyResultSetFlagFieldActor(const TArray<FString>& TagLists);
    void NotifyInteractedFreeBuffPoint(const TArray<FFieldActorBuffPointNotifyInfo>& InInfo, ESBFieldActorInteractPoint InInteractPoint);
    void NotifyInteractedFieldActor(const TArray<FFieldActorPickupNotifyInfo>& InInfo, ESBFieldActorInteractPoint InInteractPoint);
    int32 GetStackableNum(class ASBPlayerController* PlayerController, const EItemType InItemType, const int32 InItemIndex, const bool bInInventory);
    void ClientInteractedFreeBuffPoint(const FFieldActorBuffPointNotifyInfo& InInfo);
    void ClientInteractedFieldActor(const FFieldActorPickupNotifyInfo& InInfo, ESBFieldActorInteractPoint OnInteractPoint);
}; // Size: 0x138

class USBPlayerFishingComponent : public USBPlayerActorComponent
{
    EPlayerFishingState PlayerFishingState;                                           // 0x00D8 (size: 0x1)
    bool IsBigFish;                                                                   // 0x00D9 (size: 0x1)
    char padding_0[0x6];                                                              // 0x00DA (size: 0x6)
    class UAkAudioEvent* PlayReelEvent;                                               // 0x00E0 (size: 0x8)
    class UAkAudioEvent* StopReelEvent;                                               // 0x00E8 (size: 0x8)

    void SetPlayerFishingState(EPlayerFishingState State);
    void SetFishingRodDirection(float Direction);
    void SetFishingGame(class ASBFishingGame* InFishingGame);
    void ServerSetPlayerFishingState(EPlayerFishingState State);
    void ServerSetFishingDebugParam(class ASBFishingGame* InFishingGame, const FSBFishDebugParam& FishDebugParam);
    void ServerChangeFishingState(class ASBFishingGame* InFishingGame, const ESBFishingGameState InNewState, FString InOption);
    void RequestSpawnFishingRod(const FName& AssetName);
    void MulticastSetPlayerFishingSuccess(bool InIsBigFish);
    void MulticastSetPlayerFishingState(EPlayerFishingState State);
    class USBWeaponFishingRodComponent* GetWeaponFishingRodComponent();
    bool GetIsBigFish();
    class ASBWeapon* GetFishingRodWeapon();
    float GetFishingRodDirection();
    EPlayerFishingState GetFishingPlayerState();
    class ASBFishingGame* GetFishingGame();
    void ClientStartFishing(class ASBFishingGame* InFishingGame, int32 InPositionId);
    void ClientShowResult(bool Success, FName FishId, int32 FishItemId, float FishLength, int32 ItemAmount, bool NewFish, bool NewRecord, int32 RetCode);
    void ClientNoVacantEnd(class ASBFishingGame* InFishingGame);
    void ClientInitFish(const FName InFishId, float InsRarity);
    void Client_FishingResultItemUpdate(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
}; // Size: 0x118

class USBPlayerFmComponent : public USBPlayerControllerComponentBase
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBPlayerFootprintComponent : public USBFootprintComponent
{
    float m_FootprintParticleScaleFemale;                                             // 0x0480 (size: 0x4)
    float m_FootprintDecalSizeFemale;                                                 // 0x0484 (size: 0x4)

    float GetParticleScale();
}; // Size: 0x488

class USBPlayerForecastSkillController : public USBPlayerSkillController
{
    char padding_0[0x48];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x48

class USBPlayerFreeBuffPointComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerFreeBuffPointComponentOnFreeBuffPointChangeStateNPC OnFreeBuffPointChangeStateNPC; // 0x00D0 (size: 0x10)
    void OnFreeBuffPointChangeStateNPC();
    char padding_0[0x28];                                                             // 0x00E0 (size: 0x28)
    class ASBFieldActorFreeBuffPoint* FieldFreeBuffPointActor;                        // 0x0108 (size: 0x8)
    char padding_1[0x8];                                                              // 0x0110 (size: 0x8)
    FDateTime RequestTime;                                                            // 0x0118 (size: 0x8)
    char padding_2[0x18];                                                             // 0x0120 (size: 0x18)
    TArray<ESBFreeBuffPointType> LotBuffTypes;                                        // 0x0138 (size: 0x10)
    char padding_3[0x18];                                                             // 0x0148 (size: 0x18)
    TArray<FSBFreeBuffPlayerBuffTimeInfo> PlayerBuffTimeInfoLists;                    // 0x0160 (size: 0x10)
    class USBHttpQuery* HttpQuery;                                                    // 0x0170 (size: 0x8)
    class UDataTable* BuffCheckDataTable;                                             // 0x0178 (size: 0x8)

    void SpawnFreeBuffPoint(int32 FreeBuffPointId, ESBFreeBuffPointType Type, ESBFreeBuffPointView BuffPointView);
    void SetRespawnBaseSecondTime(int32 ChangeRespawnBaseSecondTime);
    void ServerWebAPIBuffForMap(bool bRemove);
    void ServerUpdateRespawnTime(const FSBFreeBuffPointRespawnInfo& RespawnInfo, const TArray<FString>& FreeBuffPointTag, bool IsUpdateRespawn);
    void ServerUpdateActivateInfo(bool DebugView);
    void ServerSpawnFreeBuffPoint(FString ClassName, int32 FreeBuffPointId, ESBFreeBuffPointType Type, ESBFreeBuffPointView BuffPointView);
    void ServerSetBuffCheckDataTable(class UDataTable* DataTable);
    void ServerEntryFreeBuffPoint(FString ObjectId, const ESBFreeBuffPointView BuffPointView, const class UDataTable* DataTable);
    void RequestRegistBuffTable(class UDataTable* DataTable);
    void RequestEntryFreeBuffPoint(class AActor* Actor, const class UDataTable* DataTable);
    void OnWebAPIFinished(int32 InRetCode, FFieldActorBuffPointNotifyInfo BuffPointInfo);
    void OnFreeBuffPointChangeStateNPC__DelegateSignature();
    TArray<FSBFreeBuffPlayerBuffTimeInfo> GetFreeBuffPlayerBuffTimeInfoLists();
    class UDataTable* GetBuffCheckDataTable();
    void DebugDrawFreeBuffPointInfo(bool bEnable);
    void DebugDrawFreeBuffActivateInfo(bool bEnable);
    void ClientRelocationFreeBuffPoint(const TArray<FSBFreeBuffPointEntryInfo>& ObjectIds);
    void ClientNotifyMessage(FString Message, FString FreeBuffPointTag, int32 FreeBuffPointId);
    void ClientInteractFreeBuffPoint(ESBFreeBuffPointLotResult Result, FString ObjectId, int32 RetCode, const TArray<ESBFreeBuffPointType>& InLotBuffTypes);
    void ClientDebugDrawActivateInfo(const TArray<FSBFreeBuffPlayerBuffTimeInfo>& BuffTimeInfoLists);
    void ClientActivateInfo(const TArray<FSBFreeBuffPlayerBuffTimeInfo>& BuffTimeInfoLists);
}; // Size: 0x188

class USBPlayerFriendComponent : public USBPlayerPropertyComponent
{
    FSBPlayerFriendComponentOnFollowStateChanged OnFollowStateChanged;                // 0x00B8 (size: 0x10)
    void OnFollowStateChanged();
    FSBPlayerFriendComponentOnAddFavoritePlayerDelegate OnAddFavoritePlayerDelegate;  // 0x00C8 (size: 0x10)
    void OnAddFavoritePlayerDelegate(const bool bWasSuccessful, const int32 RetCode);
    FSBPlayerFriendComponentOnRemoveFavoritePlayerDelegate OnRemoveFavoritePlayerDelegate; // 0x00D8 (size: 0x10)
    void OnRemoveFavoritePlayerDelegate(const bool bWasSuccessful);
    FSBPlayerFriendComponentOnAddBlackListPlayerDelegate OnAddBlackListPlayerDelegate; // 0x00E8 (size: 0x10)
    void OnAddBlackListPlayerDelegate(const bool bWasSuccessful);
    FSBPlayerFriendComponentOnRemoveBlackListPlayerDelegate OnRemoveBlackListPlayerDelegate; // 0x00F8 (size: 0x10)
    void OnRemoveBlackListPlayerDelegate(const bool bWasSuccessful);
    FSBPlayerFriendComponentOnGetBlackListDataDelegate OnGetBlackListDataDelegate;    // 0x0108 (size: 0x10)
    void OnGetBlackListDataDelegate(const bool bWasSuccessful, const TArray<FPlayerProfileSummaryData>& CharacterName, const int32 totalPageNum, const int32 currentPageNum);

    void ServerUnFollowPlayer(FString CharacterId);
    void ServerRemoveBlackListPlayer(FString CharacterId);
    void ServerFollowPlayer(FString CharacterId);
    void ServerAddBlackListPlayer(FString CharacterId);
    void RequestUnFollowPlayer(FString CharacterId, FRequestUnFollowPlayerCompleteDelegate CompleteDelegate);
    void RequestRemoveFavoritePlayer(FString CharacterId);
    void RequestRemoveBlackListPlayer(FString CharacterId);
    void RequestGetBlackListData(const int32 Page);
    void RequestFollowPlayer(FString CharacterId, FRequestFollowPlayerCompleteDelegate CompleteDelegate);
    void RequestAddFavoritePlayer(FString CharacterId);
    void RequestAddBlackListPlayer(FString CharacterId);
    void OnRemoveFavoritePlayerDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnRemoveBlackListPlayerDelegate__DelegateSignature(const bool bWasSuccessful);
    void OnGetBlackListDataDelegate__DelegateSignature(const bool bWasSuccessful, const TArray<FPlayerProfileSummaryData>& CharacterName, const int32 totalPageNum, const int32 currentPageNum);
    void OnAddFavoritePlayerDelegate__DelegateSignature(const bool bWasSuccessful, const int32 RetCode);
    void OnAddBlackListPlayerDelegate__DelegateSignature(const bool bWasSuccessful);
    bool IsRemoveBlackListDelegate();
    bool IsFollowed(FString CharacterId);
    bool IsFollow(FString CharacterId);
    bool IsBlackListPlayer(FString CharacterId);
    bool IsAddBlackListDelegate();
    ESBFollowStatusType GetFollowStatus(FString CharacterId);
    void GetBlackListPlayer(TArray<FString>& List);
    void ClientUnFollowPlayerComplete(FString CharacterId, ESBFollowStatusType FollowStatus, bool bResult);
    void ClientRemoveBlackListPlayerComplete(FString CharacterId, bool bResult);
    void ClientFollowPlayerComplete(FString CharacterId, FString CharacterName, ESBFollowStatusType FollowStatus, bool bResult, const int32 RetCode);
    void ClientAddBlackListPlayerComplete(FString CharacterId, bool bResult);
}; // Size: 0x1D8

class USBPlayerGatherPointComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerGatherPointComponentOnFiledGatherPointLotDelegete OnFiledGatherPointLotDelegete; // 0x00B8 (size: 0x10)
    void OnFiledGatherPointLotDelegete(ESBGatherPointLotResult Result, FString ObjectId, const TArray<FGatherPointLotResult>& LotResults);
    FSBPlayerGatherPointComponentOnGatherPointEnableDelegete OnGatherPointEnableDelegete; // 0x00C8 (size: 0x10)
    void OnGatherPointEnableDelegete(const bool IsElable);
    char padding_0[0x58];                                                             // 0x00D8 (size: 0x58)
    FDateTime RequestTime;                                                            // 0x0130 (size: 0x8)

    void UpdateRespawnRequestTime();
    void SpawnGatherPoint(int32 GatherPointId, ESBTreasureBoxRarity Rarity);
    void SimulateOpenGatherPoint(int32 TreasureId, int32 OpenCount);
    void SetRespawnBaseSecondTime(int32 ChangeRespawnBaseSecondTime);
    void SetArrangementGatherPoint(TSubclassOf<class ASBGatherPointSpot> DropGatherSpotClass, const FTransform InTransform, int32 InTreasureItemId, FString TagName);
    void ServerUpdateRespawnTime(const FSBGatherPointRespawnInfo& RespawnInfo, const TArray<FString>& GatherPointTag, bool IsUpdateRespawn);
    void ServerSpawnGatherPoint(FString ClassName, int32 GatherPointId, ESBTreasureBoxRarity Rarity);
    void ServerSimulateOpenGatherPoint(int32 GatherPointId, int32 OpenCount);
    void ServerEntryGatherPoint(FString ObjectId, FString GatherTag);
    bool RequestSBGatherPointEntryList();
    void RequestEntryGatherPoint(class AActor* Actor);
    void OnGatherPointEnableDelegete__DelegateSignature(const bool IsElable);
    void OnFiledGatherPointLotDelegete__DelegateSignature(ESBGatherPointLotResult Result, FString ObjectId, const TArray<FGatherPointLotResult>& LotResults);
    void OnAddItemFinished(int32 InRetCode, const TArray<FSBDiffItemInfo>& AddItemDatas, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    int32 GetLotBonusProbabilityNum();
    float GetGatheringMotionReducedTime(class ASBFieldActorGatherPoint* GatherPointActor);
    int32 GetGatheringDropUpNum(class ASBFieldActorGatherPoint* GatherPointActor);
    float GetGatherAddLottery(class ASBFieldActorGatherPoint* GatherPointActor);
    void DebugDrawGatherPointInfo(bool bEnable);
    void ClientSimulateOpenGatherPoint(ESBGatherPointLotResult Result, int32 GatherPointId, const TArray<FSBGatherPointLotSimulateResult>& Results);
    void ClientRelocationGatherPoint(const TArray<FSBGatherPointEntryInfo>& ObjectIds);
    void ClientNotifyMessage(FString Message, FString GatherPointTag, int32 GatherPointId);
    void ClientInteractGatherPoint(ESBGatherPointLotResult Result, FString ObjectId, FString GatherTag, const TArray<FGatherPointLotResult>& LotResults, int32 RetCode, bool IsBonusAdd);
}; // Size: 0x150

class USBPlayerGaugeBaseWidget : public UUserWidget
{
    bool bGaugeIn;                                                                    // 0x0278 (size: 0x1)
    bool bShowAlwaysHUD;                                                              // 0x0279 (size: 0x1)
    bool IsEditMode;                                                                  // 0x027A (size: 0x1)

    void OnInAnimation(bool bForward);
}; // Size: 0x280

class USBPlayerGuardComponent : public USBGuardComponent
{
    TArray<FSBConditionCheckIntParam> MaxShieldDurabilityModifyList;                  // 0x0448 (size: 0x10)
    char padding_0[0x8];                                                              // 0x0458 (size: 0x8)
    bool bRenewDurabilityByTime;                                                      // 0x0460 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0461 (size: 0x3)
    float RenewDurabilityTime;                                                        // 0x0464 (size: 0x4)
    TArray<FSBConditionCheckIntParam> RenewTimeModifyList;                            // 0x0468 (size: 0x10)
    float RenewDurabilityBreakTime;                                                   // 0x0478 (size: 0x4)
    char padding_2[0x4];                                                              // 0x047C (size: 0x4)
    TArray<FSBConditionCheckIntParam> RenewBreakTimeModifyList;                       // 0x0480 (size: 0x10)
    float RenewDurabilityStartTime;                                                   // 0x0490 (size: 0x4)
    char padding_3[0x14];                                                             // 0x0494 (size: 0x14)
    FVector_NetRoughDirection m_ReplicatedGuardDirection;                             // 0x04A8 (size: 0xC)
    char padding_4[0x4];                                                              // 0x04B4 (size: 0x4)
    float m_MinGuardTime;                                                             // 0x04B8 (size: 0x4)
    char padding_5[0x4];                                                              // 0x04BC (size: 0x4)
    TArray<FSBPlayerEndGuardBreakStatusAilment> EndGuardBreakStatusAilmentList;       // 0x04C0 (size: 0x10)

    void ServerSetGuardDirection(const FVector_NetRoughDirection& Direction);
    void ServerSetGuard(bool InIsGuardActive);
    bool IsGuardedMinTime();
}; // Size: 0x4D8

class USBPlayerGuardSkillController : public USBPlayerSkillController
{
    FSBPlayingEffect m_PlayingGuardEffectList;                                        // 0x0090 (size: 0x320)

}; // Size: 0x3B0

class USBPlayerGuildComponent : public USBPlayerPropertyComponent
{
    FString SearchKeyWord;                                                            // 0x00B8 (size: 0x10)
    TArray<FGuildData> GuildLists;                                                    // 0x00C8 (size: 0x10)
    TArray<FGuildEntryData> GuildEntryList;                                           // 0x00D8 (size: 0x10)
    TArray<FGuildMemberData> GuildInviteMemberList;                                   // 0x00E8 (size: 0x10)
    TArray<FGuildMemberData> GuildMemberList;                                         // 0x00F8 (size: 0x10)
    TArray<FGuildActivity> GuildActivity;                                             // 0x0108 (size: 0x10)
    TArray<FGuildEntryData> PlayerEntryList;                                          // 0x0118 (size: 0x10)
    TArray<FGuildEntryData> PlayerInviteList;                                         // 0x0128 (size: 0x10)
    bool bHasEntries;                                                                 // 0x0138 (size: 0x1)
    bool bHasInvitations;                                                             // 0x0139 (size: 0x1)
    bool bHasNewMember;                                                               // 0x013A (size: 0x1)
    char padding_0[0x5];                                                              // 0x013B (size: 0x5)
    FGuildData GuildData;                                                             // 0x0140 (size: 0xB8)
    FGuildData_CS GuildData_CS;                                                       // 0x01F8 (size: 0x88)
    FGuildData GuildDetailData;                                                       // 0x0280 (size: 0xB8)
    FGuildMemberData MemberData;                                                      // 0x0338 (size: 0xD8)
    FGuildRepData RepData;                                                            // 0x0410 (size: 0x58)
    FSBPlayerGuildComponentOnCompletedGuildOrganized OnCompletedGuildOrganized;       // 0x0468 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedGuildEntry OnCompletedGuildEntry;               // 0x0478 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedAcceptMember OnCompletedAcceptMember;           // 0x0488 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedDenyMember OnCompletedDenyMember;               // 0x0498 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedWithDraw OnCompletedWithDraw;                   // 0x04A8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedChangeRoll OnCompletedChangeRoll;               // 0x04B8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedDissolution OnCompletedDissolution;             // 0x04C8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedChangeAcceptType OnCompletedChangeAcceptType;   // 0x04D8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedChangeGuildName OnCompletedChangeGuildName;     // 0x04E8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedCancelEntry OnCompletedCancelEntry;             // 0x04F8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedInvite OnCompletedInvite;                       // 0x0508 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedInviteArraignment OnCompletedInviteArraignment; // 0x0518 (size: 0x10)
    void OnCompletedInviteAssignment(const int32 RetCode, bool isAccept, FString InEntryId);
    FSBPlayerGuildComponentOnCompletedList OnCompletedList;                           // 0x0528 (size: 0x10)
    void OnCompletedGetGuildList(const int32 RetCode, const int32 MaxPage);
    FSBPlayerGuildComponentOnCompletedGGetEntryList OnCompletedGGetEntryList;         // 0x0538 (size: 0x10)
    void OnCompletedGetGuildEntryList(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedGetInviteList OnCompletedGetInviteList;         // 0x0548 (size: 0x10)
    void OnCompletedGetGuildEntryList(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedGetEntries OnCompletedGetEntries;               // 0x0558 (size: 0x10)
    void OnCompletedGetGuildEntryList(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedGuildInviteMemberList OnCompletedGuildInviteMemberList; // 0x0568 (size: 0x10)
    void OnCompletedGetGuildInviteMemberList(const int32 RetCode);
    FSBPlayerGuildComponentOnCompleteGuildCancelInvitation OnCompleteGuildCancelInvitation; // 0x0578 (size: 0x10)
    void OnCompletedGetGuildInviteMemberList(const int32 RetCode);
    FSBPlayerGuildComponentOnCompletedGuildMemberList OnCompletedGuildMemberList;     // 0x0588 (size: 0x10)
    void OnCompletedGetGuildMemberList(const int32 RetCode);
    FSBPlayerGuildComponentOnCompleteGuildKicked OnCompleteGuildKicked;               // 0x0598 (size: 0x10)
    void OnCompletedGetGuildMemberList(const int32 RetCode);
    FSBPlayerGuildComponentOnCompleteGuildActivity OnCompleteGuildActivity;           // 0x05A8 (size: 0x10)
    void OnCompletedGetGuildActivity(const int32 RetCode);
    FSBPlayerGuildComponentOnCompleteExchangeRole OnCompleteExchangeRole;             // 0x05B8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnComplete_GetGuildData OnComplete_GetGuildData;           // 0x05C8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnComplete_GuildComment OnComplete_GuildComment;           // 0x05D8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnComplete_ChangeActivityTime OnComplete_ChangeActivityTime; // 0x05E8 (size: 0x10)
    void OnCompletedGuildRequest(const int32 RetCode);
    FSBPlayerGuildComponentOnComplete_GuildDataChanged OnComplete_GuildDataChanged;   // 0x05F8 (size: 0x10)
    void OnCompletedGuildDataChanged(const int32 RetCode, const FGuildData& InGuildData);
    FSBPlayerGuildComponentOnCompleteGuildAssumeLeader OnCompleteGuildAssumeLeader;   // 0x0608 (size: 0x10)
    void OnCompleteGuildAssumeLeader(const int32 RetCode);
    FSBPlayerGuildComponentOnGetedGuildDatail OnGetedGuildDatail;                     // 0x0618 (size: 0x10)
    void OnCompleteGetGuildDetail(const int32 RetCode, const FGuildData& InGuildData);
    FSBPlayerGuildComponentOnInviteArrived OnInviteArrived;                           // 0x0628 (size: 0x10)
    void OnInvited();
    FSBPlayerGuildComponentOnCompleteNotifyKickedFromGuild OnCompleteNotifyKickedFromGuild; // 0x0638 (size: 0x10)
    void OnCompleteNotifyKickedFromGuild(FString KickedGuildName);
    FSBPlayerGuildComponentOnAddedNewMember OnAddedNewMember;                         // 0x0648 (size: 0x10)
    void OnAddedNewMember();
    FSBPlayerGuildComponentOnCompleteGuildNameCheck OnCompleteGuildNameCheck;         // 0x0658 (size: 0x10)
    void CheckGuildNamed(const int32 RetCode, const bool bIsDuplicate);
    FSBPlayerGuildComponentOnComplete_SearchGuildDataShortID OnComplete_SearchGuildDataShortID; // 0x0668 (size: 0x10)
    void OnCompletedSearchGuildDataShortID(const int32 RetCode);

    void SetSearchKeyWord(FString InKeyWord);
    void SetHasNewMember(bool InHasNewMember);
    void SetGuildDetailDataIsEntryInfo(bool InIsEntry);
    void Server_SendInviteGuild(class ASBPlayerController* InPlayerController, FString InInviteUserId, FString InInviteCharacterId);
    void Server_RequestWithDraw(class ASBPlayerController* InPlayerController);
    void Server_RequestGuildOrganize(class ASBPlayerController* InPlayerController, const FGuildData& InGuildData);
    void Server_RequestGuildEntryAssociate(class ASBPlayerController* InPlayerController, FString InGuildId, FString InComment);
    void Server_RequestEntryAssociate(class ASBPlayerController* InPlayerController, FString InEntryId, bool isAccept);
    void Server_RequestDissolution(class ASBPlayerController* InPlayerController, FString InLastMessage);
    void Server_RequestChangeRole(class ASBPlayerController* InPlayerController, FString InMemberUserId, FString InMemberCharacterId, const TEnumAsByte<EGuildMemberRole::Type>& Role);
    void Server_RequestAssumeLeader(class ASBPlayerController* InPlayerController, FString InGuildId);
    void Server_KickMember(class ASBPlayerController* InPlayerController, FString TargetUserId, FString InCharacterId);
    void Server_InviteArraignment(class ASBPlayerController* InPlayerController, FString InEntryId, bool isAccept);
    void Server_GetRequestGuildData();
    void Server_ExchangeRole(class ASBPlayerController* InPlayerController, FString InTargetUserId, FString InTargetCharacterId);
    void Server_CreateGuildChatRoom(const FGuildData& InGuildData, const FGuildMemberData& InMemberData, bool bInOrganize);
    void Server_ChangeGuildName(class ASBPlayerController* InPlayerController, FString NewGuildName, FString NewGuildShortName);
    void Server_ChangeGuildData(class ASBPlayerController* InPlayerController, const FGuildChangeData& ChangeData);
    void Server_ChangeActivityTime(class ASBPlayerController* InPlayerController, const ESBGuildActivityTime& InActivityTime);
    void Server_CancelInvitation(class ASBPlayerController* InPlayerController, FString InEntryId);
    void Server_CancelEntry(class ASBPlayerController* InPlayerController, FString InEntryId);
    void Send_InviteGuild(FString InInviteUserId, FString InviteCharacterId);
    bool Request_WithDraw();
    void Request_SearchGuildDataShortIds(const TArray<FString>& InGuildShortIDs);
    void Request_SearchGuildDataShortId(FString InGuildShortID);
    void Request_KickMember(const FGuildMemberData& InMemberData);
    bool Request_InviteData();
    void Request_InviteArraignment(const FGuildEntryData& InEntryData, bool isAccept);
    void Request_GuildOrganize(const FGuildData& InGuildData);
    void Request_GuildNameDuplicateCheck(FString InGuildName);
    bool Request_GuildDissolution(FString InLastMessage);
    void Request_GuildDetailData(FString InGuildId);
    void Request_GuildDataRPC();
    void Request_GuildData();
    bool Request_GetSendedEntries();
    void Request_GetNewMemberAddedInfo();
    bool Request_GetGuildMemberList();
    bool Request_GetGuildList(int32 Page);
    bool Request_GetGuildInviteMemberList();
    bool Request_GetEntryList();
    void Request_GetActivity();
    void Request_ExchangeRole(const FGuildMemberData& InMemberData);
    void Request_EntryAssociate(FString InGuildId, FString InComment);
    void Request_DenyEntry(const FGuildEntryData& EntryData);
    void Request_ChangeRole(const FGuildMemberData& TargetMemberData, const TEnumAsByte<EGuildMemberRole::Type>& NewMemberRole);
    void Request_ChangeGuildName(FString InNewGuildName, FString InNewShortName);
    void Request_ChangeGuildActivityTime(const ESBGuildActivityTime& InActivityTime);
    void Request_ChangeData(const FGuildChangeData& InData);
    void Request_CancelInvitation(const FGuildMemberData& InMemberData);
    void Request_CancelEntry(const FGuildEntryData& InEntryData);
    void Request_AssumeLeader();
    void Request_AcceptEntry(const FGuildEntryData& EntryData);
    void OnRep_RepData();
    void OnRep_MemberData();
    void OnRep_GuildData();
    void OnInvited__DelegateSignature();
    void OnCompleteNotifyKickedFromGuild__DelegateSignature(FString KickedGuildName);
    void OnCompleteGuildAssumeLeader__DelegateSignature(const int32 RetCode);
    void OnCompleteGetGuildDetail__DelegateSignature(const int32 RetCode, const FGuildData& InGuildData);
    void OnCompletedSearchGuildDataShortID__DelegateSignature(const int32 RetCode);
    void OnCompletedInviteAssignment__DelegateSignature(const int32 RetCode, bool isAccept, FString InEntryId);
    void OnCompletedGuildRequest__DelegateSignature(const int32 RetCode);
    void OnCompletedGuildDataChanged__DelegateSignature(const int32 RetCode, const FGuildData& InGuildData);
    void OnCompletedGetGuildMemberList__DelegateSignature(const int32 RetCode);
    void OnCompletedGetGuildList__DelegateSignature(const int32 RetCode, const int32 MaxPage);
    void OnCompletedGetGuildInviteMemberList__DelegateSignature(const int32 RetCode);
    void OnCompletedGetGuildEntryList__DelegateSignature(const int32 RetCode);
    void OnCompletedGetGuildActivity__DelegateSignature(const int32 RetCode);
    void OnAddedNewMember__DelegateSignature();
    bool IsGuildPromoter();
    bool IsGuildMember();
    bool IsGuildMaster();
    bool IsGuildGrandMaster();
    bool IsActivateAssumeLeader();
    bool HasNewMember();
    bool HasInvites();
    bool HasEntryData(FString InGuildId, bool IsInvite);
    bool HasEntries();
    FGuildRepData GetRepData();
    TArray<FGuildEntryData> GetPlayerInviteList();
    TArray<FGuildEntryData> GetPlayerEntryList();
    TArray<FGuildMemberData> GetGuildMemberList();
    TArray<FGuildData> GetGuildList();
    TArray<FGuildMemberData> GetGuildInviteMemberList();
    FString GetGuildId();
    TArray<FGuildEntryData> GetGuildEntryList();
    FGuildData GetGuildDetailData();
    FGuildData_CS GetGuildData_CS();
    FGuildData GetGuildData();
    FString GetGuildComment();
    TArray<FGuildActivity> GetGuildActivity();
    ESBGuildErrorCode EncodeGuildErrorCode(int32 ErrorCode);
    void Client_SendInviteGuild(const int32 RetCode);
    void Client_RequestWithDraw(const int32 RetCode);
    void Client_RequestGuildOrganize(const int32 RetCode, const FGuildData& InGuildData, const FGuildMemberData& InMemberData);
    void Client_RequestGuildEntryAssociate(const int32 RetCode, const FGuildEntryData& InGuildEntryData);
    void Client_RequestGuildDissolution(const int32 RetCode);
    void Client_RequestEntryAssociate(const int32 RetCode, FString InEntryId, bool InIsAccept, const TArray<FGuildEntryData>& InGuildEntries);
    void Client_RequestChangeRole(const int32 RetCode, const FGuildMemberData& InMemberData);
    void Client_RequestAssumeLeader(const int32 RetCode, const FGuildData& InGuildData, const TArray<FGuildMemberData>& InMemberDatas);
    void Client_OnGetRequestGuildData(const FGuildData& InGuildData);
    void Client_KickMember(const int32 RetCode, FString InUserId, FString InMemberCharacterId);
    void Client_JoinGuildChatRoom(const FGuildData& InGuildData, const FGuildMemberData& InMemberData, bool bInOrganize, bool bRoomCreationResult);
    void Client_InviteArraignment(const int32 RetCode, FString InEntryId, bool isAccept, const FGuildData& InGuildData, const FGuildMemberData& InMemberData);
    void Client_HasEntry(bool bInHasEntries);
    void Client_ExchangeRole(const int32 RetCode, const FGuildData& InGuildData, const TArray<FGuildMemberData>& InMemberData);
    void Client_ChangeGuildName(const int32 RetCode, const FGuildData& InGuildData);
    void Client_ChangeGuildData(const int32 RetCode, const FGuildData& InGuildData);
    void Client_ChangeActivityTime(const int32 RetCode, const FGuildData& InGuildData);
    void Client_CancelInvitation(const int32 RetCode, FString InEntryId);
    void Client_CancelEntry(const int32 ErrorCode, FString InEntryId);
    void CheckGuildNamed__DelegateSignature(const int32 RetCode, const bool bIsDuplicate);
}; // Size: 0x6C0

class USBPlayerGutsPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBConditionCheckFloatParam> SettingList;                                  // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBPlayerHPGaugeWidget : public USBPlayerGaugeBaseWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x280

class USBPlayerHPRecoveryItemRemoveStatusAndResetElementPassiveSkill : public USBPlayerHPRecoveryItemRemoveStatusPassiveSkill
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBPlayerHPRecoveryItemRemoveStatusPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBPassiveHPRecoveryItemRemoveStatusSetting> SettingList;                  // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBPlayerHoldHandComponent : public USBHoldHandComponent
{
    FSBHoldHandParam HoldHandParam_Default;                                           // 0x00E0 (size: 0x20)
    FSBHoldHandParam HoldHandParam_Follow;                                            // 0x0100 (size: 0x20)

    void ServerResponseHoldHandRequest(ESBHoldHandResponse Response);
    void ServerRequestHoldHand(class ASBPlayerCharacter* TargetPlayerCharacter);
    void ServerEndHoldHand();
    void MulticastStartHoldHandAsLead(class ASBPlayerCharacter* FollowerPlayerCharacter);
    void MulticastStartHoldHandAsFollower(class ASBPlayerCharacter* LeadPlayerCharacter);
    void MulticastEndHoldHand();
    class ASBPlayerCharacter* GetHoldHandTargetPlayer();
    void ClientSendHoldHandResponse(ESBHoldHandResponse Response);
    void ClientNotifyHoldHandFollowRequest(class ASBPlayerCharacter* LeadPlayerCharacter);
    void ClientLeadNotifyArbitration();
}; // Size: 0x130

class USBPlayerInteractionComponent : public USBPlayerActorComponent
{
    class UDataTable* InteractionSearchPriorityDataTable;                             // 0x00F8 (size: 0x8)
    char padding_0[0x18];                                                             // 0x0100 (size: 0x18)
    float PreActionTimeOutMaxDeltaTime;                                               // 0x0118 (size: 0x4)
    char padding_1[0x24];                                                             // 0x011C (size: 0x24)
    TWeakObjectPtr<class USBInteractionTargetComponent> OccupiedTarget;               // 0x0140 (size: 0x8)
    char padding_2[0x4];                                                              // 0x0148 (size: 0x4)
    float CureBadConditionSearchLength;                                               // 0x014C (size: 0x4)
    FSBPlayerInteractionComponentOnSetInteractionDelegate OnSetInteractionDelegate;   // 0x0150 (size: 0x10)
    void OnSetInteractionDelegate(const bool IsOccupied);

    void SetOccupied_Server(class USBInteractionTargetComponent* TargetComponent);
    void SetOccupied_Multicast(class USBInteractionTargetComponent* TargetComponent, ESBOccupiedState ReturnOccupiedState);
    void SetInteractionUIActive(bool bActive);
    void SetCurrentInteractionInfoType(ESBInteractionType InType);
    void SetCurrentInteractionInfoTargetComponent(class USBInteractionTargetComponent* TargetComp);
    void SetCurrentInteractionInfoLocation(const FVector& InLocation);
    void Server_SetInteractionActive(class USBInteractionTargetComponent* InTarget, class UPrimitiveComponent* InMesh, bool InFlag);
    void ResetInteractionActionDeltaTime();
    void Request_SetInteractionActive(class USBInteractionTargetComponent* InTarget, class UPrimitiveComponent* InMesh, bool InFlag);
    void ReleaseOccupied_Server();
    void ReleaseOccupied_Multicast();
    void OnSetInteractionDelegate__DelegateSignature(const bool IsOccupied);
    void OnChangeInteractionUI();
    bool IsPlayerInteractionEnable(ESBInteractionType InteractionType);
    bool IsInteractionUIActive();
    bool IsInteractionTargetMyOccupied();
    FVector GetPlayerInteractCriterionLocation(const class ASBPlayerCharacter* OwnerPlayer);
    ESBJointGestureState GetJointGestureState();
    float GetIteractionInputGauge();
    ESBInteractionState GetCurrentInteractionState();
    FSBInteractionInfo GetCurrentInteractionInfo();
    void Client_SetInteractionActive(class USBInteractionTargetComponent* InTarget, class UPrimitiveComponent* InMesh, bool InFlag);
}; // Size: 0x168

class USBPlayerInterruptQuestComponent : public USBPlayerPropertyComponent
{
    FSBInterruptQuestPlayInfo PlayInfo;                                               // 0x00B8 (size: 0x18)
    FSBInterruptQuestResultInfo ResultInfo;                                           // 0x00D0 (size: 0x18)
    TArray<FSBInterruptQuestNpcData> NpcDataDataList;                                 // 0x00E8 (size: 0x10)
    TArray<FSBInterruptQuestGimmickObjectData> GimmickObjectDataList;                 // 0x00F8 (size: 0x10)
    TArray<FSBInterruptQuestDestructibleObjectData> DestructibleObjectDataList;       // 0x0108 (size: 0x10)
    char padding_0[0x30];                                                             // 0x0118 (size: 0x30)
    FSBPlayerInterruptQuestComponentOnAwakeInterruptQuestDelegete OnAwakeInterruptQuestDelegete; // 0x0148 (size: 0x10)
    void OnAwakeInterruptQuestDelegete(const FName& InQuestId);
    FSBPlayerInterruptQuestComponentOnJoinInterruptQuestDelegete OnJoinInterruptQuestDelegete; // 0x0158 (size: 0x10)
    void OnJoinInterruptQuestDelegete(class USBPlayerInterruptQuestComponent* InComponent, const bool bInFirst);
    FSBPlayerInterruptQuestComponentOnLeaveInterruptQuestDelegete OnLeaveInterruptQuestDelegete; // 0x0168 (size: 0x10)
    void OnLeaveInterruptQuestDelegete(const FName& InQuestId);
    FSBPlayerInterruptQuestComponentOnSuccessInterruptQuestDelegete OnSuccessInterruptQuestDelegete; // 0x0178 (size: 0x10)
    void OnSuccessInterruptQuestDelegete(const FName& InQuestId, bool InSuccess);
    FSBPlayerInterruptQuestComponentOnFailedInterruptQuestDelegete OnFailedInterruptQuestDelegete; // 0x0188 (size: 0x10)
    void OnFailedInterruptQuestDelegete(const FName& InQuestId);
    FSBPlayerInterruptQuestComponentOnUpdateProgressInterruptQuestDelegete OnUpdateProgressInterruptQuestDelegete; // 0x0198 (size: 0x10)
    void OnUpdateProgressInterruptQuestDelegete(class USBPlayerInterruptQuestComponent* InComponent);
    FSBPlayerInterruptQuestComponentOnRepInterruptQuestPlayInfoDelegete OnRepInterruptQuestPlayInfoDelegete; // 0x01A8 (size: 0x10)
    void OnRepInterruptQuestPlayInfoDelegete(const FSBInterruptQuestPlayInfo& InPlayInfo);
    FSBPlayerInterruptQuestComponentOnRepTeamMemberInterruptQuestDelegete OnRepTeamMemberInterruptQuestDelegete; // 0x01B8 (size: 0x10)
    void OnRepTeamMemberInterruptQuestDelegete();
    FSBPlayerInterruptQuestComponentOnRepResultInfoInterruptQuestDelegete OnRepResultInfoInterruptQuestDelegete; // 0x01C8 (size: 0x10)
    void OnRepResultInfoInterruptQuestDelegete(const FSBInterruptQuestResultInfo& InResultInfo);
    FSBPlayerInterruptQuestComponentOnRepUpdateInterruptQuestNpcDelegete OnRepUpdateInterruptQuestNpcDelegete; // 0x01D8 (size: 0x10)
    void OnRepUpdateInterruptQuestNpcDelegete(const TArray<FSBInterruptQuestNpcData>& InNpcDataList);
    FSBPlayerInterruptQuestComponentOnRepUpdateInterruptQuestGimmickObjectDelegete OnRepUpdateInterruptQuestGimmickObjectDelegete; // 0x01E8 (size: 0x10)
    void OnRepUpdateInterruptQuestGimmickObjectDelegete(const TArray<FSBInterruptQuestGimmickObjectData>& InGimmickObjectList);
    FSBPlayerInterruptQuestComponentOnRepUpdateInterruptQuesteDestructibleObjectDelgete OnRepUpdateInterruptQuesteDestructibleObjectDelgete; // 0x01F8 (size: 0x10)
    void OnRepUpdateInterruptQuesteDestructibleObjectDelgete(const TArray<FSBInterruptQuestDestructibleObjectData>& InDestructibleObjectDataList);

    void SetStartNotifyFlag(bool Flag);
    void Server_SetFieldObjectVisibleFlag(const FName& InQuestId, const FName& InProfileId, bool InIsCondition, bool InIsQuestExect);
    void Server_ResetFieldObjectVisibleFlag();
    void Server_ObjectPopupLog(FString ObjectId);
    void Server_NpcPopupLog(FString QuestID, FString NpcId);
    void Server_EnemyPopupLog(FString EnemyId);
    void Server_DeleteGimmickObjectData(FString InName, const FName& InQuestId);
    void Server_DeleteFieldObjectVisibleFlag(const FName& InQuestId);
    void Server_DeleteDestructibleObjectData(FString InName, const FName& InQuestId);
    void Server_DebugPrint(FString Message, float Duration);
    void Server_AddGimmickObjectData(FString InName, const FName& InQuestId);
    void Server_AddDestructibleObjectData(FString InName, const FName& InQuestId, bool Inactive);
    void Server_ActionNotification_Recovery(float InRecoveryValue);
    void Server_ActionNotification_NpcTalk_Start(FString InQuestId);
    void Server_ActionNotification_NpcTalk_Clear(FString InQuestId);
    void Server_ActionNotification_ItemUse(int32 ItemId);
    void Server_ActionNotification_Interact(FString InProfileId);
    void Server_ActionNotification_Gather(const int32 GatherPointId);
    void Server_ActionNotification_Emote(const FName& EmotName);
    void Request_UpdateDestructibleObjectInstallation();
    void Request_InterruptQuestGimmickObjectAppearLog(class ASBInterruptQuestGimmickActorBase* InGimmickActor, bool InIsAppear, bool IsVisibleFlag);
    void Request_InterruptQuestGimickObjectAppear(class ASBInterruptQuestGimmickActorBase* InGimmickActor, bool InIsAppear);
    void Request_DeleteGimmickObjectData(FString InName, const FName& InQuestId);
    void Request_DeleteDestructibleObjectData(FString InId, const FName& InQuestId);
    void Request_AddGimmickObjectData(FString InName, const FName& InQuestId);
    void Request_AddDestructibleObjectData(FString InId, const FName& InQuestId, bool Inactive);
    void OnRep_TeamMember();
    void OnRep_ResultInfo();
    void OnRep_PlayInfo();
    bool IsQuestJoined();
    bool IsInTeamMember(class ASBPlayerState* pState);
    int32 GetTeamMemberNum();
    class ASBPlayerState* GetTeamMember(int32 Index);
    FSBInterruptQuestResultInfo GetResultInfo();
    int32 GetQuestInstanceId();
    FName GetQuestId();
    FSBInterruptQuestProgressInfo GetProgressInfo();
    TArray<FSBInterruptQuestNpcData> GetNpcDataDataList();
    TArray<FSBInterruptQuestGimmickObjectData> GetGimmickObjectDataList();
    FDateTime GetEndTime();
    TArray<FSBInterruptQuestDestructibleObjectData> GetDestructibleObjectDataList();
    int32 GetCurrentStep();
    bool GetActiveQuestName(FString& OutQuestName);
    void DeleteNpcData(const FName& Name, const FName& InQuestId);
    void DeleteGimmickObjectData(FString InObjectId, const FName& InQuestId);
    void DeleteDestructibleObjectData(FString InObjectId, const FName& InQuestId);
    void Client_UpdateNpcInstallation();
    void Client_UpdateGimmickObjectInstallation();
    void Client_UpdateDestructibleObjectInstallation();
    void Client_SuccessInterruptQuest(const FName& InQuestId, bool InSuccess, const TArray<FSBMasterReward>& RewardList, const TArray<FSBCharacterToken>& InToken);
    void Client_SetQuestProgress(const int32 InCurStep, const FSBInterruptQuestProgressInfo& InProgressInfo);
    void Client_SetFieldObjectVisibleFlag(const FName& InQuestId, const FName& InProfileId, bool InIsCondition, bool InIsQuestExect);
    void Client_ResetFieldObjectVisibleFlag();
    void Client_RandomEnemyPopLogPut(FString InQuestId, int32 InRandNum, int32 InCheckNum);
    void Client_PutInterruptQuestStatus(const FName& InQuestId, float InCoolTime, const TArray<FSBInterruptQuestPointCounter>& InCounter, const class ASBInterruptQuestGimmickActor* InGimmickActor, const class ASBInterruptQuestInteractionGimmickActor* InInteractionGimmickActor);
    void Client_ObjectPopupLog(FString ObjectId);
    void Client_NpcPopupLog(FString NpcId);
    void Client_NotifyLeaveInterruptQuest(const FName& InQuestId);
    void Client_NotifyJoinInterruptQuest(const FSBInterruptQuestPlayInfo& InPlayInfo, const bool bInFirst, const int32 InCurStep, const FSBInterruptQuestProgressInfo& InProgressInfo);
    void Client_NotifyIsStartQuest(bool IsStart);
    void Client_NotifyFailedInterruptQuest(const FName& InQuestId);
    void Client_NotifyAwakeInterruptQuest(const FName& InQuestId);
    void Client_InterruptQuestGimmickObjectAppearLog(class ASBInterruptQuestGimmickActorBase* InGimmickActor, bool InIsAppear, bool InIsServer, bool IsVisibleFlag);
    void Client_InterruptQuestGimickObjectAppear(class ASBInterruptQuestGimmickActorBase* InGimmickActor, bool isAppear);
    void Client_FieldObjectUpdate();
    void Client_ErrorMsgPut(FString InMessage);
    void Client_EnemyPopupLog(FString EnemyId);
    void Client_DeleteGimmickObjectData(FString InName, const FName& InQuestId);
    void Client_DeleteFieldObjectVisibleFlag(const FName& InQuestId);
    void Client_DeleteDestructibleObjectData(FString InId, const FName& InQuestId);
    void Client_DebugPrint(FString Message, float Duration);
    void Client_DebugLogPut(FString InMsg);
    void Client_AddGimmickObjectData(FString InName, const FName& InQuestId);
    void Client_AddDestructibleObjectData(FString InId, const FName& InQuestId, bool Inactive);
    void AddNpcData(const FName& InName, const FName& InQuestId, const FVector& Location);
    void AddGimmickObjectData(FString InName, const FName& InQuestId);
    void AddDestructibleObjectData(FString InId, const FName& InQuestId, bool Inactive);
}; // Size: 0x208

class USBPlayerLevelStartSequenceComponent : public UActorComponent
{
    TArray<class USBPlayerLevelStartSequenceTaskBase*> TaskLists;                     // 0x00B8 (size: 0x10)
    TArray<class USBPlayerLevelStartSequenceTaskBase*> TempTaskLists;                 // 0x00C8 (size: 0x10)

    bool CreateTaskList();
    void AddTask(TSubclassOf<class USBPlayerLevelStartSequenceTaskBase> InTaskClass);
}; // Size: 0xE0

class USBPlayerLevelStartSequenceMapLevelInfoInitializedReady : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskBase : public UObject
{
    bool bStart;                                                                      // 0x0028 (size: 0x1)
    bool bFinished;                                                                   // 0x0029 (size: 0x1)

    void Tick(const float fDeltaTime);
    void Start();
    void PreStart();
    void OnEnd();
    FString GetDescription();
    void Finish();
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskCallJingleForUpdatedQuests : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskCallOtherNotifications : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskCheckInitialEvent : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBPlayerLevelStartSequenceTaskCheckTermUI : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskEnablePlayerInput : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskFadein : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskFadeout : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskLoadBattleNpcAssets : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBPlayerLevelStartSequenceTaskLockLoadingScreen : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskPerformanceFadein : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskReplicatGuildDataUpdated : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskShowLoadingScreen : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskUnlockLoadingScreen : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskWaitEnemyLoading : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLevelStartSequenceTaskWaitPlayerReady : public USBPlayerLevelStartSequenceTaskBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBPlayerLiquidMemoryComponent : public UActorComponent
{
    FSBPlayerLiquidMemoryComponentOnAccumulateLiquidMemoryDelegate OnAccumulateLiquidMemoryDelegate; // 0x00B8 (size: 0x10)
    void OnAccumulateLiquidMemoryDelegate(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InUpdatedLiquidMemoryInfos);
    FSBPlayerLiquidMemoryComponentOnUseLiquidMemoryDelegate OnUseLiquidMemoryDelegate; // 0x00C8 (size: 0x10)
    void OnUseLiquidMemoryDelegate(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InUpdatedLiquidMemoryInfos);
    char padding_0[0x20];                                                             // 0x00D8 (size: 0x20)
    FSBPlayerLiquidMemoryComponentOnOnMergeLiquidMemoryDelegate OnOnMergeLiquidMemoryDelegate; // 0x00F8 (size: 0x10)
    void OnMergeLiquidMemoryDelegate(const int32 InRetCode);
    FSBPlayerLiquidMemoryComponentOnGetAccumulateLiquidMemoryTokenDelegate OnGetAccumulateLiquidMemoryTokenDelegate; // 0x0108 (size: 0x10)
    void OnGetAccumulateLiquidMemoryTokenDelegate(const bool InSuccess, const TArray<FSBLiquidMemoryAccumulateTokenInfo>& InTokenInfos);
    TArray<FSBLiquidMemoryInfo> RepLiquidMemoryInfos;                                 // 0x0118 (size: 0x10)

    void Server_UseLiquidMemory(const TArray<int32>& InLiquidMemoryIdList, const TArray<int32>& InLiquidMemoryLevelList);
    void Server_UnlockLiquidMemoryLevel(const int32 InLiquidMemoryId, const int32 InLevel);
    void Server_OnUseLiquidMemory(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos, const int32 InRemainMoney);
    void Server_OnUnlockLiquidMemoryLevel(const int32 InRetCode);
    void Server_OnMergeLiquidMemory(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos);
    void Server_OnAddLiquidMemory(const int32 InRetCode);
    void Server_OnAccumulateLiquidMemoryWithToken(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos, const TArray<int32>& InTokenIdList, const TArray<int32>& InTokenAmountList);
    void Server_OnAccumulateLiquidMemory(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos);
    void Server_GetLatestTimeElapseAccumulateLiquidMemory();
    void Server_AddLiquidMemory(const int32 InLiquidMemoryId, const int32 InLevel, const int32 InAccumulatedAmount);
    void Server_AccumulateLiquidMemoryWithToken(const int32 InLiquidMemoryId, const TArray<int32>& InTokenIdList, const TArray<int32>& InTokenAmountList);
    void Server_AccumulateLiquidMemory(const ESBLiquidMemoryAccumulateConditionType InAccumulateConditionType);
    void Request_UseLiquidMemory(const TMap<int32, int32>& InLiquidMemoryIdAndLevelList);
    bool Request_UnlockLiquidMemoryLevel(const int32 InLiquidMemoryId, const int32 InLevel);
    void Request_GetLiquidMemoryAccumulateTokens();
    void Request_GetLatestTimeElapseAccumulateLiquidMemory();
    bool Request_AddLiquidMemory(const int32 InLiquidMemoryId, const bool IsMaxAccumulatedFlag, const int32 InLevel);
    void Request_AccumulateLiquidMemoryWithToken(const int32 InLiquidMemoryId, const TMap<int32, int32>& InTokenList);
    void Request_AccumulateLiquidMemory(const ESBLiquidMemoryAccumulateConditionType InAccumulateConditionType);
    void OnUseLiquidMemoryDelegate__DelegateSignature(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InUpdatedLiquidMemoryInfos);
    void OnUnlockLiquidMemoryLevelDelegate__DelegateSignature(const int32 InRetCode);
    void OnRep_LiquidMemoryInfos();
    void OnMergeLiquidMemoryDelegate__DelegateSignature(const int32 InRetCode);
    void OnGetLiquidMemoryAccumulateTokens(const bool InWasSuccessful, const TArray<FSBLiquidMemoryAccumulateTokenInfo>& InTokenList);
    void OnGetAccumulateLiquidMemoryTokenDelegate__DelegateSignature(const bool InSuccess, const TArray<FSBLiquidMemoryAccumulateTokenInfo>& InTokenInfos);
    void OnAddLiquidMemoryDelegate__DelegateSignature(const int32 InRetCode);
    void OnAccumulateLiquidMemoryDelegate__DelegateSignature(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InUpdatedLiquidMemoryInfos);
    void Client_OnUseLiquidMemory(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos, const int32 InRemainMoney);
    void Client_OnUnlockLiquidMemoryLevel(const int32 InRetCode);
    void Client_OnMergeLiquidMemory(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos);
    void Client_OnAddLiquidMemory(const int32 InRetCode);
    void Client_OnAccumulateLiquidMemoryWithToken(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos, const TArray<int32>& InTokenIdList, const TArray<int32>& InTokenAmountList);
    void Client_OnAccumulateLiquidMemory(const int32 InRetCode, const TArray<FSBLiquidMemoryInfo>& InDirtyLiquidMemoryInfos);
}; // Size: 0x130

class USBPlayerLoginBonusComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerLoginBonusComponentOnCheckComplete OnCheckComplete;                      // 0x00B8 (size: 0x10)
    void OnLoginBonusQueryComplete(const bool bWasSuccessful, const int32 ErrorCode);
    FSBPlayerLoginBonusComponentOnGetActiveComplete OnGetActiveComplete;              // 0x00C8 (size: 0x10)
    void OnLoginBonusQueryComplete(const bool bWasSuccessful, const int32 ErrorCode);
    FSBPlayerLoginBonusComponentOnGetDetailComplete OnGetDetailComplete;              // 0x00D8 (size: 0x10)
    void OnLoginBonusQueryComplete(const bool bWasSuccessful, const int32 ErrorCode);

    void Server_OnLoginBonusCheck(TArray<FSBLoginBonus> DataList, TArray<int32> DayCount, bool bWasSuccessful, int32 ErrorCode);
    void Server_OnGetLoginBonusDetail(TArray<FSBLoginBonus> DataList, TArray<int32> DayCount, bool bWasSuccessful, const int32 ErrorCode);
    void Server_OnGetActiveList(TArray<FSBLoginBonus> DataList, TArray<int32> DayCount, bool bWasSuccessful, const int32 ErrorCode);
    void Server_LoginBonusCheck();
    void Server_GetLoginBonusDetail(const TArray<FString>& TargetIds);
    void Server_GetActiveList();
    void Request_LoginBonusCheck();
    void Request_GetLoginBonusDetail(TArray<FString> TargetIds);
    void Request_GetActiveList();
    void OnLoginBonusQueryComplete__DelegateSignature(const bool bWasSuccessful, const int32 ErrorCode);
    bool IsNeedLoginBonusWindow();
    void Client_OnLoginBonusCheck(const TArray<FSBLoginBonus>& DataList, const TArray<int32>& DayCount, bool bWasSuccessful, const int32 ErrorCode);
    void Client_OnGetLoginBonusDetail(const TArray<FSBLoginBonus>& DataList, const TArray<int32>& DayCount, bool bWasSuccessful, const int32 ErrorCode);
    void Client_OnGetActiveList(const TArray<FSBLoginBonus>& DataList, const TArray<int32>& DayCount, bool bWasSuccessful, const int32 ErrorCode);
}; // Size: 0xE8

class USBPlayerMagicPointSkillController : public USBPlayerSkillController
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerMailComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerMailComponentOnMailListReceived OnMailListReceived;                      // 0x00B8 (size: 0x10)
    void OnCompletedReadedMailList(const bool bWasSuccessful, const int32 ErrorCode, const TArray<FSBMailData>& ReceivedMailList);
    FSBPlayerMailComponentOnAttachmentMailListReceived OnAttachmentMailListReceived;  // 0x00C8 (size: 0x10)
    void OnCompletedReadedMailList(const bool bWasSuccessful, const int32 ErrorCode, const TArray<FSBMailData>& ReceivedMailList);
    FSBPlayerMailComponentOnMailStatusChanged OnMailStatusChanged;                    // 0x00D8 (size: 0x10)
    void OnCompletedChangeStatus(bool bWasSuccessful, int32 ErrorCode, FString MailId);
    FSBPlayerMailComponentOnMailTransed OnMailTransed;                                // 0x00E8 (size: 0x10)
    void OnCompletedChangeStatus(bool bWasSuccessful, int32 ErrorCode, FString MailId);
    FSBPlayerMailComponentOnUpdatedUnreadCount OnUpdatedUnreadCount;                  // 0x00F8 (size: 0x10)
    void OnCompletedUnreadCount(bool bWasSuccessful, int32 ErrorCode, int32 UnreadCount);
    FSBPlayerMailComponentOnObtainedItems OnObtainedItems;                            // 0x0108 (size: 0x10)
    void OnCompletedObtainItems(bool bWasSuccessful, int32 ErrorCode, const FSBMailRewardData& RewardData);
    FSBPlayerMailComponentOnMultiDeleteMail OnMultiDeleteMail;                        // 0x0118 (size: 0x10)
    void OnCompletedMultiDeleteMail(bool bWasSuccessful);
    FSBPlayerMailComponentOnAleatUpdate OnAleatUpdate;                                // 0x0128 (size: 0x10)
    void OnCompletedAleatUpdate(bool bIsAleat);
    FSBPlayerMailComponentOnLimitSyncd OnLimitSyncd;                                  // 0x0138 (size: 0x10)
    void OnCompletedLimitSyncd(bool bIsSyncd);
    FSBPlayerMailComponentOnCompletedSendMail OnCompletedSendMail;                    // 0x0148 (size: 0x10)
    void OnCompletedSendMail(bool bWasSuccessful, int32 ErrorCode);
    FSBPlayerMailComponentOnCompletedGetTransableCharacters OnCompletedGetTransableCharacters; // 0x0158 (size: 0x10)
    void OnCompletedSendMail(bool bWasSuccessful, int32 ErrorCode);
    FSBPlayerMailComponentOnRestrictUpdated OnRestrictUpdated;                        // 0x0168 (size: 0x10)
    void OnCompleteRestrictUpdated();
    FSBPlayerMailComponentOnPriorityUpdated OnPriorityUpdated;                        // 0x0178 (size: 0x10)
    void OnCompleteChangeMailPriority(bool bWasSuccessful, int32 ErrorCode);
    FSBPlayerMailComponentOnGetBulkRetrieval OnGetBulkRetrieval;                      // 0x0188 (size: 0x10)
    void OnCompletedReadedMailList(const bool bWasSuccessful, const int32 ErrorCode, const TArray<FSBMailData>& ReceivedMailList);
    char padding_0[0x80];                                                             // 0x0198 (size: 0x80)
    FSBMailLimitStatus LimitStat;                                                     // 0x0218 (size: 0x10)
    ESBMailType LastMailType;                                                         // 0x0228 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0229 (size: 0x7)
    TArray<ESBMailFilterType> LastUsedFilter;                                         // 0x0230 (size: 0x10)
    ESBMailSortType LastUsedSort;                                                     // 0x0240 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0241 (size: 0x3)
    int32 Page;                                                                       // 0x0244 (size: 0x4)
    int32 UnreadMailCount;                                                            // 0x0248 (size: 0x4)
    int32 TotalMailCount;                                                             // 0x024C (size: 0x4)
    int32 MaxMailCapacity;                                                            // 0x0250 (size: 0x4)
    int32 FilteredMailCount;                                                          // 0x0254 (size: 0x4)
    int32 FirstMailLimitCount;                                                        // 0x0258 (size: 0x4)
    char padding_3[0x4];                                                              // 0x025C (size: 0x4)
    bool AutoDeleteCheckmark;                                                         // 0x0260 (size: 0x1)
    bool bIsLimitSyncd;                                                               // 0x0261 (size: 0x1)
    bool bShowSystemMessageRequest;                                                   // 0x0262 (size: 0x1)
    bool IsAcceptAttachmentMail;                                                      // 0x0263 (size: 0x1)

    void SetBppIrredeemable(bool Flag);
    void SetAutoDeleteCheckmark(bool Flag);
    void Server_RPC_Request_UpdateMailRestrictedFlags(class ASBPlayerController* InPlayerController);
    void Server_RPC_Request_UnProtectMailList(class ASBPlayerController* InPlayerController, const TArray<FString>& MailIds, int32 Skip, int32 take, const TArray<ESBMailFilterType>& Filter, ESBMailSortType SortType);
    void Server_RPC_Request_TransMail(class ASBPlayerController* InPlayerController, const FSBMailData& MailData, FString InTargetPlayerId, FString InTargetCharacterId);
    void Server_RPC_Request_TransableCharacterList(class ASBPlayerController* InPlayerController);
    void Server_RPC_Request_SendMail(class ASBPlayerController* InPlayerController, const FName& MailId, FString InPlayerId, FString InCharacterId, const FDateTime& DateTime, int32 ExpiredDate);
    void Server_RPC_Request_ReceiveMail(class ASBPlayerController* InPlayerController, int32 Skip, int32 take, const TArray<ESBMailFilterType>& Filter, ESBMailSortType SortType);
    void Server_RPC_Request_ReceiveAttachmentMails(class ASBPlayerController* InPlayerController, int32 OrderNum, bool ReceivedExclusion);
    void Server_RPC_Request_ReadMailList(class ASBPlayerController* InPlayerController, const TArray<FString>& MailIds, int32 Skip, int32 take, const TArray<ESBMailFilterType>& Filter, ESBMailSortType SortType);
    void Server_RPC_Request_ProtectMailList(class ASBPlayerController* InPlayerController, const TArray<FString>& MailIds, int32 Skip, int32 take, const TArray<ESBMailFilterType>& Filter, ESBMailSortType SortType);
    void Server_RPC_Request_ProtectMail(class ASBPlayerController* InPlayerController, FString MailId, bool protect, int32 Skip, int32 take, const TArray<ESBMailFilterType>& Filter, ESBMailSortType SortType);
    void Server_RPC_Request_ObtainMailAttachment(class ASBPlayerController* InPlayerController, const TArray<FString>& MailIds, bool IsAutoDelete);
    void Server_RPC_Request_GetUnreadCount(class ASBPlayerController* InPlayerController);
    void Server_RPC_Request_GetBulkRetrieval(class ASBPlayerController* InPlayerController, int32 MailCount);
    void Server_RPC_Request_DeleteMailMulti(class ASBPlayerController* InPlayerController, const TArray<FString>& MailIds, int32 Skip, int32 take, const TArray<ESBMailFilterType>& Filter, ESBMailSortType SortType);
    void Server_RPC_Request_ChangeMailPriority(class ASBPlayerController* InPlayerController, FString MailId);
    void Request_UpdateMailRestrictedFlag();
    void Request_UnProtectMailList(const TArray<FString>& MailIds);
    void Request_TransMail(const FSBMailData& MailData, FString TargetUserId, FString TargetCharacterId);
    void Request_TransableCharacterList();
    void Request_SendMail(const FName& MailId, FString InPlayerId, FString InCharacterId, const FDateTime& DateTime, int32 ExpiredDate);
    void Request_ReceivedMailList(int32 InPage, const TArray<ESBMailFilterType>& InFilterType, ESBMailSortType InSortType);
    void Request_ReceivedAttachmentMailList(int32 OrderNum, bool ReceivedExclusion);
    void Request_ReadMailList(const TArray<FString>& MailIds);
    void Request_ProtectMailList(const TArray<FString>& MailIds);
    void Request_ProtectMail(FString MailId);
    void Request_ObtainMailAttachmentsMulti(const TArray<FString>& MailIds, bool IsAutoDelete);
    void Request_ObtainMailAttachments(FString MailId, bool IsAutoDelete);
    void Request_GetUnreadCount();
    void Request_GetBulkRetrieval(int32 MailCount);
    void Request_DeleteMailMulti(const TArray<FString>& MailIds);
    void Request_DeleteMail(FString MailId);
    void Request_ChangeMailPriority(FString MailId);
    void OnCompleteRestrictUpdated__DelegateSignature();
    void OnCompletedUnreadCount__DelegateSignature(bool bWasSuccessful, int32 ErrorCode, int32 UnreadCount);
    void OnCompletedSendMail__DelegateSignature(bool bWasSuccessful, int32 ErrorCode);
    void OnCompletedReadedMailList__DelegateSignature(const bool bWasSuccessful, const int32 ErrorCode, const TArray<FSBMailData>& ReceivedMailList);
    void OnCompletedObtainItems__DelegateSignature(bool bWasSuccessful, int32 ErrorCode, const FSBMailRewardData& RewardData);
    void OnCompletedMultiDeleteMail__DelegateSignature(bool bWasSuccessful);
    void OnCompletedLimitSyncd__DelegateSignature(bool bIsSyncd);
    void OnCompletedChangeStatus__DelegateSignature(bool bWasSuccessful, int32 ErrorCode, FString MailId);
    void OnCompletedAleatUpdate__DelegateSignature(bool bIsAleat);
    void OnCompleteChangeMailPriority__DelegateSignature(bool bWasSuccessful, int32 ErrorCode);
    bool IsRestrictedUsage();
    bool IsLimitSyncd();
    bool IsEncourageOrganization();
    int32 GetViewLetterStartIndex();
    int32 GetViewLetterNum();
    int32 GetUnreadCount();
    TArray<FSBTransableCharacterData> GetTransableUserCharacter();
    TArray<FSBTransableCharacterData> GetTransableGuildMember();
    TArray<FSBTransableCharacterData> GetTransableFollowCharacter();
    int32 GetPageMax();
    int32 GetPage();
    TArray<FSBMailData> GetMailList();
    bool GetMailLimitAleat();
    int32 GetMailFirstLimit();
    int32 GetMailCount();
    int32 GetMailCapacity();
    FSBMailLimitStatus GetLimitStatus();
    int32 GetFilteredMailCount();
    bool GetBppIrredeemable();
    bool GetAutoDeleteCheckmark();
    bool GetAcceptAttachmentMailFlag();
    FSBMailData FindMailData(FString MailId);
    void Client_RPC_UpdateMailRestrictedFlags(bool bWasSuccessful, int32 ErrorCode, bool InIsRestrictedUsage, bool InIsEncourageOrganize);
    void Client_RPC_TransMail(bool bWasSuccessful, int32 ErrorCode, FString MailId, int32 Status, bool tranced);
    void Client_RPC_TransableCharacterList(bool bWasSuccessful, int32 ErrorCode, const TArray<FSBTransableCharacterData>& UserCharacter, const TArray<FSBTransableCharacterData>& FolloMember);
    void Client_RPC_SyncMailStats(const FSBMailLimitStatus& Status, bool bLimitAleart);
    void Client_RPC_SyncMailLimit(const FSBMailLimitStatus& Stat);
    void Client_RPC_SyncMailCounts(int32 totalCount, int32 firstLimit);
    void Client_RPC_SetUnreadCount(int32 InCount);
    void Client_RPC_SetRestrictFlags(bool Resctiction, bool Endcourage);
    void Client_RPC_SetAcceptAttachmentFlag(bool Flag);
    void Client_RPC_SendMail(bool bWasSuccessful, int32 ErrorCode);
    void Client_RPC_ReceiveMail(bool bWasSuccessful, int32 ErrorCode, const TArray<FSBMailData>& datas, int32 TotalMail, int32 MaxMail, int32 FilterTotalMail, int32 UnreadCountNum, const TArray<FOwnItemInfo>& attachments);
    void Client_RPC_ReceiveAttachmentMails(bool bWasSuccessful, int32 ErrorCode, const TArray<FSBMailData>& datas, int32 TotalMail, int32 MaxMail, int32 FilterTotalMail, int32 UnreadCountNum, const TArray<FOwnItemInfo>& attachments);
    void Client_RPC_ReadMailList(bool bWasSuccessful, int32 ErrorCode, const TArray<FString>& MailIds, const TArray<ESBMailReadStatus>& ReadStatusList, int32 UnreadCount);
    void Client_RPC_ProtectMailList(bool bWasSuccessful);
    void Client_RPC_ObtainMailAttachment(bool bWasSuccessful, int32 ErrorCode, const FSBMailRewardData& InRewardData, const TArray<FSBMailData>& MailData, bool IsAutoDelete, bool IsMultiData);
    void Client_RPC_GetUnreadCount(bool bWasSuccessful, int32 ErrorCode, int32 CountNum);
    void Client_RPC_GetBulkRetrieval(bool bWasSuccessful, int32 ErrorCode, const TArray<FSBMailData>& datas);
    void Client_RPC_DeleteMailMulti(bool bWasSuccessful);
    void Client_RPC_ChangeMailPriority(bool bWasSuccessful, int32 ErrorCode, const TArray<FString>& MailIds, const TArray<bool>& FlagList);
    void Change_ReadMail(FString MailId);
}; // Size: 0x268

class USBPlayerManager : public UObject
{
    TMap<class ESBPlayerClassCommonParam, class FSBMultiType> m_ClassCommonDataList;  // 0x0028 (size: 0x50)
    class UDataTable* m_ClassCommonSkillDataTable;                                    // 0x0078 (size: 0x8)
    FSBGamePadSettings m_ClassCommonDefaultGamepadKeyConfig;                          // 0x0080 (size: 0x88)
    FSBKeyboardSettings m_ClassCommonDefaultKeyboardKeyConfig;                        // 0x0108 (size: 0x98)
    FSBMouseSettings m_ClassCommonDefaultMouseKeyConfig;                              // 0x01A0 (size: 0x98)
    char padding_0[0x1D0];                                                            // 0x0238 (size: 0x1D0)
    TArray<FSBPlayerClassKeyConfigData> m_ClassDefaultKeyConfigList;                  // 0x0408 (size: 0x10)
    char padding_1[0x10];                                                             // 0x0418 (size: 0x10)
    FSBPlayerManagerOnUpdateKeyConfig OnUpdateKeyConfig;                              // 0x0428 (size: 0x10)
    void OnUpdateKeyConfig();
    TMap<class ESBClassType, class FSBPlayerCharacterParamInfo> PlayerCharacterParams; // 0x0438 (size: 0x50)
    TArray<FSBPlayerSkillTagPreset> SkillTagPresetList;                               // 0x0488 (size: 0x10)
    TArray<FSBPlayerSignificanceAnimUpdateRateSetting> m_SignificanceAnimUpdateRateThresholdList; // 0x0498 (size: 0x10)
    float m_ZeroSignificanceIdleTime;                                                 // 0x04A8 (size: 0x4)
    char padding_2[0x3C];                                                             // 0x04AC (size: 0x3C)
    FSBCameraShieldingTransparentParam CameraShieldingTransparentParam_Player;        // 0x04E8 (size: 0x8)
    FSBCameraShieldingTransparentParam CameraShieldingTransparentParam_Enemy;         // 0x04F0 (size: 0x8)
    FSBCameraShieldingTransparentParam CameraShieldingTransparentParam_Npc;           // 0x04F8 (size: 0x8)
    FSBCameraShieldingTransparentParam CameraShieldingTransparentParam_Mount;         // 0x0500 (size: 0x8)
    FSBCameraShieldingTransparentParam CameraShieldingTransparentParam_Other;         // 0x0508 (size: 0x8)
    TArray<FSBPlayerTransformSetting> TransformSettingList;                           // 0x0510 (size: 0x10)
    FSBPlayerFollowParam PlayerFollowParam_Default;                                   // 0x0520 (size: 0x1C)
    FSBPlayerFollowParam PlayerFollowParam_Mount;                                     // 0x053C (size: 0x1C)
    FSBPlayerFollowParam PlayerFollowParam_HoldHand;                                  // 0x0558 (size: 0x1C)
    char padding_3[0x4];                                                              // 0x0574 (size: 0x4)
    TArray<class UObject*> m_HoldingPlayerAssets;                                     // 0x0578 (size: 0x10)
    char padding_4[0x10];                                                             // 0x0588 (size: 0x10)
    TArray<class UObject*> m_HoldingResidentAssets;                                   // 0x0598 (size: 0x10)
    TArray<class UObject*> m_LoadedResidentAssets;                                    // 0x05A8 (size: 0x10)

    void SetClassKeyConfig(class UObject* WorldContextObject, const FSBPlayerClassKeyConfigData& ConfigData);
    void SetClassCommonKeyConfig(class UObject* WorldContextObject, const FSBPlayerClassKeyConfigData& ConfigData);
    void ResetClassKeyConfigAsCommon(class UObject* WorldContextObject, ESBClassType ClassType);
    void ResetAllKeyConfig(class UObject* WorldContextObject);
    bool IsClassKeyConfigCustomized(ESBClassType ClassType);
    bool IsClassCommonKeyConfigCustomized();
    FString GetSkillNameText(const int32 SkillId);
    class USBSkillInfoClass* GetSkillInfo_BP(int32 SkillId, ESBClassType ClassType);
    class UTexture2D* GetSkillIconSmall(int32 SkillId, const class ASBPlayerCharacter* PlayerCharacter, bool bDefault);
    class UTexture2D* GetSkillIconLarge(int32 SkillId, const class ASBPlayerCharacter* PlayerCharacter, bool bDefault);
    ESBSkillElementIconType GetSkillIconElementType(int32 SkillId, const class ASBPlayerCharacter* PlayerCharacter);
    TSoftObjectPtr<UTexture2D> GetSkillIconDetail(int32 SkillId);
    ESBSkillIconBgType GetSkillIconBgType(int32 SkillId, const class ASBPlayerCharacter* PlayerCharacter);
    FString GetSkillDescriptionText(const int32 SkillId, const int32 SkillLevel);
    class UDataTable* GetSkillDataTable(ESBClassType ClassType);
    TArray<FName> GetSkillBufIconList(int32 SkillId, int32 SkillLV, ESBClassType ClassType);
    float GetResurrectionTime();
    class USBPlayerPassiveSkill* GetPassiveSkillInfo_BP(int32 PassiveSkillID, ESBClassType ClassType);
    int32 GetPassiveSkillID(FName SkillName, ESBClassType ClassType);
    class UDataTable* GetPassiveSkillDataTable(ESBClassType ClassType);
    class USBImagineSkillInfo* GetImagineSkillInfo_BP(FName ImagineName);
    TArray<FName> GetEquippablePassiveSkillList(ESBClassType ClassType, int32 CurrentLevel);
    FString GetDefaultSkillNameText(ESBClassType ClassType, ESkillActionPosition SAP);
    FString GetClassPassiveSkillNameText(int32 PassiveSkillID);
    class UTexture2D* GetClassPassiveSkillLargeIcon(int32 PassiveSkillID, ESBClassType ClassType);
    class UTexture2D* GetClassPassiveSkillIcon(int32 PassiveSkillID, ESBClassType ClassType);
    FString GetClassPassiveSkillDescriptionText(int32 PassiveSkillID, const int32 SkillLevel);
    FSBPlayerClassKeyConfigData GetClassKeyConfig(ESBClassType ClassType);
    FSBPlayerClassKeyConfigData GetClassCommonKeyConfig();
    int32 GetClassCommonDataInt32(ESBPlayerClassCommonParam ParamType, int32 DefaultValue);
    float GetClassCommonDataFloat(ESBPlayerClassCommonParam ParamType, float DefaultValue);
}; // Size: 0x5C0

class USBPlayerMarkerSkillController : public USBPlayerSkillController
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerMissionQuestComponent : public UActorComponent
{
    TArray<FSBMissionQuestRequestParam> RequestParamList;                             // 0x00B8 (size: 0x10)
    FSBMissionQuestMissionScore MissionScore;                                         // 0x00C8 (size: 0x70)

    void Server_UpdateWishListEntryCondition();
    void Server_UpdateWeaponShopCheckCondition();
    void Server_UpdateStorageCheckCondition();
    void Server_UpdateStampCondition(int32 InStampId);
    void Server_UpdateSkillEquipCondition(int32 InSkillId);
    void Server_UpdateResuscitationCondition();
    void Server_UpdateRankingBoardCheckCondition();
    void Server_UpdatePartyJoinCondition();
    void Server_UpdateItemUseCondition(int32 InItemID);
    void Server_UpdateItemShopCheckCondition();
    void Server_UpdateGestureCondition(FString InGestureId);
    void Server_UpdateExchangeShopCheckCondition();
    void Server_TreasureGetCountCondition();
    void Server_TakeElementStatusCondition(ESBAttribute InElementId);
    void Server_TakeDamageCondition(float InDamgePoint);
    void Server_TakeBadStatusCondition(ESBAttribute InAttributeId);
    void Server_SupplierUseCondition();
    void Server_MountCondition(int32 InMountId);
    void Server_MissionScoreLog(FString InMsg);
    void Server_JustAvoidCountCondition();
    void Server_ElementalBurstCondition(ESBAttribute InElementId);
    void Server_DestructibleObjectBreakCondition(const class ASBDestructible* InDestructibleObject);
    void Server_DeadCondition();
    void Server_DamegeCondition(int32 InDamgePoint);
    void Server_CriticalDamegeCondition(int32 InDamgePoint);
    void Server_BadStatusCondition(ESBAttribute InAttributeId);
    void Server_AutoMessageCondition();
    void Client_MissionScoreLog(FString InMsg, const FSBMissionQuestMissionScore& InMissionScore);
    void Client_LogPut(FString InMsg);
}; // Size: 0x140

class USBPlayerModifyAutoTargetSkillController : public USBPlayerSkillController
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBPlayerModifyTakeDamageByDistancePassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBConditionCheckFloatCurveParam> DistanceRateCurveSettingList;            // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBPlayerMovementComponent : public USBPlayerMovementComponentBase
{
    float InitialMaxWalkSpeedUnsheathed;                                              // 0x0E10 (size: 0x4)
    FRotator InitialRotationRate;                                                     // 0x0E14 (size: 0xC)
    FRotator InitialRotationRateUnsheathed;                                           // 0x0E20 (size: 0xC)
    char padding_0[0x4];                                                              // 0x0E2C (size: 0x4)
    class UCurveFloat* NormalMoveCurve;                                               // 0x0E30 (size: 0x8)
    float SBWalkSpeed;                                                                // 0x0E38 (size: 0x4)
    float MaxDashSpeed;                                                               // 0x0E3C (size: 0x4)
    class UCurveFloat* RotationRateYawVelocityAdjust;                                 // 0x0E40 (size: 0x8)
    float MaxWalkSpeedUnsheathed;                                                     // 0x0E48 (size: 0x4)
    float UnsheatheBackWalkSpeedRate;                                                 // 0x0E4C (size: 0x4)
    FRotator RotationRateUnsheathed;                                                  // 0x0E50 (size: 0xC)
    float UnsheatheJumpZVelocity;                                                     // 0x0E5C (size: 0x4)
    float MaxRunSpeedCarrying;                                                        // 0x0E60 (size: 0x4)
    float MaxDashSpeedCarrying;                                                       // 0x0E64 (size: 0x4)
    char padding_1[0x58];                                                             // 0x0E68 (size: 0x58)
    float m_GoAroundRadiusMin;                                                        // 0x0EC0 (size: 0x4)
    char padding_2[0xC];                                                              // 0x0EC4 (size: 0xC)
    float MaxSwimmingBuoyancy;                                                        // 0x0ED0 (size: 0x4)
    FSBSwimMeshOffsetParam_Gender SwimMeshOffsetParam;                                // 0x0ED4 (size: 0x30)
    char padding_3[0x4];                                                              // 0x0F04 (size: 0x4)
    class UCurveFloat* SwimmingAdjustBlendYCurve;                                     // 0x0F08 (size: 0x8)
    class UCurveFloat* SwimmingTurnSlowDownCurve;                                     // 0x0F10 (size: 0x8)
    class UCurveFloat* SwimmingTurnSlowRefRateToSpeed;                                // 0x0F18 (size: 0x8)
    float SwimmingStartSlowDownRotateDegree;                                          // 0x0F20 (size: 0x4)
    char padding_4[0x5C];                                                             // 0x0F24 (size: 0x5C)
    float FallDamageMinPar;                                                           // 0x0F80 (size: 0x4)
    float FallDamageMinHeight;                                                        // 0x0F84 (size: 0x4)
    float FallDamageMaxHeight;                                                        // 0x0F88 (size: 0x4)
    float FallDamageStunHeight;                                                       // 0x0F8C (size: 0x4)
    int32 FallDamageStunLevel;                                                        // 0x0F90 (size: 0x4)
    float CanFallingSkillActionHeight;                                                // 0x0F94 (size: 0x4)
    bool bLandedWithFallDamageStun;                                                   // 0x0F98 (size: 0x1)

    void StopCurveMove();
    void SetupCurveMove(FName CurveName, bool bUseTSkillStepInput);
    void RestoreRotationRateUnsheathed();
    void RestoreRotationRate();
    void RestoreMaxWalkSpeedUnsheathed();
    void RequestSetVelocity(const FVector& SetVelocity);
    bool IsMeshClimbingMoveForward();
    bool GetPrevIsUseLeftClimbAnim();
    int32 GetMeshClimbingTargetPointID();
    TEnumAsByte<EMeshClimbingState> GetMeshClimbingState();
    class USBClimbingPointsManagerComponent* GetMeshClimbingPointsManager();
    int32 GetMeshClimbingCurrentPointID();
    FSBSwimMeshOffsetParam GetCurrentSwimMeshOffsetParam();
    void DebugUpdateSwimMeshOffset(FSBSwimMeshOffsetParam InSwimMeshOffsetParam);
    bool DebugIsSwimSpeedConstVelocity();
    bool DebugEnableQuicklyStopToDash();
    FVector CalcSwimMeshOffset();
}; // Size: 0xFA0

class USBPlayerMovementComponentBase : public USBCharacterMovementComponent
{
    FSBPlayerInterpMoveSetting InterpMoveSetting;                                     // 0x0D20 (size: 0x40)

    void RequestTurnActorToLocation(FVector Location, FName TurnProcessName, float InterpSpeed);
    void RequestTurnActorOnce(ESBTurnPlayerActorType TurnType, bool bImmediately);
    void RequestTurnActor(ESBTurnPlayerActorType TurnType, FName TurnProcessName, bool bImmediately, float InterpSpeed);
    void RequestSmoothMoveJump();
    void RemoveTurnActorRequestByName(const FName& TurnProcessName);
    bool CanSmoothMoveJump();
}; // Size: 0xE10

class USBPlayerNaEventComponent : public USBPlayerControllerComponentBase
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBPlayerNamePlateWidget : public USBNamePlateWidget
{
    TWeakObjectPtr<class ASBPlayerCharacter> PlayerCharacter;                         // 0x0288 (size: 0x8)
    class USBDeadMarkerWidget* DeadMarker;                                            // 0x0290 (size: 0x8)
    class UCanvasPanel* HPGrp;                                                        // 0x0298 (size: 0x8)
    class UImage* Line1;                                                              // 0x02A0 (size: 0x8)
    class USBBuffListWidget* BuffList;                                                // 0x02A8 (size: 0x8)
    class UImage* HPPrev;                                                             // 0x02B0 (size: 0x8)
    class UCanvasPanelSlot* HPPrevSlot;                                               // 0x02B8 (size: 0x8)
    class USBDsStateWidget* DsState;                                                  // 0x02C0 (size: 0x8)
    class UImage* HPLoss;                                                             // 0x02C8 (size: 0x8)
    class UImage* HPLossLine;                                                         // 0x02D0 (size: 0x8)
    bool HpGaugeVisibility;                                                           // 0x02D8 (size: 0x1)
    bool bIsHpMax;                                                                    // 0x02D9 (size: 0x1)
    char padding_0[0x2];                                                              // 0x02DA (size: 0x2)
    float LerpHpRateTimer;                                                            // 0x02DC (size: 0x4)
    float PrevHpRate;                                                                 // 0x02E0 (size: 0x4)
    float CurHpRate;                                                                  // 0x02E4 (size: 0x4)
    float ItplSpeed;                                                                  // 0x02E8 (size: 0x4)
    FVector2D SlotSizeXY;                                                             // 0x02EC (size: 0x8)
    bool bLastCheckParty;                                                             // 0x02F4 (size: 0x1)
    bool bLastSimplycityPartyOn;                                                      // 0x02F5 (size: 0x1)

    void OnUpdatenSimplycityPartyOn();
    void OnUpdateNameColor(bool bParty);
    bool IsCheckParty();
}; // Size: 0x2F8

class USBPlayerPassiveParamModifyConditionSkill : public USBPlayerPassiveSkill
{
    ESBPassiveArtsModifyCategory Category;                                            // 0x0040 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0041 (size: 0x7)
    TArray<FSBConditionCheckParam> ConditionList;                                     // 0x0048 (size: 0x10)
    TArray<FSBPassiveLevelParamModifySetting> LevelParamModifySettingList;            // 0x0058 (size: 0x10)

}; // Size: 0x68

class USBPlayerPassiveParamModifySkill : public USBPlayerPassiveSkill
{
    ESBPassiveArtsModifyCategory Category;                                            // 0x0040 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0041 (size: 0x7)
    TArray<FSBPassiveLevelParamModifySetting> LevelParamModifySettingList;            // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBPlayerPassiveSkill : public UObject
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerPathFollowingComponent : public UPathFollowingComponent
{
    char padding_0[0x268];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x268

class USBPlayerPhotoModeComponent : public USBPlayerControllerComponentBase
{
    TSubclassOf<class ASBPhotoModeController> PhotoModeControllerClass;               // 0x00B8 (size: 0x8)
    char padding_0[0x8];                                                              // 0x00C0 (size: 0x8)
    class ASBPhotoModeController* PhotoModeController;                                // 0x00C8 (size: 0x8)

    void TogglePhotoMode();
    void SetPlayerControlMode(bool bValue);
    void OnSetMenuMode(class UObject* Sender, class UObject* Param);
    void OnRequestPlayerWarp(class UObject* Sender, class UObject* Param);
    void OnRequestPlayerRestart(class UObject* Sender, class UObject* Param);
    void OnBeginScript(class ASBScriptActor* InScriptActor);
    bool IsPlayerControlMode();
    bool IsPhotoModePlayerControlMode();
    bool IsPhotoMode();
    bool IsPhotoCameraControlMode();
    class ASBPhotoModeController* GetPhotoModeController();
    bool CanStartPhotoMode(ESBPhotoModeStartState& State);
    bool CanControlPhotoMode();
    void BP_OnCantStartPhotoMode(ESBPhotoModeStartState State);
}; // Size: 0xD8

class USBPlayerPresetEquipComponent : public USBPlayerActorComponent
{
    FSBPlayerPresetEquipComponentOnLoadPresetEquipmentListDelegate OnLoadPresetEquipmentListDelegate; // 0x00D0 (size: 0x10)
    void OnLoadPresetEquipmentListDelegate(const int32 RetCode);
    FSBPlayerPresetEquipComponentOnClearPresetEquipmentListSlotDelegate OnClearPresetEquipmentListSlotDelegate; // 0x00E0 (size: 0x10)
    void OnClearPresetEquipmentListSlotDelegate();
    FSBPlayerPresetEquipComponentOnLoadPresetEquipmentParamDelegate OnLoadPresetEquipmentParamDelegate; // 0x00F0 (size: 0x10)
    void OnLoadPresetEquipmentParamDelegate(const int32 RetCode);
    FSBPlayerPresetEquipComponentOnSwapPresetEquipmentListDelegate OnSwapPresetEquipmentListDelegate; // 0x0100 (size: 0x10)
    void OnSwapPresetEquipmentListDelegate(const int32 RetCode, const int32 DstListIndex);
    FSBPlayerPresetEquipComponentOnSavePresetEquipmentDelegate OnSavePresetEquipmentDelegate; // 0x0110 (size: 0x10)
    void OnSavePresetEquipmentDelegate(int32 RetCode);
    FSBPlayerPresetEquipComponentOnSaveCharaPresetEquipmentDelegate OnSaveCharaPresetEquipmentDelegate; // 0x0120 (size: 0x10)
    void OnSaveCharaPresetEquipmentDelegate(int32 RetCode);

    void Server_SwapPresetEquipmentList(const int32 InSrcListIndex, const int32 InDstListIndex);
    void Server_SavePresetEquipment(const int32 InListIndex, const FSBPlayerPresetEquipList& InPresetEquipList, const TArray<FSBPlayerPresetEquipItem>& InPresetEquipItems);
    void Server_SaveCharaCostumePresetEquip(ESBClassType ClassType, const int32 listIndex, const TArray<FSBPlayerPresetEquipItem>& EquipItem);
    void Server_SaveCharaBattlePresetEquip(const int32 InListIndex, class ASBPlayerState* InSBPlayerState, const bool bInIsClassChange);
    void Server_RenamePresetEquipmentList(int32 InListIndex, FString InName);
    void Server_OnSwapPresetEquipmentList(const int32 InRetCode, const int32 InSrcListIndex, const int32 InDstListIndex);
    void Server_OnRenamePresetEquipmentList(int32 InListIndex, FString InName, int32 InRetCode);
    void Server_OnClearPresetEquipmentList(const int32 InRetCode);
    void Server_LoadPresetEquipmentParam(const int32 RetCode);
    void Server_LoadPresetEquipmentList();
    void Server_ClearPresetEquipmentListSlot();
    void Server_ClearPresetEquipmentList(int32 listIndex);
    void Request_SwapPresetEquipmentList(const int32 InSrcListIndex, const int32 InDstListIndex);
    void Request_SavePresetEquipment(const int32 InListIndex, const FSBPlayerPresetEquipList& InPresetEquipList, const TArray<FSBPlayerPresetEquipItem>& InPresetEquipItems);
    void Request_SaveCharaCostumePresetEquip(ESBClassType ClassType, const int32 listIndex, const TArray<FSBPlayerPresetEquipItem>& EquipItem);
    void Request_SaveCharaBattlePresetEquip(const int32 InListIndex, class ASBPlayerState* InSBPlayerState, const bool bInIsClassChange);
    void Request_RenamePresetEquipmentList(int32 InListIndex, FString InName);
    void Request_LoadPresetEquipmentList();
    void Request_ClearPresetEquipmentList(int32 listIndex);
    void OnSwapPresetEquipmentListDelegate__DelegateSignature(const int32 RetCode, const int32 DstListIndex);
    void OnSavePresetEquipmentDelegate__DelegateSignature(int32 RetCode);
    void OnSaveCharaPresetEquipmentDelegate__DelegateSignature(int32 RetCode);
    void OnLoadPresetEquipmentParamDelegate__DelegateSignature(const int32 RetCode);
    void OnLoadPresetEquipmentListDelegate__DelegateSignature(const int32 RetCode);
    void OnClearPresetEquipmentListSlotDelegate__DelegateSignature();
    void Client_SavePresetEquipment(const int32 InListIndex, const FSBPlayerPresetEquipList& InPresetEquipList, const TArray<FSBPlayerPresetEquipItem>& InPresetEquipItems, const int32 InRetCode);
    void Client_SaveCharaCostumePresetEquip(const int32 RetCode, const int32 listIndex, const TArray<FSBPlayerPresetEquipItem>& EquipItem);
    void Client_SaveCharaBattlePresetEquip(const int32 RetCode, const int32 listIndex, const TArray<FSBPlayerPresetEquipItem>& EquipItem);
    void Client_RenamePresetEquipmentList(int32 InListIndex, FString InName, int32 InRetCode);
    void Client_OnSwapPresetEquipmentList(const int32 InRetCode, const int32 InSrcListIndex, const int32 InDstListIndex);
    void Client_OnClearPresetEquipmentList(const int32 InRetCode, const FSBPlayerPresetEquipSet& InPresetEquipSet);
    void Client_LoadPresetEquipmentParam(const int32 RetCode);
    void Client_LoadPresetEquipmentList(const TArray<FSBPlayerPresetEquipList>& InPresetEquipLists, const TArray<FSBPlayerPresetEquipItem>& InPresetEquipItems, const int32 RetCode);
    void Client_ClearPresetEquipmentListSlot();
}; // Size: 0x130

class USBPlayerPresetEquipFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsPresetEquipListItemAllIn(class ASBPlayerCharacter* InPlayerCharacterPtr, int32 ItemListIndex);
    bool isImagineByBattleEquipItem(int32 Index);
    bool isEquipArtsByEquipItem(int32 Index);
    bool isEquipArtsByBattleEquipItem(int32 Index);
    int32 GetPresetEquipListMax();
    int32 GetPresetEquipListBlankDataIndex(class ASBPlayerCharacter* pPlayerCharacter);
    int32 GetPassiveImagineSlotIdByBattleEquipItem(int32 Index);
    int32 GetImagineArtsSlotIdByBattleEquipItem(int32 Index);
    int32 GetEquipTypeIndexByEquipItem(int32 Type);
    int32 GetEquipItemIndexByEquipType(int32 Type);
    int32 GetEquipItemIndexByCostumeEquipItem(int32 Type);
    int32 GetEquipItemIndexByBattleEquipItem(int32 Type);
    int32 GetEquipItemIndexByArtsSlotId(int32 SlotId);
    int32 GetEquipedImaginSlotIdByEquipItem(int32 Type);
    int32 GetEquipedArtsSlotIdByEquipItem(int32 Type);
    bool GetCostumePresetEquipDataFormNowEquipItem(class ASBPlayerCharacter* InPlayerCharacterPtr, TArray<FSBPlayerPresetEquipItem>& OutItemList);
    int32 GetCostumeEquipItemIndexByEquipType(int32 Type);
    int32 GetCostumeEquipItemIndexByEquipItem(int32 Type);
    bool GetBattlePresetEquipItemArtsParam(ESBPlayerBattlePresetEquipItem Type, ESBPlayerArtsType& OutArtsType, int32& OutSlotId);
    bool GetBattlePresetEquipDataFormNowEquipItem(class ASBPlayerCharacter* InPlayerCharacterPtr, TArray<FSBPlayerPresetEquipItem>& OutItemList);
    int32 GetBattleEquipItemIndexByEquipType(int32 Type);
    int32 GetBattleEquipItemIndexByEquipItem(int32 Type);
    bool GetBattleEquipItemArtsParamByCharacterEquipedArts(const class UObject* InWorldContextObject, const ESBPlayerBattlePresetEquipItem EquipItemType, FSBPlayerPresetEquipItem& OutEquipItem);
}; // Size: 0x28

class USBPlayerPropertyComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBPlayerRecepiComponentBase : public USBPlayerControllerComponentBase
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBPlayerResurrectionApplyBattleStatusParamModifyPassiveSkill : public USBPlayerPassiveParamModifySkill
{
    TArray<FSBPassiveResurrectionApplyBattleStatusSetting> SettingList;               // 0x0058 (size: 0x10)

}; // Size: 0x68

class USBPlayerResurrectionComponent : public USBPlayerActorComponent
{
    float ResurrectionSearchAngle;                                                    // 0x00D0 (size: 0x4)
    float ResurrectionSearchLength;                                                   // 0x00D4 (size: 0x4)
    int32 ResurrectionAttackID;                                                       // 0x00D8 (size: 0x4)
    float CurrentResurrectionTime;                                                    // 0x00DC (size: 0x4)
    FSBPlayingEffect m_PlayingResurrectionEffect;                                     // 0x00E0 (size: 0xC8)

    void SetResurrectionPlayerCharacter_Server(class ASBPlayerCharacter* PlayerCharacter);
    void SetResurrectionPlayerCharacter_Multicast(class ASBPlayerCharacter* PlayerCharacter);
    void MulticastSetResurrectionPenalty(float Penalty);
    bool IsResurrected();
}; // Size: 0x1D0

class USBPlayerRewardBoostComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerRewardBoostComponentOnGetRewardBoostCompletedDelegate OnGetRewardBoostCompletedDelegate; // 0x00B8 (size: 0x10)
    void OnRequestCompletedDelegate(int32 InRetCode);
    TArray<FSBRewardBoostInfo> RewardBoostInfoList;                                   // 0x00C8 (size: 0x10)

    void ServerGetRewardBoost();
    void RequestGetRewardBoost(FRequestGetRewardBoostOnCompleted OnCompleted);
    void OnRequestCompletedDelegate__DelegateSignature(int32 InRetCode);
    bool IsEffectiveWeaponRefining(int32 ItemId);
    bool IsEffectiveToken(int32 TokenID);
    bool IsEffectiveStackBByUniqueIdAndContainer(FString UniqueId, class USBOwnItemListContainer* Container);
    bool IsEffectiveStackB(ESBRewardBoostStackBItemType ItemType, int32 ItemId, int32 StackBNum, int32 SupportItemId);
    bool IsEffectiveSeasonPassQuestQuest(int32 QuestID);
    bool IsEffectiveMissionByMapId(FName MapId);
    bool IsEffectiveMission(FName DungeonRewardId);
    bool IsEffectiveLiquidMemory(int32 LiquidMemoryId);
    bool IsEffectiveImagineRefining(int32 ItemId);
    bool IsEffectiveImagineCraft(int32 CraftRecipeId);
    bool IsEffectiveGetBootyItem(const FName& EnemyId, int32 ItemId);
    bool IsEffectiveFusion(int32 ItemId);
    bool IsEffectiveFangExpedition();
    bool IsEffectiveDefeatEnemy(const FName& EnemyId);
    bool IsEffectiveCraft(int32 CraftRecipeId);
    bool IsEffectiveAutoDeliveryQuest();
    bool IsEffectiveAdventureBoardBonus(FString MissionId, int32& OutBonusCount, bool& bOutLimited, FString& OutEventTerm);
    void GetWeaponRefiningTooltipText(int32 ItemId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    bool GetWeaponRefiningExpBonus(int32 ItemId, float& ExpBonus);
    bool GetWeaponRefiningCostReduction(int32 ItemId, float& CostReduction);
    void GetTokenTooltipText(int32 TokenID, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    void GetStackBToolTipText(ESBRewardBoostStackBItemType ItemType, int32 ItemId, int32 StackBNum, int32 SupportItemId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    bool GetStackBSuccessRate(ESBRewardBoostStackBItemType ItemType, int32 ItemId, int32 StackBNum, int32 SupportItemId, float& SuccessRateBonus);
    bool GetStackBMoneyDiscount(ESBRewardBoostStackBItemType ItemType, int32 ItemId, int32 StackBNum, int32 SupportItemId, float& DiscountRate);
    bool GetStackBEconomyItemRate(ESBRewardBoostStackBItemType ItemType, int32 ItemId, int32 StackBNum, int32 SupportItemId, float& EconomyRate);
    bool GetStackBEconomyItemNum(ESBRewardBoostStackBItemType ItemType, int32 ItemId, int32 StackBNum, int32 SupportItemId, int32& EconomyNum);
    void GetSeasonPassQuestTooltipText(int32 QuestID, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    void GetMissionTooltipTextByMapId(FName MapId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    void GetMissionTooltipText(FName DungeonRewardId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    void GetLiquidMemoryTooltipText(int32 LiquidMemoryId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    void GetImagineRefiningTooltipText(int32 ItemId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    bool GetImagineRefiningExpBonus(int32 ItemId, float& ExpBonus);
    bool GetImagineRefiningCostReduction(int32 ItemId, float& CostReduction);
    void GetImagineCraftTooltipText(int32 CraftRecipeId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    bool GetImagineCraftCostReduction(int32 CraftRecipeId, float& CostReduction);
    void GetFusionTooltipText(int32 ItemId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    void GetFangExpeditionToolTipText(TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    bool GetEffectiveRewardBoostMissionData(FName DungeonRewardId, FSBRewardBoostMissionMasterData& RewardBoostMissionData);
    void GetCraftTooltipText(int32 CraftRecipeId, TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    bool GetCraftSuccessRateBonus(int32 CraftRecipeId, float& SuccessRateBonus);
    bool GetCraftCostReduction(int32 CraftRecipeId, float& CostReduction);
    void GetAutoDeliveryQuestTooltipText(TArray<FSBRewardBoostTooltipData>& TooltipDataList);
    void ClientOnGetRewardBoostCompleted(int32 RetCode, const TArray<FSBRewardBoostInfo>& InNewData);
}; // Size: 0xD8

class USBPlayerRootCollisionComponent : public UCapsuleComponent
{
    char padding_0[0x4A0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x4A0

class USBPlayerSTGaugeWidget : public USBPlayerGaugeBaseWidget
{
    char padding_0[0x280];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x280

class USBPlayerSceneComponent : public USceneComponent
{
    char padding_0[0x220];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x220

class USBPlayerSeasonPassComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerSeasonPassComponentOnBuySeasonPassCompletedDelegate OnBuySeasonPassCompletedDelegate; // 0x00B8 (size: 0x10)
    void OnRequestCompletedAmountOfMoneyDelegate(int32 InRetCode, int32 InFreeMoney, int32 InPaidMoney);
    FSBPlayerSeasonPassComponentOnSeasonPassRankUpCompletedDelegate OnSeasonPassRankUpCompletedDelegate; // 0x00C8 (size: 0x10)
    void OnRequestCompletedDelegate(int32 InRetCode);
    FSBPlayerSeasonPassComponentOnSeasonPassBuyRankUpCompletedDelegate OnSeasonPassBuyRankUpCompletedDelegate; // 0x00D8 (size: 0x10)
    void OnRequestCompletedAmountOfMoneyDelegate(int32 InRetCode, int32 InFreeMoney, int32 InPaidMoney);
    FSBPlayerSeasonPassComponentOnGetSeasonPassRewardCompletedDelegate OnGetSeasonPassRewardCompletedDelegate; // 0x00E8 (size: 0x10)
    void OnRequestCompletedDelegate(int32 InRetCode);
    FSBPlayerSeasonPassComponentOnGetSeasonPassRewardAllCompletedDelegate OnGetSeasonPassRewardAllCompletedDelegate; // 0x00F8 (size: 0x10)
    void OnRequestCompletedDelegate(int32 InRetCode);
    FSBPlayerSeasonPassComponentOnGetSeasonPassInfoCompletedDelegate OnGetSeasonPassInfoCompletedDelegate; // 0x0108 (size: 0x10)
    void OnRequestCompletedDelegate(int32 InRetCode);
    FSBSeasonPassInfo SeasonPassInfo;                                                 // 0x0118 (size: 0x1C)
    char padding_0[0x4];                                                              // 0x0134 (size: 0x4)
    TArray<FSBSeasonPassReceivedRewardInfo> ReceivedRewardInfoList;                   // 0x0138 (size: 0x10)

    void ServerSeasonPassRankUp(int32 UpRank);
    void ServerSeasonPassBuyRankUp(int32 UpRank);
    void ServerGetSeasonPassRewardAll();
    void ServerGetSeasonPassReward(FName RewardId);
    void ServerGetSeasonPassInfo();
    void ServerBuySeasonPass(ESBSeasonPassPlanState InSeasonPassType);
    void RequestSeasonPassRankUp(int32 UpRank, FRequestSeasonPassRankUpOnCompleted OnCompleted);
    void RequestSeasonPassBuyRankUp(int32 UpRank, FRequestSeasonPassBuyRankUpOnCompleted OnCompleted);
    void RequestGetSeasonPassRewardAll(FRequestGetSeasonPassRewardAllOnCompleted OnCompleted);
    void RequestGetSeasonPassReward(FName RewardId, FRequestGetSeasonPassRewardOnCompleted OnCompleted);
    void RequestGetSeasonPassInfo(FRequestGetSeasonPassInfoOnCompleted OnCompleted);
    void RequestBuySeasonPass(ESBSeasonPassPlanState InSeasonPassType, FRequestBuySeasonPassOnCompleted OnCompleted);
    void OnRequestCompletedDelegate__DelegateSignature(int32 InRetCode);
    void OnRequestCompletedAmountOfMoneyDelegate__DelegateSignature(int32 InRetCode, int32 InFreeMoney, int32 InPaidMoney);
    bool IsValidNextSeasonPoint();
    bool IsValidNextSeasonDiscount();
    bool IsValidDiscount();
    bool IsShowSeasonPassDebugUi();
    bool IsSeasonValid();
    bool IsSeasonShopOpened();
    bool IsSeasonProgressValid();
    bool IsRewardReceived(FName RewardId);
    bool IsPaidPlanSubscribed();
    bool IsMaxRank();
    bool IsCorrespondPlan(ESBSeasonPassRewardType PlanType);
    bool IsAutoRankupEnabled();
    bool IsAnyRewardCanReceived();
    int32 GetUpRankAtAutoRankup();
    int32 GetShopEmancipationRank();
    ESBSeasonPassPlanState GetSeasonPassType();
    FSBSeasonPassQuestInfo GetSeasonPassQuestInfo();
    FSBSeasonPassInfo GetSeasonPassInfo();
    int32 GetSeasonId();
    int32 GetRequiredRankupPoint();
    TArray<FSBSeasonPassReceivedRewardInfo> GetReceivedRewardInfoList();
    int32 GetRank();
    int32 GetQuestReloadCountMax();
    int32 GetQuestReloadCount();
    int32 GetPoint();
    int32 GetPickupUnit();
    int32 GetPaidRankupPrice();
    int32 GetNextSeasonPoint();
    int32 GetNextSeasonDiscount();
    int32 GetMaxRank();
    FString GetGuidePaidPlanText();
    int32 GetDiscount();
    FDateTime GetCurrentSeasonStartDate();
    TArray<FName> GetCurrentSeasonReceivedRewardIdList();
    FDateTime GetCurrentSeasonProgressEndDate();
    FString GetCurrentSeasonPassName();
    FString GetCurrentSeasonName();
    FDateTime GetCurrentSeasonEndDate();
    int32 GetCurrentPaidPlanIndex();
    void ClientOnUpdateSeasonPassInfoByQuestReward(const FSBSeasonPassInfo& InSeasonPassInfo);
    void ClientOnSeasonPassRankUpCompleted(int32 RetCode, const FSBSeasonPassInfo& InSeasonPassInfo);
    void ClientOnSeasonPassBuyRankUpCompleted(int32 RetCode, const FSBSeasonPassInfo& InSeasonPassInfo, int32 InFreeMoney, int32 InPaidMoney);
    void ClientOnGetSeasonPassRewardCompleted(int32 RetCode, const TArray<FSBSeasonPassReceivedRewardInfo>& InReceivedRewardInfoList);
    void ClientOnGetSeasonPassRewardAllCompleted(int32 RetCode, const FSBSeasonPassInfo& InSeasonPassInfo, const TArray<FSBSeasonPassReceivedRewardInfo>& InReceivedRewardInfoList);
    void ClientOnGetSeasonPassInfoCompleted(int32 RetCode, const FSBSeasonPassInfo& InSeasonPassInfo, const TArray<FSBSeasonPassReceivedRewardInfo>& InReceivedRewardInfoList);
    void ClientOnBuySeasonPassCompleted(int32 RetCode, const FSBSeasonPassInfo& InSeasonPassInfo, int32 InFreeMoney, int32 InPaidMoney);
    bool CanRankup();
    bool CanAutoRankup();
    FSBMasterSeasonPass BP_GetCurrentSeasonMasterSeasonPass(ESBSeasonPassPlanState PassType, bool& bIsExists);
    FSBMasterSeasonPass BP_GetCurrentMasterSeasonPass(bool& bIsExists);
    FSBMasterSeason BP_GetCurrentMasterSeason(bool& bIsExists);
}; // Size: 0x148

class USBPlayerSessionState : public UObject
{
    FUniqueNetIdRepl UniqueId;                                                        // 0x0030 (size: 0x28)

}; // Size: 0xC8

class USBPlayerShieldSkillController : public USBPlayerSkillController
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerShopComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerShopComponentOnSellOwnItemDelegate OnSellOwnItemDelegate;                // 0x00B8 (size: 0x10)
    void OnSellOwnItemDelegate(int32 InRetCode);

    void Server_SellOwnItem(const TArray<FString>& UniqueIdList, const TArray<int32>& ItemAmountList, const TArray<int32>& ItemStorageNo);
    void Server_OnSellOwnItem(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems, const int32 RemainMoney);
    void Request_SellOwnItem(const TArray<FString>& UniqueIdList, const TArray<int32>& ItemAmountList, const TArray<int32>& ItemStorageNo);
    void OnSellOwnItemDelegate__DelegateSignature(int32 InRetCode);
    void Client_SellOwnItem(int32 InRetCode, const TArray<FOwnItemInfo>& DiffOwnItemList, const int32 RemainMoney);
}; // Size: 0xC8

class USBPlayerShortPinComponent : public USBPlayerPropertyComponent
{
    TArray<FSBShortPinInfo> PinInfo;                                                  // 0x00B8 (size: 0x10)
    bool IsChangePinInfo;                                                             // 0x00C8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00C9 (size: 0x7)
    TArray<FHitResult> Hits;                                                          // 0x00D0 (size: 0x10)

    TArray<FHitResult> ShortPin_LineTraceObjects(class ASBPlayerController* InPlayerController);
    void Server_SharePinInfo(const FSBShortPinInfo InPinInfo, const TArray<FString>& inMemberIdList);
    void Server_GetTargetLocation(FString inPinId);
    void Request_GetTargetLocation(FSBShortPinInfo InPinInfo);
    void Request_AddPin(FSBShortPinInfo InPinInfo);
    void RemovePin(FSBShortPinInfo InPinInfo);
    FVector_NetQuantize GetPinLocation(FString inPinId);
    class ASBEnemyCharacter* GetOrderEnemy();
    TArray<class ASBEnemyCharacter*> GetOrderEnemies(class AActor* inPlayerActor, TArray<class ASBEnemyCharacter*> inEnemyArray);
    void Client_GetTargetLocation(FString inPinId, const FVector InTargetLocation);
    void Client_AddPin(const FSBShortPinInfo InPinInfo);
}; // Size: 0xE0

class USBPlayerSkillActionComponent : public USBPlayerActorComponent
{
    TArray<ESBCommunicatePlayerSkillFlag> m_SkillParamFlagOnList;                     // 0x00D0 (size: 0x10)
    char padding_0[0x4];                                                              // 0x00E0 (size: 0x4)
    FVector_NetQuantize m_LargeShieldLocation;                                        // 0x00E4 (size: 0xC)
    FVector_NetRoughDirection m_LargeShieldDirection;                                 // 0x00F0 (size: 0xC)

    void ServerSetSkillFlag(ESBCommunicatePlayerSkillFlag SkillFlag, bool bEnable, bool bMulticast);
    void ServerSetLargeShieldSpawnInfo(const FVector_NetQuantize& Location, const FVector_NetRoughDirection& Direction, int32 InSkillId, float InWidth, float InHeight, float InThickness, float InMaxTime);
    void ServerNotifySkillParamFloat(ESBCommunicatePlayerSkillParam SkillParam, float Value, bool bMulticast);
    void ServerNotifySkillEvent(ESBCommunicatePlayerSkillEvent SkillEvent, bool bMulticast);
    void MulticastSkillParamFloat(ESBCommunicatePlayerSkillParam SkillParam, float Value);
    void MulticastSkillFlag(ESBCommunicatePlayerSkillFlag SkillFlag, bool bEnable);
    void MulticastSkillEvent(ESBCommunicatePlayerSkillEvent SkillEvent);
    void MulticastSetLargeShieldSpawnInfo(const FVector_NetQuantize& Location, const FVector_NetRoughDirection& Direction);
    bool IsStoneBodyActive();
    bool IsPrepareStyleActive();
    bool IsGlitterModeActive();
    bool IsBloodAxeActive();
    bool IsAttackUp(const ESkillActionPosition Position);
    float GetStoneBodyDurabilityRate();
    float GetRegularBuffArrowMaxGaugeAmount();
    int32 GetRegularBuffArrowMaxChargeLevel();
    float GetRegularBuffArrowGaugeAmount();
    int32 GetRegularBuffArrowChargeLevel();
    int32 GetGlitterModeLevel();
    float GetGlitterModeGaugeRatio();
    int32 GetErasedMarkNum();
    class USBPCSmasherComponent* GetClassComponentAsSmasher();
    float GetBloodAxeDrainUpRate();
    void GetBerserkModePowerupSkillArray(TArray<FSBActiveArtsID>& OutPowerupSkillArray);
    int32 GetAttackUpRank(const ESkillActionPosition Position);
    void ClientSetStoneBodyDurability(float Durability);
    void ClientSetNextSkillRecastZero(bool bNextRecastZero);
    void ClientNotifyetErasedMarkNum(int32 MarkEraseCount);
    void ClientNotifyEndMarkCountStatus();
}; // Size: 0x100

class USBPlayerSkillChargeSuperArmorController : public USBPlayerSkillController
{
    char padding_0[0x88];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x88

class USBPlayerSkillChargeSuperArmorPassiveSkill : public USBPlayerConditionParamPassiveSkill
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBPlayerSkillController : public UObject
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerSkillController_BallShootBase : public USBPlayerSkillController
{
    char padding_0[0x660];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x660

class USBPlayerSkillController_DustStorm : public USBPlayerSkillController
{
    char padding_0[0x100];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x100

class USBPlayerSkillController_ElementAmp : public USBPlayerSkillController
{
    TArray<FSBCreatedElementAmpOption> m_ElementAmpOptionList;                        // 0x0048 (size: 0x10)

}; // Size: 0x68

class USBPlayerSkillController_ElementSpreadShot : public USBPlayerSkillController
{
    char padding_0[0x98];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x98

class USBPlayerSkillController_FireBurner : public USBPlayerSkillController
{
    TArray<FSBFireBurnerFireShot> m_FireBurnerFireShotList;                           // 0x0058 (size: 0x10)

}; // Size: 0x80

class USBPlayerSkillController_GlitterMode : public USBPlayerSkillController
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBPlayerSkillController_GravityDive : public USBPlayerSkillController_BallShootBase
{
    char padding_0[0x7D8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x7D8

class USBPlayerSkillController_GravityShot : public USBPlayerSkillController_BallShootBase
{
    char padding_0[0x660];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x660

class USBPlayerSkillController_HatTrick : public USBPlayerSkillController
{
    char padding_0[0xA8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xA8

class USBPlayerSkillController_HateCollect : public USBPlayerSkillController
{
    char padding_0[0x70];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x70

class USBPlayerSkillController_HealBullet : public USBPlayerSkillController
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerSkillController_LancerMainAction : public USBPlayerSkillController
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBPlayerSkillController_LargeShield : public USBPlayerGuardSkillController
{
    FSBPlayingEffect m_ShieldEffect;                                                  // 0x03D8 (size: 0xC8)

}; // Size: 0x4E8

class USBPlayerSkillController_MultiShot : public USBPlayerSkillController
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerSkillController_PowerReload : public USBPlayerSkillController
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerSkillController_PowerShot : public USBPlayerSkillController_BallShootBase
{
    char padding_0[0x6A8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x6A8

class USBPlayerSkillController_PrepareStyle : public USBPlayerSkillController
{
    char padding_0[0x90];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x90

class USBPlayerSkillController_Protection : public USBPlayerSkillController
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBPlayerSkillController_QuickShot : public USBPlayerSkillController_BallShootBase
{
    char padding_0[0x678];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x678

class USBPlayerSkillController_RegularBallShoot : public USBPlayerSkillController_BallShootBase
{
    char padding_0[0x688];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x688

class USBPlayerSkillController_RegularBuffArrow : public USBPlayerSkillController
{
    char padding_0[0xA0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xA0

class USBPlayerSkillController_ResonanceSpear : public USBPlayerSkillController
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x78

class USBPlayerSkillController_ShieldDash : public USBPlayerGuardSkillController
{
    char padding_0[0x3F0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x3F0

class USBPlayerSkillController_SpearVisibility : public USBPlayerSkillController
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBPlayerSkillController_StoneBody : public USBPlayerGuardSkillController
{
    char padding_0[0x3B0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x3B0

class USBPlayerSkillController_SwingRush : public USBPlayerSkillController_BallShootBase
{
    char padding_0[0x6F0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x6F0

class USBPlayerSkillController_Taunt : public USBPlayerSkillController
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBPlayerSkillController_ThunderBeam : public USBPlayerSkillController
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBPlayerSkillController_ThunderMine : public USBPlayerSkillController
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x78

class USBPlayerSkillController_TnunderCloud : public USBPlayerSkillController
{
    TArray<FSBCreatedThunderCloudOption> m_ThunderCloudOptionList;                    // 0x0048 (size: 0x10)

}; // Size: 0x78

class USBPlayerSkillInActionEffectController : public USBPlayerSkillController
{
    TArray<FSBPlayingEffect> m_PlayingEffectList;                                     // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBPlayerSkillMarker : public USBPlayerActorComponent
{
    char padding_0[0x110];                                                            // 0x0000 (size: 0x0)

    void SetAimLocation(const FVector& Location);
    void NotifyMarkerOverlapped(bool bOverlapped);
    bool IsMarkerShown();
    bool IsFoundLocation();
    FVector GetAimLocation();
}; // Size: 0x110

class USBPlayerSortTypes : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBPlayerSortSave Data;                                                           // 0x0050 (size: 0x50)

}; // Size: 0xA0

class USBPlayerSpecialSkill : public USBPlayerActorComponent
{
    float GaugeSyncTime;                                                              // 0x00EC (size: 0x4)

    void ServerSetGauge(float Value);
    void ServerRequestSpecialSkillStart();
    void ServerNotifyCastSpecialSkill();
    void RequestSpecialSkillStart();
    bool IsGaugeFull();
    bool HasSpecialSkillRequestResult();
    float GetMaxGaugeDefault();
    float GetMaxGauge();
    float GetGaugeTimeChargeAmount();
    float GetCurrentGauge();
    void ClientSetGaugeAmountUnreliable(float GaugeAmount, uint8 ChargeID);
    void ClientSetGaugeAmount(float GaugeAmount, uint8 ChargeID);
    void ClientRespondSpecialSkillStart(bool bCanStart, ESBRequestSpecialSkillReason Reason);
    bool CanStartSpecialSkill();
}; // Size: 0x100

class USBPlayerStaminaSkillController : public USBPlayerSkillController
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBPlayerStampComponent : public USBPlayerPropertyComponent
{
    FSBPlayerStampComponentOnCompletedGetStampList OnCompletedGetStampList;           // 0x00B8 (size: 0x10)
    void OnCompletedGetStampList(int32 InRetCode, const TArray<FSBUnlockStampCategoryData>& StampList);
    FSBPlayerStampComponentOnValidStampDelegate OnValidStampDelegate;                 // 0x00C8 (size: 0x10)
    void OnValidStampDelegate(bool bValid, int32 StampId);
    FSBPlayerStampComponentOnValidStampListDelegate OnValidStampListDelegate;         // 0x00D8 (size: 0x10)
    void OnValidStampListDelegate(bool bValid, const TArray<int32>& StampIds);

    void Server_UnlockStamp(const TArray<int32>& StampIds);
    void Server_OnComplete(const TArray<FSBUnlockStampCategoryData>& InStampData, bool IsGetList, int32 InRetCode);
    void Server_CheckValidStampList(const TArray<int32>& StampIds);
    void Server_CheckValidStamp(int32 StampId);
    void Server_CheckUnlockStampData(const TArray<FSBUnlockStampCategoryData>& InClientStampData, bool IsGetList, int32 InRetCode);
    bool RequestGetStampList(class ASBPlayerController* InPlayerController);
    void OnValidStampListDelegate__DelegateSignature(bool bValid, const TArray<int32>& StampIds);
    void OnValidStampDelegate__DelegateSignature(bool bValid, int32 StampId);
    void OnCompletedGetStampList__DelegateSignature(int32 InRetCode, const TArray<FSBUnlockStampCategoryData>& StampList);
    bool IsPlayerStampPossession(int32 StampId);
    bool IsLimitedTimeStamp(int32 StampId);
    void GetUnlockTermStampDataList(TArray<FSBStampMasterData>& OutMasterDataList);
    TArray<FSBUnlockStampCategoryData> GetUnlockStampData();
    bool GetTermCategoryList(TArray<FSBStampCategoryMasterData>& OutTermCategoryDataList, TArray<int32> StampIds);
    bool GetStampTerm(int32 StampId, FDateTime& OutStartTime, FDateTime& OutEndTime);
    void Client_OnComplete(const TArray<FSBUnlockStampCategoryData>& InStampData, bool IsGetList, int32 InRetCode);
    void Client_CheckValidStampResult(bool IsValid, int32 StampId);
    void Client_CheckValidStampListResult(bool IsValid, const TArray<int32>& ValidStampIds);
    void Client_CheckUnlockStampData(const TArray<FSBUnlockStampCategoryData>& InServerStampData, bool IsGetList, int32 InRetCode);
    void CheckValidStampList(TArray<int32> StampIds);
    void CheckValidStamp(int32 StampId);
    bool CheckTermIdByList(TArray<int32> InStampIds, TArray<int32>& OutStampIds);
    bool CheckCategoryStampComplete(int32 CategoryId);
}; // Size: 0xF8

class USBPlayerStorageComponent : public USBPlayerPropertyComponent
{
    FSBPlayerStorageComponentOnSaveItemLockDelegate OnSaveItemLockDelegate;           // 0x00C0 (size: 0x10)
    void OnSaveItemLockDelegate(const bool Result, const TArray<FSBLockItemData>& LockItemData, const int32 InRetCode);
    FSBPlayerStorageComponentOnAddItemDelegate OnAddItemDelegate;                     // 0x00D0 (size: 0x10)
    void OnAddItemDelegate(int32 InRetCode, const TArray<FSBDiffItemInfo>& AddItemData, const TArray<FSBMasterReward>& OutRewardList, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    FSBPlayerStorageComponentOnSaveItemStorageDelegate OnSaveItemStorageDelegate;     // 0x00E0 (size: 0x10)
    void OnSaveItemStorageDelegate(const int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    FSBPlayerStorageComponentOnSaveItemBoxStorageDelegate OnSaveItemBoxStorageDelegate; // 0x00F0 (size: 0x10)
    void OnSaveItemBoxStorageDelegate(const int32 InRetCode, const FSBStorageItemBoxResultData& InItemBoxResultData);
    FSBPlayerStorageComponentOnCancelActiveItemDelegate OnCancelActiveItemDelegate;   // 0x0100 (size: 0x10)
    void OnCancelActiveItemDelegate(const int32 InRetCode, FString InId);
    FSBPlayerStorageComponentOnCompletedGetBagItemList OnCompletedGetBagItemList;     // 0x0110 (size: 0x10)
    void OnCompletedGetBagItemList(const int32 InRetCode, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds);
    FSBPlayerStorageComponentOnCompletedGetStorageItemList OnCompletedGetStorageItemList; // 0x0120 (size: 0x10)
    void OnCompletedGetStorageItemList(const bool bWasSuccessful, const TArray<FOwnItemInfo>& InDirtyItems, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds);
    FSBPlayerStorageComponentOnChangeCostumeDataDelegate OnChangeCostumeDataDelegate; // 0x0130 (size: 0x10)
    void OnChangeCostumeDataDelegate(const int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    char padding_0[0x8];                                                              // 0x0140 (size: 0x8)
    FSBPlayerStorageComponentOnCompletedGetRestoreItems OnCompletedGetRestoreItems;   // 0x0148 (size: 0x10)
    void OnCompletedGetRestoreItems(const int32 RetCode, int32 MaxPage, const TArray<FOwnItemInfo>& Items);
    int32 RestoreMaxPage;                                                             // 0x0158 (size: 0x4)
    int32 RestoreCurrentPage;                                                         // 0x015C (size: 0x4)
    bool bRequestItemNow;                                                             // 0x0160 (size: 0x1)
    bool bRequestCheerfulItemNow;                                                     // 0x0161 (size: 0x1)
    char padding_1[0x6];                                                              // 0x0162 (size: 0x6)
    FSBPlayerStorageComponentOnCompleted_MoveItemRequest OnCompleted_MoveItemRequest; // 0x0168 (size: 0x10)
    void OnCompleted_MoveList(bool IsSuccessed);
    FSBPlayerStorageComponentOnCompleted_ReleaseMovedItems OnCompleted_ReleaseMovedItems; // 0x0178 (size: 0x10)
    void OnCompleted_MoveList(bool IsSuccessed);
    FSBPlayerStorageComponentOnGetExpiredEquipmentDataGettedAtJoinDelegate OnGetExpiredEquipmentDataGettedAtJoinDelegate; // 0x0188 (size: 0x10)
    void OnGetExpiredEquipmentDataGettedAtJoinDelegate(const FSBExpiredEquipmentData& InExpiredEquipmentData);
    char padding_2[0x130];                                                            // 0x0198 (size: 0x130)
    TArray<FSBRecipeCondition> RepReleasedRecipes;                                    // 0x02C8 (size: 0x10)
    char padding_3[0x10];                                                             // 0x02D8 (size: 0x10)
    TArray<FSBActiveItemData> ActiveItems;                                            // 0x02E8 (size: 0x10)
    TArray<FOwnItemInfo> DelayConsumeItems;                                           // 0x02F8 (size: 0x10)
    TArray<FSBActiveItemData> ExpiryItems;                                            // 0x0308 (size: 0x10)
    FSBPlayerStorageComponentOnActiveItemaUpdateDelegate OnActiveItemaUpdateDelegate; // 0x0318 (size: 0x10)
    void OnActiveItemaUpdateDelegate();
    FSBPlayerStorageComponentOnCompletedRankingRewardDataListDelegate OnCompletedRankingRewardDataListDelegate; // 0x0328 (size: 0x10)
    void OnCompletedRankingRewardDataListDelegate(const int32 InRetCode, const TArray<FSBRankingRewardData>& RankingRewardDataList);

    void Server_SaveReleasedRecipes(const int32 RetCode, const TArray<FSBRecipeCondition>& InReleasedRecipes, bool bImmediateNotification);
    void Server_SaveItemStorage(EStorageApiType InApiType, const TArray<FSBStorageItemData>& InStorageItemData, int32 InToStorageNo);
    void Server_SaveItemLock(const TArray<FSBLockItemData>& InLockItemData);
    void Server_SaveItemBoxStorage(const FSBStorageItemBoxData& InStorageItemData);
    void Server_SaveExpIncreaseStorage(const TArray<FSBStorageItemData>& InStorageItemData);
    void Server_RequestRankingRewardDataList();
    void Server_RequestMovedItemList();
    void Server_Request_ReleaseMovedItemList();
    void Server_ParseStorageCapacity(int32 Type, int32 Capacity);
    void Server_OnSaveRankingRewardDataList(int32 InRetCode, const TArray<FSBRankingRewardData>& InRankingRewardDataList);
    void Server_OnSaveItemStorage(int32 InRetCode, const EStorageApiType InApiType, const FSBStorageItemAPIResponseData& InResponseData, const bool InOpenCommandMenuFlag);
    void Server_OnSaveItemLock(int32 InRetCode, const TArray<FSBLockItemData>& InLockItemData);
    void Server_OnSaveItemBoxStorage(int32 InRetCode, const FSBStorageItemBoxResultData& InItemBoxResultData);
    void Server_OnRequest_Restoreitems(class ASBPlayerController* InPlayerController, int32 Page);
    void Server_OnChangeCostumeData(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    void Server_OnAddItem(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    void Server_GetExpiredEquipmentDataGettedAtJoin();
    void Server_ChangeCostumeData(const TArray<FSBChangeCostumeData>& InChangeCostumeDataArray, const TArray<FSBStorageItemData>& InUseStorageItemDataArray, const TArray<FCharaEquipItemCharaCreateInfo>& InChangeCostumeCharaCreateInfos);
    void Server_CancelActiveItem(FString InId);
    void Server_AddItem(const TArray<FSBAddItemData>& InAddItemData, bool ForceAdd);
    void SaveReleasedRecipes(const TArray<FSBRecipeCondition>& InReleasedRecipes);
    void RequestRankingRewardDataList();
    bool Request_SaveItemUse(const FSBStorageItemData InStorageItemData);
    void Request_SaveItemsMove(const TArray<FSBStorageItemData> InStorageItemData, int32 ToStorageNo);
    void Request_SaveItemsDrop(const TArray<FSBStorageItemData> InStorageItemData);
    bool Request_SaveItemMove(const FSBStorageItemData InStorageItemData, int32 ToStorageNo);
    void Request_SaveItemLock(const TArray<FSBLockItemData> InLockItemData);
    bool Request_SaveItemDrop(const FSBStorageItemData InStorageItemData);
    void Request_SaveItemBoxUse(const FSBStorageItemBoxData InStorageItemData);
    void Request_ReleaseMovedItemList();
    void Request_MovedItemList();
    bool Request_GetStorageItemList(int32 StorageNo);
    void Request_GetRestoreItems(int32 Page);
    void Request_GetExpiredEquipmentDataGettedAtJoin();
    bool Request_GetBagItemList();
    void Request_ExpIncreaseUse(const FSBStorageItemData InStorageItemData);
    void Request_ExpIncreasesUse(const TArray<FSBStorageItemData>& InStorageItemDatas);
    bool Request_ChangeCostumeData(const class UObject* WorldContextObject, class USBEventScheduler* InEventScheduler, class USBColoringShopComponent* InColoringShopComp, const TArray<FSBChangeCostumeData>& InChangeCostumeDataArray, const TArray<FSBStorageItemData>& InUseStorageItemDataArray, const TArray<FCharaEquipItemCharaCreateInfo>& InChangeCostumeCharaCreateInfos);
    void Request_CancelActiveItem(const FString InId);
    void Request_AddItems(const TArray<FSBAddItemData>& InAddItemData, bool ForceAdd);
    void Request_AddItem(const FSBAddItemData InAddItemData, bool ForceAdd);
    void OnSaveItemStorageDelegate__DelegateSignature(const int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    void OnSaveItemLockDelegate__DelegateSignature(const bool Result, const TArray<FSBLockItemData>& LockItemData, const int32 InRetCode);
    void OnSaveItemBoxStorageDelegate__DelegateSignature(const int32 InRetCode, const FSBStorageItemBoxResultData& InItemBoxResultData);
    void OnRep_ReleasedRecipesData();
    void OnGetStorageItemList(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas);
    void OnGetExpiredEquipmentDataGettedAtJoinDelegate__DelegateSignature(const FSBExpiredEquipmentData& InExpiredEquipmentData);
    void OnGetBagItemList(int32 InRetCode, const TArray<FOwnItemInfo>& InItems, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas);
    void OnCompletedRankingRewardDataListDelegate__DelegateSignature(const int32 InRetCode, const TArray<FSBRankingRewardData>& RankingRewardDataList);
    void OnCompletedGetStorageItemList__DelegateSignature(const bool bWasSuccessful, const TArray<FOwnItemInfo>& InDirtyItems, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds);
    void OnCompletedGetRestoreItems__DelegateSignature(const int32 RetCode, int32 MaxPage, const TArray<FOwnItemInfo>& Items);
    void OnCompletedGetBagItemList__DelegateSignature(const int32 InRetCode, const bool bInIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds);
    void OnCompleted_MoveList__DelegateSignature(bool IsSuccessed);
    void OnChangeCostumeDataDelegate__DelegateSignature(const int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    void OnCancelActiveItemDelegate__DelegateSignature(const int32 InRetCode, FString InId);
    void OnAddItemDelegate__DelegateSignature(int32 InRetCode, const TArray<FSBDiffItemInfo>& AddItemData, const TArray<FSBMasterReward>& OutRewardList, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    void OnActiveItemaUpdateDelegate__DelegateSignature();
    void ItemExpiryNotification(int32 InItemID);
    bool IsThereExpiredEquipment(const FSBExpiredEquipmentData& InExpiredEquipmentData);
    bool IsRecastTime();
    bool IsActiveEfficacyType(const EItemEfficacyType InEfficacyType);
    bool IsActiveCheerfulItem();
    float GetRemainingRecastTime();
    TArray<FSBRecipeCondition> GetReleasedRecipes();
    float GetRecastTimeMax();
    int32 GetRecastItemIndex();
    void GetPrevPageRestoreItems();
    void GetNextPageRestoreItems();
    TArray<FSBActiveItemData> GetExpiryItems_BP();
    TArray<FSBActiveItemData> GetActiveItems_BP();
    void EmptyExpiryItems();
    int32 ConvertStorageNumberEquipmentBagToInt32();
    void Client_UpdateExpiryItems(const TArray<FSBActiveItemData>& InExpiryItems);
    void Client_UpdateActiveItems(const TArray<FSBActiveItemData>& InDirtyItems);
    void Client_SaveReleasedRecipes(const TArray<FSBRecipeCondition>& InReleasedRecipes, bool bImmediateNotification);
    void Client_SaveItemStorage(int32 InRetCode, const FSBStorageItemAPIResponseData& InResponseData, const FSBRecastTimeInfo& NewRecastTime, const bool InOpenCommandMenuFlag);
    void Client_SaveItemLock(int32 InRetCode, const TArray<FSBLockItemData>& InLockItemData);
    void Client_SaveItemBoxStorage(int32 InRetCode, const FSBStorageItemBoxResultData& InItemBoxResultData);
    void Client_Request_ReleaseMovedItemList();
    void Client_Request_MovedItemList(const FSBOwnItemListContainerData& IdentifiedData_Appraised, const FSBOwnItemListContainerData& IdentifiedData_Unidentified, const FSBOwnItemListContainerData& DeletedData_Appraised, const FSBOwnItemListContainerData& DeletedData_Unidentified, const int32 InSaleProfits);
    void Client_RankingRewardDataList(int32 InRetCode, const TArray<FSBRankingRewardData>& InRankingRewardDataList);
    void Client_ParseStorageCapacity(int32 Type, int32 Capacity);
    void Client_OnCompleted_Restoreitems(int32 RetCode, int32 MaxPage, const TArray<FOwnItemInfo>& Items);
    void Client_OnCancelActiveItem(const int32 InRetCode, FString InId, const TArray<FOwnItemInfo>& InResumeItems);
    void Client_GetExpiredEquipmentDataGettedAtJoin(const FSBExpiredEquipmentData& InExpiredEquipmentData);
    void Client_ChangeCostumeData(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    void Client_AddItem(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    void CallNotifyMessageReleasedRecipes();
}; // Size: 0x338

class USBPlayerSuperArmorPassiveSkill : public USBPlayerPassiveSkill
{
    int32 DamageAdjust;                                                               // 0x0048 (size: 0x4)

}; // Size: 0x50

class USBPlayerTargetingComponent : public USBPlayerActorComponent
{
    FTargetingInfo TargetingInfo;                                                     // 0x00E8 (size: 0x38)
    char padding_0[0x50];                                                             // 0x0120 (size: 0x50)
    class UDataTable* LockOnRangeInfoDataTable;                                       // 0x0170 (size: 0x8)

    void SetFrontFacing(bool InFrontFacing);
    void OnDelegated_UpdateAutoTargetSightFocus(bool bSightFocus);
    void OnDelegated_UpdateAutoTargetEnable(bool bEnable);
    bool IsTargetMulti();
    bool IsTargetLockOnSuspend();
    bool IsTargetLockOn();
    bool IsTargetAuto();
    bool IsEnableAutoTargetCursor();
}; // Size: 0x210

class USBPlayerTreasureBoxComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerTreasureBoxComponentOnAddDirectRewardItemDelegate OnAddDirectRewardItemDelegate; // 0x00B8 (size: 0x10)
    void OnAddDirectRewardItemDelegate(int32 InRetCode, const TArray<FSBDiffItemInfo>& AddItemData, const TArray<FSBMasterReward>& OutRewardList, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    char padding_0[0x50];                                                             // 0x00C8 (size: 0x50)
    FDateTime RequestTime;                                                            // 0x0118 (size: 0x8)
    bool IsInitRelocationTreasureBox;                                                 // 0x0120 (size: 0x1)

    void UpdateRespawnRequestTime();
    void SpawnTreasureBox(int32 TreasureId, ESBTreasureBoxRarity Rarity);
    void SpawnDestructibleObjectDrop(FString ClassName, int32 TreasureId, FVector SpawnLocation, int32 MinMoney, int32 MaxMoney, ESBTreasureBoxRewardType DropTreasureReward);
    void SimulateOpenTreasureBox(int32 TreasureId, int32 OpenCount);
    void ServerUpdateRespawnTime(const FSBTreasureBoxRespawnInfo& RespawnInfo);
    void ServerSpawnTreasureBox(FString ClassName, int32 TreasureBoxId, ESBTreasureBoxRarity Silver);
    void ServerSpawnDestructibleObjectDrop(FString ClassName, int32 TreasureBoxId, FVector SpawnLocation, int32 MinMoney, int32 MaxMoney, ESBTreasureBoxRewardType DropTreasureReward);
    void ServerSimulateOpenTreasureBox(int32 TreasureBoxId, int32 OpenCount);
    void ServerOpenTreasureBox(FString ObjectId);
    void ServerForceSpawnRandomTreasureBox();
    void ServerDirectTreasureBox(FString Tag, int32 TreasureBoxId, ESBTreasureBoxRarity TreasureBoxRarity, int32 MinMoney, int32 MaxMoney);
    void OnAddMoneyFinished(bool Result, int32 AddMoney);
    void OnAddItemFinishedByDB(int32 InRetCode, const TArray<FSBDiffItemInfo>& AddItemDatas, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    void OnAddItemFinished(int32 InRetCode, const TArray<FSBDiffItemInfo>& AddItemData, const TArray<FSBMasterReward>& OutRewardList, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    void OnAddDirectRewardItemDelegate__DelegateSignature(int32 InRetCode, const TArray<FSBDiffItemInfo>& AddItemData, const TArray<FSBMasterReward>& OutRewardList, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    void ForceSpawnRandomTreasureBox();
    void DestroyTreasureBoxByEnemyDrop();
    void DebugDrawTreasureBoxInfo(bool bEnable);
    void ClientSimulateOpenTreasureBox(ESBTreasureBoxLotResult Result, int32 TreasureBoxId, const TArray<FSBTreasureBoxLotSimulateResult>& Results);
    void ClientRelocationTreasureBox(const TArray<FSBTreasureBoxEntryInfo>& ObjectIds, int32 TreasureSpotNum, int32 TreasureSpotNum2, ESBTreasureBoxRewardType DropTreasureReward);
    void ClientOpenTreasureBox(ESBTreasureBoxLotResult Result, FString ObjectId, const TArray<FSBTreasureBoxLotResult>& LotResults, FString Tag, int32 RetCode, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    void ClientNotifyMessage(FString Message, FString TreasureBoxTag, int32 TreasureId);
    void ClientDestroyTreasureBox();
}; // Size: 0x160

class USBPlayerUIComponent : public USceneComponent
{
    char padding_0[0x210];                                                            // 0x0000 (size: 0x0)

    void SetEndEscapeConfirmation(bool IsEnd);
    void Server_RaidBattleGateStatusPut(FString GateName);
    void NotifyCastSkill(ESkillActionPosition InSkillPosition);
    void EndRespawnMenu();
    void DebugPlayGashaSpecialCut(const ESBRarity InDemoRarity, const ESBRarity InActualRarity);
    void DebugPlayGashaDemo(const FSBGashaResultData& InResultData, const bool bInSkip);
    void Client_RaidBattleGateStatusPut(bool Hit, FString GateName, FString ServerDungeonId, FString ServerTermId, const bool IsInitialize);
    void BP_UpdateRespawnGauge();
    void BP_ShowSerialKillMessage(const int32 InKillCount);
    void BP_ShowRespawnBattleArea();
    void BP_ShowRespawn(const float RespawnTime);
    void BP_ShowKillMessage(const class AActor* InOtherActor);
    void BP_ShowKillMark();
    void BP_ShowJankenWindow();
    void BP_ShowCombo(const int32 InComboNum);
    void BP_EscapeConfirmation();
    void BP_DisableRespawn();
}; // Size: 0x210

class USBPlayerVirtualDateTimeComponent : public UActorComponent
{
    ESBEventTermVirtualDateType Type;                                                 // 0x00B8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x00B9 (size: 0x7)
    FDateTime NowTime;                                                                // 0x00C0 (size: 0x8)
    FDateTime StartTime;                                                              // 0x00C8 (size: 0x8)

    ESBEventTermVirtualDateType GetType();
    FDateTime GetStartTime();
    int32 GetParam(ESBVirtualDateTimeParam Param);
    FDateTime GetNowTime();
}; // Size: 0xD0

class USBPlayerWarpComponent : public USBPlayerActorComponent
{
    float DefaultWarpLoopMotionTime;                                                  // 0x00D8 (size: 0x4)
    float DefaultWarpStartToFadeOutTime;                                              // 0x00DC (size: 0x4)
    class UCurveFloat* WarpInCameraDistanceCurve;                                     // 0x00E0 (size: 0x8)
    class UCurveVector* WarpInCameraLocationCurve;                                    // 0x00E8 (size: 0x8)
    class UCurveVector* WarpInCameraRotationCurve;                                    // 0x00F0 (size: 0x8)
    float WarpInCameraFadeInTime;                                                     // 0x00F8 (size: 0x4)
    float WarpInCameraFadeInDelayTime;                                                // 0x00FC (size: 0x4)
    float WarpInCameraEndBlendDurationTIme;                                           // 0x0100 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0104 (size: 0x4)
    class UCurveFloat* WarpOutCameraDistanceCurve;                                    // 0x0108 (size: 0x8)
    class UCurveVector* WarpOutCameraLocationCurve;                                   // 0x0110 (size: 0x8)
    class UCurveVector* WarpOutCameraRotationCurve;                                   // 0x0118 (size: 0x8)
    float WarpOutCameraFadeOutTime;                                                   // 0x0120 (size: 0x4)
    float WarpOutCameraFadeOutDelayTime;                                              // 0x0124 (size: 0x4)
    float WarpOutDisappearEffectDelayTime;                                            // 0x0128 (size: 0x4)
    char padding_1[0x4];                                                              // 0x012C (size: 0x4)
    class UCurveFloat* CityExitCameraDistanceCurve;                                   // 0x0130 (size: 0x8)
    class UCurveVector* CityExitCameraLocationCurve;                                  // 0x0138 (size: 0x8)
    class UCurveVector* CityExitCameraRotationCurve;                                  // 0x0140 (size: 0x8)
    float CityExitCameraFadeOutTime;                                                  // 0x0148 (size: 0x4)
    float CityExitCameraFadeOutDelayTime;                                             // 0x014C (size: 0x4)
    float CityExitCameraFadeInTime;                                                   // 0x0150 (size: 0x4)
    float CityExitCameraFadeInDelayTime;                                              // 0x0154 (size: 0x4)
    float FieldSheatheCameraFadeOutTime;                                              // 0x0158 (size: 0x4)
    char padding_2[0x4];                                                              // 0x015C (size: 0x4)
    class UCurveFloat* CityEnterCameraDistanceCurve;                                  // 0x0160 (size: 0x8)
    class UCurveVector* CityEnterCameraLocationCurve;                                 // 0x0168 (size: 0x8)
    class UCurveVector* CityEnterCameraRotationCurve;                                 // 0x0170 (size: 0x8)
    float CityEnterCameraFadeInTime;                                                  // 0x0178 (size: 0x4)
    float CityEnterCameraFadeInDelayTime;                                             // 0x017C (size: 0x4)
    float CityEnterCameraEndBlendDurationTIme;                                        // 0x0180 (size: 0x4)
    float LocalWarpInEffectDelayTime;                                                 // 0x0184 (size: 0x4)
    float LocalWarpInCanInputDelayTime;                                               // 0x0188 (size: 0x4)
    float LoginCameraFadeInTime;                                                      // 0x018C (size: 0x4)
    float LoginCameraFadeInDelayTime;                                                 // 0x0190 (size: 0x4)
    float LogoutCameraFadeOutTime;                                                    // 0x0194 (size: 0x4)
    float LogoutCameraFadeOutDelayTime;                                               // 0x0198 (size: 0x4)
    float LocalWarpEffectSimpleTimeScale;                                             // 0x019C (size: 0x4)
    float WorldWarpWaitTime;                                                          // 0x01A0 (size: 0x4)
    float WarpLoopMotionTime;                                                         // 0x01A4 (size: 0x4)
    float WarpStartToFadeOutTime;                                                     // 0x01A8 (size: 0x4)
    char padding_3[0x1C];                                                             // 0x01AC (size: 0x1C)
    FSBPlayingEffect m_WarpShowEffect;                                                // 0x01C8 (size: 0xC8)
    char padding_4[0x100];                                                            // 0x0290 (size: 0x100)
    FSBPlayerWarpComponentOnLocalWarpEndDelegate OnLocalWarpEndDelegate;              // 0x0390 (size: 0x10)
    void OnLocalWarpEndDelegate();
    FSBPlayerWarpComponentOnWarpFailedDelegate OnWarpFailedDelegate;                  // 0x03A0 (size: 0x10)
    void OnWarpFailedDelegate();

    void ShowCountDownUI();
    void SetUIVisibilityByWarpAroundEffect(bool bIsVisible);
    void SetPlayerGodModeByWarpAroundEffect(bool bIsModeActive);
    void SetCannotInputByWarpAroundEffect(bool bIsCannotInput);
    void ServerRequestLocalWarpToLocation(FSBWarpDestinationLocationInfo WarpDestination, bool bForceWarp, bool bNoWarpAroundEffect, bool bWarpEffectSimple, class ASBFieldActorWarpPoint* WarpPoint);
    void ServerNotifyRequestWarp(int64 startGameTime, float WarpWaitTime, float GodModeActiveTime);
    void ServerNotifyCancelWarp(bool bForceCancel);
    void ServerAllPartyMemberLocalWarpToLocation(FSBWarpDestinationLocationInfo WarpDestination, bool bForceWarp, bool bNoWarpAroundEffect, bool bWarpEffectSimple, class ASBFieldActorWarpPoint* WarpPoint);
    void ResetWarpFlags(class ASBPlayerController* PlayerController);
    bool RequestWarpDisapearFlagSet(bool sw, float DelayTime);
    bool RequestWarp(const FName& InDestWarpPointId, const int32 InPassageCost, class ASBFieldActorWarpPoint* WarpPoint);
    bool RequestTravelToOnlinePlayerSessionByWarpType(TScriptInterface<class ISBOnlinePlayerState> TargetPlayer, const ESBPlayerWarpType InWarpType);
    bool RequestTravelToOnlinePlayerSessionByFriendCharacterId(FString FriendCharacterId, const ESBPlayerWarpType InWarpType);
    bool RequestTravelToOnlinePlayerSession(TScriptInterface<class ISBOnlinePlayerState> TargetPlayer);
    bool RequestLocalWarpToLocation(FVector ToWarpLocation, FRotator ToWarpRotation, FRotator AfterCameraRotation, float AppearRandomDistanceX, float AppearRandomDistanceY, bool bShowCountDown, bool bNoWarpAroundEffect, bool bWarpEffectSimple, class ASBFieldActorWarpPoint* WarpPoint);
    bool RequestFieldTravelFullStatus(const FName& InTravelFieldId, FString InTravelMapName, FString InTravelPortal, const bool InIsKeepLocationTravel, bool InIsSpawnEffect, bool InIsDisappearEffect, bool InIsCityEntrance, const FVector InDemoTargetLocation, const FVector InTravelFailedReturnLocation);
    bool RequestFieldTravel(class ASBFieldTravelTrigger* FieldTravelTrigger);
    bool RequestDungeonResultWarp();
    bool RequestAllPartyMemberLocalWarpToLocation(FVector ToWarpLocation, FRotator ToWarpRotation, FRotator AfterCameraRotation, float AppearRandomDistanceX, float AppearRandomDistanceY, bool bForceWarp, bool bNoWarpAroundEffect, bool bWarpEffectSimple, class ASBFieldActorWarpPoint* WarpPoint);
    void OnWarpFailedDelegate__DelegateSignature();
    void OnLocalWarpEndDelegate__DelegateSignature();
    void MovedWarpEffectAction();
    bool IsWaitTimeDone();
    bool IsCountDownUICancelPressed();
    void HideCountDownUI();
    uint8 GetWarpState();
    bool GetWarpCancelFlag();
    bool GetTravelWarpFlag();
    float GetRemainWarpWaitTime();
    bool GetLocalWarpFlag();
    void FieldTravelFailedAfterProcess();
    void FadeInOutByWarpAroundEffect(float FadeInOutTime, bool bIsFadeIn);
    void EndLoadCompletePlayerToVillageFunction();
    void ClientRequestLocalWarpToLocation(FSBWarpDestinationLocationInfo WarpDestination, bool bForceWarp, bool bNoWarpAroundEffect, bool bWarpEffectSimple, class ASBFieldActorWarpPoint* WarpPoint);
}; // Size: 0x3B0

class USBPlayerWarpPointComponent : public USBPlayerPropertyComponent
{
    FSBPlayerWarpPointComponentOnChangedDataDelegate OnChangedDataDelegate;           // 0x00B8 (size: 0x10)
    void OnChangedDataDelegate();

    void ServerAddActivate(FString WarpPointId, bool bRemove);
    void ServerActivateWarpPoint(class ASBFieldActorWarpPoint* WarpPoint);
    bool RequestAddActivate(FName WarpPointId);
    void OnChangedDataDelegate__DelegateSignature();
    bool IsActivatedWarpPoint(FName WarpPointId);
    bool IsActivatedMap(FName ZoneId);
    void GetWarpPoints(TArray<FName>& OutArray);
    void Client_OnSaveWarpPointComplete(const TArray<FName>& InActivates, bool bInWasSuccessful);
}; // Size: 0xF8

class USBPlayerWeaponComponent : public USBPlayerPropertyComponent
{
    FSBPlayerWeaponComponentOnUseAppearanceWeaponStickerDelegate OnUseAppearanceWeaponStickerDelegate; // 0x00B8 (size: 0x10)
    void OnUseAppearanceWeaponStickerDelegate(const int32 InRetCode, FString InStickerUsedWeaponUniqueId, const bool InIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InExpiredStickerWeaponItemDatas);
    FSBPlayerWeaponComponentOnRemoveAppearanceWeaponStickerDelegate OnRemoveAppearanceWeaponStickerDelegate; // 0x00C8 (size: 0x10)
    void OnRemoveAppearanceWeaponStickerDelegate(const int32 InRetCode, FString InStickerRemovedWeaponUniqueId, const bool InIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InExpiredStickerWeaponItemDatas);
    TArray<FString> RepExpiredStickerWeaponUniqueIdInfos;                             // 0x00D8 (size: 0x10)

    void Server_UseAppearanceWeaponSticker(FString InWeaponUniqueId, FString InStickerUniqueId, const bool InIsUsingToEquippedWeapon);
    void Server_RemoveAppearanceWeaponSticker(FString InWeaponUniqueId, FString InRemoveItemUniqueId, const bool InIsUsingRemoveItem, const bool InIsRemovingFromEquippedWeapon);
    void Server_OnUseAppearanceWeaponSticker(const int32 InRetCode, FString InDirtyStickerUsedWeaponUniqueId, const FSBWeaponItemData& InDirtyStickerUsedWeaponItemData, const TArray<FOwnItemInfo>& InDirtyUsedItemInfos, const TArray<FOwnItemInfo>& InExpiredItemInfos, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const bool InIsUsingToEquippedWeapon);
    void Server_OnRemoveAppearanceWeaponSticker(const int32 InRetCode, FString InDirtyStickerUsedWeaponUniqueId, const FSBWeaponItemData& InDirtyStickerRemovedWeaponItemData, const TArray<FOwnItemInfo>& InDirtyUsedItemInfos, const TArray<FOwnItemInfo>& InDirtyAddedItemInfos, const TArray<FOwnItemInfo>& InExpiredItemInfos, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const bool InIsRemovingFromEquippedWeapon);
    void Request_UseAppearanceWeaponSticker(FString InWeaponUniqueId, FString InStickerUniqueId, const bool InIsUsingToEquippedWeapon);
    void Request_RemoveAppearanceWeaponSticker(FString InWeaponUniqueId, FString InRemoveItemUniqueId, const bool InIsUsingRemoveItem, const bool InIsRemovingFromEquippedWeapon);
    void OnUseAppearanceWeaponStickerDelegate__DelegateSignature(const int32 InRetCode, FString InStickerUsedWeaponUniqueId, const bool InIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InExpiredStickerWeaponItemDatas);
    void OnRep_ExpiredStickerWeaponUniqueIdInfos();
    void OnRemoveAppearanceWeaponStickerDelegate__DelegateSignature(const int32 InRetCode, FString InStickerRemovedWeaponUniqueId, const bool InIsExpiredStickerWeapons, const TArray<FString>& InExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InExpiredStickerWeaponItemDatas);
    TArray<FString> GetExpiredWeaponStickerInfosGettedAtJoin();
    void Client_OnUseAppearanceWeaponSticker(const int32 InRetCode, FString InDirtyStickerUsedWeaponUniqueId, const FSBWeaponItemData& InDirtyStickerUsedWeaponItemData, const TArray<FOwnItemInfo>& InDirtyUsedItemInfos, const TArray<FOwnItemInfo>& InExpiredItemInfos, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const bool InIsUsingToEquippedWeapon);
    void Client_OnRemoveAppearanceWeaponSticker(const int32 InRetCode, FString InDirtyStickerRemovedWeaponUniqueId, const FSBWeaponItemData& InDirtyStickerRemovedWeaponItemData, const TArray<FOwnItemInfo>& InDirtyUsedItemInfos, const TArray<FOwnItemInfo>& InDirtyAddedItemInfos, const TArray<FOwnItemInfo>& InExpiredItemInfos, const TArray<FString>& InDirtyExpiredStickerWeaponUniqueIds, const TArray<FSBWeaponItemData>& InDirtyExpiredStickerWeaponItemDatas, const bool InIsRemovingFromEquippedWeapon);
}; // Size: 0x100

class USBPlayerWeaponEnhancementComponent : public USBPlayerControllerComponentBase
{
    FSBPlayerWeaponEnhancementComponentOnFinishedWeaponMerge OnFinishedWeaponMerge;   // 0x00B8 (size: 0x10)
    void OnFinished_WeaponMerge(const int32 ErrorCode, const bool bWasSuccessful, const FOwnItemInfo& Info);
    FSBPlayerWeaponEnhancementComponentWeaponPerkSlotUnlockCallback WeaponPerkSlotUnlockCallback; // 0x00C8 (size: 0x10)
    void OnFinished_UnlockPerkSlot(const int32 ErrorCode, const bool bWasSuccessful, const FOwnItemInfo& Info);
    FSBPlayerWeaponEnhancementComponentWeaponAbilityRemovedCallback WeaponAbilityRemovedCallback; // 0x00D8 (size: 0x10)
    void OnFinished_PerkDelete(const int32 ErrorCode, const bool bWasSuccessful, const FOwnItemInfo& Info);
    FSBPlayerWeaponEnhancementComponentWeaponTuningCallback WeaponTuningCallback;     // 0x00E8 (size: 0x10)
    void OnFinished_PerkRebuild(const int32 ErrorCode, const bool bWasSuccessful, const FOwnItemInfo& Info);
    FSBPlayerWeaponEnhancementComponentOnComplete_MasterFusionCost OnComplete_MasterFusionCost; // 0x00F8 (size: 0x10)
    void OnCOmpleted_MasterDataLoad(bool bSuccess);
    FSBPlayerWeaponEnhancementComponentOnComplete_MasterFusionTicket OnComplete_MasterFusionTicket; // 0x0108 (size: 0x10)
    void OnCOmpleted_MasterDataLoad(bool bSuccess);

    void Server_WeaponTuning(class ASBPlayerController* InPlayerController, FString WeaponUID, int32 TuningTokenID, int32 ProtectTokenID, const TArray<int32>& Slots);
    void Server_WeaponMerge(class ASBPlayerController* InPlayerController, FString WeaponUID, FString ImagineUID);
    void Server_WeaponAbilityRemove(class ASBPlayerController* InPlayerController, FString WeaponUID, int32 TokenID, const TArray<int32>& Slots);
    void Server_UnlockWeaponPerkSlot(class ASBPlayerController* InPlayerController, FString WeaponUID, int32 TokenID);
    void Server_FusionWeapon(class ASBPlayerController* InPlayerController, FString WeaponUID, const TArray<int32>& FusionItemIds);
    void Request_WeaponTuning(FString WeaponUID, int32 TuningTokenID, int32 ProtectTokenID, const TArray<int32>& Slots);
    void Request_WeaponMerge(FString WeaponUID, FString ImagineUID);
    void Request_WeaponAbilitryRemove(FString WeaponUID, int32 TokenID, const TArray<int32>& Slots);
    void Request_UnlockWeaponPerkSlot(FString WeaponUID, int32 TokenID);
    void Request_MasterData_FusionTicket();
    void Request_MasterData_FusionCost();
    void Request_FusionWeapon(FString WeaponUID, const TArray<int32>& FusionItemIds);
    void OnFinished_WeaponMerge__DelegateSignature(const int32 ErrorCode, const bool bWasSuccessful, const FOwnItemInfo& Info);
    void OnFinished_UnlockPerkSlot__DelegateSignature(const int32 ErrorCode, const bool bWasSuccessful, const FOwnItemInfo& Info);
    void OnFinished_PerkRebuild__DelegateSignature(const int32 ErrorCode, const bool bWasSuccessful, const FOwnItemInfo& Info);
    void OnFinished_PerkDelete__DelegateSignature(const int32 ErrorCode, const bool bWasSuccessful, const FOwnItemInfo& Info);
    void OnCOmpleted_MasterDataLoad__DelegateSignature(bool bSuccess);
    bool IsLoadedMasterFusionCost();
    FSBFusionTicketMasterData GetTickets(const ESBFusionTicketType& Type, int32 WeaponLevel);
    FSBFusionCostMasterData GetCost(int32 Level);
    void Client_OnFinished_WeaponTuning(int32 RetCode, bool bWasSuccessful, const FOwnItemInfo& Weapon, const TArray<FSBCharacterToken>& Tokens);
    void Client_OnFinished_WeaponPerkSlotUnlock(int32 RetCode, bool bWasSuccessful, const FOwnItemInfo& Weapon, const TArray<FSBCharacterToken>& Token);
    void Client_OnFinished_WeaponMerge(int32 ErrorCode, bool bWasSuccessful, const TArray<FOwnItemInfo>& Infos, FString WeaponUID, const int32 Money);
    void Client_OnFinished_WeaponAbilityRemove(int32 RetCode, bool bWasSuccessful, const FOwnItemInfo& Weapon, const TArray<FOwnItemInfo>& RecycleItems, const TArray<FSBCharacterToken>& Tokens);
    void Client_OnFinished_FusionWeapon(int32 ErrorCode, bool bWasSuccessful, const FOwnItemInfo& Weapon, const TArray<FOwnItemInfo>& Items, const int32 Money);
}; // Size: 0x118

class USBPlaylog : public UObject
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x58

class USBProfileBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBProfilePlayerState* GetProfilePlayerState(class UObject* WorldContextObject, FString CharacterId);
}; // Size: 0x28

class USBProfileManager : public UObject
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x78

class USBProfilePlayerState : public UObject
{
    FUniqueNetIdRepl UniqueId;                                                        // 0x0030 (size: 0x28)

    bool IsActive();
    bool HasOnlineStatus(ESBOnlineStatus InOnlineStatus);
    FString GetZoneId();
    bool GetProfileMenuDataForBP(FPlayerProfileMenuDetailData& OutData);
    ESBTensionTagType GetMoodIconId();
    FText GetDisplayName();
    bool CanJump();
}; // Size: 0xA8

class USBProjectileAreaAttackComponent : public USBProjectileRapidComponent
{
    float EffectiveRadius;                                                            // 0x0140 (size: 0x4)
    EProjectileAreaAttackSpawnOrder Order;                                            // 0x0144 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0145 (size: 0x3)
    uint8 bIsUpperSphere;                                                             // 0x0148 (size: 0x1)
    uint8 bIsAdjustGround;                                                            // 0x0148 (size: 0x1)

}; // Size: 0x160

class USBProjectileAssetLoader : public UActorComponent
{
    TArray<FSBProjectileMasterInfo> ProjectileBuildResource;                          // 0x00B8 (size: 0x10)

}; // Size: 0xD8

class USBProjectileAttachToActorBaseComponent : public UActorComponent
{
    FProjectileAttachInfo AtachInfo;                                                  // 0x00C8 (size: 0x40)

}; // Size: 0x108

class USBProjectileAttachToActorComponent : public USBProjectileAttachToActorBaseComponent
{
    char padding_0[0x108];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x108

class USBProjectileAttachToActorOnHitComponent : public USBProjectileAttachToActorBaseComponent
{
    char padding_0[0x108];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x108

class USBProjectileAttackParamComponent : public UActorComponent
{
    TArray<TWeakObjectPtr<USceneComponent>> TargetCompList;                           // 0x00D0 (size: 0x10)
    FVector_NetQuantize TargetPoint;                                                  // 0x00E0 (size: 0xC)
    uint8 bValidTargetPoint;                                                          // 0x00EC (size: 0x1)
    char padding_0[0x3];                                                              // 0x00ED (size: 0x3)
    FVector_NetQuantize TargetVectorOnSpawn;                                          // 0x00F0 (size: 0xC)
    float Speed;                                                                      // 0x00FC (size: 0x4)
    FVector_NetQuantizeNormal Direction;                                              // 0x0100 (size: 0xC)
    float PenetrateObstacleTime;                                                      // 0x010C (size: 0x4)
    TArray<class AActor*> IgnoreHitActorList;                                         // 0x0110 (size: 0x10)
    FVector_NetQuantize ReplicatedVelocity;                                           // 0x0120 (size: 0xC)
    char padding_1[0x10];                                                             // 0x012C (size: 0x10)
    float RequestServerOnlyFixDamage;                                                 // 0x013C (size: 0x4)
    float RequestServerOnlyRateDamage;                                                // 0x0140 (size: 0x4)
    float InitCollisionScale;                                                         // 0x0144 (size: 0x4)

    void OnRep_TargetPoint();
    void OnRep_TargetableComp();
    void OnRep_Speed();
    void OnRep_Direction();
    FVector GetInitialDirection();
}; // Size: 0x148

class USBProjectileBDFObjectComponent : public UActorComponent
{
    TMap<class ESBProjectileBDFRotType, class FSBProjectileSelectHandle> BDFProjectileHandleList; // 0x00B8 (size: 0x50)

    bool SpawnProjectileHandle(FSBProjectileSelectHandle ProjectileHandle);
    bool SpawnChainBeamProjectile(ESBProjectileBDFRotType RotType);
    bool OwnerHasAuthority();
    void Multicast_SwitchMesh();
    void Multicast_Initialize(const ESBBDFObjectType ObjType);
    void Multicast_Detach();
    void Multicast_Destroy();
    void Multicast_Dead();
    void Multicast_Collect();
    void Multicast_Attach(FString SocketName);
    void EndOverlap(class AActor* OverlapActor);
    void DestroyChainBeamProjectile();
    void BP_SwitchMesh();
    void BP_Initialize(ESBBDFObjectType ObjType);
    void BP_Detach();
    void BP_Destroy();
    void BP_Dead();
    void BP_Collect();
    void BP_Attach(FString SocketName);
    void BeginOverlap(class AActor* OverlapActor);
}; // Size: 0x118

class USBProjectileBPFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool SpawnProjectileProfessional(class AActor* ExecActor, FDataTableRowHandle Handle, FName UniqueName, class AActor* OwnerActor, class APawn* InstigatorPawn, class AActor* Spawner, bool bManage);
    bool SpawnProjectileDefOnSpawnerOffsetPos(class APawn* InstigatorPawn, FDataTableRowHandle Handle, class AActor* Spawner, const FVector& InOffsetPos);
    bool SpawnProjectileDefOnSpawner(class APawn* InstigatorPawn, FDataTableRowHandle Handle, class AActor* Spawner);
    bool SpawnEmitterAttachByEffectID(class AActor* ExecActor, EEffectId ID, class USceneComponent* AttachComp, ESBEffectVisibleType VisibleType, FName AttachPointName, FVector Location, FRotator Rotation, float ScaleValue, TEnumAsByte<EAttachLocation::Type> LocationType, bool bAutoDestroy);
    bool RequestSpawnProjectileOrderedBySystem(class AActor* ExecActor, class AActor* OwnerPawn, class APawn* InstigatorPawn, FDataTableRowHandle Handle, class AActor* Spawner);
    int32 GetProjectileActiveListNumALL(const class ASBCharacter* InProjectileInstigator);
    int32 GetProjectileActiveListNum(const FDataTableRowHandle& InProjectileHandle, const class ASBCharacter* InProjectileInstigator);
    void EditorLoadSyncProjectileBuildResource(class UDataTable* ProjectileConfig, class UDataTable* ProjectileEffect);
    void DisableAutoDestroyEffect();
    bool DestroyProjectileForManage(class AActor* ExecActor);
}; // Size: 0x28

class USBProjectileBeamCollisionComponent : public USBProjectileCollisionComponent
{
    char padding_0[0x340];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x340

class USBProjectileBeamComponent : public UActorComponent
{
    TSoftObjectPtr<UParticleSystem> ConfigBeamMainParticle;                           // 0x0108 (size: 0x28)
    TSoftObjectPtr<UParticleSystem> ConfigBeamEndParticle;                            // 0x0130 (size: 0x28)

}; // Size: 0x158

class USBProjectileBeamImpactComponent : public USBProjectileRapidComponent
{
    char padding_0[0x180];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x180

class USBProjectileBoxComponent : public UBoxComponent
{
    char padding_0[0x4C0];                                                            // 0x0000 (size: 0x0)

    void OnAttackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    void OnAttackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
}; // Size: 0x4C0

class USBProjectileCapsuleComponent : public UCapsuleComponent
{
    char padding_0[0x4B0];                                                            // 0x0000 (size: 0x0)

    void OnAttackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    void OnAttackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
}; // Size: 0x4B0

class USBProjectileChainMovementParamAlongGround : public USBProjectileChainMovementParamStraight
{
    FSBProjectileAlongGroundParameter AlongGroundConfig;                              // 0x00B0 (size: 0x1C)

}; // Size: 0xD0

class USBProjectileChainMovementParamBase : public UDataAsset
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBProjectileChainMovementParamMovementMagnet : public USBProjectileChainMovementParamBase
{
    FName MagnetSpawnerSocketName;                                                    // 0x0030 (size: 0x8)
    float InitSpeed;                                                                  // 0x0038 (size: 0x4)
    float AccelSpeed;                                                                 // 0x003C (size: 0x4)
    float MaxSpeed;                                                                   // 0x0040 (size: 0x4)
    float DecelerationStartDistance;                                                  // 0x0044 (size: 0x4)
    float DecelerationSpeed;                                                          // 0x0048 (size: 0x4)
    float RotateLerpRate;                                                             // 0x004C (size: 0x4)

}; // Size: 0x50

class USBProjectileChainMovementParamSimulatePhysics : public USBProjectileChainMovementParamBase
{
    bool bIsVelocityTakeover;                                                         // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    FVector LaunchVelocity;                                                           // 0x0034 (size: 0xC)
    float LinearDamping;                                                              // 0x0040 (size: 0x4)
    float AngularDamping;                                                             // 0x0044 (size: 0x4)
    float FakeGravityZ;                                                               // 0x0048 (size: 0x4)
    float MaxVelocity;                                                                // 0x004C (size: 0x4)

}; // Size: 0x50

class USBProjectileChainMovementParamStraight : public USBProjectileChainMovementParamBase
{
    FProjectileMoveBaseConfig MoveBaseConfig;                                         // 0x0030 (size: 0x40)
    FProjectileHomingConfig MoveHomingConfig;                                         // 0x0070 (size: 0x40)

}; // Size: 0xB0

class USBProjectileCollisionComponent : public USceneComponent
{
    TArray<FValidHitOverlapActorInfo> ValidHitOverlapActorInfoList;                   // 0x0250 (size: 0x10)
    char padding_0[0x18];                                                             // 0x0260 (size: 0x18)
    TArray<class UPrimitiveComponent*> CollisionList;                                 // 0x0278 (size: 0x10)
    char padding_1[0x8];                                                              // 0x0288 (size: 0x8)
    FBlockingCollisionActor BlockingCollisionInfo;                                    // 0x0290 (size: 0x4)
    char padding_2[0xC];                                                              // 0x0294 (size: 0xC)
    FCollisionHitSettingExtended CacheCollisionHitSettingExtended;                    // 0x02A0 (size: 0x30)
    TArray<FCollisionOnOffData> CacheCollisionOnOffDataList;                          // 0x02D0 (size: 0x10)
    FVector ScaleVector;                                                              // 0x02E0 (size: 0xC)
    uint8 ScaleVectorFromZero;                                                        // 0x02EC (size: 0x1)
    char padding_3[0x3];                                                              // 0x02ED (size: 0x3)
    class UCurveBase* ScaleCurve;                                                     // 0x02F0 (size: 0x8)
    uint8 bIsInheritanceInstigatorScale;                                              // 0x02F8 (size: 0x1)

    void SetCollisionEnableMode(const ESBProjectileCollisionSpecificGroup SpecificGroup, bool bEnable);
    void OnAttackEndOverlap(class USceneComponent* HitSelfComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    void OnAttackBeginOverlap(class USceneComponent* HitSelfComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    int32 GetHitNum();
}; // Size: 0x300

class USBProjectileDebugComponent : public UActorComponent
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC8

class USBProjectileDestroyConditionComponent : public UActorComponent
{
    char padding_0[0xD8];                                                             // 0x0000 (size: 0x0)

    void SetDestroyEnableModeByStageHit(bool bIsEnable);
    void RequestDestroyMyself();
}; // Size: 0xD8

class USBProjectileEffectComponent : public USceneComponent
{
    FParticleParameter ParticleParam;                                                 // 0x0210 (size: 0x90)
    FEffectActorParameter EffectActorParam;                                           // 0x02A0 (size: 0x60)
    float SpawnDelayTime;                                                             // 0x0300 (size: 0x4)
    ESBEffectVisibleType MainEffectVisibleType;                                       // 0x0304 (size: 0x1)
    char padding_0[0x1B];                                                             // 0x0305 (size: 0x1B)
    FAkEventVariables SpawnEffectSound;                                               // 0x0320 (size: 0x40)
    char padding_1[0x28];                                                             // 0x0360 (size: 0x28)
    TArray<FSBManageEffectActor> ManageEffectActorList;                               // 0x0388 (size: 0x10)
    char padding_2[0x4];                                                              // 0x0398 (size: 0x4)
    int32 SpawnEffectSoundPlayingId;                                                  // 0x039C (size: 0x4)

    bool IsAliveEffect();
    void AddManageEffectActor(class AActor* EffectActor, bool bAutoDestroy);
}; // Size: 0x3B0

class USBProjectileForecastComponent : public UActorComponent
{
    char padding_0[0x140];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x140

class USBProjectileGroundCollisionBox : public UBoxComponent
{
    char padding_0[0x4B0];                                                            // 0x0000 (size: 0x0)

    void SetGroundCollisionEnableMode(bool enable);
    void OnGroundComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
}; // Size: 0x4B0

class USBProjectileGroundCollisionComponent : public UCapsuleComponent
{
    char padding_0[0x4B0];                                                            // 0x0000 (size: 0x0)

    void SetGroundCollisionEnableMode(bool enable);
    void OnGroundComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
}; // Size: 0x4B0

class USBProjectileHealthConditionComponent : public UActorComponent
{
    FSBProjectileHealthConditionConfig HealthConditionConfig;                         // 0x00C8 (size: 0x8)
    float CurrentHitPoint;                                                            // 0x00D0 (size: 0x4)

    float GetHitPointMax();
    float GetCurrentHitPoint();
}; // Size: 0xD8

class USBProjectileHitChainComponent : public UActorComponent
{
    FProjectileHitChainConfig HitChainConfig;                                         // 0x00D8 (size: 0x70)
    FProjectileSelfDeadChainConfig SelfDeadChainConfig;                               // 0x0148 (size: 0x30)

    void OnGroundHitChainProjectile(class UPrimitiveComponent* HitSelfComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
}; // Size: 0x178

class USBProjectileHitTargetLimitComponent : public UActorComponent
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC8

class USBProjectileImagineCharacterAnimInstance : public USBCharacterAnimInstance
{
    TSoftObjectPtr<UASAnimationSet> AnimationSet;                                     // 0x0FD8 (size: 0x28)

    void UpdateCharacterVariables(float FrameDeltaTime);
    bool IsNotifiedMotionEnd();
    float GetStateMachinePlayRate();
    class UASStateMachine* GetStateMachine();
    class UASAnimationSet* GetAnimationSet();
}; // Size: 0x1000

class USBProjectileImagineMeterialReferenceReplaceDataAsset : public UPrimaryDataAsset
{
    TArray<FSBReferenceReplaceDataSet> DataArray;                                     // 0x0030 (size: 0x10)

}; // Size: 0x40

class USBProjectileManager : public UObject
{
    TSubclassOf<class ASBProjectilePath> ProjectileDefaultPath;                       // 0x0028 (size: 0x8)
    TMap<class ESBProjectileSplashSize, class FSBProjectileManageEffect> InWaterEffectList; // 0x0030 (size: 0x50)
    TMap<class ESBProjectileMeshCollisionType, class UStaticMesh*> MeshCollisionMap;  // 0x0080 (size: 0x50)
    char padding_0[0x14];                                                             // 0x00D0 (size: 0x14)
    float ExclusionObstacleHitDistance;                                               // 0x00E4 (size: 0x4)
    TArray<class UObject*> StationaryLoadedAssets;                                    // 0x00E8 (size: 0x10)

    void RequestDestroyProjectile(const class AActor* InProjectileInstigator, const class UDataTable* InDataTable, FName InRowName);
    bool IsExistProjectile(const class AActor* InProjectileInstigator, const class UDataTable* InDataTable, FName InRowName);
    float GetExclusionObstacleHitDistance();
}; // Size: 0xF8

class USBProjectileMeshComponent : public UStaticMeshComponent
{
    FVector BaseScaleVector;                                                          // 0x0520 (size: 0xC)

    void OnAttackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    void OnAttackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
}; // Size: 0x530

class USBProjectileMeshControllComponent : public USceneComponent
{
    char padding_0[0x230];                                                            // 0x0000 (size: 0x0)

    TArray<class UPrimitiveComponent*> GetControllMeshList();
}; // Size: 0x230

class USBProjectileMovementBaseComponent : public UMovementComponent
{
    FSBProjectileMovementBaseComponentOnSbGroundHit OnSbGroundHit;                    // 0x0108 (size: 0x10)
    void OnGroundHitMovementDelegate(const FHitResult& ImpactResult);

    void OnGroundHitMovementDelegate__DelegateSignature(const FHitResult& ImpactResult);
    void OnGroundHitMovement(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
}; // Size: 0x140

class USBProjectileMovementFakeFall : public USBProjectileMovementBaseComponent
{
    char padding_0[0x158];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x158

class USBProjectileMovementHomingComponent : public USBProjectileMovementBaseComponent
{
    float InitialSpeed;                                                               // 0x0140 (size: 0x4)
    char padding_0[0xC];                                                              // 0x0144 (size: 0xC)
    float MaxSpeed;                                                                   // 0x0150 (size: 0x4)
    float MinSpeed;                                                                   // 0x0154 (size: 0x4)
    char padding_1[0x4];                                                              // 0x0158 (size: 0x4)
    int32 MaxSimulationIterations;                                                    // 0x015C (size: 0x4)
    float MaxSimulationTimeStep;                                                      // 0x0160 (size: 0x4)
    uint8 bForceSubStepping;                                                          // 0x0164 (size: 0x1)
    uint8 bRotationFollowsVelocity;                                                   // 0x0164 (size: 0x1)
    uint8 bIsEnableGravity;                                                           // 0x0164 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0165 (size: 0x3)
    float ProjectileGravityScale;                                                     // 0x0168 (size: 0x4)
    float BeginEffectiveGravityTime;                                                  // 0x016C (size: 0x4)
    float EndEffectiveGravityTime;                                                    // 0x0170 (size: 0x4)
    char padding_3[0x4];                                                              // 0x0174 (size: 0x4)
    float LimitTotalDistance;                                                         // 0x0178 (size: 0x4)
    uint8 bLimitDistance;                                                             // 0x017C (size: 0x1)
    uint8 bStopMoveWhenGroundHit;                                                     // 0x017C (size: 0x1)
    char padding_4[0x3B];                                                             // 0x017D (size: 0x3B)
    FProjectileHomingConfig HomingConfig;                                             // 0x01B8 (size: 0x40)

    void SetHomingTargetPoint(const FVector& Target);
    void SetHomingTarget(const class USceneComponent* Target);
    bool IsProcessHomingTime();
    bool IsEnableHomingTarget();
    bool IsEnableHoming();
    EHomingType GetHomingType();
    float GetHomingAccelerateMagnitude();
}; // Size: 0x218

class USBProjectileParamComponent : public UActorComponent
{
    FSBProjectileParamComponentOnSbProjectileConfigRep OnSbProjectileConfigRep;       // 0x00D0 (size: 0x10)
    void OnProjectileConfigRepDelegate();
    TWeakObjectPtr<class AActor> ProjectileSpawner;                                   // 0x00E0 (size: 0x8)
    FSBProjectileSelectHandle ProjectileConfigHandle;                                 // 0x00E8 (size: 0x18)
    FDataTableRowHandle ProjectileEffectHandle;                                       // 0x0100 (size: 0x10)
    char padding_0[0x45];                                                             // 0x0110 (size: 0x45)
    EProjectileNetworkSpawnType NetworkSpawnTypeConcrete;                             // 0x0155 (size: 0x1)
    char padding_1[0x2];                                                              // 0x0156 (size: 0x2)
    float BaseLifeTime;                                                               // 0x0158 (size: 0x4)
    char padding_2[0x4];                                                              // 0x015C (size: 0x4)
    uint64 AuthoritySpawnID;                                                          // 0x0160 (size: 0x8)
    uint64 AuthoritySpawnerSpawnID;                                                   // 0x0168 (size: 0x8)
    uint8 bSpecialAttack;                                                             // 0x0170 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0171 (size: 0x3)
    uint8 SkillIDPosition;                                                            // 0x0174 (size: 0x1)
    char padding_4[0x3];                                                              // 0x0175 (size: 0x3)
    uint32 ImagineStackBNum;                                                          // 0x0178 (size: 0x4)
    char padding_5[0x4];                                                              // 0x017C (size: 0x4)
    TArray<int8> ParamCompEncryptionKeyList;                                          // 0x0180 (size: 0x10)
    int32 SkillId;                                                                    // 0x0190 (size: 0x4)
    uint8 bIsRequestedSpawnOnServer;                                                  // 0x0194 (size: 0x1)
    char padding_6[0x3];                                                              // 0x0195 (size: 0x3)
    float ProjectileBaseScale;                                                        // 0x0198 (size: 0x4)
    FVector_NetQuantize InitProjectilePos;                                            // 0x019C (size: 0xC)
    uint32 ChainDisappearID;                                                          // 0x01A8 (size: 0x4)
    bool bIsDestroyInstigatorActionSuspendChainDisappearIDOnce;                       // 0x01AC (size: 0x1)

    void OnRep_ProjectileConfigHandle();
    void OnRep_NetworkSpawnTypeConcrete();
    void OnRep_ChainDisappearID();
    void OnRep_BaseLifeTime();
    void OnProjectileConfigRepDelegate__DelegateSignature();
    class AActor* GetSpawner();
    int32 GetSkillID();
    float GetRemainLifeTime();
}; // Size: 0x1B0

class USBProjectilePartyShotComponent : public USBProjectileRapidComponent
{
    char padding_0[0x160];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x160

class USBProjectileRapidComponent : public UActorComponent
{
    FSBProjectileSelectHandle RapidProjectileSelectHandle;                            // 0x00D8 (size: 0x18)
    FProjectileRapidParam RapidParam;                                                 // 0x00F0 (size: 0x38)

}; // Size: 0x140

class USBProjectileSendNetDataComponent : public UActorComponent
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)

    void ServerRemoteProjectileOfReservedChainMovementIndex(int32 InReservedChainMovementIndex, class AActor* InProjectileInstigator, int64 InAuthoritySpawnID);
    void ServerRemoteProjectileOfDestroy(uint32 Reasons, class AActor* InProjectileInstigator, int64 InAuthoritySpawnID);
    void ServerRemoteChainDisappearProjectile(class AActor* InProjectileInstigator, int32 InDisappearID);
    void MulticastRemoteProjectileOfReservedChainMovementIndex(int32 InReservedChainMovementIndex, class AActor* InProjectileInstigator, int64 InAuthoritySpawnID);
    void MulticastRemoteProjectileOfDestroy(uint32 Reasons, class AActor* InProjectileInstigator, int64 InAuthoritySpawnID);
    void MulticastRemoteProjectileLimitDamageOver(class AActor* Owner, FSBProjectileIdentifyHandle Handle);
    void MulticastRemoteChainDisappearProjectile(class AActor* InProjectileInstigator, int32 InDisappearID);
}; // Size: 0xC8

class USBProjectileShareHitComponent : public UActorComponent
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC8

class USBProjectileSpawnComponent : public UActorComponent
{
    TArray<FSBProjectileMasterInfo> ProjectileBuildResource;                          // 0x00B8 (size: 0x10)
    char padding_0[0x38];                                                             // 0x00C8 (size: 0x38)
    TMap<uint32, FProjectileSpawnRelayParameter> ProjectileCacheArray;                // 0x0100 (size: 0x50)

    void ServerPushHitInfo(int64 HitTime, const FSBProjectileIdentifyHandle Handle, const FSBDamageEvent& DamageEventEncrypted, class AActor* DamageDst, class AActor* Instigator, int16 PrimitiveCollisionIndex);
    void RequestSpawnRapidParameterServer(uint32 CacheID, const FProjectileSpawnRapidParameter RapidParam, class AActor* OwnerActor, class APawn* InstigatorPawn, class ACharacter* RequestedCharacterOnClient, bool isSpawnOnServer);
    void RequestSpawnRapidParameterMulticast(int32 CacheID, const FProjectileSpawnRapidParameter RapidParam, class AActor* OwnerActor, class APawn* InstigatorPawn, class ACharacter* RequestedCharacterOnClient);
    void RequestSpawnParameterServerOnDelegatedSpawnAuth(const FProjectileSpawnRelayParameter& ProjSpawnRelayParam, class AActor* OwnerActor, class APawn* InstigatorPawn, class ACharacter* RequestedCharacterOnClient, uint32 CacheID, bool isSpawnOnServer);
    void RequestSpawnParameterServer(const FProjectileSpawnRelayParameter& ProjSpawnRelayParam, class AActor* OwnerActor, class APawn* InstigatorPawn, class ACharacter* RequestedCharacterOnClient, uint32 CacheID, bool isSpawnOnServer);
    void RequestSpawnParameterMulticast(const FProjectileSpawnRelayParameter& ProjSpawnRelayParam, class AActor* OwnerActor, class APawn* InstigatorPawn, class ACharacter* RequestedCharacterOnClient, uint32 CacheID);
    void RequestSpawnEmitterBySplashTypeServer(ESBProjectileSplashSize SplashSize, FVector_NetQuantize Pos, FRotator Rot, float ScaleValue, bool bAutoDestroy);
    void RequestSpawnEmitterBySplashTypeMulticast(ESBProjectileSplashSize SplashSize, FVector_NetQuantize Pos, FRotator Rot, float ScaleValue, bool bAutoDestroy);
    void RequestSpawnEmitterByProjectileIDServer(FSBRequiredParam_SpawnEmitterByProjectileID RequiredParam, FSBCustomParam_SpawnEmitterByProjectileID CustomParam);
    void RequestSpawnEmitterByProjectileIDMulticast(FSBRequiredParam_SpawnEmitterByProjectileID RequiredParam, FSBCustomParam_SpawnEmitterByProjectileID CustomParam);
    void RequestSpawnEmitterAttachServer(EEffectId ID, class USceneComponent* AttachComp, ESBEffectVisibleType VisibleType, FName AttachPointName, FVector_NetQuantize Location, FRotator Rotation, float ScaleValue, TEnumAsByte<EAttachLocation::Type> LocationType, bool bAutoDestroy, bool bHeal);
    void RequestSpawnEmitterAttachMulticast(EEffectId ID, class USceneComponent* AttachComp, ESBEffectVisibleType VisibleType, FName AttachPointName, FVector_NetQuantize Location, FRotator Rotation, float ScaleValue, TEnumAsByte<EAttachLocation::Type> LocationType, bool bAutoDestroy, bool bHeal);
    void RequestProjectileRapidEndServer(uint32 CacheID);
    void RequestProjectileRapidEndMulticast(uint32 CacheID);
    void RequestPlaySoundServer(uint64 AuthoritySpawnID, class ASBCharacter* TargetCharacter, class UAkAudioEvent* Event);
    void RequestPlaySoundMulticast(uint64 AuthoritySpawnID, class ASBCharacter* TargetCharacter, class UAkAudioEvent* Event);
    void NotifyOrderedChainHitProjectileServer(uint64 AuthoritySpawnID, class ASBCharacter* TargetCharacter, uint64 OtherAuthoritySpawnID, class ASBCharacter* OtherTargetCharacter);
    void NotifyOrderedChainHitProjectileMulticast(uint64 AuthoritySpawnID, class ASBCharacter* TargetCharacter, uint64 OtherAuthoritySpawnID, class ASBCharacter* OtherTargetCharacter);
}; // Size: 0x160

class USBProjectileSphereComponent : public USphereComponent
{
    char padding_0[0x4B0];                                                            // 0x0000 (size: 0x0)

    void OnAttackEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    void OnAttackBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
}; // Size: 0x4B0

class USBProjectileSummonImagineComponent : public UActorComponent
{
    TSoftClassPtr<AASCharacterBase> SummonImagineCharacterAsset;                      // 0x00C8 (size: 0x28)
    class AASCharacterBase* ImagineCharacterInstance;                                 // 0x00F0 (size: 0x8)

}; // Size: 0x100

class USBProjectileTickable_BlueprintBase : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void ReceiveTick(float DeltaTime, class AActor* OwnerActor);
    void ReceiveEndPlay(class AActor* OwnerActor);
    void ReceiveBeginPlay(class AActor* OwnerActor);
    void DrawDebugSphere(class AActor* Owner, const FVector Center, float Radius, int32 Segments, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugPoint(class AActor* Owner, const FVector Position, float Size, FLinearColor PointColor, float Duration);
    void DrawDebugLine(class AActor* Owner, const FVector LineStart, const FVector LineEnd, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCircle(class AActor* Owner, FVector Center, float Radius, int32 NumSegments, FLinearColor LineColor, float Duration, float Thickness, FVector YAxis, FVector ZAxis, bool bDrawAxis);
    void DrawDebugBox(class AActor* Owner, const FVector Center, FVector Extent, FLinearColor LineColor, const FRotator Rotation, float Duration, float Thickness);
    void DrawDebugArrow(class AActor* Owner, const FVector LineStart, const FVector LineEnd, float ArrowSize, FLinearColor LineColor, float Duration, float Thickness);
}; // Size: 0x28

class USBProjectileTrailImpactComponent : public UActorComponent
{
    FSBProjectileTrailImpactInfo TrailImpactInfo;                                     // 0x00E8 (size: 0x50)

}; // Size: 0x138

class USBProjectileWideShotComponent : public USBProjectileRapidComponent
{
    char padding_0[0x170];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x170

class USBQuestBPFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UpdateQuestRouteGuide(class UObject* WorldContextObject, bool bIsLevelNameOverride);
    bool StartInterruptQuest(class ASBInterruptQuestPoint* InPoint);
    void SetPictureInSkitFadeOutFlag(const bool Flag);
    void RequestQuestJingleSound(class UObject* WorldContextObject, const bool bIsAccept);
    void Request_InterruptQuestGimmickObjectAppearLog(class UObject* WorldContextObject, class ASBInterruptQuestGimmickActorBase* InGimmickActor, bool InIsAppear, bool InIsVisible);
    int32 QueryReportableQuest(class UObject* WorldContextObject, FName ReporterId);
    void PlayInterruptQuestSuccess(FName InQuestId);
    void PlayInterruptQuestStepUp(FName InQuestId);
    void PlayInterruptQuestStart(FName InQuestId);
    void PlayInterruptQuestLeave(FName InQuestId);
    void PlayInterruptQuestFailed(FName InQuestId);
    bool IsSubQuest(class UObject* WorldContextObject, const int32 QuestID);
    bool IsStepCompleteNotifyEnable(class UObject* WorldContextObject, const int32 InQuestId, const int32 InStepNo);
    bool IsQuestValidList(class UObject* WorldContextObject);
    bool IsQuestStepRouteGuideProhibit(class UObject* WorldContextObject, const int32 QuestIndex);
    bool IsQuestRewardHaveAnyOverflow(class UObject* WorldContextObject, const int32 InQuestIndex);
    bool IsQuestMissMatchClassType(const class USBNetworkDataCache* NetworkDataCache, const int32 QuestIndex);
    bool IsLotteryTypeRewardOverflow(class UObject* WorldContextObject, const int32 InLotteryGroupId, const int32 InAmount);
    bool IsInterruptQuestStartCheckAreaIn(class UObject* WorldContextObject, class ASBPlayerCharacter* PlayerCharacter);
    bool IsInterruptQuestJoined(class UObject* WorldContextObject);
    bool IsExistQuestTargetNpc(class UObject* WorldContextObject, const FName NpcId, int32& QuestID);
    bool IsExistQuestStoppingFromNpc(class UObject* WorldContextObject, const FName NpcId, int32& QuestID);
    bool IsExistQuestStepSynopsis(class UObject* WorldContextObject, const int32 QuestIndex);
    bool IsExistQuestStartFromNpc(class UObject* WorldContextObject, const FName NpcId, int32& QuestID);
    bool IsExistQuestReportForNpc(class UObject* WorldContextObject, const FName NpcId, int32& QuestID);
    bool IsDestinationMap(class UObject* WorldContextObject, const int32 QuestIndex);
    bool IsContainInterruptQuestTargetEnemy(class UObject* WorldContextObject, const int32 InQuestIndex, const FName InEnemyId);
    void InterruptQuest_ActionNotification_ItemUse(class ASBPlayerCharacter* pPC, int32 ItemId);
    bool GetWishListProgressUIInfo(class UObject* WorldContextObject, const FSBWishListData& InWishListData, TArray<FSBQuestProgressItemUIInfo>& OutProgressItemList);
    bool GetStepCompleteText(class UObject* WorldContextObject, FString& OutText, const int32 InQuestId, const int32 InStepNo);
    FString GetReportableStatusText(class UObject* WorldContextObject, const int32 QuestIndex);
    int32 GetRelationQuest(class UObject* WorldContextObject, const FName TargetId, TArray<int32>& OutQuestIndexList);
    int32 GetQuestStoppingFromNpc(class UObject* WorldContextObject, const FName NpcId);
    FString GetQuestStep(class UObject* WorldContextObject, const int32 QuestID);
    FString GetQuestStatusString(class UObject* WorldContextObject, const EQuestStatus InQuestStatus);
    ESBQuestStatusOnClassChange GetQuestStatusOnClassChange(class UObject* WorldContextObject, const ESBClassType ClassType);
    EQuestStatus GetQuestStatus(class UObject* WorldContextObject, const int32 QuestID);
    int32 GetQuestStartFromNpc(class UObject* WorldContextObject, const FName NpcId);
    bool GetQuestRewardInfoMailData(class UObject* WorldContextObject, const int32 InQuestIndex, TArray<FSBMailData>& OutMailDatas);
    bool GetQuestProgressUIInfo(class UObject* WorldContextObject, const int32 QuestIndex, const int32 StepNo, TArray<FSBQuestProgressItemUIInfo>& OutProgressItemList);
    bool GetQuestProgressDiffUIInfo(class UObject* WorldContextObject, const int32 QuestIndex, const FQuestProgressInfo& PrevProgressInfo, const FQuestProgressInfo& AfterProgressInfo, TArray<FSBQuestProgressItemUIInfo>& OutProgressItemList);
    void GetQuestPreconditionUIInfo(class UObject* WorldContextObject, const int32 InQuestIndex, TArray<FSBQuestPreconditionUIInfo>& OutPreconditionList);
    FString GetQuestNameByTextId(class UObject* WorldContextObject, const FName& InTextTableName, const FSBTextTableHash& InTextId);
    void GetQuestNameArray(class UObject* WorldContextObject, const TArray<int32> QuestIndexList, const FString FormatText, TArray<FString>& OutQuestNameList);
    FString GetQuestName(class UObject* WorldContextObject, const int32 QuestIndex);
    EQuestIconType GetQuestIconType(class UObject* WorldContextObject, int32 QuestID);
    FString GetQuestDoneText(class UObject* WorldContextObject, const int32 QuestIndex);
    FString GetQuestDescByTextId(class UObject* WorldContextObject, const FName& InTextTableName, const FSBTextTableHash& InTextId);
    FString GetQuestDescAndSynopsis(class UObject* WorldContextObject, const int32 QuestIndex);
    FString GetQuestDesc(class UObject* WorldContextObject, const int32 QuestIndex);
    bool GetQuestDeadlineOfUnlockCondition(class UObject* WorldContextObject, int32 InQuestId, FDateTime& OutDeadline);
    FString GetQuestConditionDetailByTextId(class UObject* WorldContextObject, const FName& InTextTableName, const FSBTextTableHash& InTextId);
    FString GetQuestConditionDetail(class UObject* WorldContextObject, const int32 QuestIndex);
    FString GetQuestCloseText(class UObject* WorldContextObject, const int32 QuestIndex);
    bool GetQuestAreaIconInfoId(class UObject* WorldContextObject, const int32 InQuestIndex, TArray<FName>& OutIdArray);
    void GetQuestAdditionalRewardInfo(class UObject* WorldContextObject, const int32 InQuestIndex, TArray<FSBQuestAdditionalRewardUIInfo>& OutInfos);
    bool GetQuestAcceptableCount(class UObject* WorldContextObject, int32 InQuestId, int32& OutNum, int32& OutMaxNum);
    bool GetPictureInSkitFadeOutFlag();
    EQuestIconType GetNpcQuestIconType(class UObject* WorldContextObject, const FName NpcId, int32& QuestID);
    bool GetNextMainQuestPrevId(class UObject* WorldContextObject, int32& OutNextMainQuestPrevIndex);
    void GetNextMainQuestPreconditionUIInfo(class UObject* WorldContextObject, FSBQuestPreconditionUIInfo& OutPrecondition);
    bool GetNextMainQuestId(class UObject* WorldContextObject, int32& OutNextMainQuestIndex);
    FString GetMainQuestIntervalText(class UObject* WorldContextObject);
    int32 GetLotteryTypeRewardStorageType(class UObject* WorldContextObject, const int32 InLotteryGroupId);
    int32 GetLatestMainQuest(class UObject* WorldContextObject);
    FString GetInterruptQuestRemainTimeString(const FTimespan& InRemainTime);
    bool GetInterruptQuestProgressUIInfo(const int32 InQuestIndex, const FQuestProgressInfo& InProgressInfo, const int32 InStepNo, TArray<FSBQuestProgressItemUIInfo>& OutProgressItemList);
    bool GetInterruptQuestName(const FString InQuestId, FString& OutQuestName);
    bool GetDungeonProgressUIInfo(class UObject* WorldContextObject, TArray<FSBDungeonProgressItemUIInfo>& OutProgressItemList);
    FName GetCurrentLevelKillLocationId(class UObject* WorldContextObject);
    int32 GetConditionNum(class UObject* WorldContextObject, const int32 QuestIndex, const int32 StepNo);
    void GetActiveQuestTargetNpc(class UObject* WorldContextObject, const FName NpcId, TArray<int32>& OutQuests);
    void GetActiveQuestTargetEnemy(class UObject* WorldContextObject, const FName EnemyId, TArray<int32>& OutQuests);
    void ConvertRewarIdToRewarInfo(const TArray<FName>& InRewarIdList, TArray<FRewardInfo>& OutRewarInfoList, EQuestRewardCategory InCategory, bool HiddenFlag);
    bool ContainsCollectTriggerCondition(class UObject* WorldContextObject, const int32 QuestIndex);
    bool ContainsClassTypePrecondition(class UObject* WorldContextObject, const int32 InQuestIndex, ESBClassType ClassType);
    bool ContainsClassPrecondition(class UObject* WorldContextObject, const int32 InQuestIndex, ESBClassType ClassType, int32 ClassLevel);
    bool ContainsClassLevelPrecondition(class UObject* WorldContextObject, const int32 InQuestIndex, int32 ClassLevelMin, int32 ClassLevelMax);
    bool CheckQuestRevivalCondition(class UObject* WorldContextObject, const int32 InQuestIndex, FDateTime& OutRevivalDate);
    bool CheckPreconditionByQuestId(const class USBNetworkDataCache* InNetworkDataCache, const FName& InQuestLongId);
    bool CheckPreconditionByIndex(const class USBNetworkDataCache* InNetworkDataCache, const int32 InQuestIndex);
    bool CheckPrecoditionForQuestScript(class UObject* WorldContextObject, int32 InQuestIndex);
    int32 CalcCompletedConditionNum(class UObject* WorldContextObject, const int32 QuestIndex);
}; // Size: 0x28

class USBQuestBoard : public USBUserWidget
{
    FName QuestBoardId;                                                               // 0x02B0 (size: 0x8)
    char padding_0[0x20];                                                             // 0x02B8 (size: 0x20)
    TArray<FQuestBoardQuestData> QuestListDone;                                       // 0x02D8 (size: 0x10)
    TArray<FQuestBoardQuestData> QuestList;                                           // 0x02E8 (size: 0x10)

    void CollectQuest();
    void ApplyFilter(const TArray<FFilterGroup>& InFilters);
}; // Size: 0x308

class USBQuestCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UpdateUnlockedQuestList();
    void UpdateQuestProgressGather(ESBTreasureBoxRarity TreasureBoxRarity, ESBDayTime DayTime);
    void UnlockQuest(FString InLongId);
    void UnlockAllQuests();
    void StartTestInterruptQuest(const FName& QuestID);
    void SetRouteGuideQuestId(FString InLongId);
    void SetAutoDeliveryQuestUIQuestIdDraw(const bool IsDraw);
    void Server_InterruptQuestLotteryTest(FString InCharacterId, const FName& QuestID, bool bRandomNumCheck);
    void PutInterruptQuestStatus(const FName& QuestID);
    void OnCompleteQuestStep(bool bResult, const int32 RetCode, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void OnCompleteQuest(int32 RetCode, int32 QuestIndex, EQuestCompleteResult CompleteResult, const FSBMailRewardData& MailRewardData);
    void OnChangeQuestStep(bool bResult, const int32 RetCode, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void OnCancelQuest(bool bResult, int32 QuestID);
    void OnAcceptQuest(bool bResult, const EAcceptedQuestErrorCode ErrorCode, const int32 RetCode, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void InterruptQuestPointReset(const FName& QuestID);
    void InterruptQuestLotteryTest(const FName& QuestID, bool bRandomNumCheck);
    void DumpUnlockedQuestList();
    void DumpQuestCheckList();
    void DumpAcceptedQuestList();
    void CompleteQuestStep(const FName& QuestID, const FName& StepId);
    void CompleteQuest(const FName& QuestID);
    void ChangeQuestStep(const FName& QuestID, const FName& StepId);
    void CancelQuest(const FName& QuestID);
    void AdventureBoardSetDummyVersion(FString InDummyVersion);
    void AdventureBoardDebugIdDraw(bool bIsDraw);
    void AdvanceQuest(const FName& QuestID);
    void AdvanceAdventureBoard(int32 InBoardId);
    void AddAutoOrderQuest(FString QuestID);
    void AcceptQuest(const FName& QuestID);
}; // Size: 0x28

class USBQuestComponent : public UActorComponent
{
    FSBQuestComponentOnQuestListDelegete OnQuestListDelegete;                         // 0x00C0 (size: 0x10)
    void OnQuestListDelegete(const TArray<FUnlockedQuestInfo>& QuestList);
    FSBQuestComponentOnAcceptedQuestListDelegete OnAcceptedQuestListDelegete;         // 0x00D0 (size: 0x10)
    void OnAcceptedQuestListDelegete();
    FSBQuestComponentOnAcceptQuestDelegate OnAcceptQuestDelegate;                     // 0x00E0 (size: 0x10)
    void OnAcceptQuestDelegate(bool Result, const EAcceptedQuestErrorCode ErrorCode, const int32 RetCode, const FAcceptedQuestInfo& AcceptedQuestInfo);
    FSBQuestComponentOnCancelQuestDelegate OnCancelQuestDelegate;                     // 0x00F0 (size: 0x10)
    void OnCancelQuestDelegate(bool Result, int32 QuestIndex);
    FSBQuestComponentOnCompleteQuestDelegate OnCompleteQuestDelegate;                 // 0x0100 (size: 0x10)
    void OnCompleteQuestDelegate(int32 RetCode, int32 QuestIndex, EQuestCompleteResult CompleteResult, const FSBMailRewardData& MailRewardData);
    FSBQuestComponentOnCompleteQuestServerDelegate OnCompleteQuestServerDelegate;     // 0x0110 (size: 0x10)
    void OnCompleteQuestServerDelegate(class USBQuestComponent* InComponent, int32 InRetCode, int32 InQuestIndex);
    FSBQuestComponentOnUpdateQuestProgressDelegate OnUpdateQuestProgressDelegate;     // 0x0120 (size: 0x10)
    void OnUpdateQuestProgressDelegate(bool Result, int32 RetCode, const FAcceptedQuestInfo& PrevAcceptedQuestInfo);
    char padding_0[0x58];                                                             // 0x0130 (size: 0x58)
    TArray<int32> UpdatedQuests;                                                      // 0x0188 (size: 0x10)
    FSBQuestComponentOnUpdatedQuestsAtJoinDelegete OnUpdatedQuestsAtJoinDelegete;     // 0x0198 (size: 0x10)
    void OnUpdatedQuestsAtJoin(const TArray<int32>& QuestIndexes);
    TArray<FSBQuestUpdatedItemsAtJoin> UpdatedItemsAtJoin;                            // 0x01A8 (size: 0x10)
    char padding_1[0x8];                                                              // 0x01B8 (size: 0x8)
    TArray<int32> DeletedQuestList;                                                   // 0x01C0 (size: 0x10)
    TArray<int32> MainQuestIdList;                                                    // 0x01D0 (size: 0x10)

    void SyncUpdatedItemsAtJoin();
    void SyncDeletedQuestList();
    void SetRouteGuideQuestId(FName InId);
    void Server_UpdateQuestProgressWarpPortal(const FName& WarpPortalId);
    void Server_UpdateQuestProgressTalkNpc(int32 QuestIndex, const FName& NpcId);
    void Server_UpdateQuestProgressPayedMoney(const int32 QuestIndex, const FName& InNpcId);
    void Server_UpdateQuestProgressKillEnemy(const FName& EnemyId);
    void Server_UpdateQuestProgressInteraction(const FName& ObjectId);
    void Server_UpdateQuestProgressGather(const ESBTreasureBoxRarity GatherPointType, ESBDayTime DayTime);
    void Server_UpdateQuestProgressEmote(const FName& EmoteId);
    void Server_UpdateQuestProgressCraftItem(const EItemType ItemType, const int32 ItemId);
    void Server_UpdateQuestProgressCollectTriggerByEnemy(const FName& EnemyId);
    void Server_UpdateQuestProgressCollectTrigger(int32 QuestIndex, int32 ConditionId);
    void Server_UpdateQuestProgressCollectItem(const EItemType ItemType, int32 ItemIndex);
    void Server_UpdateQuestProgressClearID(const FName& DungeonId);
    void Server_UpdateQuestProgressChallengeQuestStart(const FName& InQuestId);
    void Server_UpdateQuestProgressArriveAt(const FName& InPlaceId);
    void Server_UpdateQuestProgressAnyCondition(int32 QuestIndex, const int32 InConditionId, FString InConditionName);
    void Server_UpdateQuestProgressAdventurerRankUp(const int32 Rank);
    void Server_UpdateQuestProgress(const TArray<int32>& UpdateQuestList);
    void Server_UpdatedQuestsAtJoin();
    void Server_QuestList();
    void Server_OnUpdateQuestProgress(bool Result, const int32 SBRetCode, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void Server_OnCompleteQuest(const int32 InRetCode, const FCompleteQuestResponseData& InResponseData);
    void Server_OnCancelQuest(bool Result, int32 QuestIndex);
    void Server_OnAcceptQuest(bool Result, const EAcceptedQuestErrorCode ErrorCode, const int32 RetCode, const FAcceptedQuestInfo& Quest);
    void Server_CompleteStep(const int32 InQuestIndex, const int32 InStepNo, const int32 InConditionDataId);
    void Server_CompleteQuest(int32 QuestIndex, int32 RewardIndex, bool bUpsert, bool bIsOverflowLimitDiscard, bool bIsOverflowLimitSell);
    void Server_ChangeStep(const int32 InQuestIndex, const int32 InStepNo);
    void Server_CancelQuest(int32 QuestIndex);
    void Server_AcceptQuest(int32 QuestIndex);
    void Server_AcceptedQuestList();
    void SaveRouteGuideQuestId();
    bool Request_UpdateQuestProgressWarpPortal(const FName& WarpPortalId);
    bool Request_UpdateQuestProgressTalkNpc(int32 QuestIndex, const FName& NpcId);
    bool Request_UpdateQuestProgressPayedMoney(const int32 QuestIndex, const FName& InNpcId);
    bool Request_UpdateQuestProgressKillEnemy(const FName& EnemyId);
    bool Request_UpdateQuestProgressInteraction(const FName& ObjectId);
    bool Request_UpdateQuestProgressGather(ESBTreasureBoxRarity GatherPointType, ESBDayTime DayTime);
    bool Request_UpdateQuestProgressEmote(const FName& EmoteId);
    bool Request_UpdateQuestProgressCraftItem(const EItemType ItemType, const int32 ItemIndex);
    bool Request_UpdateQuestProgressCollectTriggerByEnemy(const FName& EnemyId);
    bool Request_UpdateQuestProgressCollectTrigger(int32 QuestIndex, int32 ConditionId);
    bool Request_UpdateQuestProgressClearID(const FName OverrideDungeonName);
    bool Request_UpdateQuestProgressChallengeQuestStart(const FName& InQuestId);
    bool Request_UpdateQuestProgressArriveAt(const FName& InPlaceId);
    bool Request_UpdateQuestProgressAnyCondition(int32 QuestIndex, const int32 InConditionId, const FString InConditionName);
    bool Request_UpdateQuestProgressAdventurerRankUp(const int32 Rank);
    bool Request_QuestList();
    bool Request_CompleteStep(const int32 InQuestIndex, const int32 InStepNo, const int32 InConditionDataId);
    bool Request_CompleteQuest(int32 QuestIndex, int32 RewardIndex, bool bIsOverflowLimitDiscard, bool bIsOverflowLimitSell);
    bool Request_CancelQuest(int32 QuestIndex);
    bool Request_AcceptQuest(int32 QuestIndex);
    bool Request_AcceptedQuestList();
    void OnUpdateQuestProgressDelegate__DelegateSignature(bool Result, int32 RetCode, const FAcceptedQuestInfo& PrevAcceptedQuestInfo);
    void OnUpdatedQuestsAtJoin__DelegateSignature(const TArray<int32>& QuestIndexes);
    void OnQuestListDelegete__DelegateSignature(const TArray<FUnlockedQuestInfo>& QuestList);
    void OnOwnItemPostUpdatedItems();
    void OnOwnItemChangeAmount(const FSBChangeItemAmountParam& InParam);
    void OnIDClearConditionComplete(const FName& InDungeonName);
    void OnCompleteQuestServerDelegate__DelegateSignature(class USBQuestComponent* InComponent, int32 InRetCode, int32 InQuestIndex);
    void OnCompleteQuestDelegate__DelegateSignature(int32 RetCode, int32 QuestIndex, EQuestCompleteResult CompleteResult, const FSBMailRewardData& MailRewardData);
    void OnCancelQuestDelegate__DelegateSignature(bool Result, int32 QuestIndex);
    void OnAcceptQuestDelegate__DelegateSignature(bool Result, const EAcceptedQuestErrorCode ErrorCode, const int32 RetCode, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void OnAcceptedQuestListDelegete__DelegateSignature();
    void LoadRouteGuideQuestId();
    TArray<FSBQuestUpdatedItemsAtJoin> GetUpdatedItemsAtJoin();
    FName GetRouteGuideQuestId();
    TArray<int32> GetDeletedQuestList();
    void Client_UpdateQuestProgress(bool Result, const int32 SBRetCode, const FAcceptedQuestInfo& AcceptedQuestInfo);
    void Client_UpdatedQuestsAtJoin(const TArray<int32>& Quests);
    void Client_SyncUpdatesItemsAtJoin(const TArray<FSBQuestUpdatedItemsAtJoin>& UpdatedItems);
    void Client_SyncDeletedQuestList(const TArray<int32>& InDeletedQuestList);
    void Client_QuestList(const TArray<FUnlockedQuestInfo>& QuestList);
    void Client_CompleteQuest(const int32 InRetCode, const EQuestCompleteResult InCompleteResult, const FCompleteQuestResponseData& InResponseData);
    void Client_CancelQuest(bool Result, int32 QuestIndex);
    void Client_AcceptQuest(bool Result, const EAcceptedQuestErrorCode ErrorCode, const int32 RetCode, const FAcceptedQuestInfo& Quest);
    void Client_AcceptedQuestList(const TArray<FAcceptedQuestInfo>& QuestList);
    void ClearDeletedQuestList();
}; // Size: 0x1E0

class USBQuestList : public USBUserWidget
{
    FSBQuestListFilterSetting FilterSetting;                                          // 0x02B0 (size: 0x10)
    TArray<FQuestListQuestData> QuestList;                                            // 0x02C0 (size: 0x10)
    TArray<int32> ReferenceList;                                                      // 0x02D0 (size: 0x10)

    void SortList();
    void SetQuestStatus(const int32 InQuestIndex, const EQuestStatus InQuestStatus);
    void SetFilterSetting(EQuestListFilterType InFilterType, const bool bInFlag);
    void RemoveFromListByQuestIndex(const int32 InQuestIndex);
    void CollectQuest();
    bool CheckFilter(const int32 InQuestIndex);
}; // Size: 0x2E0

class USBQuestManager : public UObject
{
    TSubclassOf<class ASBScriptActor> ScriptActorClass;                               // 0x0028 (size: 0x8)

}; // Size: 0x30

class USBQuestMiscSaveGame : public USaveGame
{
    FString SaveSlotName;                                                             // 0x0028 (size: 0x10)
    uint32 UserIndex;                                                                 // 0x0038 (size: 0x4)
    char padding_0[0x4];                                                              // 0x003C (size: 0x4)
    TMap<class FString, class FString> RouteGuideQuestIdTable;                        // 0x0040 (size: 0x50)

}; // Size: 0x90

class USBRS_MovementModeChange : public UAIFwReactiveSkill
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)

    void OnMovementModeChange(class ACharacter* Character, TEnumAsByte<EMovementMode> PrevMovementMode, uint8 PreviousCustomMode);
}; // Size: 0x68

class USBRaidBattleBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void RaidBattleScoreCount_GimmickAction(class UObject* WorldContextObject, class ASBPlayerCharacter* Player);
    bool IsRaidBattle(class UObject* WorldContextObject);
    void GetRaidBattleMasterDataList(TArray<FSBRaidBattleMasterData>& MasterDataList, bool& IsExists);
    bool GetRaidBattleMasterData(FString InGameContentId, FSBRaidBattleMasterData& OutRaidBattleMasterData);
    bool GetRaidBattleData(class UObject* InWorldContextObject, FString InGateName, FString& OutDungeonId, FString& OutTermId);
    int32 GetAwardNum(class UObject* InWorldContextObject);
    void DebugPrintRaidResult(class UObject* InWorldContextObject);
}; // Size: 0x28

class USBRaidBattleComponent : public USBPlayerPropertyComponent
{
    FSBRaidBattleComponentOnRaidBattleOccurringDelegete OnRaidBattleOccurringDelegete; // 0x00B8 (size: 0x10)
    void OnRaidBattleOccurringDelegete(FString InMapId, FString InQuestName);
    FSBRaidBattleComponentOnIsRaidGateActiveDelegete OnIsRaidGateActiveDelegete;      // 0x00C8 (size: 0x10)
    void OnIsRaidGateActiveDelegete(FString InMapId, bool IsActive);

    void Server_IsGateActive(FString GateName);
    void Request_IsGateActive(FString GateName);
    void OnRaidBattleOccurringDelegete__DelegateSignature(FString InMapId, FString InQuestName);
    void OnIsRaidGateActiveDelegete__DelegateSignature(FString InMapId, bool IsActive);
    void Client_RaidBattleOccurringInfo(FString InMapId, FString InQuestName);
    void Client_IsGateActive(FString InGateName, FString InDungeonId, FString InTermId, bool InOpen);
}; // Size: 0xD8

class USBRaidBattleManager : public UObject
{
    char padding_0[0x58];                                                             // 0x0000 (size: 0x0)

    void Request_GateServerStatusPut(class ASBPlayerCharacter* pPC, FString GateName);
    void GateOpen(FSBRaidBattleData& Data);
    void GateClose(FSBRaidBattleData& Data);
    void DelegeteGateOpen(FString TermId);
    void DelegeteGateClose(FString TermId);
}; // Size: 0x58

class USBRandomLightMaterialComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)

    int32 RewriteMaterialsOfStaticMeshesForPreview(TArray<class UMaterialInstance*> SourceMaterials, TArray<class UMaterialInstanceDynamic*> PreviewMaterials);
    int32 RewriteMaterialsOfStaticMeshes(TArray<class UMaterialInstance*> TargetMaterials);
    int32 RewriteMaterialsOfDecals(TArray<class UMaterialInstance*> TargetMaterials);
    void RewriteMaterialsCore(class UStaticMeshComponent* MeshComp, class UMaterialInstance* TargetMaterial, int32 Idx);
    int32 MeshesResetToDefaultMaterials(TArray<class UMaterialInstance*> SourceMaterials);
    class UMaterialInstanceDynamic* FindDecalsMaterial(class UDecalComponent* DecalComp, class UMaterialInstance* TargetMaterial, int32 Idx);
    int32 EditorPreview(float TimeRate, bool Preview);
    bool CheckEditorPreviewInit(TArray<class UMaterialInstance*> SourceMaterials);
}; // Size: 0xB8

class USBRankingWidget : public USBUserWidget
{
    TArray<FRankingData> RankingList;                                                 // 0x02B0 (size: 0x10)
    TArray<FRankingHistoryData> RankingHistoryList;                                   // 0x02C0 (size: 0x10)
    TArray<FRankingHistoryData> HistoryComboBoxList;                                  // 0x02D0 (size: 0x10)
    bool IsLoaded;                                                                    // 0x02E0 (size: 0x1)
    char padding_0[0x3];                                                              // 0x02E1 (size: 0x3)
    int32 MyRank;                                                                     // 0x02E4 (size: 0x4)
    int32 IsRankingOut;                                                               // 0x02E8 (size: 0x4)
    bool IsRankingAggregation;                                                        // 0x02EC (size: 0x1)
    char padding_1[0x3];                                                              // 0x02ED (size: 0x3)
    FRankingData MyRankData;                                                          // 0x02F0 (size: 0x48)
    int32 totalCount;                                                                 // 0x0338 (size: 0x4)

    FRankingHistoryData SearchRankingHistoryData(const FRankingHistoryData& InHistoryData, const ESBClassType& InClassType);
    bool Request_RankingPageView(class ASBPlayerController* PlayerController, const FRankingHistoryData& InHistoryData, FString InCharacterId, ESBClassType InClassType, const int32& InPageIndex);
    bool Request_RankingHistory(class ASBPlayerController* PlayerController);
    void OnFailedRankingView();
    void OnCompletedRankingView();
    void OnCompletedRankingHistory();
    bool IsLoad();
    int32 GetTotalCount();
    TArray<FRankingData> GetRankingList();
    TArray<FRankingHistoryData> GetRankingHistoryList();
    int32 GetMyRank();
    TArray<FRankingHistoryData> GetHistoryComboBoxList();
    int32 GetCharacterRank(const FString InCharacterId);
}; // Size: 0x340

class USBRebellionChargeSkill : public USBRebellionSkillInfo
{
    FSBPlayerSkillChargeSetting ChargeSkillSetting;                                   // 0x02D0 (size: 0x28)

}; // Size: 0x2F8

class USBRebellionCounterBarrierSkill : public USBRebellionSkillInfo
{
    FSBEffectSetting BarrierEffect;                                                   // 0x02C8 (size: 0x150)
    FSBEffectSetting BarrierDamageEffect;                                             // 0x0418 (size: 0x150)
    float BarrierHP;                                                                  // 0x0568 (size: 0x4)
    float BarrierTimeDamage;                                                          // 0x056C (size: 0x4)

}; // Size: 0x570

class USBRebellionGlitterModeSkill : public USBRebellionSkillInfo
{
    FDataTableRowHandle GlitterModeStatus;                                            // 0x02C8 (size: 0x10)
    float EnergyAmoountMax;                                                           // 0x02D8 (size: 0x4)
    float GuardAddEnergy;                                                             // 0x02DC (size: 0x4)
    TArray<FDataTableRowHandle> GaugeBuffList;                                        // 0x02E0 (size: 0x10)
    float GaugeBuffRange;                                                             // 0x02F0 (size: 0x4)
    int32 GaugeBuffPlayerNum;                                                         // 0x02F4 (size: 0x4)

}; // Size: 0x2F8

class USBRebellionGuardSkill : public USBRebellionSkillInfo
{
    int32 CounterCost;                                                                // 0x02C8 (size: 0x4)

    float GetCounterCostValue(class ASBPlayerCharacter* PlayerCharacter);
}; // Size: 0x2D0

class USBRebellionHateCollectSkill : public USBRebellionMarkerChargeSkill
{
    TArray<FSBConditionCheckParam> AttackHitAddShieldDurabilityConditionList;         // 0x0370 (size: 0x10)
    float AttackHitAddShieldDurabilityRate;                                           // 0x0380 (size: 0x4)
    float AttackHitAddShieldDurabilityRateMax;                                        // 0x0384 (size: 0x4)
    TArray<FSBRebellionHateCollectHitStatusAilmentConfig> HitStatusAilmentConfigList; // 0x0388 (size: 0x10)

}; // Size: 0x398

class USBRebellionLargeShieldExtendTimePassiveSkill : public USBPlayerPassiveSkill
{
    float ExtendTime;                                                                 // 0x0040 (size: 0x4)

}; // Size: 0x48

class USBRebellionLargeShieldSeparationPassiveSkill : public USBPlayerPassiveSkill
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBRebellionLargeShieldSkill : public USBRebellionSkillInfo
{
    float ShieldWidth;                                                                // 0x02D0 (size: 0x4)
    float ShieldHeight;                                                               // 0x02D4 (size: 0x4)
    float ShieldThickness;                                                            // 0x02D8 (size: 0x4)
    FVector RelativeLocation;                                                         // 0x02DC (size: 0xC)
    float MaxShieldTime;                                                              // 0x02E8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02EC (size: 0x4)
    TArray<FSBRebellionLargeShieldAdjustTimeSetting> AdjustTimeConditionList;         // 0x02F0 (size: 0x10)
    FDataTableRowHandle NoShieldDamageStatusAilment;                                  // 0x0300 (size: 0x10)
    FSBDefenceGuardConfig LargeShieldGuardConfig;                                     // 0x0310 (size: 0xC)
    char padding_1[0x4];                                                              // 0x031C (size: 0x4)
    FDataTableRowHandle OverlapAttackProjectile;                                      // 0x0320 (size: 0x10)
    FSBAttackID MeleePushBackAttack;                                                  // 0x0330 (size: 0x4)
    char padding_2[0x4];                                                              // 0x0334 (size: 0x4)
    TArray<FSBRebellionLargeShieldChargeLevelSetting> ChargeSettingList;              // 0x0338 (size: 0x10)
    TArray<FSBConditionCheckFloatParam> ChargeAmountModifyList;                       // 0x0348 (size: 0x10)
    TArray<FSBGuardEffectSetting> GuardEffectSettingList;                             // 0x0358 (size: 0x10)
    TArray<FSBConditionCheckParam> ShockWaveConditionList;                            // 0x0368 (size: 0x10)
    TArray<FSBRebellionLargeShieldGuardSucceededSelfStatusAilment> GuardSucceededSelfStatusAilmentList; // 0x0378 (size: 0x10)
    uint8 GuardSucceededSelfStatusAilmentCountMax;                                    // 0x0388 (size: 0x1)
    char padding_3[0x3];                                                              // 0x0389 (size: 0x3)
    float GuardSucceededSelfStatusAilmentInterval;                                    // 0x038C (size: 0x4)

    float GetShieldEnergyAmount(const class ASBPlayerCharacter* PlayerCharacter);
}; // Size: 0x390

class USBRebellionMarkerChargeSkill : public USBRebellionChargeSkill
{
    FSBSkillMarkerSetting MarkerSetting;                                              // 0x0300 (size: 0x70)

}; // Size: 0x370

class USBRebellionPowerBurstSkill : public USBRebellionSkillInfo
{
    TArray<FSBRebellionSpecialSkillHandle> ChangeSkillHandleList;                     // 0x02C8 (size: 0x10)
    float UseGaugeAmount;                                                             // 0x02D8 (size: 0x4)

}; // Size: 0x2E0

class USBRebellionProtectionSkill : public USBRebellionSkillInfo
{
    FSBEffectAsset GuardSuccessEffect;                                                // 0x02C8 (size: 0x1A8)
    TArray<FSBConditionCheckRowHandleParam> GuardLaunchProjectileList;                // 0x0470 (size: 0x10)
    FName GuardLaunchProjectileSpawnSocketName;                                       // 0x0480 (size: 0x8)
    FVector GuardLaunchProjectileOffsetFromOwner;                                     // 0x0488 (size: 0xC)
    FVector GuardLaunchProjectileOffsetFromLargeShield;                               // 0x0494 (size: 0xC)
    float GuardLaunchProjectileCoolDown;                                              // 0x04A0 (size: 0x4)

}; // Size: 0x4A8

class USBRebellionShieldDashSkill : public USBRebellionSkillInfo
{
    float DashStamina;                                                                // 0x02D0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02D4 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> DashStaminaModifySettingList;                 // 0x02D8 (size: 0x10)
    TArray<FSBRebellionShieldDashDamageUpConfig> DamageUpSettingList;                 // 0x02E8 (size: 0x10)
    FSBAttackID DashEndAttackID;                                                      // 0x02F8 (size: 0x4)

}; // Size: 0x300

class USBRebellionShieldGaugeDamageMagnificationPassiveSkill : public USBPlayerPassiveSkill
{
    TArray<FSBConditionCheckFloatCurveParam> DamageMagnificationCurveSettings;        // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBRebellionShieldPressureSkill : public USBRebellionSkillInfo
{
    TArray<FDataTableRowHandle> ChangeSkillHandleList;                                // 0x02C8 (size: 0x10)

}; // Size: 0x2D8

class USBRebellionSkillInfo : public USBSkillInfoClass
{
    bool bNeedShield;                                                                 // 0x02A0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x02A1 (size: 0x7)
    TArray<FSBConditionCheckParam> NotNeedShieldConditionList;                        // 0x02A8 (size: 0x10)
    TArray<FSBConditionCheckFloatParam> CastShieldDurabilityList;                     // 0x02B8 (size: 0x10)

}; // Size: 0x2C8

class USBRebellionTauntSkill : public USBSkillInfoClass
{
    TArray<FSBAttackID> NotCorrespondingAttackIDList;                                 // 0x02A0 (size: 0x10)
    TArray<FSBConditionCheckRowHandleParam> GiveStatusAilmentList;                    // 0x02B0 (size: 0x10)
    TArray<FSBConditionCheckRowHandleParam> DeactiveSelfStatusAilmentList;            // 0x02C0 (size: 0x10)
    float GraceTime;                                                                  // 0x02D0 (size: 0x4)
    int32 MaxNumCharacterGiveStatus;                                                  // 0x02D4 (size: 0x4)
    bool IsBattleImagineGiveStatusAilment;                                            // 0x02D8 (size: 0x1)

}; // Size: 0x2E0

class USBReplicationGraph : public UReplicationGraph
{
    TArray<class UClass*> SpatializedClasses;                                         // 0x04A8 (size: 0x10)
    TArray<class UClass*> NonSpatializedChildClasses;                                 // 0x04B8 (size: 0x10)
    TArray<class UClass*> AlwaysRelevantClasses;                                      // 0x04C8 (size: 0x10)
    class UReplicationGraphNode_GridSpatialization2D* GridNode;                       // 0x04D8 (size: 0x8)
    class UReplicationGraphNode_ActorList* AlwaysRelevantNode;                        // 0x04E0 (size: 0x8)
    char padding_0[0x50];                                                             // 0x04E8 (size: 0x50)
    TArray<class USBReplicationGraphNode*> SBReplicationGraphNodeList;                // 0x0538 (size: 0x10)
    TArray<class UClass*> ExplicitySetReplicationInfoClasses;                         // 0x0548 (size: 0x10)
    char padding_1[0x98];                                                             // 0x0558 (size: 0x98)
    int32 CurrentOneFrameProcessedConnections;                                        // 0x05F0 (size: 0x4)

    void NotifyPlayerReplicateState(class AActor* PlayerActor, const FVector& Location);
}; // Size: 0x600

class USBReplicationGraphNode : public UReplicationGraphNode
{
    char padding_0[0x60];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x60

class USBReplicationGraphNode_AlwaysRelevant_ForConnection : public UReplicationGraphNode
{
    class AActor* LastPawn;                                                           // 0x0270 (size: 0x8)

}; // Size: 0x280

class USBReplicationGraphNode_City_PlayerState_ForConnection : public USBReplicationGraphNode
{
    TArray<FSBPlayerStateRepForCity> PlayerRepStateList;                              // 0x0060 (size: 0x10)

}; // Size: 0x88

class USBReplicationGraphNode_Field_EnemyCharacter_ForConnection : public UReplicationGraphNode
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBReplicationGraphNode_Field_PlayerCharacter_ForConnection : public UReplicationGraphNode
{
    char padding_0[0x80];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x80

class USBReplicationGraphNode_Field_PlayerState_ForConnection : public UReplicationGraphNode
{
    char padding_0[0xA0];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xA0

class USBReplicationGraphNode_GlobalPlayer : public USBReplicationGraphNode
{
    TArray<FSBGlobalRepTargetInfo> WorldActorList;                                    // 0x0060 (size: 0x10)

}; // Size: 0x80

class USBReplicationGraphNode_PlayerStateFrequencyLimiter : public UReplicationGraphNode
{
    char padding_0[0x78];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x78

class USBReplicationGraphNode_Player_ForGlobalConnection : public USBReplicationGraphNode_GlobalPlayer
{
    FSBReplicationPlayerSyncImportant SyncObject;                                     // 0x0080 (size: 0x60)

}; // Size: 0xE0

class USBReplicationGraphNode_ViewController_ForConnection : public USBReplicationGraphNode
{
    char padding_0[0x68];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x68

class USBReplicationGraph_City : public USBReplicationGraph
{
    class USBReplicationGraphNode_City_PlayerState_ForConnection* PlayerStateConnectionNode; // 0x05F8 (size: 0x8)
    class USBReplicationGraphNode_Player_ForGlobalConnection* PlayerCharacterConnectionNode; // 0x0600 (size: 0x8)
    class USBReplicationGraphNode_Player_ForGlobalConnection* PlayerCharacterConnectionNode2; // 0x0608 (size: 0x8)

}; // Size: 0x610

class USBReplicationGraph_Field : public USBReplicationGraph
{
    TArray<class APlayerState*> WorldPlayerStateList;                                 // 0x05F8 (size: 0x10)
    TArray<class ASBPlayerCharacter*> WorldPlayerCharacterList;                       // 0x0608 (size: 0x10)
    TArray<class ASBEnemyCharacter*> WorldEnemyCharacterList;                         // 0x0618 (size: 0x10)
    class USBReplicationGraphNode_City_PlayerState_ForConnection* PlayerStateConnectionNode; // 0x0628 (size: 0x8)
    class USBReplicationGraphNode_Player_ForGlobalConnection* PlayerCharacterConnectionNode; // 0x0630 (size: 0x8)
    class USBReplicationGraphNode_Player_ForGlobalConnection* EnemyCharacterConnectionNode; // 0x0638 (size: 0x8)

}; // Size: 0x640

class USBReplicationTestComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)

    void RequestRepTest();
    void Multicast_RepTest();
}; // Size: 0xB8

class USBReportComponent : public USBPlayerPropertyComponent
{
    FSBReportComponentOnRequestReportSendDelegate OnRequestReportSendDelegate;        // 0x00B8 (size: 0x10)
    void OnRequestReportSendDelegate(const bool bWasSuccessful, const int32 RetCode);

    void ServerRequestReportSend(const FReportData& ReportData);
    void SaveReportedLog(FString TargetCharacterId);
    void RequestReportSend(const FReportData& ReportData);
    void OnRequestReportSendDelegate__DelegateSignature(const bool bWasSuccessful, const int32 RetCode);
    bool IsAbleToReport(FString TargetCharacterId);
    void ClientRequestReportSendComplete(const bool bWasSuccessful, const int32& RetCode);
}; // Size: 0xE8

class USBReportLogSaveGame : public USaveGame
{
    FString SaveSlotName;                                                             // 0x0028 (size: 0x10)
    uint32 UserIndex;                                                                 // 0x0038 (size: 0x4)
    char padding_0[0x4];                                                              // 0x003C (size: 0x4)
    TMap<class FString, class FSBReportedInfo> ReportedInfoMaps;                      // 0x0040 (size: 0x50)

}; // Size: 0x90

class USBResearchTeamComponent : public USBPlayerControllerComponentBase
{
    FSBResearchTeamComponentOnGetListDelegate OnGetListDelegate;                      // 0x00B8 (size: 0x10)
    void OnGetListDelegate(bool Result);
    FSBResearchTeamComponentOnActivateDelegate OnActivateDelegate;                    // 0x00C8 (size: 0x10)
    void OnActivateDelegate(bool Result);

    void Server_OnActivate(int32 InRetCode, const FSBResearchTeamData& InData);
    void Server_Activate();
    void Request_GetList();
    void Request_Activate();
    void OnGetListDelegate__DelegateSignature(bool Result);
    void OnGetList(int32 InRetCode);
    void OnActivateDelegate__DelegateSignature(bool Result);
    TArray<FSBResearchTeamData> GetList();
    FTimespan GetDuration();
    FSBResearchTeamData GetData();
    void Client_Sync(const FSBResearchTeamData& InData);
    void Client_Activate(bool Result, const FSBResearchTeamData& InData);
}; // Size: 0x128

class USBRespawnHUD : public UUserWidget
{
    bool IsGameOver;                                                                  // 0x0278 (size: 0x1)
    bool IsInit;                                                                      // 0x0279 (size: 0x1)
    bool IsBattleAreaMessage;                                                         // 0x027A (size: 0x1)
    char padding_0[0x5];                                                              // 0x027B (size: 0x5)
    class UCanvasPanel* RootPanel;                                                    // 0x0280 (size: 0x8)
    class UPanelWidget* KeyOverlay;                                                   // 0x0288 (size: 0x8)
    class USBCountdownUI* CountdownUI;                                                // 0x0290 (size: 0x8)

    void OnUpdateGauge();
    void DisableRespawn();
}; // Size: 0x298

class USBResponseChecker : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void Request_GetAPICheck(class ASBPlayerController* InPlayerController, bool bServer, FString URL);
    void Request_APICheck(class ASBPlayerController* InPlayerController, bool bServer, FString URL, FString PostData);
    void OnCompleteAPICheck(bool bWasSuccessful, FString Response);
    FString GenerateParamData(const TArray<FSBDebugPostDataType>& PostData);
}; // Size: 0x278

class USBResultBaseWidget : public UUserWidget
{
    FSBResultBaseWidgetOnEndDelegate OnEndDelegate;                                   // 0x0278 (size: 0x10)
    void OnEndDelegate();
    FKey MenuGamePadKey_;                                                             // 0x0288 (size: 0x18)
    FKey MenuKeyboardKey_;                                                            // 0x02A0 (size: 0x18)
    ESBUIKeyConfigAction ShortcutRingKeyConfigAct_;                                   // 0x02B8 (size: 0x1)
    char padding_0[0x7];                                                              // 0x02B9 (size: 0x7)
    TArray<FKey> ShortcutRingGamePadKey_;                                             // 0x02C0 (size: 0x10)
    TArray<FKey> ShortcutRingKeyboardKey_;                                            // 0x02D0 (size: 0x10)

    void VisibleInputUI();
    void SetVisibleMouseCursor(bool IsVisible);
    void SetEnableControlShortcutRing(bool Flag);
    void SetEnableControlMenu(bool Flag);
    void Open();
    void OnTerminate();
    void OnInitialize();
    void OnEventKeyUp(const FKeyEvent& Event);
    void OnEventKeyDown(const FKeyEvent& Event);
    void OnEndDelegate__DelegateSignature();
    void OnEnd();
    bool IsEnableControlShortcutRing();
    bool IsEnableControlMenu();
    void ExecuteShortcutRing();
    void ExecuteMenu();
    void EventKeyUp(const FKeyEvent& Event);
    void EventKeyDown(const FKeyEvent& Event);
    void End();
    void DebugPrint(const FString inString);
    void Close();
}; // Size: 0x2F8

class USBResultBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool IsGameOverResult(class UObject* InWorldContextObject);
    bool IsEndResult(class UObject* InWorldContextObject);
}; // Size: 0x28

class USBReticleCharge : public UUserWidget
{
    class UImage* ShotCharge;                                                         // 0x0278 (size: 0x8)
    class USBRuntimeTextBlock* TextLevel;                                             // 0x0280 (size: 0x8)
    class UTextBlock* TextLevelValue;                                                 // 0x0288 (size: 0x8)

    void Setup(int32 InLevel, bool IsLockOn, bool IsCharge, float InChargeRate);
    void SetRayHit(bool bRayHit);
}; // Size: 0x2A0

class USBReticleComponent : public UActorComponent
{
    float m_RayLength;                                                                // 0x0134 (size: 0x4)
    bool DebugDrawLineTrace;                                                          // 0x0138 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0139 (size: 0x3)
    float DebugDrawLineLifetime;                                                      // 0x013C (size: 0x4)

}; // Size: 0x150

class USBRichTextBlock : public UWidget
{
    FName TextTableName;                                                              // 0x0120 (size: 0x8)
    class USBTextTableAsset* TextTableAsset;                                          // 0x0128 (size: 0x8)
    bool bIsNumberId;                                                                 // 0x0130 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0131 (size: 0x3)
    int32 TextId;                                                                     // 0x0134 (size: 0x4)
    FName TextIdString;                                                               // 0x0138 (size: 0x8)
    FText Text;                                                                       // 0x0140 (size: 0x18)
    bool UsePlainText;                                                                // 0x0158 (size: 0x1)
    bool bEnableWidthFitting;                                                         // 0x0159 (size: 0x1)
    char padding_1[0x2];                                                              // 0x015A (size: 0x2)
    FSBRichTextBlockTextDelegate TextDelegate;                                        // 0x015C (size: 0x10)
    FText GetText();
    char padding_2[0x4];                                                              // 0x016C (size: 0x4)
    FSlateFontInfo Font;                                                              // 0x0170 (size: 0x88)
    FSlateFontInfo RubyFont;                                                          // 0x01F8 (size: 0x88)
    int32 RubySize;                                                                   // 0x0280 (size: 0x4)
    FVector2D RubyOffset;                                                             // 0x0284 (size: 0x8)
    int32 BigRubySize;                                                                // 0x028C (size: 0x4)
    FVector2D BigRubyOffset;                                                          // 0x0290 (size: 0x8)
    FLinearColor Color;                                                               // 0x0298 (size: 0x10)
    TEnumAsByte<ETextJustify::Type> Justification;                                    // 0x02A8 (size: 0x1)
    bool AutoWrapText;                                                                // 0x02A9 (size: 0x1)
    char padding_3[0x2];                                                              // 0x02AA (size: 0x2)
    float WrapTextAt;                                                                 // 0x02AC (size: 0x4)
    FMargin Margin;                                                                   // 0x02B0 (size: 0x10)
    float LineHeightPercentage;                                                       // 0x02C0 (size: 0x4)
    char padding_4[0xC];                                                              // 0x02C4 (size: 0xC)
    FTextBlockStyle DefaultStyle;                                                     // 0x02D0 (size: 0x2A0)
    char padding_5[0x20];                                                             // 0x0570 (size: 0x20)
    FSBRichTextBlockOnLinkClicked OnLinkClicked;                                      // 0x0590 (size: 0x10)
    void OnLinkClicked(const TArray<FString>& Keys, const TArray<FString>& Values);

    void SetText(const FText& InText);
    void SetColor(const FLinearColor& InColor);
}; // Size: 0x5C0

class USBRichTextBlockDecorator : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBRmShopComponent : public UActorComponent
{
    FSBRmShopComponentOnCertificationDelegate OnCertificationDelegate;                // 0x00B8 (size: 0x10)
    void OnCertificationDelegate(const bool Result, const int32 RetCode);
    FSBRmShopComponentOnGetHistoryDelegate OnGetHistoryDelegate;                      // 0x00C8 (size: 0x10)
    void OnGetHistoryDelegate(const bool Result, const int32 RetCode, const TArray<FSBCashHistory>& HistoryData);
    FSBRmShopComponentOnGetCryptocurrencyDelegate OnGetCryptocurrencyDelegate;        // 0x00D8 (size: 0x10)
    void OnGetCryptocurrencyDelegate(const bool Result, const int32 RetCode, const FSBCryptoCurrency& Cryptocurrency);
    char padding_0[0x8];                                                              // 0x00E8 (size: 0x8)
    FSBRmShopComponentOnGetHistoryExpiredDelegate OnGetHistoryExpiredDelegate;        // 0x00F0 (size: 0x10)
    void OnGetHistoryExpiredDelegate(const bool Result, const int32 RetCode, const FSBHistoryExpired& HistoryExpired);
    FSBRmShopComponentOnCheckStatus OnCheckStatus;                                    // 0x0100 (size: 0x10)
    void OnCheckStatus(const ESBRmShopErrorStatus Result, const int32 RetCode);
    FSBRmShopComponentOnGetShopItemsDelegate OnGetShopItemsDelegate;                  // 0x0110 (size: 0x10)
    void OnGetShopItemsDelegate(const bool Result, const int32 RetCode, const TArray<FSBShopItem>& ShopItems);
    FSBRmShopComponentOnValidateItemDelegate OnValidateItemDelegate;                  // 0x0120 (size: 0x10)
    void OnValidateItemDelegate(const bool Result, const int32 RetCode, const bool IsOk, const FSBPurchaseCondition InPurchaseConditionData);
    FSBRmShopComponentOnGetShopItemsRoPSDelegate OnGetShopItemsRoPSDelegate;          // 0x0130 (size: 0x10)
    void OnGetShopItemsRoPS(const bool Result, const int32 RetCode, const TArray<FSBShopItemRoPS>& ResponseData, const int32 PruchasePrice);
    FSBRmShopComponentOnPurchaseRoPS OnPurchaseRoPS;                                  // 0x0140 (size: 0x10)
    void OnPurchaseRoPS(const bool Result, const int32 RetCode, const FSBPurchaseRoPSResponse& ResponseData);
    FSBRmShopComponentOnRetryPurchaseRoPS OnRetryPurchaseRoPS;                        // 0x0150 (size: 0x10)
    void OnRetryPurchaseRoPS(const bool Result, const int32 RetCode);
    FSBRmShopComponentOnCancelPurchaseRoPS OnCancelPurchaseRoPS;                      // 0x0160 (size: 0x10)
    void OnCancelPurchaseRoPS(const bool Result, const int32 RetCode);
    FSBRmShopComponentOnNotifyPayment OnNotifyPayment;                                // 0x0170 (size: 0x10)
    void OnNotifyPayment(const bool Result, const int32 RetCode, const FSBPurchaseRoPSResponse& ResponseData);
    char padding_1[0x8];                                                              // 0x0180 (size: 0x8)
    FSBRmShopComponentOnPurchaseFS OnPurchaseFS;                                      // 0x0188 (size: 0x10)
    void OnPurchaseFS(const bool Result, const int32 RetCode, const FSBPurchaseFSResponse& ResponseData);
    FSBRmShopComponentOnCheckCouponCode OnCheckCouponCode;                            // 0x0198 (size: 0x10)
    void OnCheckCouponCode(const bool Result, const int32 RetCode, const bool IsEnable, const int32 Rate);
    FSBRmShopComponentOnTermsOfUseGet OnTermsOfUseGet;                                // 0x01A8 (size: 0x10)
    void OnTermsOfUseGet(const TArray<FSBTermsOfUseInfo>& TermsOfUseList);
    FSBRmShopComponentOnTermsOfUseRead OnTermsOfUseRead;                              // 0x01B8 (size: 0x10)
    void OnTermsOfUseRead(const int32 RetCode);
    FSBRmShopComponentOnPurchaseSPS OnPurchaseSPS;                                    // 0x01C8 (size: 0x10)
    void OnPurchaseSPS(const bool Result, const int32 RetCode, const FSBPurchaseFSResponse& ResponseData);
    FSBRmShopComponentOnExchangeItemDelegate OnExchangeItemDelegate;                  // 0x01D8 (size: 0x10)
    void OnExchangeItemDelegate(const int32 RetCode, const int32 BP_Point);
    FSBRmShopComponentOnGetUserCouponDelegate OnGetUserCouponDelegate;                // 0x01E8 (size: 0x10)
    void OnGetUserCouponDelegate(const int32 RetCode, bool IsSuccess, bool IsQuestClear, const FSBUserCoupon UserCoupon);
    FSBRmShopComponentOnGenerateCouponDelegate OnGenerateCouponDelegate;              // 0x01F8 (size: 0x10)
    void OnGenerateCouponDelegate(const int32 RetCode, const FSBUserCoupon UserCoupon);

    void ServerGetUserCoupon();
    void ServerGenerateCoupon(int32 CouponId);
    void ServerCertification(const int32 InYear, const int32 InMonth);
    void Server_ValidateItem(const ESBRmShopMenuType InShopType, int32 InItemID, int32 InAmount);
    void Server_RetryPurchaseRoPS();
    void Server_PurchaseSPS(int32 InItemID, int32 InAmount, int32 InPayType, int32 InSeasonId);
    void Server_PurchaseRoPS(FString InPaymentType, int32 InShopId, int32 InItemID);
    void Server_PurchaseFS(const ESBRmShopMenuType InShopType, int32 InItemID, int32 InAmount, FString InCoupon);
    void Server_OnSellOwnItem(int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems, const int32 BpPointAfter);
    void Server_GetHistoryExpired(const ESBHistoryType InHistoryType);
    void Server_GetHistory(const ESBHistoryType InType, int32 InYear, const int32 InMonth, const int32 InIndex, const int32 InCount);
    void Server_GetCryptocurrency();
    void Server_ExchangeItem(const TArray<FString>& UniqueIdList, const TArray<int32>& ItemAmountList, const TArray<int32>& ItemStorageNo);
    void Server_CheckCouponCode(FString CouponCode);
    void Server_CancelPurchaseRoPS();
    void SaveSeasonPoint(const int32 InSeasonPoint);
    void RequestTermsOfUseRead(TArray<int32> InIds);
    void RequestTermsOfUseGet();
    void RequestGetUserCoupon();
    void RequestGenerateCoupon(int32 CouponId);
    void Request_ValidateItem(ESBRmShopMenuType ShopType, int32 InItemID, int32 InAmount);
    void Request_RetryPurchaseRoPS();
    void Request_PurchaseSPS(int32 InItemID, int32 InAmount, int32 InPayType, int32 InSeasonId);
    void Request_PurchaseRoPS(FString InPaymentType, int32 InShopId, int32 InItemID);
    void Request_PurchaseFS(ESBRmShopMenuType ShopType, int32 InItemID, int32 InAmount, FString InCoupon);
    void Request_GetShopItemsRoPS(int32 InShopId);
    void Request_GetShopItems(ESBRmShopMenuType ShopType, int32 InShopId);
    void Request_GetHistoryExpired(class ASBPlayerController* InPlayerController, ESBHistoryType InHistoryType);
    void Request_GetHistory(ESBHistoryType InType, int32 InYear, int32 InMonth, int32 InIndex, int32 InCount);
    bool Request_GetCryptocurrency(class ASBPlayerController* InPlayerController);
    void Request_ExchangeItem(const TArray<FString>& UniqueIdList, const TArray<int32>& ItemAmountList, const TArray<int32>& ItemStorageNo);
    void Request_CheckStatus(ESBRmShopType ShopType);
    void Request_CheckCouponCode(FString CouponCode);
    void Request_Certification(int32 Year, int32 Month);
    void Request_CancelPurchaseRoPS();
    void OnValidateItemDelegate__DelegateSignature(const bool Result, const int32 RetCode, const bool IsOk, const FSBPurchaseCondition InPurchaseConditionData);
    void OnTermsOfUseRead__DelegateSignature(const int32 RetCode);
    void OnTermsOfUseGet__DelegateSignature(const TArray<FSBTermsOfUseInfo>& TermsOfUseList);
    void OnRetryPurchaseRoPS__DelegateSignature(const bool Result, const int32 RetCode);
    void OnPurchaseSPS__DelegateSignature(const bool Result, const int32 RetCode, const FSBPurchaseFSResponse& ResponseData);
    void OnPurchaseRoPS__DelegateSignature(const bool Result, const int32 RetCode, const FSBPurchaseRoPSResponse& ResponseData);
    void OnPurchaseFS__DelegateSignature(const bool Result, const int32 RetCode, const FSBPurchaseFSResponse& ResponseData);
    void OnNotifyPayment__DelegateSignature(const bool Result, const int32 RetCode, const FSBPurchaseRoPSResponse& ResponseData);
    void OnGetUserCouponDelegate__DelegateSignature(const int32 RetCode, bool IsSuccess, bool IsQuestClear, const FSBUserCoupon UserCoupon);
    void OnGetShopItemsRoPS__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FSBShopItemRoPS>& ResponseData, const int32 PruchasePrice);
    void OnGetShopItemsDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FSBShopItem>& ShopItems);
    void OnGetHistoryExpiredDelegate__DelegateSignature(const bool Result, const int32 RetCode, const FSBHistoryExpired& HistoryExpired);
    void OnGetHistoryDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FSBCashHistory>& HistoryData);
    void OnGetCryptocurrencyDelegate__DelegateSignature(const bool Result, const int32 RetCode, const FSBCryptoCurrency& Cryptocurrency);
    void OnGenerateCouponDelegate__DelegateSignature(const int32 RetCode, const FSBUserCoupon UserCoupon);
    void OnExchangeItemDelegate__DelegateSignature(const int32 RetCode, const int32 BP_Point);
    void OnCheckStatus__DelegateSignature(const ESBRmShopErrorStatus Result, const int32 RetCode);
    void OnCheckCouponCode__DelegateSignature(const bool Result, const int32 RetCode, const bool IsEnable, const int32 Rate);
    void OnCertificationDelegate__DelegateSignature(const bool Result, const int32 RetCode);
    void OnCancelPurchaseRoPS__DelegateSignature(const bool Result, const int32 RetCode);
    int32 GetSeasonPoint();
    void CreateURL(FString InURL, FString& OutURL);
    void ClientGetUserCoupon(int32 InRetCode, bool IsSuccess, bool IsQuestClear, const FSBUserCoupon UserData);
    void ClientGenerateCoupon(int32 InRetCode, const FSBUserCoupon UserData);
    void ClientCertificationComplete(bool bInWasSuccessful, const int32 InRetCode);
    void Client_ValidateItem(bool bInWasSuccessful, const int32 InRetCode, const bool IsOk, const FSBPurchaseCondition InPurchaseConditionData);
    void Client_SellOwnItem(int32 InRetCode, const TArray<FOwnItemInfo>& DiffOwnItemList, const int32 BpPointAfter);
    void Client_RetryPurchaseRoPS(bool bInWasSuccessful, const int32 InRetCode);
    void Client_PurchaseRoPS(bool bInWasSuccessful, const int32 InRetCode, const FSBPurchaseRoPSResponse InResponseData);
    void Client_PurchaseFS(bool bInWasSuccessful, const int32 InRetCode, const FSBPurchaseFSResponse InResponseData);
    void Client_GetHistoryExpired(bool bInWasSuccessful, const int32 InRetCode, const FSBHistoryExpired InHistoryExpired);
    void Client_GetHistory(bool bInWasSuccessful, const int32 InRetCode, const TArray<FSBCashHistory>& InHistoryData);
    void Client_GetCryptocurrency(bool bInWasSuccessful, const int32 InRetCode, const FSBCryptoCurrency InCryptocurrency);
    void Client_CheckCouponCode(bool bInWasSuccessful, const int32 InRetCode, const bool InEnable, const int32 InRate);
    void Client_CancelPurchaseRoPS(bool bInWasSuccessful, const int32 InRetCode);
}; // Size: 0x208

class USBRmShopMenu : public USBUserWidget
{
    int32 Cert_Year;                                                                  // 0x02B0 (size: 0x4)
    int32 Cert_Month;                                                                 // 0x02B4 (size: 0x4)
    int32 Cert_Count;                                                                 // 0x02B8 (size: 0x4)
    int32 Cert_Age;                                                                   // 0x02BC (size: 0x4)

    void SetEscIconVisibility(bool IsShow);
    void OnSubMenuTermReady_RoPurchaseEx();
    void OnSubMenuTermReady();
    void OnSubDialogCloseReady();
    void OnRsDialogManagerCloseReady();
    void OnEndOutAnim();
    void OnEndInAnim();
    void DialogOpen_Certification();
}; // Size: 0x2C0

class USBRmShopMenuChildBase : public UUserWidget
{
    ESBRmShopMenuType CurrentShopType;                                                // 0x0278 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0279 (size: 0x7)
    class USBRmShopMenu* OwnerRmShopMenu;                                             // 0x0280 (size: 0x8)
    bool IsMaintenanceAll;                                                            // 0x0288 (size: 0x1)

    void ShopOutAnim();
    void ShopInAnim();
    void SetOwnerRmShopMenu(class USBRmShopMenu* InOwnerRmShopMenu);
    void SetMaintenanceAll(bool InIsMaintenanceAll);
    void SetCurrentShopType(ESBRmShopMenuType InCurrentShopType);
    void ListenInput(bool IsStart);
    bool GetMaintenanceAll();
    void CloseExWindow();
}; // Size: 0x290

class USBRsDialog : public USBUserWidget
{
    FSBRsDialogEndDynamicDelegate EndDynamicDelegate;                                 // 0x02C8 (size: 0x10)
    void DialogEndDynamicDelegate(ERsDialogResult Result);
    ERsDialogResult OkOperation;                                                      // 0x02D8 (size: 0x1)
    ERsDialogResult CancelOperation;                                                  // 0x02D9 (size: 0x1)

    void StartProcessingRsDialog(const FText& Message);
    void StartErrorMessageRsDialog(int32 MessageId, int32 ErrorCode);
    void SetYesButtonClickSe(class UAkAudioEvent* AkEvent, FString EventName);
    void SetDefaultOperation(ERsDialogResult InOkOperation, ERsDialogResult InCancelOperation);
    void OnEndDialog(const ERsDialogResult Result);
    void EndProcessingRsDialog();
    void DialogEndDynamicDelegate__DelegateSignature(ERsDialogResult Result);
}; // Size: 0x2E0

class USBRsDialogBPFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    class USBRsDialog* ShowProcessingRsDialog(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, const FText Message, class UUserWidget* InParentWidget, TEnumAsByte<EUIZOrder::Type> InZOrder);
    void ShowMessageDialog(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, const FText Message, class UUserWidget* InParentWidget, TEnumAsByte<EUIZOrder::Type> InZOrder);
    void ShowErrorMessageRsDialog(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, int32 MessageId, int32 ErrorCode, class UUserWidget* InParentWidget, TEnumAsByte<EUIZOrder::Type> InZOrder);
    void HideProcessingRsDialog(class UObject* WorldContextObject, FLatentActionInfo LatentInfo);
}; // Size: 0x28

class USBRuntimeTextBlock : public UTextBlock
{
    class USBTextTableAsset* TextTable;                                               // 0x02F8 (size: 0x8)
    int32 TextId;                                                                     // 0x0300 (size: 0x4)
    FName NameTextId;                                                                 // 0x0304 (size: 0x8)

    void SetTextTable(class USBTextTableAsset* InTextTable);
    void SetTextId(int32 InTextId);
    void SetNameTextId(FName InTextId);
}; // Size: 0x310

class USBSTActorTag : public USBSTInitializer
{
    FAIFwBTNodePropertyString Tag;                                                    // 0x0038 (size: 0x20)

}; // Size: 0x58

class USBSTBattleSequence : public USBSTInitializer
{
    bool bContinuous;                                                                 // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBSTDestroyMode : public USBSTInitializer
{
    bool bWhenNoPlayersNearby;                                                        // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBSTEffectSettings : public USBSTInitializer
{
    bool bSpawnEffect;                                                                // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBSTEnemyWave : public UAIFwBTDecoratorNode
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBSTEnemyWaveArea : public UAIFwBTDecoratorNode
{
    FAIFwBTNodePropertyString SpawnAreaKey;                                           // 0x0038 (size: 0x20)

}; // Size: 0x58

class USBSTInitializer : public UAIFwBTDecoratorNode
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBSTLeader : public USBSTInitializer
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBSTPickSpawnSettings : public UAIFwBTNode
{
    FString LocationKey;                                                              // 0x0040 (size: 0x10)
    FString EnemyIdKey;                                                               // 0x0050 (size: 0x10)
    FString LevelMinKey;                                                              // 0x0060 (size: 0x10)
    FString LevelMaxKey;                                                              // 0x0070 (size: 0x10)
    FString RespawnTimeKey;                                                           // 0x0080 (size: 0x10)

}; // Size: 0x90

class USBSTRespawnSettings : public USBSTInitializer
{
    FAIFwBTNodePropertyFloat RespawnTime;                                             // 0x0038 (size: 0x18)

}; // Size: 0x50

class USBSTSpawnActor : public UAIFwBTNode
{
    TSubclassOf<class AActor> ActorClass;                                             // 0x0040 (size: 0x8)
    FString Location;                                                                 // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBSTSpawnEnemy : public UAIFwBTNode
{
    TSubclassOf<class ASBEnemyCharacter> EnemyClass;                                  // 0x0040 (size: 0x8)
    FString Location;                                                                 // 0x0048 (size: 0x10)
    int32 LevelMin;                                                                   // 0x0058 (size: 0x4)
    int32 LevelMax;                                                                   // 0x005C (size: 0x4)
    int32 LevelMin2;                                                                  // 0x0060 (size: 0x4)
    int32 LevelMax2;                                                                  // 0x0064 (size: 0x4)
    int32 LevelMin3;                                                                  // 0x0068 (size: 0x4)
    int32 LevelMax3;                                                                  // 0x006C (size: 0x4)
    int32 LevelMin4;                                                                  // 0x0070 (size: 0x4)
    int32 LevelMax4;                                                                  // 0x0074 (size: 0x4)
    int32 LevelMin5;                                                                  // 0x0078 (size: 0x4)
    int32 LevelMax5;                                                                  // 0x007C (size: 0x4)

}; // Size: 0x80

class USBSTSpawnEnemyById : public UAIFwBTNode
{
    FAIFwBTNodePropertyString EnemyId;                                                // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString Location;                                               // 0x0060 (size: 0x20)
    FAIFwBTNodePropertyInt LevelMin;                                                  // 0x0080 (size: 0x18)
    FAIFwBTNodePropertyInt LevelMax;                                                  // 0x0098 (size: 0x18)

}; // Size: 0xB0

class USBSTSpawnEnemyBySetId : public UAIFwBTNode
{
    FAIFwBTNodePropertyString EnemySetId;                                             // 0x0040 (size: 0x20)
    FAIFwBTNodePropertyString Location;                                               // 0x0060 (size: 0x20)

}; // Size: 0x80

class USBSTSpawnEnemySet : public UAIFwBTNode
{
    FAIFwBTNodePropertyString Location;                                               // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBSTSpawnEnemyWaveBySetId : public UAIFwBTNode
{
    FAIFwBTNodePropertyString Location;                                               // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBSTWaitForEnemyWaveAssetLoaded : public UAIFwBTNode
{
    FAIFwBTNodePropertyString SpawnAreaKey;                                           // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBSTWaitForEnemyWaveStepSatisfied : public UAIFwBTNode
{
    FAIFwBTNodePropertyString SpawnAreaKey;                                           // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBSTWaitForMasterDataToReady : public UAIFwBTNode
{
    ESBSTMasterDataType MasterDataType;                                               // 0x0040 (size: 0x1)

}; // Size: 0x48

class USBSTWaitForWaveRuleSatisfied : public UAIFwBTNode
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBScbPopup : public UUserWidget
{
    TArray<FSBScbClassData> ClassDataList;                                            // 0x0278 (size: 0x10)
    FSBScbClassData TotalData;                                                        // 0x0288 (size: 0x24)
    char padding_0[0x4];                                                              // 0x02AC (size: 0x4)
    TArray<FSBScbClassConditionsData> ClassConditionsDataList;                        // 0x02B0 (size: 0x10)

    void CreateDummyData();
    void CreateData();
}; // Size: 0x2C0

class USBScbUtility : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FSBScbClassData GetScbTotalData(const class UObject* WorldContextObject);
    FSBScbClassData GetScbClassData(const class UObject* WorldContextObject, ESBClassType ClassType, int32 OverrideClassLevel);
}; // Size: 0x28

class USBScreenShotUtils : public UObject
{
    FString SaveMyDocumentsFolderPathProjectName;                                     // 0x0040 (size: 0x10)
    FString SaveFileNameBase;                                                         // 0x0050 (size: 0x10)
    bool bAddTimestampString;                                                         // 0x0060 (size: 0x1)
    bool bSaveToMyDocuments;                                                          // 0x0061 (size: 0x1)
    bool bShowUi;                                                                     // 0x0062 (size: 0x1)
    bool bAddUniqueSuffix;                                                            // 0x0063 (size: 0x1)
    char padding_0[0x4];                                                              // 0x0064 (size: 0x4)
    TArray<FWatermarkSetting> WatermarkSettings;                                      // 0x0068 (size: 0x10)
    char padding_1[0x10];                                                             // 0x0078 (size: 0x10)
    TSubclassOf<class UUserWidget> ScreenshotNotificationClass;                       // 0x0088 (size: 0x8)
    class UUserWidget* ScreenshotNotification;                                        // 0x0090 (size: 0x8)
    char padding_2[0xC];                                                              // 0x0098 (size: 0xC)
    int32 SaveProcessFlag;                                                            // 0x00A4 (size: 0x4)
    char padding_3[0x10];                                                             // 0x00A8 (size: 0x10)
    bool bDebugUseEngineProcess;                                                      // 0x00B8 (size: 0x1)
    bool bDebugStopOnCaptured;                                                        // 0x00B9 (size: 0x1)
    bool bDebugStopOnCompressed;                                                      // 0x00BA (size: 0x1)

}; // Size: 0xC0

class USBScriptAsset : public UDataAsset
{
    FString Code;                                                                     // 0x0030 (size: 0x10)

    FString BP_GetCode();
}; // Size: 0x40

class USBScriptBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool SuspendScript(class UObject* InWorldContextObject, const int32 InHandle);
    int32 StartScript_TalkByTriggerArray(class UObject* InWorldContextObject, const TArray<FName>& InMainTriggers, const TArray<FName>& InSubTriggers, TMap<class FName, class FString> ParamMap);
    int32 StartScript_TalkByTrigger(class UObject* InWorldContextObject, const FName& InTrigger, const TArray<FName>& InSubTriggers, TMap<class FName, class FString> ParamMap);
    int32 StartScript_Talk(class UObject* InWorldContextObject, class USBScriptAsset* InScriptAsset, TMap<class FName, class FString> ParamMap);
    int32 StartScript(class UObject* InWorldContextObject, FSBScriptActorCreateDesc InCreateDesc);
    void SetLocalVariable(class UObject* InWorldContextObject, const FName InName, const FString InValue);
    bool GetUserFlag(class UObject* InWorldContextObject, const FName InName, bool& bOutExist);
    ESBScriptStatus GetScriptStatus(class UObject* InWorldContextObject, const int32 InScriptHandle);
    class USBScriptManager* GetScriptManager(class UObject* InWorldContextObject);
    bool GetScriptActorFastForwardFlag(class UObject* InWorldContextObject);
    class ASBScriptActor* GetActiveScriptActor(class UObject* InWorldContextObject);
    bool CheckEventTriggerConditionByTriggerId(class UObject* InWorldContextObject, const FName InTriggerId);
    bool CheckEventTriggerCondition(class UObject* InWorldContextObject, const FSBEventTriggerCondition& InCondition);
    bool CheckEventTriggerCloseConditionByTriggerId(class UObject* InWorldContextObject, const FName InTriggerId);
}; // Size: 0x28

class USBScriptExecutor : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    FString LoadStringFromFile(FString InFilePath);
    TArray<FString> GetLuaScripts();
    void ExecuteSBScript(FString InScriptCode);
    void ExecuteConsoleCommands(FString InConsoleCommands);
}; // Size: 0x278

class USBScriptManager : public UObject
{
    FSBScriptManagerBeginScriptDelegate BeginScriptDelegate;                          // 0x00F0 (size: 0x10)
    void BeginScriptDelegate(class ASBScriptActor* InScriptActor);
    FSBScriptManagerEndScriptDelegate EndScriptDelegate;                              // 0x0100 (size: 0x10)
    void EndScriptDelegate(class ASBScriptActor* InScriptActor, int32 InScriptHandle);

    bool IsScriptRunning();
}; // Size: 0x110

class USBSeasonPassMenu : public USBCommandMenuChildBase
{
    char padding_0[0x2A8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2A8

class USBSeasonPassMenuRewardData : public UObject
{
    TArray<class USBSeasonPassMenuRewardRankData*> RewardList;                        // 0x0028 (size: 0x10)

    void Update();
    void Init();
    int32 GetMaxRank();
    int32 GetAchievedRank();
    void CreateDummyData();
}; // Size: 0x38

class USBSeasonPassMenuRewardItemData : public UObject
{
    FName SeasonPassRewardId;                                                         // 0x0028 (size: 0x8)
    ESBSeasonPassRewardType Plan;                                                     // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    FName RewardId;                                                                   // 0x0034 (size: 0x8)
    int32 Rank;                                                                       // 0x003C (size: 0x4)
    bool bIsReceived;                                                                 // 0x0040 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0041 (size: 0x3)
    TWeakObjectPtr<class USBSeasonPassMenuRewardRankData> Owner;                      // 0x0044 (size: 0x8)

    bool IsValid();
    bool IsMaxRankData();
    bool IsAchieved();
    ESBSeasonPassRewardItemState GetState();
    FSBMasterReward FindMasterReward(bool& bExists);
    bool CanReceive();
}; // Size: 0x50

class USBSeasonPassMenuRewardRankData : public UObject
{
    int32 Rank;                                                                       // 0x0028 (size: 0x4)
    char padding_0[0x4];                                                              // 0x002C (size: 0x4)
    class USBSeasonPassMenuRewardItemData* FreeReward;                                // 0x0030 (size: 0x8)
    class USBSeasonPassMenuRewardItemData* SubscribedReward1;                         // 0x0038 (size: 0x8)
    class USBSeasonPassMenuRewardItemData* SubscribedReward2;                         // 0x0040 (size: 0x8)
    class USBSeasonPassMenuRewardItemData* SubscribedReward3;                         // 0x0048 (size: 0x8)
    TWeakObjectPtr<class USBSeasonPassMenuRewardData> Owner;                          // 0x0050 (size: 0x8)

    bool IsLastReward();
    bool IsCurrentRank();
    bool IsAchieved();
    bool HasCanReceiveItemData();
}; // Size: 0x58

class USBSeasonPassPurchaseMenu : public UUserWidget
{
    TArray<class USBSeasonPassPurchasePlanData*> DataList;                            // 0x0278 (size: 0x10)

    int32 GetDataNum();
    class USBSeasonPassPurchasePlanData* GetData(int32 Index);
    void CreateDummyData();
}; // Size: 0x288

class USBSeasonPassPurchasePlanData : public UObject
{
    int32 PlanIndex;                                                                  // 0x0028 (size: 0x4)
    ESBSeasonPassPlanState PassType;                                                  // 0x002C (size: 0x1)
    char padding_0[0x3];                                                              // 0x002D (size: 0x3)
    FText Name;                                                                       // 0x0030 (size: 0x18)
    FText Description;                                                                // 0x0048 (size: 0x18)
    int32 Price;                                                                      // 0x0060 (size: 0x4)
    bool PaidOnly;                                                                    // 0x0064 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0065 (size: 0x3)
    TArray<class USBSeasonPassPurchaseRewardItemData*> RewardItemList;                // 0x0068 (size: 0x10)
    TArray<class USBSeasonPassPurchaseRewardItemData*> ReceiptRewardItemList;         // 0x0078 (size: 0x10)

    void Init(int32 InPaidPlanIndex);
    void CreateDummyData(int32 InPlanIndex);
}; // Size: 0x88

class USBSeasonPassPurchaseRewardItemData : public UObject
{
    int32 PlanIndex;                                                                  // 0x0028 (size: 0x4)
    ESBSeasonPassPurchaseRewordType Type;                                             // 0x002C (size: 0x1)
    char padding_0[0x3];                                                              // 0x002D (size: 0x3)
    int32 Amount;                                                                     // 0x0030 (size: 0x4)
    int32 CurrentRunk;                                                                // 0x0034 (size: 0x4)
    int32 AfterRunk;                                                                  // 0x0038 (size: 0x4)
    bool bIsOverMax;                                                                  // 0x003C (size: 0x1)
    char padding_1[0x3];                                                              // 0x003D (size: 0x3)
    FName RewardId;                                                                   // 0x0040 (size: 0x8)

    FSBMasterReward FindMasterReward(bool& bExists);
}; // Size: 0x48

class USBSeasonPassQuestMenu : public UUserWidget
{
    TArray<class USBSeasonPassQuestMenuListData*> QuestDataList;                      // 0x0278 (size: 0x10)

    void SetQuestListManager(const FSBSeasonPassQuestListManager& InListManager);
    void Init();
    class USBSeasonPassQuestMenuListData* GetWeeklyQuestData();
    class USBSeasonPassQuestMenuListData* GetSeasonQuestData();
    class USBSeasonPassQuestMenuListData* GetDailyQuestData();
    class USBSeasonPassQuestMenuListData* GetBonusQuestData();
}; // Size: 0x288

class USBSeasonPassQuestMenuBlurprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    int32 GetSeasonWeek(const class UObject* WorldContextObject, const FDateTime InStartDate, const FDateTime InEndDate);
}; // Size: 0x28

class USBSeasonPassQuestMenuListData : public UObject
{
    FSBSeasonPassQuestListData Data;                                                  // 0x0028 (size: 0x18)

    bool IsShowReloadButton();
    TArray<FSBSeasonPassQuestItemData> GetWeekData(const class UObject* WorldContextObject, int32 WeekCount, ESBSeasonPassQuestFilterType InFilter);
    TArray<FSBSeasonPassQuestItemData> GetStandardDataList(const class UObject* WorldContextObject, ESBSeasonPassQuestFilterType InFilter);
    TArray<FSBSeasonPassQuestItemData> GetQuestItemList(const class UObject* WorldContextObject, ESBSeasonPassQuestFilterType InFilter);
    int32 GetLastWeekCount();
    TArray<FSBSeasonPassQuestItemData> GetEventDataList(const class UObject* WorldContextObject, ESBSeasonPassQuestFilterType InFilter);
}; // Size: 0x40

class USBSecondPasswordSender : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void OnAuthorizeSecondPassword(bool bWasSuccessful, int32 ExpireCount, ESendSecondPasswordRole Role, bool bWasAuthorized);
    void AuthorizeSecondPassword(int32 Password, ESendSecondPasswordRole Role);
}; // Size: 0x278

class USBSegmentNavLinkComponent : public UNavRelevantComponent
{
    uint32 NavLinkUserId;                                                             // 0x00F0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x00F4 (size: 0x4)
    TSubclassOf<class UNavArea> EnabledAreaClass;                                     // 0x00F8 (size: 0x8)
    TSubclassOf<class UNavArea> DisabledAreaClass;                                    // 0x0100 (size: 0x8)
    FVector LinkRelativeStartMin;                                                     // 0x0108 (size: 0xC)
    FVector LinkRelativeStartMax;                                                     // 0x0114 (size: 0xC)
    FVector LinkRelativeEndMin;                                                       // 0x0120 (size: 0xC)
    FVector LinkRelativeEndMax;                                                       // 0x012C (size: 0xC)
    TEnumAsByte<ENavLinkDirection::Type> LinkDirection;                               // 0x0138 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0139 (size: 0x3)
    uint8 bLinkEnabled;                                                               // 0x013C (size: 0x1)
    uint8 bNotifyWhenEnabled;                                                         // 0x013C (size: 0x1)
    uint8 bNotifyWhenDisabled;                                                        // 0x013C (size: 0x1)
    uint8 bCreateBoxObstacle;                                                         // 0x013C (size: 0x1)
    char padding_2[0x3];                                                              // 0x013D (size: 0x3)
    FVector ObstacleOffset;                                                           // 0x0140 (size: 0xC)
    FVector ObstacleExtent;                                                           // 0x014C (size: 0xC)
    TSubclassOf<class UNavArea> ObstacleAreaClass;                                    // 0x0158 (size: 0x8)
    float BroadcastRadius;                                                            // 0x0160 (size: 0x4)
    float BroadcastInterval;                                                          // 0x0164 (size: 0x4)
    TEnumAsByte<ECollisionChannel> BroadcastChannel;                                  // 0x0168 (size: 0x1)

}; // Size: 0x1A8

class USBSerialCodeComponent : public UActorComponent
{
    FSBSerialCodeComponentOnSerialCodeAuthenticateDelegate OnSerialCodeAuthenticateDelegate; // 0x00B8 (size: 0x10)
    void OnSerialCodeAuthenticateDelegate(const bool Result, const bool AuthenticateSuccessed);

    bool Request_SerialCodeAuthenticate(FString InSerialCode);
    void OnSerialCodeAuthenticateDelegate__DelegateSignature(const bool Result, const bool AuthenticateSuccessed);
}; // Size: 0xC8

class USBSerializeTextTableDataFiles : public UObject
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC8

class USBSerializeTextTableFiles : public UObject
{
    char padding_0[0xC8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xC8

class USBServerSelectWindow : public UUserWidget
{
    TArray<FSBServerEntry> ServerList;                                                // 0x0278 (size: 0x10)

    void UpdateServerList(class UObject* WorldContextObject);
    void RequestInformationList();
    void OnUpdatedServerList(bool IsExists);
    void OnLoginFailure(const int32 InRetCode);
    void OnInformationList(bool bWasSuccessful, const TArray<FSBOperationInformation>& InformationList);
    void OnFailedConnectServer(int32 RetCode);
    bool GetKeyValue(FString CharacterId, FString InKeyName, FString& OutValue);
    bool ConnectToServerAtFriendSession(class UObject* WorldContextObject, FString CharacterId, FString InFriendCharacterId);
    bool ConnectToServer(class UObject* WorldContextObject, FString CharacterId, bool bReturnDisconnect);
    void ConnectToJoinServer(int32 SessionIndexInSearchResults);
}; // Size: 0x290

class USBShapeSoundBaseComponent : public UAkComponent
{
    float EnablebUpdateDistance;                                                      // 0x0404 (size: 0x4)
    class UAkAudioEvent* PlayEvent;                                                   // 0x0408 (size: 0x8)

    void StopShapeSound(class UAkAudioEvent* StopEvent);
    void ActiveShapeSound();
}; // Size: 0x410

class USBShieldGuardComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBShopSetting : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBShopSettingData Data;                                                          // 0x0050 (size: 0x18)

}; // Size: 0x68

class USBShortCutInfo : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FSBShortcutDatas Data;                                                            // 0x0040 (size: 0x20)

}; // Size: 0x60

class USBShortPinView : public UUserWidget
{
    TArray<FKey> RayKeyPad;                                                           // 0x0278 (size: 0x10)
    TArray<FKey> RayKeyBoard;                                                         // 0x0288 (size: 0x10)
    TArray<class USBShortPinWidget*> ShortPinList;                                    // 0x0298 (size: 0x10)
    class UUserWidget* CommonAimModeUI;                                               // 0x02A8 (size: 0x8)
    bool IsEnemyTarget;                                                               // 0x02B0 (size: 0x1)
    char padding_0[0x7];                                                              // 0x02B1 (size: 0x7)
    FString EnemyTargetID;                                                            // 0x02B8 (size: 0x10)
    bool IsRayButtonDown;                                                             // 0x02C8 (size: 0x1)
    char padding_1[0x7];                                                              // 0x02C9 (size: 0x7)
    FDateTime SetPinTime;                                                             // 0x02D0 (size: 0x8)

    void SetPinPosition(class USBShortPinWidget* ShortPin);
    void SetPinInfo();
    void SetPinFromPlayer();
    void SetPinFromEnemy();
    bool IsKeyDownRayButton();
}; // Size: 0x2E8

class USBShortPinWidget : public UUserWidget
{
    float RemoveTime;                                                                 // 0x0278 (size: 0x4)
    char padding_0[0x4];                                                              // 0x027C (size: 0x4)
    class UWidgetSwitcher* Switcher;                                                  // 0x0280 (size: 0x8)
    FSBShortPinInfo PinInfo;                                                          // 0x0288 (size: 0x48)

    void UpdatePinInfo(bool IsNew);
    void RemovePin();
}; // Size: 0x2D0

class USBShortcutBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool CommandIDToBookMarkerSlot(EShortcutIconCommandID InCommandID, ESBBookMarkerSlot& OutBookMarkSlot);
    bool CommandIDToBookMark(class UObject* WorldContextObject, EShortcutIconCommandID InCommandID, FString& OutBookMark);
}; // Size: 0x28

class USBShortcutRingEdit : public UUserWidget
{
    class USBShortcutRingEditTabList* TabList;                                        // 0x0278 (size: 0x8)
    class USBShortcutRingEditFilter* Filter;                                          // 0x0280 (size: 0x8)
    class USBShortcutRingEditIconList* IconList;                                      // 0x0288 (size: 0x8)
    class USBShortcutRingEditRing* Ring;                                              // 0x0290 (size: 0x8)
    class USBShortcutRingEditIndexList* IndexList;                                    // 0x0298 (size: 0x8)
    FSBShortcutRingEditEventOnClose EventOnClose;                                     // 0x02A0 (size: 0x10)
    void EventShortcutRingEdit();

    void UpdateSelectedIcon(const FShortcutItemInfo& InItemInfo);
    void SetSelectedInfo(EShortcutType InType, int32 InRingIndex, int32 InIconIndex, const FShortcutItemInfo& InItemInfo, class USBShortcutRingIcon* InSelectIcon);
    void SelectIcon(class USBShortcutRingIcon* InSelectIcon);
    void SelectCancel();
    void RightClickRingIcon(int32 InIndex);
    void ResetIconList();
    void PlayAnimOut();
    void PlayAnimIn();
    bool OnUpdateIcon(const FShortcutItemInfo& InItemInfo);
    void OnUnbind();
    void OnSetupItem(int32 InIndex, bool IsCanUse);
    void OnSetupInventory(const FOwnItemInfo& InItemInfo);
    void OnSetupFixedPhrase();
    void OnSetupCommand();
    void OnSetSelectedInfo();
    void OnSelect(class USBShortcutRingIcon* InSelectIcon);
    void OnPlaySELeftClickRingIcon();
    void OnClearSelectedInfo();
    void OnBind();
    void LeftClickRingIcon(int32 InIndex);
    bool IsSameSelectedItemInfo(const FShortcutItemInfo& InItemInfo);
    bool IsKeyDownCloseButton();
    bool IsClickedLMB();
    void InsertLeftPageItemInfoList(const FShortcutItemInfo& InItemInfo, int32 InIndex);
    EShortcutType GetSelectTab();
    EShortcutType GetSelectedType();
    int32 GetSelectedRingIndex();
    FShortcutItemInfo GetSelectedItemInfo();
    TArray<FShortcutItemInfo> GetLeftPageItemInfoList();
    void EventShortcutRingEdit__DelegateSignature();
    void DeleteMouseTrackIconUI();
    void CreateMouseTrackIconUI();
    void Close();
    void ClickedTab();
    void ClickedStampCategory(const FSBStampCategoryMasterData& InMasterData);
    void ClickedRingIndex();
    void ClickedFilter();
    void CallEventOnClose();
    void AddLeftPageItemInfoList(const FShortcutItemInfo& InItemInfo);
}; // Size: 0x330

class USBShortcutRingEditFilter : public UUserWidget
{
    class UWidgetSwitcher* Switcher;                                                  // 0x0278 (size: 0x8)
    class USBRuntimeTextBlock* Text;                                                  // 0x0280 (size: 0x8)

    void OnShowStampCategory();
    FSBStampCategoryMasterData GetSelectStampCategoryMasterData();
}; // Size: 0x290

class USBShortcutRingEditIconList : public UUserWidget
{
    class UGridPanel* IconList;                                                       // 0x0278 (size: 0x8)
    int32 ColumnsIcon;                                                                // 0x0280 (size: 0x4)
    int32 ColumnsText;                                                                // 0x0284 (size: 0x4)
    int32 ColumnsCommand;                                                             // 0x0288 (size: 0x4)
    int32 ColumnsWarp;                                                                // 0x028C (size: 0x4)
    FMargin PaddingIcon;                                                              // 0x0290 (size: 0x10)
    FMargin PaddingText;                                                              // 0x02A0 (size: 0x10)
    FMargin PaddingCommand;                                                           // 0x02B0 (size: 0x10)
    FMargin PaddingWarp;                                                              // 0x02C0 (size: 0x10)

    void OnUnbindIcon(class USBShortcutRingIcon* InIcon);
    class USBShortcutRingIcon* OnCreateIcon();
    void OnBindIcon(class USBShortcutRingIcon* InIcon);
}; // Size: 0x2D8

class USBShortcutRingEditIndex : public UUserWidget
{
    class USBRuntimeTextBlock* TxtIndex;                                              // 0x0278 (size: 0x8)
    class USBRuntimeTextBlock* TxtTitle;                                              // 0x0280 (size: 0x8)
    class USBButtonBase* Button;                                                      // 0x0288 (size: 0x8)
    int32 Index;                                                                      // 0x0290 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0294 (size: 0x4)
    FSlateColor ActiveTextColor;                                                      // 0x0298 (size: 0x28)
    FSlateColor DisableTextColor;                                                     // 0x02C0 (size: 0x28)
    FSlateBrush SlateBrushButtonNormal;                                               // 0x02E8 (size: 0x88)
    FSlateBrush SlateBrushButtonHovered;                                              // 0x0370 (size: 0x88)
    FSlateBrush SlateBrushButtonPressed;                                              // 0x03F8 (size: 0x88)

}; // Size: 0x480

class USBShortcutRingEditIndexList : public UUserWidget
{
    FSBShortcutRingEditIndexListOnClickIndex OnClickIndex;                            // 0x0278 (size: 0x10)
    void OnClickIndex();
    class UCanvasPanel* CanvasPanel;                                                  // 0x0288 (size: 0x8)
    class USBShortcutRingEditIndex* LastSelectedRingIndex;                            // 0x0290 (size: 0x8)

    void SetSelectIndex(int32 InIndex);
    void OnClickIndex__DelegateSignature();
}; // Size: 0x2A0

class USBShortcutRingEditRing : public UUserWidget
{
    class UWidgetSwitcher* Switcher;                                                  // 0x0278 (size: 0x8)
    class UCanvasPanel* CanvasPanel;                                                  // 0x0280 (size: 0x8)

}; // Size: 0x288

class USBShortcutRingEditRingIcon : public UUserWidget
{
    class UWidgetSwitcher* FrameSwitcher;                                             // 0x0278 (size: 0x8)
    class USBShortcutRingIcon* Icon;                                                  // 0x0280 (size: 0x8)

    void SetHover(bool IsCondition);
    void PlayAnimClick();
    void OnPlayHoverSE();
}; // Size: 0x288

class USBShortcutRingEditTab : public UUserWidget
{
    class UWidgetSwitcher* TabSwitcher;                                               // 0x0278 (size: 0x8)
    class USBRuntimeTextBlock* Text;                                                  // 0x0280 (size: 0x8)
    int32 TextId;                                                                     // 0x0288 (size: 0x4)
    char padding_0[0x4];                                                              // 0x028C (size: 0x4)
    FSlateColor ActiveTextColor;                                                      // 0x0290 (size: 0x28)
    FSlateColor DisableTextColor;                                                     // 0x02B8 (size: 0x28)

}; // Size: 0x2E0

class USBShortcutRingEditTabList : public UUserWidget
{
    FSBShortcutRingEditTabListOnClickTab OnClickTab;                                  // 0x0278 (size: 0x10)
    void OnClickTab();
    class USBShortcutRingEditTab* TabItem;                                            // 0x0288 (size: 0x8)
    class USBShortcutRingEditTab* TabFixedPhrase;                                     // 0x0290 (size: 0x8)
    class USBShortcutRingEditTab* TabStamp;                                           // 0x0298 (size: 0x8)
    class USBShortcutRingEditTab* TabGesture;                                         // 0x02A0 (size: 0x8)
    class USBShortcutRingEditTab* TabCommand;                                         // 0x02A8 (size: 0x8)
    class USBShortcutRingEditTab* TabWarp;                                            // 0x02B0 (size: 0x8)
    class USBShortcutRingEditTab* LastSelectedTab;                                    // 0x02B8 (size: 0x8)

    void SetSelectType(EShortcutType InType);
    void OnClickTab__DelegateSignature();
}; // Size: 0x2C8

class USBShortcutRingIcon : public UUserWidget
{
    class UCanvasPanel* CanvasPanel;                                                  // 0x0278 (size: 0x8)
    class USBShortcutRingIconBase* ActiveIcon;                                        // 0x0280 (size: 0x8)

    void Setup(const FShortcutItemInfo& InInfo);
    void SetSelect(bool InSelect);
    void OnUnbindIcon(class USBShortcutRingIconBase* InIcon);
    class USBShortcutRingIconBase* OnCreateWarpIcon();
    class USBShortcutRingIconBase* OnCreateTextIcon();
    class USBShortcutRingIconBase* OnCreateNoneIcon();
    class USBShortcutRingIconBase* OnCreateCommandIcon();
    class USBShortcutRingIconBase* OnCreateBasicIcon();
    void OnBindIcon(class USBShortcutRingIconBase* InIcon);
    bool IsGrayoutFlag();
    FShortcutItemInfo GetShortcutItemInfo();
}; // Size: 0x290

class USBShortcutRingIconBase : public UUserWidget
{
    FSBShortcutRingIconBaseOnHover OnHover;                                           // 0x0278 (size: 0x10)
    void OnEventShortcutRingIcon();
    FSBShortcutRingIconBaseOnUnhover OnUnhover;                                       // 0x0288 (size: 0x10)
    void OnEventShortcutRingIcon();
    class UWidgetSwitcher* WSButton;                                                  // 0x0298 (size: 0x8)

    void SetVisibleShortcutIcon(bool InVisible);
    void SetHover(bool InHover);
    void SetGrayOut(bool InGrayOut);
    void SetEnableHoverFlag(bool Flag);
    void PlayAnimPressed();
    bool IsSelectFlag();
    bool IsHoverFlag();
    bool IsEnableHoverFlag();
    FShortcutItemInfo GetShortcutItemInfo();
}; // Size: 0x2F8

class USBShortcutRingIconBasic : public USBShortcutRingIconBase
{
    char padding_0[0x2F8];                                                            // 0x0000 (size: 0x0)

    void OnSetVisibleShortcutIcon(bool InVisible);
    void OnSetSupply(int32 InItemIndex, int32 InItemAmount);
    void OnSetStamp(FString InStampId);
    void OnSetOwnItem(int32 InItemIndex);
    void OnSetGrayOut(bool InGrayOut);
    void OnSetEnableToolTip(bool InEnable);
    void OnSetEmotion(FString InEmotionId);
    void OnSetCoolTime(bool InIsShow);
    void OnExecuteSupply(int32 InItemIndex, ESBItemUseStatus InItemUseStatus);
    void OnExecuteOwnItem(FString InUniqueId, int32 InItemIndex, ESBItemUseStatus InItemUseStatus);
    void OnClear();
}; // Size: 0x2F8

class USBShortcutRingIconCommand : public USBShortcutRingIconBase
{
    class UCanvasPanel* CP_Command;                                                   // 0x02F8 (size: 0x8)
    class UImage* Icon;                                                               // 0x0300 (size: 0x8)
    class USBRuntimeTextBlock* Text;                                                  // 0x0308 (size: 0x8)
    class UDataTable* CommandDataTable;                                               // 0x0310 (size: 0x8)
    FLinearColor ActiveColor;                                                         // 0x0318 (size: 0x10)
    FLinearColor DisableColor;                                                        // 0x0328 (size: 0x10)
    int32 TextNum;                                                                    // 0x0338 (size: 0x4)

    void OnSetEnableToolTip(bool InEnable);
    FText GetViewToolTipText();
    bool GetKeyconfigItemsStr(EShortcutIconCommandID CommandID, FString& OutString);
    bool GetBookmarkFieldStr(EShortcutIconCommandID CommandID, FString& OutString);
    bool GetBookmarkFieldAbbrStr(EShortcutIconCommandID CommandID, FString& OutString);
}; // Size: 0x358

class USBShortcutRingIconNone : public USBShortcutRingIconBase
{
    char padding_0[0x2F8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2F8

class USBShortcutRingIconText : public USBShortcutRingIconBase
{
    class UTextBlock* Message;                                                        // 0x02F8 (size: 0x8)
    class USBTextTableAsset* TextTableAsset;                                          // 0x0300 (size: 0x8)

}; // Size: 0x308

class USBShortcutRingIconWarp : public USBShortcutRingIconBase
{
    class UCanvasPanel* CP_Command;                                                   // 0x02F8 (size: 0x8)
    class USBRuntimeTextBlock* Text;                                                  // 0x0300 (size: 0x8)
    int32 TextNum;                                                                    // 0x0308 (size: 0x4)

    FText GetViewToolTipText();
}; // Size: 0x328

class USBShortcutRingIndex : public UUserWidget
{
    class UWidgetSwitcher* Switcher;                                                  // 0x0278 (size: 0x8)
    int32 Index;                                                                      // 0x0280 (size: 0x4)

    void OnSetSelectedButton(bool InIsSelected);
}; // Size: 0x288

class USBShortcutRingKeyGuidePlate : public UUserWidget
{
    class UCanvasPanel* CanvasPanelEdit;                                              // 0x0278 (size: 0x8)
    class UCanvasPanel* CanvasPanelWheel;                                             // 0x0280 (size: 0x8)

    void OnSetup();
}; // Size: 0x288

class USBShortcutRingRing : public UUserWidget
{
    class UCanvasPanel* Bgs;                                                          // 0x0278 (size: 0x8)
    class UCanvasPanel* Icons;                                                        // 0x0280 (size: 0x8)
    class USBShortcutRingIndex* RingIndex;                                            // 0x0288 (size: 0x8)
    TArray<FVector2D> PosNone;                                                        // 0x0290 (size: 0x10)
    TArray<FVector2D> PosBasic;                                                       // 0x02A0 (size: 0x10)
    TArray<FVector2D> PosText;                                                        // 0x02B0 (size: 0x10)
    TArray<FVector2D> PosCommand;                                                     // 0x02C0 (size: 0x10)

    void PlayAnimOut();
    void PlayAnimIn();
    int32 GetIconIndex(class USBShortcutRingIcon* InIcon);
}; // Size: 0x2D0

class USBShortcutRingWidget : public UUserWidget
{
    FSBShortcutRingWidgetEventOnOpen EventOnOpen;                                     // 0x0278 (size: 0x10)
    void EventShortcutRing();
    FSBShortcutRingWidgetEventOnClose EventOnClose;                                   // 0x0288 (size: 0x10)
    void EventShortcutRing();
    FSBShortcutRingWidgetEventOnOpenEdit EventOnOpenEdit;                             // 0x0298 (size: 0x10)
    void EventShortcutRing();
    FSBShortcutRingWidgetEventOnCloseEdit EventOnCloseEdit;                           // 0x02A8 (size: 0x10)
    void EventShortcutRing();
    class UWidgetSwitcher* Switcher;                                                  // 0x02B8 (size: 0x8)
    class UCanvasPanel* CPRoot;                                                       // 0x02C0 (size: 0x8)
    class USBShortcutRingRing* Ring;                                                  // 0x02C8 (size: 0x8)
    class USBShortcutRingKeyGuidePlate* KeyGuidePlate;                                // 0x02D0 (size: 0x8)
    class USBShortcutRingEdit* EditWindow;                                            // 0x02D8 (size: 0x8)

    void UnregistShortcutKey();
    void Switch(bool IsEnableEdit);
    void SetupRing();
    void SetOptionEditMode(bool IsOptionEditMode);
    void Reset(int32 Index);
    void RegistShortcutKey();
    void PlaySESelectIcon();
    void PlaySEExecute();
    void PlayAnimOut();
    void PlayAnimIn();
    void OpenEnd();
    void Open(bool IsEnableEdit);
    void OnUnbind();
    void OnDeleteEditWindow();
    void OnCreateEditWindow();
    void OnBind();
    bool IsOpenFlag();
    int32 GetSelectSlotID();
    void ExecuteKeyF9();
    void ExecuteKeyF8();
    void ExecuteKeyF7();
    void ExecuteKeyF6();
    void ExecuteKeyF5();
    void ExecuteKeyF12();
    void ExecuteKeyF11();
    void ExecuteKeyF10();
    void EventShortcutRing__DelegateSignature();
    void DeleteEditWindow();
    void CreatedEditWindow();
    void CloseEnd();
    void Close();
}; // Size: 0x328

class USBShowWebBrowserImpl : public UObject
{
    FString CloseUrlResult;                                                           // 0x0028 (size: 0x10)

    void OnFinish(FString InResult);
}; // Size: 0x38

class USBShowYesNoDialog2Impl : public UObject
{
    class USBDialog* CreatedDialog;                                                   // 0x0028 (size: 0x8)
    EYesNoDialogResult Result;                                                        // 0x0030 (size: 0x1)

    void OnWorldCleanup(class UWorld* World, bool bSessionEnded, bool bCleanupResources);
    void OnFinish(const EYesNoDialogResult InResult);
}; // Size: 0x38

class USBSkeletalMeshBImagineWeaponComponent : public USBSkeletalMeshComponent
{
    TArray<FSBWeaponAnimationSetting> AnimationList;                                  // 0x0FC0 (size: 0x10)
    int32 InventoryIdentifyIndex;                                                     // 0x0FD0 (size: 0x4)

    void ReceivePlayWeaponAnimation(int32 Anim);
}; // Size: 0xFE0

class USBSkeletalMeshComponent : public USkeletalMeshComponent
{
    int32 ResetDynamicsCount;                                                         // 0x0F30 (size: 0x4)
    float ResetDynamicsCountScale;                                                    // 0x0F34 (size: 0x4)
    bool m_bIsInitInvisibleOnCullingOpacity;                                          // 0x0F38 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0F39 (size: 0x7)
    TArray<class UMaterialInstanceDynamic*> MaterialInstanceList;                     // 0x0F40 (size: 0x10)
    TArray<class UMaterialInterface*> MaterialInstanceCacheList;                      // 0x0F50 (size: 0x10)
    TArray<class UTexture*> OverrideNonStreamingTextures;                             // 0x0F60 (size: 0x10)

    void SetForceMipLevelsToBeResident(bool enable);
    void RevertForceMipLevelsToBeResident();
    void ResetDynamics(int32 ResetCount, float DeltaTime, bool bRecreateClothing);
    bool IsLoadedAllMipTexture();
    bool IsEnableForceMipLevelsToBeResident();
    FVector GetComposedRefPosePosition(FName InBoneName);
    float GetCharaMeshScaleRatio();
}; // Size: 0xF80

class USBSkillInfoBaseWidget : public UUserWidget
{
    bool bStopUpdate;                                                                 // 0x0278 (size: 0x1)
    bool bVisibleIconDisable;                                                         // 0x0279 (size: 0x1)
    ESkillActionPosition SkillActionPosition;                                         // 0x027A (size: 0x1)

    void SetStopUpdate(const bool InStopUpdate);
    void OnIconDisableChange(bool bVisible);
    bool GetStopUpdate();
}; // Size: 0x280

class USBSkillInfoClass : public UObject
{
    FName SkillName;                                                                  // 0x002C (size: 0x8)
    char padding_0[0x2C];                                                             // 0x0034 (size: 0x2C)
    FSBStartSkillSetting NeedParam;                                                   // 0x0060 (size: 0x40)
    bool bImmediateStart;                                                             // 0x00A0 (size: 0x1)
    bool bImmediateStartOnlyTrigger;                                                  // 0x00A1 (size: 0x1)
    char padding_1[0x6];                                                              // 0x00A2 (size: 0x6)
    TArray<FName> ImmediateStartForbidTags;                                           // 0x00A8 (size: 0x10)
    bool bIsDodge;                                                                    // 0x00B8 (size: 0x1)
    bool bIsUkemi;                                                                    // 0x00B9 (size: 0x1)
    bool bIsSpecial;                                                                  // 0x00BA (size: 0x1)
    char padding_2[0x1];                                                              // 0x00BB (size: 0x1)
    float SendHateWhenStartSkill;                                                     // 0x00BC (size: 0x4)
    FSBPlayerSkillInStatusAilmentPriorityTable StatusAilmentPriorityTable;            // 0x00C0 (size: 0x10)
    TSoftObjectPtr<UASStateMachine> SkillStateMachine;                                // 0x00D0 (size: 0x28)
    TSoftObjectPtr<UASAnimationSet> SkillAlternativeAnimationSet;                     // 0x00F8 (size: 0x28)
    TSoftObjectPtr<UASAnimationSet> OverrideAnimationSetForMainSM;                    // 0x0120 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> AimBodyStateMachine;                              // 0x0148 (size: 0x28)
    TSoftObjectPtr<UASStateMachine> AimOffsetStateMachine;                            // 0x0170 (size: 0x28)
    TSoftObjectPtr<UASAnimationSet> OverrideAnimationSetForAimOffsetSM;               // 0x0198 (size: 0x28)
    EPlayerStateMachine LeadStateMachine;                                             // 0x01C0 (size: 0x1)
    char padding_3[0x3];                                                              // 0x01C1 (size: 0x3)
    float AimDistance;                                                                // 0x01C4 (size: 0x4)
    bool bCancelSameSkill;                                                            // 0x01C8 (size: 0x1)
    bool bLaunchSkillPreInput;                                                        // 0x01C9 (size: 0x1)
    char padding_4[0x2];                                                              // 0x01CA (size: 0x2)
    float LaunchSkillPreInputTime;                                                    // 0x01CC (size: 0x4)
    TArray<FSBLaunchSkillPreInputTimeConditionOverrideInfo> LaunchSkillPreInputTimeConditionOverrideInfo; // 0x01D0 (size: 0x10)
    bool bRepeatInput;                                                                // 0x01E0 (size: 0x1)
    char padding_5[0x3];                                                              // 0x01E1 (size: 0x3)
    float RecastTime;                                                                 // 0x01E4 (size: 0x4)
    TArray<FSBPlayerSkillRecastTimeModifyParam> RecastTimeModifyList;                 // 0x01E8 (size: 0x10)
    bool bRecastTimeModifyDuringRecast;                                               // 0x01F8 (size: 0x1)
    char padding_6[0x3];                                                              // 0x01F9 (size: 0x3)
    int32 AvailableCount;                                                             // 0x01FC (size: 0x4)
    bool bRemoveTurnActorRequest;                                                     // 0x0200 (size: 0x1)
    char padding_7[0x7];                                                              // 0x0201 (size: 0x7)
    TArray<FSBConditionCheckParam> RemoveTurnActorRequestConditionList;               // 0x0208 (size: 0x10)
    TArray<FSBPlayerSkillCastLaunchProjectile> CastLaunchProjectileList;              // 0x0218 (size: 0x10)
    TArray<FSBPlayerSkillAdditionalInputLaunchProjectile> AdditionalInputLaunchProjectileList; // 0x0228 (size: 0x10)
    TArray<FDataTableRowHandle> StatusAlimentHandleList;                              // 0x0238 (size: 0x10)
    TArray<int32> CastApplyStatusAlimentIndexList;                                    // 0x0248 (size: 0x10)
    TArray<FSBPlayerSkillStatusAilmentTimeModifyParam> StatusAilmentEffectiveTimeModifyList; // 0x0258 (size: 0x10)
    TArray<FSBPlayerSkillCastStatusAilment> CastApplyStatusAilmentList;               // 0x0268 (size: 0x10)
    TArray<FSBPlayerSkillInActionEffectSetting> InActionEffectSettingList;            // 0x0278 (size: 0x10)
    TArray<FSBSpecialHitEffect> SpecialHitEffectList;                                 // 0x0288 (size: 0x10)
    bool bHideCastLog;                                                                // 0x0298 (size: 0x1)

    class UASStateMachine* GetSkillStateMachine();
    FString GetSkillNameString();
    FName GetSkillName();
    int32 GetSkillID();
    float GetRecastTimeDefault(const class ASBPlayerCharacter* PlayerCharacter);
    float GetRecastTimeBySkillSetting(FSBSkillSettingConditionCheckData SkillSettingData);
    float GetRecastTime(const class ASBPlayerCharacter* PlayerCharacter);
    class UASAnimationSet* GetOverideAnimSetForMainSM();
    class UASAnimationSet* GetOverideAnimSetForAimOffsetSM();
    EPlayerStateMachine GetLeadStateMachine();
    int32 GetAvailableCount();
    class UASStateMachine* GetAimOffsetStateMachine();
    class UASStateMachine* GetAimBodyStateMachine();
}; // Size: 0x2A0

class USBSkillInfoGaugeActiveWidget : public USBSkillInfoBaseWidget
{
    class UWidgetSwitcher* SwitchSet;                                                 // 0x0280 (size: 0x8)
    char padding_0[0x4];                                                              // 0x0288 (size: 0x4)
    int32 MySkillId;                                                                  // 0x028C (size: 0x4)
    ESBSkillIconBgType IconBgType;                                                    // 0x0290 (size: 0x1)
    bool bIsAttackUp;                                                                 // 0x0291 (size: 0x1)

    void OnUpdateIconTexture(class UTexture2D* SkillIconSmall);
    void OnStopBerserkMode();
    void OnStartBerserkMode();
    void OnSetKeyGuideVisible(bool IsVisible);
    void OnAttackUpChange(bool InAttackUp, class USBPlayerSkillActionComponent* SkillActionComp);
}; // Size: 0x298

class USBSkillInfoGaugeImagineWidget : public USBSkillInfoBaseWidget
{
    int32 SlotNum;                                                                    // 0x0280 (size: 0x4)

    void OnUpdateIconTexture(FString inImagineUniqueId, const FName& InImagineName);
    void OnStopHyouiAnimation();
    void OnStartHyouiAnimation();
}; // Size: 0x298

class USBSkillInfoGaugeSpecialWidget : public USBSkillInfoBaseWidget
{
    class UWidgetSwitcher* SwitchSet;                                                 // 0x0280 (size: 0x8)

    void OnUpdateIconTexture(bool inbActive);
}; // Size: 0x288

class USBSkillInfoItemWidget : public UUserWidget
{
    ESkillActionPosition SkillActionPosition;                                         // 0x0278 (size: 0x1)
    bool bRecastWait;                                                                 // 0x0279 (size: 0x1)
    char padding_0[0x2];                                                              // 0x027A (size: 0x2)
    float CachedRecastTime;                                                           // 0x027C (size: 0x4)
    float MaxCachedRecastTime;                                                        // 0x0280 (size: 0x4)
    bool bCachedShowInfo;                                                             // 0x0284 (size: 0x1)
    bool bOnCastSkill;                                                                // 0x0285 (size: 0x1)
    bool bChargeStartAnim;                                                            // 0x0286 (size: 0x1)
    bool bEndFlowWait;                                                                // 0x0287 (size: 0x1)

    void OnUpdatePercent();
    void OnPlayAnimUse(bool Init);
    void OnPlayAnimChargeStart();
    void OnPlayAnimChargeEnd();
}; // Size: 0x288

class USBSkillInfoWidget : public UUserWidget
{
    bool IsEditMode;                                                                  // 0x0278 (size: 0x1)
    bool bInfoIn;                                                                     // 0x0279 (size: 0x1)
    char padding_0[0x6];                                                              // 0x027A (size: 0x6)
    TArray<class USBSkillInfoItemWidget*> SkillInfoItemList;                          // 0x0280 (size: 0x10)
    class UCanvasPanel* SkillGrp;                                                     // 0x0290 (size: 0x8)
    bool bShowAlwaysHUD;                                                              // 0x0298 (size: 0x1)
    ESBPlayerSkillPaletteSide LastPaletteSide;                                        // 0x0299 (size: 0x1)
    bool bBackPaletteVisible;                                                         // 0x029A (size: 0x1)

    void OnInAnimation(bool bForward);
    void OnChangePalette(ESBPlayerSkillPaletteSide PaletteSide);
    void OnChangeBackPaletteVisible(bool Visible);
    bool IsPlayAnimation();
}; // Size: 0x2A0

class USBSkinMaterialManager : public UObject
{
    FSBSkinData M300;                                                                 // 0x0028 (size: 0xF0)
    FSBSkinData F300;                                                                 // 0x0118 (size: 0xF0)
    TMap<class FSBReplaceMaterialBaseType, class FSBMaterialBaseReplaceDataArray> MaterialBaseReplaceDataArrayMap; // 0x0208 (size: 0x50)

}; // Size: 0x258

class USBSkyMeshComponent : public UStaticMeshComponent
{
    class UMaterialInterface* SkyMaterial;                                            // 0x04F8 (size: 0x8)
    class UCurveLinearColor* ZenithColorCurve;                                        // 0x0500 (size: 0x8)
    class UCurveLinearColor* SkyColorCurve;                                           // 0x0508 (size: 0x8)
    class UCurveFloat* HorizonBrightnessCurve;                                        // 0x0510 (size: 0x8)
    class UCurveFloat* HorizonAreaContrastCurve;                                      // 0x0518 (size: 0x8)
    class UCurveFloat* HorizonReduceShadowSideCurve;                                  // 0x0520 (size: 0x8)
    class UCurveFloat* SunSideHardnessCurve;                                          // 0x0528 (size: 0x8)
    class UCurveFloat* SunSideRadiusCurve;                                            // 0x0530 (size: 0x8)
    class UCurveFloat* SunSideBrightnessCurve;                                        // 0x0538 (size: 0x8)
    class UCurveFloat* SunLightAreaHardnessCurve;                                     // 0x0540 (size: 0x8)
    class UCurveFloat* SunLightAreaRadiusCurve;                                       // 0x0548 (size: 0x8)
    class UCurveFloat* SunLightAreaMaskDistortionScaleCurve;                          // 0x0550 (size: 0x8)
    class UCurveLinearColor* ShadowSideColorCurve;                                    // 0x0558 (size: 0x8)
    class UCurveFloat* ShadowSideHardnessCurve;                                       // 0x0560 (size: 0x8)
    class UCurveFloat* ShadowSideRadiusCurve;                                         // 0x0568 (size: 0x8)
    class UCurveLinearColor* SunDiskColorCurve;                                       // 0x0570 (size: 0x8)
    class UCurveFloat* DaytimeNightCurve;                                             // 0x0578 (size: 0x8)
    class UCurveFloat* SkySphereContrastCurve;                                        // 0x0580 (size: 0x8)
    class UCurveFloat* MoonOpacityCurve;                                              // 0x0588 (size: 0x8)
    class UCurveLinearColor* CloudColorFrontCurve;                                    // 0x0590 (size: 0x8)
    class UCurveLinearColor* CloudColorMiddleCurve;                                   // 0x0598 (size: 0x8)
    class UCurveLinearColor* CloudColorShadowCurve;                                   // 0x05A0 (size: 0x8)
    class UCurveFloat* CloudsBrightnessSunSideCurve;                                  // 0x05A8 (size: 0x8)
    class UCurveFloat* CloudsSaturationCurve;                                         // 0x05B0 (size: 0x8)
    class UCurveFloat* MoonLightAreaMaskDistortionScaleCurve;                         // 0x05B8 (size: 0x8)
    class UCurveFloat* SunMoonLightBrightnessCurve;                                   // 0x05C0 (size: 0x8)
    class UCurveFloat* VertexNormalFlipTimingCurve;                                   // 0x05C8 (size: 0x8)
    class UCurveFloat* CloudShadingStepBalanceSunSideCurve;                           // 0x05D0 (size: 0x8)
    class UCurveFloat* CloudShadingStepBalanceShadowSideCurve;                        // 0x05D8 (size: 0x8)
    class UCurveFloat* CloudShadingContrastShadowSideCurve;                           // 0x05E0 (size: 0x8)
    class UCurveFloat* SunDiskBrightnessCurve;                                        // 0x05E8 (size: 0x8)
    class UCurveLinearColor* SkyBottomColorCurve;                                     // 0x05F0 (size: 0x8)
    class UCurveFloat* SkyBottomAreaContrastCurve;                                    // 0x05F8 (size: 0x8)
    class UCurveLinearColor* HorizonColorHighCurve;                                   // 0x0600 (size: 0x8)
    class UCurveLinearColor* HorizonColorLowCurve;                                    // 0x0608 (size: 0x8)
    class UCurveLinearColor* HorizonColorMiddleCurve;                                 // 0x0610 (size: 0x8)
    class UCurveFloat* HorizonColorShiftCurve;                                        // 0x0618 (size: 0x8)
    class UCurveFloat* HorizonAddSunSideCurve;                                        // 0x0620 (size: 0x8)
    class UCurveFloat* SkyBottomReduceShadowSideCurve;                                // 0x0628 (size: 0x8)
    class UCurveLinearColor* SunSideColorInsideCurve;                                 // 0x0630 (size: 0x8)
    class UCurveLinearColor* SunSideColorOutsideCurve;                                // 0x0638 (size: 0x8)
    class UCurveFloat* RingBrightnessCurve;                                           // 0x0640 (size: 0x8)
    class UCurveFloat* SkyColorRefrectionAreaContrastCurve;                           // 0x0648 (size: 0x8)
    class UCurveFloat* SkyColorRefrectionScaleCurve;                                  // 0x0650 (size: 0x8)

}; // Size: 0x660

class USBSliderBase : public USlider
{
    bool PadAndKeyInputEnabled;                                                       // 0x0510 (size: 0x1)

    void SetSliderStepSize(float InValue);
    void SetPadAndKeyInputEnabled(bool InValue);
}; // Size: 0x528

class USBSmasherBallShootFinalHitGiveMoveSpeedDownPassiveSkill : public USBSmasherPassiveSkill
{
    TArray<FSmasherStatusAlimentSkillSetting> GiveStatusAlimentSettingList;           // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBSmasherBallShootFinalHitSpawnShockWaveSkillInfo : public USBSmasherPassiveSkill
{
    TArray<FSmasherShockWaveProjectileHandleSetting> ShockWaveProjectileHandleSettingList; // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBSmasherBallShootReduceConsumeBoostCartridgePassiveSkill : public USBSmasherPassiveSkill
{
    TArray<FSBPassiveBallShootReduceConsumeSetting> ReduceConsumeSettingList;         // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBSmasherBallShootTypeSkillInfo : public USBSmasherSkillInfo
{
    float BallShootReturnMoveSpeed;                                                   // 0x0320 (size: 0x4)
    FRotator BallShootBallRotate;                                                     // 0x0324 (size: 0xC)
    float BallReturnThreshold;                                                        // 0x0330 (size: 0x4)
    float BallLocationShiftAmount;                                                    // 0x0334 (size: 0x4)
    bool bShowReturnBallEffect;                                                       // 0x0338 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0339 (size: 0x7)
    FSBEffectAsset ReturnBallEffectSetting;                                           // 0x0340 (size: 0x1A8)
    bool bShowBeamEffectToBall;                                                       // 0x04E8 (size: 0x1)
    char padding_1[0x7];                                                              // 0x04E9 (size: 0x7)
    TSoftObjectPtr<UParticleSystem> BeamEmitterTemplateToBall;                        // 0x04F0 (size: 0x28)
    FName BeamStartSocketName;                                                        // 0x0518 (size: 0x8)
    bool bShowBallReturnTimingEffect;                                                 // 0x0520 (size: 0x1)
    char padding_2[0x7];                                                              // 0x0521 (size: 0x7)
    FSBEffectAsset BallReturnTimingEffectSetting;                                     // 0x0528 (size: 0x1A8)

}; // Size: 0x6D0

class USBSmasherBoostCartridgeMaxDownHPMaxUpPassiveSkill : public USBSmasherPassiveSkill
{
    TArray<FSmasherModifyMaxHPBoostCartridge> ModifyMaxHPBoostCartridgeList;          // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBSmasherBoostSmashSkillInfo : public USBSmasherSkillInfo
{
    char padding_0[0x320];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x320

class USBSmasherDustStormSkillInfo : public USBSmasherSkillInfo
{
    TArray<float> ConsumeStaminaAmountList;                                           // 0x0320 (size: 0x10)
    TArray<FSBConsumeStaminaAmountSetting> ConsumeStaminaAmountSettingList;           // 0x0330 (size: 0x10)
    TArray<FSBSmasherAttackLevelSetting> AttackLevelSettingList;                      // 0x0340 (size: 0x10)
    float AttackStartStaminaLowerLimit;                                               // 0x0350 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0354 (size: 0x4)
    TArray<FSBSmasherMoveSpeedSetting> MoveSpeedRateSettingList;                      // 0x0358 (size: 0x10)
    TArray<FSBEffectAsset> LevelUpEffectList;                                         // 0x0368 (size: 0x10)

}; // Size: 0x378

class USBSmasherEarthQuakeSkillInfo : public USBSmasherSkillInfo
{
    char padding_0[0x320];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x320

class USBSmasherGravityDiveSkillInfo : public USBSmasherBallShootTypeSkillInfo
{
    float DiveMoveSpeed;                                                              // 0x06D0 (size: 0x4)
    float DiveMoveEndDistanceThreshold;                                               // 0x06D4 (size: 0x4)
    float LimitDiveMoveTime;                                                          // 0x06D8 (size: 0x4)
    float LimitDiveMoveDistance;                                                      // 0x06DC (size: 0x4)
    float CheckAdditionalInputTimeToDiveMove;                                         // 0x06E0 (size: 0x4)
    float IgnoreAdditionalInputTimeFromDiveMoveStart;                                 // 0x06E4 (size: 0x4)
    TArray<FName> AdditionalInputCommandList;                                         // 0x06E8 (size: 0x10)
    FSBPassiveArtsID AddBoostCartridgePassiveArtsID;                                  // 0x06F8 (size: 0x4)
    float AddBoostCartridgeAmountByPassiveArts;                                       // 0x06FC (size: 0x4)

}; // Size: 0x700

class USBSmasherGravityShotSkillInfo : public USBSmasherBallShootTypeSkillInfo
{
    char padding_0[0x6D0];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x6D0

class USBSmasherHealBulletSkillInfo : public USBSmasherSkillInfo
{
    TArray<FDataTableRowHandle> HealProjectileHandleList;                             // 0x0320 (size: 0x10)
    FSBSmasherReloadSettingGroup ReloadSetting;                                       // 0x0330 (size: 0x20)

}; // Size: 0x350

class USBSmasherJudgementHammerSkillInfo : public USBSmasherSkillInfo
{
    char padding_0[0x320];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x320

class USBSmasherJumpingHammerSkillInfo : public USBSmasherSkillInfo
{
    char padding_0[0x320];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x320

class USBSmasherMainActionSkillInfo : public USBSmasherSkillInfo
{
    char padding_0[0x320];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x320

class USBSmasherPassiveSkill : public USBPlayerPassiveSkill
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBSmasherPowerReloadSkillInfo : public USBSmasherSkillInfo
{
    int32 DamageUpRate;                                                               // 0x0320 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0324 (size: 0x4)
    TArray<FSBSmasherDamageUpRateModifyConditionSetting> DamageUpRateModifyConditionSettingList; // 0x0328 (size: 0x10)
    FSBSmasherReloadSettingGroup ReloadSetting;                                       // 0x0338 (size: 0x20)
    FSBSmasherBoostCartridgeConsumptionSetting DecreaseConsumeBoostCartridgeSetting;  // 0x0358 (size: 0x18)
    bool bShowEffectOnWeaponBall;                                                     // 0x0370 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0371 (size: 0x7)
    FSBEffectAsset EffectOnWeaponBallSetting;                                         // 0x0378 (size: 0x1A8)

}; // Size: 0x520

class USBSmasherPowerShotSkillInfo : public USBSmasherBallShootTypeSkillInfo
{
    FSBPlayerSkillChargeSetting PowerShotChargeSetting;                               // 0x06D8 (size: 0x28)
    FSBPassiveArtsID NoHitThroughPassiveArtsID;                                       // 0x0700 (size: 0x4)

}; // Size: 0x708

class USBSmasherQuickShotSkillInfo : public USBSmasherBallShootTypeSkillInfo
{
    FName QuickShotChargeSectionAnimTag;                                              // 0x06D8 (size: 0x8)
    FSBPlayerSkillChargeSetting QuickShotChargeSetting;                               // 0x06E0 (size: 0x28)
    FName ApplySelfBuffChargeSectionAnimTag;                                          // 0x0708 (size: 0x8)
    FSBPlayerSkillChargeSetting ApplySelfBuffChargeSetting;                           // 0x0710 (size: 0x28)
    TArray<FSBQuickShotChargeSendStatusAilmentSetting> ApplySelfBuffSettingList;      // 0x0738 (size: 0x10)

}; // Size: 0x748

class USBSmasherRockNeedleSkillInfo : public USBSmasherSkillInfo
{
    char padding_0[0x320];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x320

class USBSmasherSkillInfo : public USBSkillInfoClass
{
    TArray<FSBSmasherBoostCartridgeConsumptionSetting> BoostCartridgeConsumptionSettingList; // 0x02A0 (size: 0x10)
    float ConsumeBoostCartridge;                                                      // 0x02B0 (size: 0x4)
    bool bCheckCartridgeAmountBeforeCastSkill;                                        // 0x02B4 (size: 0x1)
    bool bConsumeBoostCartridgeAtCastSkill;                                           // 0x02B5 (size: 0x1)
    bool bConsumeCurrentBoostCartridgeAll;                                            // 0x02B6 (size: 0x1)
    bool bPlayShortageCartridgeSound;                                                 // 0x02B7 (size: 0x1)
    TSoftObjectPtr<UAkAudioEvent> ShortageCartridgeSound;                             // 0x02B8 (size: 0x28)
    FAkEventVariables ShortageCartridgeSoundParam;                                    // 0x02E0 (size: 0x40)

}; // Size: 0x320

class USBSmasherStoneBodySkillInfo : public USBSmasherSkillInfo
{
    FSBDefenceGuardConfig DefenseGuardConfig;                                         // 0x0328 (size: 0xC)
    float HPToShieldDurabilityRate;                                                   // 0x0334 (size: 0x4)
    TArray<FSBConditionCheckFloatParam> HPToShieldDurabilityRateModifySettingList;    // 0x0338 (size: 0x10)
    TArray<FSBGuardEffectSetting> GuardEffectSettingList;                             // 0x0348 (size: 0x10)

}; // Size: 0x358

class USBSmasherSubActionSkillInfo : public USBSmasherBallShootTypeSkillInfo
{
    int32 BallShootHitStatusAlimentApplyHitCount;                                     // 0x06D0 (size: 0x4)
    char padding_0[0x4];                                                              // 0x06D4 (size: 0x4)
    TArray<FDataTableRowHandle> BallShootHitStatusAlimentHandleList;                  // 0x06D8 (size: 0x10)

}; // Size: 0x6E8

class USBSmasherSuperArmorReceiveDamageDownPassiveSkill : public USBSmasherPassiveSkill
{
    TArray<FSBPassiveSuperArmorReceiveDamageDownSetting> ReceiveDamageDownSettingList; // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBSmasherSwingRushSkillInfo : public USBSmasherBallShootTypeSkillInfo
{
    TArray<float> ConsumeStaminaAmountList;                                           // 0x06D0 (size: 0x10)
    TArray<FSBSmasherAttackLevelSetting> AttackLevelSettingList;                      // 0x06E0 (size: 0x10)
    float AttackStartStaminaLowerLimit;                                               // 0x06F0 (size: 0x4)
    FSBPassiveArtsID ApplyConsumeStaminaScalePassiveArtsID;                           // 0x06F4 (size: 0x4)
    float ConsumeStaminaScaleByPassiveArts;                                           // 0x06F8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x06FC (size: 0x4)
    TArray<FSBSmasherMoveSpeedSetting> MoveSpeedRateSettingList;                      // 0x0700 (size: 0x10)
    TArray<FSBEffectAsset> LevelUpEffectList;                                         // 0x0710 (size: 0x10)

}; // Size: 0x720

class USBSortFilterBluePrintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FFilterGroup RemoveFilter(FFilterGroup& Filters, TEnumAsByte<EItemFilterType::Type> Type);
    TEnumAsByte<EItemFilterType::Type> Protector2ItemFilter(const EProtectorCategory Protector);
    TEnumAsByte<EItemFilterType::Type> PassiveImagineSlot2Filter(const ESBPlayerPassiveImagineSlotType PassiveSlotType);
    TEnumAsByte<EItemFilterType::Type> ItemCategory2ItemFilter(const EItemCategory Category);
    TEnumAsByte<EItemFilterType::Type> GetQuestBoardClassLevelFilter(const int32 Index);
    FFilterGroup EmptyFilter(FFilterGroup& Filters);
    TEnumAsByte<EItemFilterType::Type> Class2ItemFilter(const ESBClassType ClassType);
    TEnumAsByte<EItemFilterType::Type> Class2FusionItemFilter(const ESBClassType ClassType);
    TEnumAsByte<EItemFilterType::Type> Attribute2ItemFilter(const ESBAttribute Attribute);
    TEnumAsByte<EItemFilterType::Type> AdventureBoardFilter(int32 TextId);
    FFilterGroup AddFilter(FFilterGroup& Filters, TEnumAsByte<EItemFilterType::Type> Type);
}; // Size: 0x28

class USBSoundManager : public UObject
{
    TArray<class UObject*> LoadedAkEvent;                                             // 0x00B0 (size: 0x10)
    char padding_0[0x10];                                                             // 0x00C0 (size: 0x10)
    TArray<class UObject*> LoadedResidentAssets;                                      // 0x00D0 (size: 0x10)
    TSoftObjectPtr<UDataTable> ResidentAkEventTable;                                  // 0x00E0 (size: 0x28)
    TSoftObjectPtr<UDataTable> SystemSETable;                                         // 0x0108 (size: 0x28)
    char padding_1[0x18];                                                             // 0x0130 (size: 0x18)
    FSBSoundManagerOnFinishedLoadResidentAsset OnFinishedLoadResidentAsset;           // 0x0148 (size: 0x10)
    void OnFinishedLoadResidentAssetDelegate();
    TSoftObjectPtr<UDataTable> ScriptSEDataTable;                                     // 0x0158 (size: 0x28)
    FSBSoundManagerOnSBSoundMusicCue OnSBSoundMusicCue;                               // 0x0180 (size: 0x10)
    void OnSBSoundMusicCue();
    FSBBGMInitializeValueData BGMInitializeValueData;                                 // 0x0190 (size: 0x128)
    TSoftObjectPtr<UDataTable> BossBGMDataTable;                                      // 0x02B8 (size: 0x28)
    class UDataTable* MapBossBGMDataTable;                                            // 0x02E0 (size: 0x8)
    class UDataTable* ServerBossBGMDataTable;                                         // 0x02E8 (size: 0x8)
    class UDataTable* BGMEventAssetDataTable;                                         // 0x02F0 (size: 0x8)
    class UDataTable* BGMTimeAttackAreaIDDataTable;                                   // 0x02F8 (size: 0x8)
    class UDataTable* BGMMuteInTheaterDataTable;                                      // 0x0300 (size: 0x8)
    char padding_2[0x488];                                                            // 0x0308 (size: 0x488)
    TSoftObjectPtr<UDataTable> WindParticleSoundDataTable;                            // 0x0790 (size: 0x28)
    TArray<TWeakObjectPtr<UAkComponent>> AmbientAkComponents;                         // 0x07B8 (size: 0x10)
    char padding_3[0xB0];                                                             // 0x07C8 (size: 0xB0)
    class UDataTable* SoundEnemyIdDataTable;                                          // 0x0878 (size: 0x8)
    TSoftObjectPtr<UDataTable> PlayerSkillVoiceTable;                                 // 0x0880 (size: 0x28)
    TArray<int32> UseCurrentSkillChargeLevelSkillIDList;                              // 0x08A8 (size: 0x10)
    class UDataTable* EnemyTypeSwitchListDataTable;                                   // 0x08B8 (size: 0x8)
    class UDataTable* UniqueEnemyVoiceDataTable;                                      // 0x08C0 (size: 0x8)
    char padding_4[0xB0];                                                             // 0x08C8 (size: 0xB0)
    class UDataTable* VoiceEffectCharaPartsNameTable;                                 // 0x0978 (size: 0x8)
    char padding_5[0x88];                                                             // 0x0980 (size: 0x88)
    class UDataTable* LODDistanceDataTable;                                           // 0x0A08 (size: 0x8)
    ESBAkEventLOD DefaultLOD;                                                         // 0x0A10 (size: 0x1)
    char padding_6[0x7];                                                              // 0x0A11 (size: 0x7)
    TMap<ESBAkEventLOD, float> FootprintLODByCharacterSizeMap;                        // 0x0A18 (size: 0x50)
    TArray<class UDataTable*> CostumeMaterialTables;                                  // 0x0A68 (size: 0x10)
    TArray<class UDataTable*> CostumeMaterialActorTables;                             // 0x0A78 (size: 0x10)
    TArray<FSBRTPCEventData> RTPCEventDataArray;                                      // 0x0A88 (size: 0x10)
    char padding_7[0x50];                                                             // 0x0A98 (size: 0x50)
    TSoftObjectPtr<UDataTable> DemoSoundDataTable;                                    // 0x0AE8 (size: 0x28)
    TMap<class FString, class FDemoSoundData> DemoSoundDataMap;                       // 0x0B10 (size: 0x50)
    char padding_8[0xA8];                                                             // 0x0B60 (size: 0xA8)
    TArray<class UDataTable*> ImagineSoundDataTables;                                 // 0x0C08 (size: 0x10)
    TMap<FString, float> CharacterSizeSwitchMap;                                      // 0x0C18 (size: 0x50)
    TMap<class FString, class FSBSoundEventTermData> EventTermIDDataMap;              // 0x0C68 (size: 0x50)
    char padding_9[0xD0];                                                             // 0x0CB8 (size: 0xD0)
    TArray<FSBSoundQuestProgressStateData> QuestProgressStateDataArray;               // 0x0D88 (size: 0x10)

    void UpdateSoundEventTerm();
    void SetForceListenerPosition(ESBListenerPosition ListenerPosition);
    void SetDebugCostumeMaterial(ESBClothSwitchType Type, ESBCostumeMaterial Material);
    void ResetDebugCostumeMaterial();
    void RequestSkipDemoEvent();
    class UAkComponent* RequestAmbientSoundBySceneComponent(class UAkAudioEvent* AudioEvent, class USceneComponent* Component);
    class UAkComponent* RequestAmbientSoundByActor(class UAkAudioEvent* AudioEvent, class AActor* Actor);
    class UAkComponent* RequestAmbientSoundAtLocation(class UAkAudioEvent* AudioEvent, const FVector& Location);
    void RequestAmbientSound(class UAkComponent* AkComponent);
    void RemoveExcludeEventTerm(FName SubLevelName);
    void PostWindParticleSound(class UParticleSystemComponent* ParticleComponent);
    bool PlayPlayerVoiceAtLocation(class UObject* WorldContextObject, FVector Location, FSBPlayerVoiceVariables PlayerVoiceVariables);
    bool PlayPlayerVoiceAtListener(FSBPlayerVoiceVariables PlayerVoiceVariables);
    int32 PlayPlayerVoice(class UAkComponent* AkComponent, FSBPlayerVoiceVariables PlayerVoiceVariables);
    int32 PlayPlayerSkillVoice(class UAkComponent* AkComponent, FSBPlayerVoiceVariables PlayerVoiceVariables);
    void OnSBSoundMusicCue__DelegateSignature();
    void OnFinishedWindComponent(class UParticleSystemComponent* FinishedComponent);
    void OnFinishedPlayingBuddyVoice(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo);
    void OnFinishedLoadResidentAssetDelegate__DelegateSignature();
    void OnDungeonResult();
    void OnClearDungeon(const FName& InDungeonName);
    void LoadResidentAsset();
    TSoftObjectPtr<UAkAudioEvent> GetSystemSEEvent(const FName& InId);
    class UAkAudioEvent* GetResidentAkEvent(const FName& InId);
    FVector GetListenerLocation();
    void AddExcludeEventTerm(FName SubLevelName);
}; // Size: 0xDA0

class USBSpawnAreaRenderingComponent : public UPrimitiveComponent
{
    char padding_0[0x470];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x470

class USBSpawnEmitterAkEventAssetUserData : public UAssetUserData
{
    class UAkAudioEvent* AkEvent;                                                     // 0x0028 (size: 0x8)
    ESBAkEventLOD LOD;                                                                // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBSpawnSourceComponent : public UAIFwSmartObjectComponent
{
    FAIFwParameterizedBTRequest SpawnTree;                                            // 0x00D8 (size: 0x18)
    char padding_0[0x20];                                                             // 0x00F0 (size: 0x20)
    TArray<class AActor*> SpawnedActors;                                              // 0x0110 (size: 0x10)

    void NotifyActorDestroyed(class AActor* Actor);
}; // Size: 0x150

class USBSpawnWaveConditionComponent : public UActorComponent
{
    FTimerHandle StepTimerHandle;                                                     // 0x00C8 (size: 0x8)
    FTimerHandle SpawnedTimerHandle;                                                  // 0x00D0 (size: 0x8)

}; // Size: 0xF8

class USBSphereSoundComponent : public USphereComponent
{
    class UAkComponent* AkComponent;                                                  // 0x0488 (size: 0x8)

}; // Size: 0x4B0

class USBSplineSoundComponent : public USplineComponent
{
    bool bDebugDisplay;                                                               // 0x0568 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0569 (size: 0x3)
    TWeakObjectPtr<class UAkComponent> AkComponent;                                   // 0x056C (size: 0x8)
    char padding_1[0x4];                                                              // 0x0574 (size: 0x4)
    class UAkAudioEvent* PlayEvent;                                                   // 0x0578 (size: 0x8)
    class UAkAudioEvent* StopEvent;                                                   // 0x0580 (size: 0x8)
    float AttenuationScalingFactor;                                                   // 0x0588 (size: 0x4)

    void StopUpdate();
    void StartUpdate();
    void SetAkEvent(class UAkAudioEvent* InPlay, class UAkAudioEvent* InStop);
    void SetAkComponent(class UAkComponent* InAkComponent);
}; // Size: 0x5A0

class USBSpringArmComponent : public USpringArmComponent
{
    char padding_0[0x340];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x340

class USBSquadMemberComponent : public USBAIHierarchyComponent
{
    FSBSquadMemberContext Context;                                                    // 0x00F8 (size: 0x30)
    class USBAIWorldProfilerComponent* WorldProfilerComponent;                        // 0x0128 (size: 0x8)
    class USBAIRoleComponent* RoleComponent;                                          // 0x0130 (size: 0x8)

    void SetContextSituation(ESBSMCSituation Situation);
}; // Size: 0x180

class USBSquadMessageListener : public UObject
{
    class USBSquadMemberComponent* SquadMemberComponent;                              // 0x0028 (size: 0x8)

}; // Size: 0x40

class USBSquadMessageListener_Buff : public USBSquadMessageListener
{
    int32 MaxTargetNum;                                                               // 0x0040 (size: 0x4)
    bool bSelfOnly;                                                                   // 0x0044 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0045 (size: 0x3)
    float MaxDistance;                                                                // 0x0048 (size: 0x4)
    char padding_1[0x4];                                                              // 0x004C (size: 0x4)
    TArray<ESBAIPartyStrategy> ExcludeStrategies;                                     // 0x0050 (size: 0x10)
    TArray<FString> TargetAppearanceIds;                                              // 0x0060 (size: 0x10)
    FString Command;                                                                  // 0x0070 (size: 0x10)

}; // Size: 0x80

class USBSquadMessageListener_ConcentratedAttack : public USBSquadMessageListener
{
    int32 MinMemberNum;                                                               // 0x0040 (size: 0x4)
    int32 MaxMemberNum;                                                               // 0x0044 (size: 0x4)
    float MinDistance;                                                                // 0x0048 (size: 0x4)
    float MaxDistance;                                                                // 0x004C (size: 0x4)
    bool bCheckDistanceFromParty;                                                     // 0x0050 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0051 (size: 0x3)
    float MaxDistanceFromParty;                                                       // 0x0054 (size: 0x4)
    TArray<class TSubclassOf<USBAIRoleBase>> ExcludeRoleClasses;                      // 0x0058 (size: 0x10)
    FString Command;                                                                  // 0x0068 (size: 0x10)

}; // Size: 0x78

class USBSquadMessageListener_CoopAction : public USBSquadMessageListener
{
    FString Command;                                                                  // 0x0040 (size: 0x10)

}; // Size: 0x50

class USBSquadMessageListener_Defend : public USBSquadMessageListener
{
    float MaxDistance;                                                                // 0x0040 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0044 (size: 0x4)
    TArray<ESBAIPartyStrategy> ExcludeStrategies;                                     // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBSquadMessageListener_Heal : public USBSquadMessageListener
{
    int32 MaxTargetNum;                                                               // 0x0040 (size: 0x4)
    float MinHPRate;                                                                  // 0x0044 (size: 0x4)
    float MaxHPRate;                                                                  // 0x0048 (size: 0x4)
    float MaxDistance;                                                                // 0x004C (size: 0x4)
    FString Command;                                                                  // 0x0050 (size: 0x10)

}; // Size: 0x60

class USBStackBBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FOwnItemInfo OverwriteStackB(const FOwnItemInfo& Info, int32 StackBNum);
    bool IsWithinLevel(const FSBStackBTicketData& Ticket, int32 Level);
    bool IsStackBMax(const FOwnItemInfo& Info);
    bool IsStackBInhelitable(const FOwnItemInfo& Info, const TArray<FSBStackBPerk>& Perks, const TArray<FSBStackBPerk>& SelectPerks);
    bool IsFullyContent(const class UObject* InWorldContextObject, const FOwnItemInfo& Target, const FSBStackBTicketData& TicketData, const FSBStackBMasterData& MasterData, const class USBOwnItemListContainer* Storage, bool bUseTicket);
    int32 GetStackBMax(const FOwnItemInfo& Info);
    FString GetStackBKeyByTypeID(const EItemType ItemType, int32 Index);
    FString GetStackBKey(const FOwnItemInfo& Info);
    ESBStackBItemType GetStackBItemType(const FOwnItemInfo& Info);
    TArray<FSBStackBPerk> GenerateStackBPerkList(const FOwnItemInfo& Target, const TArray<FOwnItemInfo>& Materials);
    FOwnItemInfo GenerateStackBItemBase(const FOwnItemInfo& Target, const TArray<FOwnItemInfo>& Materials, bool bNoStackUp);
    FSBStackBMasterData FindStackBMasterData(const FOwnItemInfo& Info);
    bool ContainsStackBMaterials(const class USBTemporallyStorage* InStorage);
    int32 CalculateStackBWeaponStatusValueByEnableType(const FOwnItemInfo& InOwnItemInfo, const ESBWeaponStatus InStatusType, const int32 InStatusValue, const ESBStackBEnableType InEnableType);
    int32 CalculatedStackBWeaponParam(const FOwnItemInfo& Info, ESBWeaponStatus Type);
    FImagineParameter CalculatedStackBImagineParamsByEnableType(const FOwnItemInfo& InOwnItemInfo, const FImagineParameter& InImagineParam, const ESBStackBEnableType InEnableType);
    FImagineParameter CalculatedStackBImagineParams(const FOwnItemInfo& Info);
    FSBStackBWeaponParam CalcStackBWeaponDiffParam(const FOwnItemInfo& Base, const FOwnItemInfo& After);
    FSBStackBImagineParam CalcStackBImagineDiffParam(const FOwnItemInfo& Base, const FOwnItemInfo& After);
    FOwnItemInfo BuildAfterStackBWeaponData(const FOwnItemInfo& Target, const TArray<FOwnItemInfo>& Materials, const TArray<FSBStackBPerk>& Perks, FString SpecialUID);
    FOwnItemInfo BuildAfterStackBImagineData(const FOwnItemInfo& Target, const FOwnItemInfo& Ability);
}; // Size: 0x28

class USBStackBComponent : public USBPlayerControllerComponentBase
{
    FSBStackBComponentOnLoadedTicketData OnLoadedTicketData;                          // 0x00B8 (size: 0x10)
    void OnLoadedTicketData(int32 RetCode);
    FSBStackBComponentOnStackWeaponCompleted OnStackWeaponCompleted;                  // 0x00C8 (size: 0x10)
    void OnCompleteStackWeapon(int32 RetCode, const FOwnItemInfo& Weapon, bool bSuccess);
    FSBStackBComponentOnStackImagineCompleted OnStackImagineCompleted;                // 0x00D8 (size: 0x10)
    void OnCompleteStackImagine(int32 RetCode, const FOwnItemInfo& Imagine, bool bSuccess);
    FSBStackBComponentOnStackMountImagineCompleted OnStackMountImagineCompleted;      // 0x00E8 (size: 0x10)
    void OnCompleteStackImagine(int32 RetCode, const FOwnItemInfo& Imagine, bool bSuccess);

    void SV_StackB_Weapon(class ASBPlayerController* InPlayerController, FString WeaponUID, const TArray<FString>& MaterialUIDs, const TArray<FSBStackBUseTicket>& Tickets, const TArray<FSBStackBSelect>& Perks, const FSBStackBSelect& Vitals);
    void SV_StackB_Mount(class ASBPlayerController* InPlayerController, FString MountUID, const TArray<FString>& MaterialUIDs, const TArray<FSBStackBUseTicket>& Tickets);
    void SV_StackB_Imagine(class ASBPlayerController* InPlayerController, FString ImagineUID, const TArray<FString>& MaterialUIDs, const TArray<FSBStackBUseTicket>& Tickets, FString Perk_Id);
    void Request_TicketData();
    void Request_StackB_Weapon(FString WeaponUID, const TArray<FString>& MaterialUIDs, const TArray<FSBStackBUseTicket>& Tickets, const TArray<FSBStackBSelect>& Perks, const FSBStackBSelect& Vital);
    void Request_StackB_MountImagine(FString MountUID, const TArray<FString>& MaterialUIDs, const TArray<FSBStackBUseTicket>& Tickets);
    void Request_StackB_Imagine(FString ImagineUID, const TArray<FString>& MaterialUIDs, const TArray<FSBStackBUseTicket>& Tickets, FString Perk_Id);
    void OnLoadedTicketData__DelegateSignature(int32 RetCode);
    void OnCompleteStackWeapon__DelegateSignature(int32 RetCode, const FOwnItemInfo& Weapon, bool bSuccess);
    void OnCompleteStackImagine__DelegateSignature(int32 RetCode, const FOwnItemInfo& Imagine, bool bSuccess);
    bool IsTicketLoaded();
    void GetTicketDatas(ESBStackBTicketType Type, TArray<FSBStackBTicketData>& Data);
    void GetAllTicketData(TArray<FSBStackBTicketData>& Data);
    FSBStackBTicketData FindTicketDataByTypeLevel(ESBStackBTicketType Type, ESBStackBItemType ItemType, int32 Level);
    FSBStackBTicketData FindTicketData(int32 token_id);
    void CL_StackB_Weapon(int32 RetCode, const FOwnItemInfo& Weapon, const TArray<FOwnItemInfo>& Items, const TArray<FSBCharacterToken>& Tokens, int32 Money, bool bSuccess);
    void CL_StackB_Mount(int32 RetCode, const FOwnItemInfo& Mount, const TArray<FOwnItemInfo>& Items, const TArray<FSBCharacterToken>& Tokens, int32 Money, bool bSuccess);
    void CL_StackB_Imagine(int32 RetCode, const FOwnItemInfo& Imagine, const TArray<FOwnItemInfo>& Items, const TArray<FSBCharacterToken>& Tokens, int32 Money, bool bSuccess);
    bool checkFullyMaterial(const FOwnItemInfo& Target, const TArray<FOwnItemInfo>& Materials, bool bUseTicket);
}; // Size: 0xF8

class USBStackBMainViewBase : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void Update();
    void Term();
    void Init();
}; // Size: 0x278

class USBStampHistoryData : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    FSBStampHistoryDatas Data;                                                        // 0x0050 (size: 0x10)

}; // Size: 0x60

class USBStartState_Emote : public UASCustomStartSate_Base
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBStateInitializerComponent : public UActorComponent
{
    TMap<class FName, class FSBSpawnActionSetting> SpawnActionSettingMap;             // 0x00D8 (size: 0x50)

}; // Size: 0x128

class USBStaticMeshComponent : public UStaticMeshComponent
{
    TArray<class UTexture*> OverrideNonStreamingTextures;                             // 0x04F8 (size: 0x10)

    void SetForceMipLevelsToBeResident(bool enable);
    bool IsLoadedAllMipTexture();
    bool IsEnableForceMipLevelsToBeResident();
}; // Size: 0x510

class USBStatusAlimentNotifyWidget : public UUserWidget
{
    class AActor* ParentActor;                                                        // 0x0278 (size: 0x8)
    float BaseScaleX;                                                                 // 0x0280 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0284 (size: 0x4)
    class UScaleBox* ScaleBox_Main;                                                   // 0x0288 (size: 0x8)
    class UCurveFloat* DistanceScaleRateCurve;                                        // 0x0290 (size: 0x8)

    void Update();
    void TransformSetting();
    float GetDistance();
    void DistanceScale();
}; // Size: 0x2A0

class USBStatusAlimentNotifyWidgetOwner : public UUserWidget
{
    TSubclassOf<class USBStatusAlimentNotifyWidget> StatusAlimentNotifyWidgetClass;   // 0x0278 (size: 0x8)
    float PopInterval;                                                                // 0x0280 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0284 (size: 0x4)
    class UCanvasPanel* Canvas;                                                       // 0x0288 (size: 0x8)

    void SetDistanceZOrder(TArray<class USBStatusAlimentNotifyWidget*> InWidgetList);
    void AddProcessing(FSBStatusAilmentIconConfig InStatusAilmentIconType, class AActor* InOwnerActor);
}; // Size: 0x290

class USBStatusAlimentUI : public UUserWidget
{
    TWeakObjectPtr<class ASBCharacter> Character;                                     // 0x0288 (size: 0x8)
    TArray<FSBStatusAlimentUIIconInfo> IconInfo;                                      // 0x0290 (size: 0x10)

    void UpdateIconInfo();
    void Show(const FSBStatusUIRequestInfo& InRequestInfo);
}; // Size: 0x2A0

class USBStepList : public UUserWidget
{
    class UWidgetSwitcher* Switcher;                                                  // 0x0278 (size: 0x8)
    class USBStepListQuest* StepListQuest;                                            // 0x0280 (size: 0x8)
    class USBStepListWishList* StepListWishList;                                      // 0x0288 (size: 0x8)
    class USBStepListAdventureBoard* StepListAdventureBoard;                          // 0x0290 (size: 0x8)

    void Unbind();
    void SetVisibleWishList(bool IsVisible);
    void SetVisibleQuestList(bool IsVisible);
    void SetVisibleAdventureBoard(bool IsVisible);
    void SetVisible(bool InVisible);
    void SetupList();
    void SetupKeyGuide();
    void SetEnable(bool IsEnable);
    void SetEditMode(bool IsEdit);
    void PlayAnim();
    void OnSetupTitle(FName TitleTextId, FName TitleBackTextID);
    void OnSetupKeyGuide();
    void NextPage();
    bool IsPlayAnim();
    bool IsEnable();
    void Bind();
}; // Size: 0x2A0

class USBStepListAdventureBoard : public UUserWidget
{
    class USBStepListAdventureBoardItem* AdventureBoardItem;                          // 0x0278 (size: 0x8)

    FSBAdventureBoardCondition CreateAdventureBoardCondition();
}; // Size: 0x280

class USBStepListAdventureBoardItem : public UUserWidget
{
    class USBStepListTitle* StepListTitle;                                            // 0x0278 (size: 0x8)
    class UVerticalBox* List;                                                         // 0x0280 (size: 0x8)

}; // Size: 0x288

class USBStepListCheckIcon : public UUserWidget
{
    class UWidgetSwitcher* SwitchOffOn;                                               // 0x0278 (size: 0x8)

}; // Size: 0x288

class USBStepListProgressListItem : public UUserWidget
{
    class USBTextTableAsset* TextTableAsset;                                          // 0x0278 (size: 0x8)
    class UHorizontalBox* HorizontalBox;                                              // 0x0280 (size: 0x8)
    class USBStepListCheckIcon* CheckIcon;                                            // 0x0288 (size: 0x8)
    class UCanvasPanel* CPBonus;                                                      // 0x0290 (size: 0x8)
    class UTextBlock* LabelBonus;                                                     // 0x0298 (size: 0x8)
    class UTextBlock* LabelCondition;                                                 // 0x02A0 (size: 0x8)
    class UTextBlock* LabelProgress;                                                  // 0x02A8 (size: 0x8)
    float SizeX;                                                                      // 0x02B0 (size: 0x4)
    float LineSize;                                                                   // 0x02B4 (size: 0x4)
    int32 LineCount;                                                                  // 0x02B8 (size: 0x4)
    char padding_0[0x4];                                                              // 0x02BC (size: 0x4)
    FText Text;                                                                       // 0x02C0 (size: 0x18)
    int32 TextNum;                                                                    // 0x02D8 (size: 0x4)

}; // Size: 0x2E0

class USBStepListQuest : public UUserWidget
{
    class UVerticalBox* VBox;                                                         // 0x0278 (size: 0x8)

}; // Size: 0x290

class USBStepListQuestItem : public UUserWidget
{
    class USBStepListTitle* StepListTitle;                                            // 0x0278 (size: 0x8)
    class USBStepListQuestItemTimer* Timer;                                           // 0x0280 (size: 0x8)
    class UVerticalBox* List;                                                         // 0x0288 (size: 0x8)
    FLinearColor DefaultOutlineColor;                                                 // 0x0290 (size: 0x10)
    FLinearColor DoneOutlineColor;                                                    // 0x02A0 (size: 0x10)

    void OnSetQuestTitle(const FQuestMasterData& QuestMasterData);
    void OnSetInterruptQuestTitle();
}; // Size: 0x2B8

class USBStepListQuestItemTimer : public UUserWidget
{
    class UTextBlock* LabelTime;                                                      // 0x0278 (size: 0x8)

}; // Size: 0x290

class USBStepListTitle : public UUserWidget
{
    class UWidgetSwitcher* IconSwitcher;                                              // 0x0278 (size: 0x8)
    class UTextBlock* TextTitle;                                                      // 0x0280 (size: 0x8)
    class UImage* RouteGuideIcon;                                                     // 0x0288 (size: 0x8)
    int32 TextNum;                                                                    // 0x0290 (size: 0x4)

    void OnSetIconWishList(EQuestStatus InQuestStatus);
    void OnSetIconQuest(int32 InQuestIndex);
}; // Size: 0x298

class USBStepListWishList : public UUserWidget
{
    class UVerticalBox* VBox;                                                         // 0x0278 (size: 0x8)

}; // Size: 0x280

class USBStepListWishListItem : public UUserWidget
{
    class USBStepListTitle* StepListTitle;                                            // 0x0278 (size: 0x8)
    class UVerticalBox* List;                                                         // 0x0280 (size: 0x8)

}; // Size: 0x288

class USBStorageCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UseItem(const int32 InItemIndex, const int32 InStorageNo);
    void SetActiveItemRemainTime(const int32 InItemID, const int32 InHour, const int32 InMinute, const int32 InSecond);
    void OnUseItemFinish(const int32 InRetCode, const TArray<FOwnItemInfo>& InDirtyItems);
    void OnCancelActiveItemFinish(const int32 InRetCode, FString InId);
    void OnAddStorageFinish(int32 InRetCode, const TArray<FSBDiffItemInfo>& InAddItemData, const TArray<FSBMasterReward>& OutRewardList, FFieldActorPickupNotifyInfo FieldActorPickupInfo);
    void CheckActiveItemLifetime();
    void CancelActiveItem(const int32 InItemIndex);
    void BulkGetItemSet(const FName ItemSetName);
    void BulkGetItemMenu();
    void AddWeapon(const int32 WeaponID, const int32 InStorageNo);
    void AddMountImagine(const int32 InId, const int32 InStorageNo);
    void AddMasterItemsMenu();
    void AddItem(const int32 ItemIndex, const int32 Amount, const int32 StorageNo);
    void AddImagineByName(const FName Name);
    void AddImagine(const int32 InId, const int32 InStorageNo);
    void AddCostume(const int32 WeaponID, const int32 InStorageNo);
}; // Size: 0x28

class USBStraightMovementComponent : public USBProjectileMovementHomingComponent
{
    char padding_0[0x218];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x218

class USBStringParam : public UObject
{
    FString Value;                                                                    // 0x0028 (size: 0x10)

    class USBStringParam* SetValue(FString InValue);
}; // Size: 0x38

class USBSubsystemConnection : public UObject
{
    FString ServerScheme;                                                             // 0x0028 (size: 0x10)
    FString ServerHost;                                                               // 0x0038 (size: 0x10)
    int32 ServerPort;                                                                 // 0x0048 (size: 0x4)
    int32 ServerApiPort;                                                              // 0x004C (size: 0x4)
    FString AppId;                                                                    // 0x0050 (size: 0x10)
    FString XmppServerDomain;                                                         // 0x0060 (size: 0x10)
    FString XmppServerMUCServicePrefix;                                               // 0x0070 (size: 0x10)

}; // Size: 0x110

class USBSurfaceFootprintSetting : public UObject
{
    TArray<FSBSurfaceFootprint> SurfaceFootprintSetting;                              // 0x0028 (size: 0x10)
    float EffectDelayTime;                                                            // 0x0038 (size: 0x4)
    char padding_0[0x4];                                                              // 0x003C (size: 0x4)
    FSBFootprintSoundSetting SoundSetting;                                            // 0x0040 (size: 0x30)

    class UParticleSystem* GetParticle(TEnumAsByte<EPhysicalSurface> SurfaceType);
    class UNiagaraSystem* GetNiagara(TEnumAsByte<EPhysicalSurface> SurfaceType);
    class UMaterialInstance* GetDecal(TEnumAsByte<EPhysicalSurface> SurfaceType);
}; // Size: 0x70

class USBSwitchableNavModifierComponent : public USceneComponent
{
    TSubclassOf<class UNavArea> NavModifierArea;                                      // 0x0208 (size: 0x8)
    bool bIsCubeBrush;                                                                // 0x0210 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0211 (size: 0x3)
    FSBCubeBuilderParameter CubeBuilderParameter;                                     // 0x0214 (size: 0xC)
    FSBCylinderBuilderParameter CylinderBuilderParameter;                             // 0x0220 (size: 0xC)
    TWeakObjectPtr<class ASBAutoCreatedSwitchableNavModifierVolume> CreatedVolume;    // 0x022C (size: 0x8)
    bool bRebuildBrush;                                                               // 0x0234 (size: 0x1)
    bool bRebuildAllBrush;                                                            // 0x0235 (size: 0x1)

    void SetNavAreaInGameplay_Client(TSubclassOf<class UNavArea> NewAreaClass);
    void SetNavAreaInGameplay(TSubclassOf<class UNavArea> NewAreaClass);
}; // Size: 0x240

class USBSystemMessage : public USBUserWidget
{
    FSBSystemMessageOnEndSystemMessageDelegete OnEndSystemMessageDelegete;            // 0x02B0 (size: 0x10)
    void OnEndSystemMessageDelegete();

    void StartMessage(const FText& Message);
    void OnEndSystemMessageDelegete__DelegateSignature();
    void OnEndShowMessage();
}; // Size: 0x2C0

class USBSystemMessageManager : public UObject
{
    class USBTextTableAsset* TextTableAsset;                                          // 0x0028 (size: 0x8)
    TSubclassOf<class USBSystemMessage> SystemMessageUI;                              // 0x0030 (size: 0x8)

    void ShowMessageByFlagWithMessage(const class UObject* WorldContextObject, const FText& Message, const bool bIsLowerPosition);
    void ShowMessageByFlag(const class UObject* WorldContextObject, ESBSystemMessageFlag InFlag, const bool bIsLowerPosition);
    void ShowMessage_NpcTalkMode(const class UObject* WorldContextObject, const FText& Message);
    void ShowMessage(const class UObject* WorldContextObject, const FText& Message, const bool IsLowerPosition, const bool bDoNotSkip);
    void ShowItemGetFailureInventoryFullMessage(const class UObject* WorldContextObject);
    void ShowHealStationHealDoneMessage(const class UObject* WorldContextObject);
    void ShowGetEmoteMessage(const class UObject* WorldContextObject, const FName& EmoteId);
    bool IsSystemMessageShowingOrStandby();
    bool IsDemoPlaying(const class UObject* WorldContextObject);
    bool GetContentActivateMessage(const TArray<FName>& ContentId, FText& Message);
    class USBSystemMessage* CreateSysMsgUI(const class UObject* WorldContextObject, const FText& Message);
    void ClearSystemMessage();
}; // Size: 0x38

class USBTargetCursorWidget : public UUserWidget
{
    class UWidgetSwitcher* SwitchAuto;                                                // 0x0278 (size: 0x8)
    class UWidgetSwitcher* SwitchLockon;                                              // 0x0280 (size: 0x8)
    class UOverlay* Overlay_0;                                                        // 0x0288 (size: 0x8)
    class USBTargetableComponent* TargetableComponent;                                // 0x0290 (size: 0x8)
    bool IsFirstLock;                                                                 // 0x0298 (size: 0x1)
    bool IsPlaySE;                                                                    // 0x0299 (size: 0x1)

    void OnPlayLockOnSe();
}; // Size: 0x2A0

class USBTargetableComponent : public USceneComponent
{
    bool bIsEnableAutoTarget;                                                         // 0x0208 (size: 0x1)
    bool bIsEnableMultiTarget;                                                        // 0x0209 (size: 0x1)
    bool bIsEnableLockOn;                                                             // 0x020A (size: 0x1)
    bool bIsTargetable;                                                               // 0x020B (size: 0x1)
    char padding_0[0x4];                                                              // 0x020C (size: 0x4)
    float AttackMoveTargetRangeForCumulate;                                           // 0x0210 (size: 0x4)

    void SetIsTargetable(bool bTargetable);
    bool IsTargetable();
}; // Size: 0x220

class USBTelemetryLogBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void Log_PushCharacterCreateButton(const class UObject* InWorldContextObject);
    void Log_CloseTutorialHelp(const class UObject* InWorldContextObject, FName InTutorialHelpId);
    void Log_AccessibilitySetting_TTS(const class UObject* InWorldContextObject);
    void Log_AccessibilitySetting_STT(const class UObject* InWorldContextObject);
}; // Size: 0x28

class USBTelopBase : public UUserWidget
{
    FSBTelopBaseOnFinishDelegate OnFinishDelegate;                                    // 0x0278 (size: 0x10)
    void OnFinishDelegate();

    void StopAnim();
    void Stop();
    void SetBG(int32 Index);
    void PlaySE(class UAkAudioEvent* SE);
    void PlayBGM();
    void PlayAnim();
    void OnPlay();
    void OnFinishDelegate__DelegateSignature();
    bool IsPlayAnim();
    class USBRuntimeTextBlock* GetTextEffect();
    class USBRuntimeTextBlock* GetText();
    class UTextBlock* GetSubText();
    FSBTelopPlayParam GetParam();
    FSBTelopDataParam GetData();
    void Finish();
}; // Size: 0x308

class USBTelopBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBTelopEventParamClassLevelUp : public UObject
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)

    int32 GetPrevLevel();
    ESBRewardItemType GetIconType();
    int32 GetIconID();
    int32 GetIconAmount();
    int32 GetCurrentLevel();
}; // Size: 0x40

class USBTelopEventParamInterruptQuestFailed : public UObject
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    FName GetQuestId();
}; // Size: 0x30

class USBTelopEventParamInterruptQuestJoin : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    bool IsFirst();
    FName GetQuestId();
}; // Size: 0x38

class USBTelopEventParamInterruptQuestSuccess : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    bool IsSuccess();
    FName GetQuestId();
}; // Size: 0x38

class USBTelopEventParamLearningSkill : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    TArray<FCharaSkillMasteryInfo> GetSkill();
}; // Size: 0x38

class USBTelopEventParamProficiencyUp : public UObject
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    int32 GetValueMax();
    int32 GetValue();
}; // Size: 0x30

class USBTelopManager : public UUserWidget
{
    FSBTelopManagerOnFinishDelegate OnFinishDelegate;                                 // 0x0278 (size: 0x10)
    void OnFinishDelegate(const FSBTelopPlayParam& InTelopParam);
    class UDataTable* TelopDataTable;                                                 // 0x0288 (size: 0x8)
    class UDataTable* TelopOverrideDataTable;                                         // 0x0290 (size: 0x8)
    class UWidgetSwitcher* WS_Telop;                                                  // 0x0298 (size: 0x8)
    class USBTelopBase* PlayTelop_;                                                   // 0x02A0 (size: 0x8)

    void PlayRequest(bool isForce, const FSBTelopPlayParam& TelopParam);
    void Pause(bool IsPause);
    void OnTerminate();
    void OnInitialize();
    class USBTelopBase* OnGetTelop(ESBTelopType TelopType);
    void OnFinishDelegate__DelegateSignature(const FSBTelopPlayParam& InTelopParam);
    bool IsRegist();
    bool IsPlayTelop();
    bool IsPause();
    void Finished();
}; // Size: 0x2C8

class USBTemporallyStorage : public USBOwnItemListContainer
{
    int32 PagerMax;                                                                   // 0x0068 (size: 0x4)
    int32 PagenateNum;                                                                // 0x006C (size: 0x4)

    bool SubItemByUniqueId(FString InUniqueId, const int32 InAmount);
    bool SubItem(const EItemType InItemType, const int32 InItemIndex, const int32 InAmount);
    void SetPagenateNum(int32 Pagenate);
    void SetFilterID(const int32 ID);
    bool MoveItem(class USBTemporallyStorage* ToStorage, FString UniqueId, const int32 InMoveAmount);
    TArray<int32> GetSortedPageIndexes(int32 InPage);
    int32 GetPagenateNum();
    int32 GetMaxPage();
    TArray<FOwnItemInfo> GetAllItems();
    void DropUniqueIdSortIndex(FString UniqueId);
    class USBTemporallyStorage* CreateEmptyTemporallyStorage(int32 Capacity);
    void BPUpdateItem(const FOwnItemInfo& Info);
    void ApplyFilterID();
    int32 AddItemByUniqueId(const EItemType InItemType, FString InUniqueId, const int32 InItemIndex, const int32 InAmount);
    int32 AddItem(const EItemType InItemType, const int32 InItemIndex, const int32 InAmount);
}; // Size: 0x78

class USBTextBlock : public UWidget
{
    FText Text;                                                                       // 0x0120 (size: 0x18)
    FSBTextBlockTextDelegate TextDelegate;                                            // 0x0138 (size: 0x10)
    FText GetText();
    FSlateColor ColorAndOpacity;                                                      // 0x0148 (size: 0x28)
    FSBTextBlockColorAndOpacityDelegate ColorAndOpacityDelegate;                      // 0x0170 (size: 0x10)
    FSlateColor GetSlateColor();
    FVector2D ShadowOffset;                                                           // 0x0180 (size: 0x8)
    FLinearColor ShadowColorAndOpacity;                                               // 0x0188 (size: 0x10)
    FSBTextBlockShadowColorAndOpacityDelegate ShadowColorAndOpacityDelegate;          // 0x0198 (size: 0x10)
    FLinearColor GetLinearColor();
    class UFont* Font;                                                                // 0x01A8 (size: 0x8)

    void SetText(FText InText);
    void SetShadowOffset(FVector2D InShadowOffset);
    void SetShadowColorAndOpacity(FLinearColor InShadowColorAndOpacity);
    void SetOpacity(float InOpacity);
    void SetFont(class UFont* InFont);
    void SetColorAndOpacity(FSlateColor InColorAndOpacity);
    FText GetText();
}; // Size: 0x1C0

class USBTextBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool NotEnable_SBTextTableHash(const FSBTextTableHash& InHash);
    FString GetZoneShortNameByZoneId(const FName InZoneId);
    FString GetZoneShortNameByContentId(const FName InContentId);
    FString GetZoneNameByZoneId(const FName InZoneId);
    FString GetZoneName(const int32 InTextId);
    FString GetWeaponTypeText(const TEnumAsByte<ESBWeaponType> InWeaponType);
    FString GetWeaponText(const FSBTextTableHash& InTextId);
    FString GetWeaponPerkText(const FSBTextTableHash& InTextId);
    FString GetWarpPointName(const FName InWarpPointId);
    FString GetUICancelText(ESBOperateMode InOperateMode);
    FString GetTokenText(const FSBTextTableHash& InTextId);
    FString GetTitleName();
    FString GetText(const FName& InTableName, const FSBTextTableHash& InTextId);
    FString GetSystemMessage(const FName InTextId);
    FString GetSystemLogMessage(const FName InTextId);
    FString GetSubLocationName(const FName InTextId);
    FString GetStampText(const FSBTextTableHash& InTextId);
    FString GetStampSetText(const FSBTextTableHash& InTextId);
    FString GetStackBText(const FSBTextTableHash& InTextId);
    FString GetStackBImagineParamText(const FSBTextTableHash& InTextId);
    FString GetStackBImagineDescText(const FOwnItemInfo& Info);
    FString GetSBRetMessage_RetryMode(const int32 InSBRetCode);
    FString GetSBRetMessage(const int32 InSBRetCode);
    FString GetRewardName(const ESBRewardItemType InRewardItemType);
    FString GetRewardItemTypeName(const ESBRewardItemType InRewardItemType);
    FString GetRecipeSetText(const FSBTextTableHash& InTextId);
    FString GetPerkName(const FSBTextTableHash& InTextId);
    FString GetObjectName(const FName InObjectId);
    FString GetNotifyMessage(const FName InTextId);
    FString GetNoticeBoardText(const FSBTextTableHash& InTextId);
    FString GetNameText(const int32 ItemId, const EItemType ItemType);
    FString GetMoneyName();
    FString GetMasterWarehouseAbilityRecipeText(const FSBTextTableHash& InTextId);
    FString GetMasterTokenText(const FSBTextTableHash& InTextId);
    FString GetMasterSkillDataText(const FSBTextTableHash& InTextId);
    FString GetMasterSeasonPassShopText(const FSBTextTableHash& InTextId);
    FString GetMasterRoseOrbShopText(const FSBTextTableHash& InTextId);
    FString GetMasterRoseOrbPurchaseShopText(const FSBTextTableHash& InTextId);
    FString GetMasterRealMoneyShopText(const FSBTextTableHash& InTextId);
    FString GetMasterRealGoodsText(const FSBTextTableHash& InTextId);
    FString GetMasterMountImagineText(const FSBTextTableHash& InTextId);
    FString GetMasterInterruptQuestText(const FSBTextTableHash& InTextId);
    FString GetMasterImagineText(const FSBTextTableHash& InTextId);
    FString GetMasterHistoryActionTypeText(const FSBTextTableHash& InTextId);
    FString GetMasterEventShopText(const FSBTextTableHash& InTextId);
    FString GetMasterBPPointShopText(const FSBTextTableHash& InTextId);
    FString GetLocationName(const FName InTextId);
    FString GetLiquidMemoryText(const FSBTextTableHash& InTextId);
    FString GetLiquidMemoryEfficacyLogMessage(const int32 InTextId);
    FString GetKeyTextByKey(const FKey& Key, const bool bReplaceFunction);
    FString GetKeyText(const FName Name, const bool bReplaceFunction);
    FString GetKeyShortText(const FName Name, const bool bReplaceFunction);
    FString GetItemText(const FSBTextTableHash& InTextId);
    FString GetGuildRankUnlockText(const FSBTextTableHash& InTextId);
    FString GetGashaText(const FSBTextTableHash& InTextId);
    FString GetGamepadStickCharaCode(const bool RightStick);
    FString GetGameBuffTypeText(const EOutGameBuffType InOutGameBuffType);
    FSBAbilityTextData GetFusionItemTextCollection(bool& bIsValid, const int32 InItemID);
    FString GetFreeCurrencyName();
    FString GetFixedPhrase(const int32 InTextId);
    FString GetEventTriggerName(const FName InEventTriggerId);
    FString GetEquipmentSeriesText(const FSBTextTableHash& InTextId);
    FString GetEnemyRaceIdName(const FSBTextTableHash& InTextId);
    FString GetEnemyName(const FSBTextTableHash& InTextId);
    FString GetEmotionTextTarget(const FName& Name);
    FString GetEmotionTextSelf(const FName& Name);
    FString GetEmotionName(const FName& Name);
    FString GetDungeonText(const FName InTextId);
    FString GetDungeonRuleName(const FName DungeonId);
    FString GetDungeonRuleDesc(const FName DungeonId);
    FString GetDungeonName(const FName InTextId);
    FString GetDungeonDisplayName(const FName DungeonId);
    FString GetDungeonDisplayDesc(const FName DungeonId);
    FString GetDungeonClearConditionText(const FName InTextId);
    FString GetCurrentZoneName(class UObject* WorldContextObject);
    FString GetCostumeText(const FSBTextTableHash& InTextId);
    FString GetCommonText(const FSBTextTableHash& InTextId);
    FString GetCommonSkillText(const FSBTextTableHash& InTextId);
    FString GetCommonSkillCategoryText(const FSBTextTableHash& InTextId);
    FString GetCoinName();
    FString GetCharacterNameByProfileId(const FName InProfileId);
    FString GetCharacterName(const FName InTextId);
    FString GetBattleLogMessage(const int32 InTextId);
    FString GetAwardsText(const FSBTextTableHash& InTextId);
    FString GetAestheShopCourseText(const FSBTextTableHash& InTextId);
    FString GetAdventureCardDecorationText(const FSBTextTableHash& InTextId);
    FString GetAchievementName(const FSBTextTableHash& InTextId);
    FString GetAchievementDescription(const FSBTextTableHash& InTextId);
    FString GetAcceptQuestErrorCodeText(const EAcceptedQuestErrorCode InErrorCode);
    FSBAbilityTextData GetAbilityTextDataCollection(const int32 InAbilityEffectId);
    bool Enable_SBTextTableHash(const FSBTextTableHash& InHash);
    FString Conv_SBTextTableHashToString(const FSBTextTableHash& InHash);
    FSBTextTableHash Conv_SBTextTableHashToInt(int32 inInt);
    FSBTextTableHash Conv_SBTextTableHashToByte(uint8 InByte);
    int32 Conv_IntToSBTextTableHash(const FSBTextTableHash& InHash);
    void ClipPaste(FString& Text);
    void ClipCopy(FString Text);
}; // Size: 0x28

class USBTextBoxBase : public UEditableTextBox
{
    char padding_0[0xAC8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0xAC8

class USBTextSettings : public UObject
{
    bool EnableTextVersionDialog;                                                     // 0x0028 (size: 0x1)
    bool UnauthorizedTextConcealment;                                                 // 0x0029 (size: 0x1)

}; // Size: 0x30

class USBTextTableAsset : public UObject
{
    TArray<FSBTextData> TextTable;                                                    // 0x0028 (size: 0x10)

}; // Size: 0x68

class USBTextWindow : public USBTextWindowBase
{
    FSBTextWindowShowTextAllDelegate ShowTextAllDelegate;                             // 0x0278 (size: 0x10)
    void ShowTextAllDelegate();
    FSBTextWindowTurnTextDelegate TurnTextDelegate;                                   // 0x0288 (size: 0x10)
    void TurnTextDelegate();

    void TurnTextDelegate__DelegateSignature();
    void ShowTextAllDelegate__DelegateSignature();
    void SetBGVisible(bool bVisible);
    void HideWithoutBG();
    bool GetBGVisible();
}; // Size: 0x298

class USBTextWindowBase : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void Show();
    void SetText(const FText& InText);
    void SetSpeaker(const FName& InProfileId);
    void SetNextMarkVisibility(const bool bInVisibility);
    bool IsShow();
    void Hide();
}; // Size: 0x278

class USBTheaterComponent : public UActorComponent
{
    FSBTheaterComponentOnGetDemoListDelegate OnGetDemoListDelegate;                   // 0x00C0 (size: 0x10)
    void OnGetDemoListDelegate(const bool Result, const int32 RetCode, const TArray<FName>& DemoList);
    char padding_0[0x18];                                                             // 0x00D0 (size: 0x18)
    FSBTheaterComponentOnSaveDemoBrowsedDelegate OnSaveDemoBrowsedDelegate;           // 0x00E8 (size: 0x10)
    void OnSaveDemoBrowsedDelegate(const bool Result, const int32 RetCode, const FName& DemoId);

    void StartTheater();
    void Server_SaveDemoBrowsed(const FName& DemoId, bool IsTheater);
    void Server_GetDemoList();
    void Request_SaveDemoFromTheater(const FName& DemoId);
    void Request_SaveDemoBrowsed(const FName& DemoId);
    void Request_GetDemoList();
    void RemoveIDsFromLoadDemoList(const TArray<FName> RemoveList);
    void OnSaveDemoBrowsedDelegate__DelegateSignature(const bool Result, const int32 RetCode, const FName& DemoId);
    void OnGetDemoListDelegate__DelegateSignature(const bool Result, const int32 RetCode, const TArray<FName>& DemoList);
    bool GetSkipFlag();
    TArray<FName> GetLoadDemoList();
    void EndTheater();
    void Client_SaveDemoBrowsed(const bool bIsSuccess, const int32 RetCode, const FName& DemoId, const int32 ResponseCode);
    void Client_GetDemoList(bool bInWasSuccessful, const int32 InRetCode, const TArray<FName>& InDemoList);
}; // Size: 0xF8

class USBTickerMessageBase : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void DumpDebugInfo();
}; // Size: 0x278

class USBTickerMessageManager : public UObject
{
    FSBTickerMessageManagerOnTickerMessageChangedDelegete OnTickerMessageChangedDelegete; // 0x0068 (size: 0x10)
    void OnTickerMessageChangedDelegete();

    void SetWidget(class USBTickerMessageBase* InWidget);
    int32 GetNextValidMesssageIndex(const int32 InStartIndex);
    int32 GetMessageNum();
    void Debug_AddMessage(const FSBTickerMessageInfo& InMessage);
    void ClearPastMessage();
    FSBTickerMessageInfo BP_GetMessageNum(const int32 InIndex);
}; // Size: 0x78

class USBTideSoundComponent : public USceneComponent
{
    char padding_0[0x210];                                                            // 0x0000 (size: 0x0)

    void SetTidePercent(float InTidePercent);
    float GetTidePercent();
}; // Size: 0x210

class USBTimeAttackHUD : public USBContentsHUDBase
{
    char padding_0[0x2D8];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x2D8

class USBTimeNotify : public USBTimeNotifyBase
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)

    bool Received_Notify();
}; // Size: 0x30

class USBTimeNotifyBase : public UObject
{
    bool bIsInstanced;                                                                // 0x0028 (size: 0x1)
    ETimeNotifyNetMode NotifyNetMode;                                                 // 0x0029 (size: 0x1)

}; // Size: 0x30

class USBTimeNotifyEventsData : public UObject
{
    TArray<FSBTimeNotifyEvent> Notifies;                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

class USBTimeNotifyState : public USBTimeNotifyBase
{
    bool bTickEnabledNotifyState;                                                     // 0x0030 (size: 0x1)

    bool Received_NotifyTick(float DeltTime);
    bool Received_NotifyEnd();
    bool Received_NotifyBegin(FSBGameTime TotalDuration);
}; // Size: 0x38

class USBTimeNotifyState_Sample : public USBTimeNotifyState
{
    FString PrintString_Begin;                                                        // 0x0038 (size: 0x10)
    FString PrintString_End;                                                          // 0x0048 (size: 0x10)

}; // Size: 0x58

class USBTimeNotify_Sample : public USBTimeNotify
{
    FString SamplePrintString;                                                        // 0x0030 (size: 0x10)

}; // Size: 0x40

class USBTimerRespawnHUD : public UUserWidget
{
    class UTextBlock* respawncountertextblock;                                        // 0x0280 (size: 0x8)
    class UTextBlock* timertextblock_min;                                             // 0x0288 (size: 0x8)
    class UTextBlock* timertextblock_sec;                                             // 0x0290 (size: 0x8)
    class UTextBlock* timertextblock_millisec;                                        // 0x0298 (size: 0x8)
    class UTextBlock* arenaFloortextblock;                                            // 0x02A0 (size: 0x8)

    void SetTimerAndRespawnTextBlock(const class UTextBlock* respawncountertextblock, const class UTextBlock* timertextblock_min, const class UTextBlock* timertextblock_sec, const class UTextBlock* timertextblock_millisec);
    void SetTimeAttackBestTime(const FText& Text);
    void SetHUDVisibility(bool On);
    void SetArenaFloorTextBlock(const class UTextBlock* arenaFloortextblock);
    void SetArenaFloorText(FText Text);
    void OnDelegated_StopTimerTimeOver();
    void OnDelegated_StopTimerGameOver();
}; // Size: 0x2A8

class USBTitleMenuCharaLayer : public UUserWidget
{
    char padding_0[0x278];                                                            // 0x0000 (size: 0x0)

    void ShowCharaLayer(bool IsSkip);
    void SetFirstPlay(bool IsFirstPlay);
}; // Size: 0x278

class USBToken : public UObject
{
    FSBTokenOnGetStateListDelegate OnGetStateListDelegate;                            // 0x0028 (size: 0x10)
    void OnGetStateListDelegate(const FSBTokenStates States);
    FSBTokenOnGetExpiredListDelegate OnGetExpiredListDelegate;                        // 0x0038 (size: 0x10)
    void OnGetExpiredListDelegate(const FSBExpiredTokenStates States);
    TArray<FSBTokenState> TokenStateList;                                             // 0x0048 (size: 0x10)

    bool Request_GetExpiredList(class ASBPlayerController* PlayerController);
    bool Request_DeleteExpired(class ASBPlayerController* PlayerController);
    void OnGetStateListDelegate__DelegateSignature(const FSBTokenStates States);
    void OnGetExpiredListDelegate__DelegateSignature(const FSBExpiredTokenStates States);
    TArray<FSBTokenState> GetTokenStateList();
    FDateTime GetNextRecoveryTimeOfWeek(ESBTokenDayOfWeek inTargetDay);
    FDateTime GetNextRecoveryTimeOfTimer(FDateTime LastRecoveryDate, int32 RecoveryMin, int32 RecoverySec);
    FDateTime GetNextRecoveryTimeOfMonth();
    FDateTime GetNextRecoveryTimeOfDay();
}; // Size: 0x68

class USBTowerChallengeWatcher : public USceneComponent
{
    FTowerChallengeInfo TowerChallengeInfo;                                           // 0x0210 (size: 0x18)
    FTowerChallengeProgressInfo TowerChallengeProgressInfo;                           // 0x0228 (size: 0x14)
    float ChallengeLimitTime;                                                         // 0x023C (size: 0x4)
    bool bActiveChallenge;                                                            // 0x0240 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0241 (size: 0x7)
    FSBTowerChallengeWatcherOnStartDelegate OnStartDelegate;                          // 0x0248 (size: 0x10)
    void OnStartDelegate(const FName& InChallengeName);
    FSBTowerChallengeWatcherOnChallengeInfoSetDelegate OnChallengeInfoSetDelegate;    // 0x0258 (size: 0x10)
    void OnChallengeInfoSetDelegate(const FName& InChallengeName);
    FSBTowerChallengeWatcherOnUpdateDelegate OnUpdateDelegate;                        // 0x0268 (size: 0x10)
    void OnUpdateDelegate(const FName& InChallengeName);
    FSBTowerChallengeWatcherOnTimeOutDelegate OnTimeOutDelegate;                      // 0x0278 (size: 0x10)
    void OnTimeOutDelegate(const FName& InMissionName);
    FSBTowerChallengeWatcherOnClearDelegate OnClearDelegate;                          // 0x0288 (size: 0x10)
    void OnClearDelegate(const FName& InChallengeName);

    void OnUpdateDelegate__DelegateSignature(const FName& InChallengeName);
    void OnTimeOutDelegate__DelegateSignature(const FName& InMissionName);
    void OnStartDelegate__DelegateSignature(const FName& InChallengeName);
    void OnRep_TowerChallengeProgressInfo();
    void OnRep_TowerChallengeInfo();
    void OnClearDelegate__DelegateSignature(const FName& InChallengeName);
    void OnChallengeInfoSetDelegate__DelegateSignature(const FName& InChallengeName);
    void NotifyIncrementFreeCount();
    void Multicast_NotifySucceededTowerChallenge(const FName& InChallengeName);
    void Multicast_NotifyStartTowerChallenge(const FName& InChallengeName);
    void Multicast_NotifyFailedTowerChallenge(const FName& InMissionName);
    bool IsActiveChallenge();
    FTowerChallengeProgressInfo GetTowerChallengeProgressInfo();
    FTowerChallengeInfo GetTowerChallengeInfo();
    float GetChallengeLimitTime();
    int32 GetAliveEnemyNum();
}; // Size: 0x2A0

class USBTowerHUD : public USBContentsHUDBase
{
    class UTextBlock* Counter;                                                        // 0x02D8 (size: 0x8)

    void SetMaxCount(const class UTextBlock* CounterWidget, FText Text);
    void SetCounterWidget(const class UTextBlock* CounterTextBlock);
    void SetCounterText(FText Text);
}; // Size: 0x2E0

class USBTrackGeneratorSoundComponent : public USceneComponent
{
    bool bDebugDisplay;                                                               // 0x0210 (size: 0x1)
    char padding_0[0xF];                                                              // 0x0211 (size: 0xF)
    class UAkAudioEvent* FirstSoundEvent;                                             // 0x0220 (size: 0x8)
    class UAkAudioEvent* FirstStopEvent;                                              // 0x0228 (size: 0x8)
    float FirstAttenuationScalingFactor;                                              // 0x0230 (size: 0x4)
    char padding_1[0xC];                                                              // 0x0234 (size: 0xC)
    class UAkAudioEvent* SecondSoundEvent;                                            // 0x0240 (size: 0x8)
    class UAkAudioEvent* SecondStopEvent;                                             // 0x0248 (size: 0x8)
    float SecondAttenuationScalingFactor;                                             // 0x0250 (size: 0x4)
    int32 IndexOfStartSecond;                                                         // 0x0254 (size: 0x4)

    void StopUpdate();
    void StartUpdate();
    void SetSplineComponent(class USplineComponent* InSpline, int32 StartSecond, class UAkComponent* InFirstAkComponent, class UAkComponent* InSecondAkComponent);
}; // Size: 0x270

class USBTransition_CanEmote : public UASTransition_BlueprintBase
{
    TArray<FName> AnimTags;                                                           // 0x0050 (size: 0x10)
    TArray<FName> ForbidAnimTags;                                                     // 0x0060 (size: 0x10)

}; // Size: 0x70

class USBTransition_CanSkillAtPosition : public UASTransition_Base
{
    ESkillActionPosition SkillPosition;                                               // 0x0030 (size: 0x1)
    EPlayerStateMachine StateMachineType;                                             // 0x0031 (size: 0x1)
    bool bIgnoreCommandCheck;                                                         // 0x0032 (size: 0x1)

}; // Size: 0x38

class USBTransition_CheckAnimTime : public UASTransition_PlayEnd
{
    float Time;                                                                       // 0x0038 (size: 0x4)

}; // Size: 0x40

class USBTransition_CheckCanGuard : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_CheckCommandOR : public UASTransition_BlueprintBase
{
    TArray<FName> Commands;                                                           // 0x0050 (size: 0x10)

}; // Size: 0x60

class USBTransition_CheckElapsedTimeAfterDodgeEnd : public UASTransition_BlueprintBase
{
    float ElapsedTime;                                                                // 0x0050 (size: 0x4)

}; // Size: 0x58

class USBTransition_CheckElapsedTimeAfterGuardSucceeded : public UASTransition_BlueprintBase
{
    float ElapsedTime;                                                                // 0x0050 (size: 0x4)

}; // Size: 0x58

class USBTransition_CheckGameInputTime : public UASTransition_Base
{
    EGameInput gameInput;                                                             // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    float Time;                                                                       // 0x0034 (size: 0x4)

}; // Size: 0x38

class USBTransition_CheckLastSetupSkill : public UASTransition_Base
{
    int32 ActiveArtsID;                                                               // 0x0030 (size: 0x4)

}; // Size: 0x38

class USBTransition_CheckNextAnimStateCountLimit : public UASTransition_Base
{
    int32 LimitCount;                                                                 // 0x0030 (size: 0x4)

}; // Size: 0x38

class USBTransition_CheckRoundBlowLoopStamina : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_CheckSkillEquipped : public UASTransition_Base
{
    int32 SkillId;                                                                    // 0x0030 (size: 0x4)

}; // Size: 0x38

class USBTransition_CheckSkillLevel : public UASTransition_Base
{
    int32 SkillId;                                                                    // 0x0030 (size: 0x4)
    int32 Level;                                                                      // 0x0034 (size: 0x4)
    ESBMagnitudeRelation Relation;                                                    // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBTransition_CheckSkillMoveInputActorForward : public UASTransition_Base
{
    float ForwardAngle;                                                               // 0x0030 (size: 0x4)

}; // Size: 0x38

class USBTransition_CheckSkillWorkTime : public UASTransition_Base
{
    ESkillActionPosition SkillPosition;                                               // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    float Time;                                                                       // 0x0034 (size: 0x4)

}; // Size: 0x38

class USBTransition_CheckSphereSweepHitForward : public UASTransition_Base
{
    float SweepHitLength;                                                             // 0x0030 (size: 0x4)
    float SphereRadius;                                                               // 0x0034 (size: 0x4)
    TArray<TEnumAsByte<ECollisionChannel>> CollisionChannelList;                      // 0x0038 (size: 0x10)

}; // Size: 0x48

class USBTransition_CheckTSkillStepInputDirection : public UASTransition_Base
{
    ESBTSkillStepInputDirection CheckDirection;                                       // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    float CheckAngle;                                                                 // 0x0034 (size: 0x4)

}; // Size: 0x38

class USBTransition_DamageDownTime : public UASTransition_Base
{
    float DamageDownTime;                                                             // 0x0030 (size: 0x4)

}; // Size: 0x38

class USBTransition_EnemyCastEnd : public UASTransition_Base
{
    uint8 bIsMainStateMachine;                                                        // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBTransition_EnemyCheckStance : public UASTransition_Base
{
    FName StanceName;                                                                 // 0x0030 (size: 0x8)

}; // Size: 0x38

class USBTransition_EnemyCommonMainFromBattleState : public UASTransition_Base
{
    TArray<FName> CommandListOR;                                                      // 0x0030 (size: 0x10)

}; // Size: 0x40

class USBTransition_EnemyIsInAttackRange : public UASTransition_BlueprintBase
{
    FSBAIAttackableArea AttackableArea;                                               // 0x0050 (size: 0x24)

}; // Size: 0x78

class USBTransition_EnemyIsInCylinderArea : public UASTransition_BlueprintBase
{
    FVector Center;                                                                   // 0x0050 (size: 0xC)
    float Radius;                                                                     // 0x005C (size: 0x4)
    float HalfHeight;                                                                 // 0x0060 (size: 0x4)

}; // Size: 0x68

class USBTransition_EnemyMovement : public UASTransition_BlueprintBase
{
    bool Walking;                                                                     // 0x0050 (size: 0x1)
    bool Falling;                                                                     // 0x0051 (size: 0x1)
    bool Flying;                                                                      // 0x0052 (size: 0x1)
    bool Swimming;                                                                    // 0x0053 (size: 0x1)

}; // Size: 0x58

class USBTransition_EnemySamplingActionDerivation : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_EnemyTakeDamageCount : public UASTransition_BlueprintBase
{
    FName AttackIDName;                                                               // 0x0050 (size: 0x8)
    int32 Count;                                                                      // 0x0058 (size: 0x4)
    ESBEnemyTakeDamageCounterComparison Comparison;                                   // 0x005C (size: 0x1)

}; // Size: 0x60

class USBTransition_FacialType : public UASTransition_Base
{
    ESBFacialType FacialType;                                                         // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBTransition_FrameCommand : public UASTransition_Base
{
    TArray<FName> CommandList;                                                        // 0x0030 (size: 0x10)
    bool bOnce;                                                                       // 0x0040 (size: 0x1)

}; // Size: 0x48

class USBTransition_HasEnterableTransitionInSubStateMachine : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_HasPlayerForecastLocation : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_HasTSkillStepInput : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_ImagineArtsPress : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IncludeTag : public UASTransition_BlueprintBase
{
    TArray<FName> Tags;                                                               // 0x0050 (size: 0x10)

}; // Size: 0x60

class USBTransition_InputPlayerMainAttack : public UASTransition_Base
{
    bool IsTackticalSkillInput;                                                       // 0x0030 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0031 (size: 0x7)
    TSoftClassPtr<USBSkillInfoClass> SkillInfoClass;                                  // 0x0038 (size: 0x28)
    ESBClassType ClassType;                                                           // 0x0060 (size: 0x1)

}; // Size: 0x68

class USBTransition_IsAimOffset : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsAlive : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsBattle : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsChanceTimeDown : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsChargeSkill : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsConduitForAnimationSampling : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsDebugMoveMode : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsDodgeSucceeded : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsEffectiveStatusAliment : public UASTransition_BlueprintBase
{
    ESBBattleEffective BattleEffectiveType;                                           // 0x0050 (size: 0x1)

}; // Size: 0x58

class USBTransition_IsElementalBurst : public UASTransition_BlueprintBase
{
    uint16 Flags;                                                                     // 0x0050 (size: 0x2)

}; // Size: 0x58

class USBTransition_IsElementalBurstWithChanceTime : public UASTransition_BlueprintBase
{
    ESBTransition_IsElementalBurstWithChanceTimeAutoSettingType AutoSettingType;      // 0x0050 (size: 0x1)

}; // Size: 0x58

class USBTransition_IsEnemyBDFObjectDestroyed : public UASTransition_Base
{
    ESBBDFObjectType Type;                                                            // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    int32 NumDestroyed;                                                               // 0x0034 (size: 0x4)
    ESBBDFObjectDestroyedComparisonOperator Operator;                                 // 0x0038 (size: 0x1)

}; // Size: 0x40

class USBTransition_IsEnemyBDFPartsBroken : public UASTransition_BlueprintBase
{
    TArray<int32> RelatedAnchorIDArray;                                               // 0x0050 (size: 0x10)

}; // Size: 0x60

class USBTransition_IsEnemyLocomotion : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsEnemyProjectileDestroyed : public UASTransition_BlueprintBase
{
    FDataTableRowHandle Projectile;                                                   // 0x0050 (size: 0x10)

}; // Size: 0x60

class USBTransition_IsEnemyStrafing : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsEnemyTideArea : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsEnemyTurn2DEnd : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsEnemyUnableActionCondition : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsEscapeJumpBack : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsEscapeJumpForwardMoveInput : public UASTransition_Base
{
    bool bIsFront;                                                                    // 0x0030 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0031 (size: 0x3)
    float InputAngle;                                                                 // 0x0034 (size: 0x4)

}; // Size: 0x38

class USBTransition_IsHoldHandActive : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsHoldHandLeftSide : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsHoldHandReverse : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsHoldHandRightSide : public UASTransition_Base
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBTransition_IsLeadStateMachineActive : public UASTransition_Base
{
    ESkillActionPosition SkillPosition;                                               // 0x0030 (size: 0x1)
    EPlayerStateMachine StateMachineType;                                             // 0x0031 (size: 0x1)

}; // Size: 0x38

class USBTransition_IsNoDamageDead : public UASTransition_BlueprintBase
{
    char padding_0[0x50];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x50

class USBTransition_IsOtherStateMachineSetup : public UASTransition_Base
{
    EPlayerStateMachine StateMachineType;                                             // 0x0030 (size: 0x1)

}; // Size: 0x38

class USBTraverseCloudWidget : public UUserWidget
{
    TArray<FName> CountAcrossMapList;                                                 // 0x0288 (size: 0x10)
    class UDataTable* TraversePointDataTable;                                         // 0x0298 (size: 0x8)
    FAnchors CloudImageAnchors;                                                       // 0x02A0 (size: 0x10)

    void UpdateTraverse(FString InMapId, int32 InFloor, const FVector2D& InMapSizeScale);
    void SetTraversePositionList(const TArray<FSBTraverseDungeonInfo>& List);
    class UUserWidget* OnCreateDungeonTraverse(class UCanvasPanel* CloudCanvas, FName Name, const FVector2D& Position, const FVector2D& Size);
    class UUserWidget* OnCreateCloudTraverse(class UCanvasPanel* CloudCanvas, FName Name, const FVector2D& Position, const FVector2D& Size, class UTexture2D* Texture);
}; // Size: 0x2C0

class USBTutorialHelpDialogBoxCommonWidget : public UUserWidget
{
    class UCanvasPanel* CanvasPanel_0;                                                // 0x0278 (size: 0x8)

}; // Size: 0x280

class USBUIAssetManager : public UObject
{
    TSubclassOf<class USBDamageUI> DamageUI;                                          // 0x0028 (size: 0x8)
    TSubclassOf<class USBBalloonWindow> BalloonWindowWidget;                          // 0x0030 (size: 0x8)
    TSubclassOf<class UUserWidget> DialogClass;                                       // 0x0038 (size: 0x8)
    TSubclassOf<class UUserWidget> MultipleSelectDialog;                              // 0x0040 (size: 0x8)
    TSubclassOf<class USBChoiceDialog> SBChoiceDialog;                                // 0x0048 (size: 0x8)
    TSubclassOf<class USBStatusAlimentUI> StatusAlimentUI;                            // 0x0050 (size: 0x8)
    TSubclassOf<class USBCommandMenu> CommandMenu;                                    // 0x0058 (size: 0x8)
    TSubclassOf<class USBLoadingBase> LoadingScreenClass;                             // 0x0060 (size: 0x8)
    class UDataTable* WordDataDB;                                                     // 0x0068 (size: 0x8)
    class UDataTable* RichTextShortSyntaxDB;                                          // 0x0070 (size: 0x8)
    TSubclassOf<class UUserWidget> RmShopDialogClass;                                 // 0x0078 (size: 0x8)
    TSubclassOf<class UUserWidget> ScreenWithWindowsDialogClass;                      // 0x0080 (size: 0x8)
    TSoftClassPtr<USBTitleMenuCharaLayer> TitleMenuCharaLayer;                        // 0x0088 (size: 0x28)
    TSoftClassPtr<AActor> TitleEffectActor;                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class USBUIBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    ESBContentLockType ToContentLockType(const ESBCommandMenuType InCommandMenuType);
    FGuildChangeData ToChangeData(const FGuildData& Data);
    void SuppressNiagaraUIIfNeeded(class UObject* InWorldContextObject, const bool bInSuppress);
    void SortSkillDatas_Priority(TArray<FSBPlayerSkillData>& SkillDatas);
    void SortSkillDatas_Master(TArray<FSBPlayerSkillData>& SkillDatas);
    void SortSkillDatas(class UObject* InWorldContextObject, TArray<FSBPlayerSkillData>& SkillDatas);
    void SortPasiveSkillDatas_Priority(TArray<FSBPlayerPassiveSkillData>& SkillDatas);
    void SortPasiveSkillDatas_Master(TArray<FSBPlayerPassiveSkillData>& SkillDatas);
    void SortPasiveSkillDatas(class UObject* InWorldContextObject, TArray<FSBPlayerPassiveSkillData>& SkillDatas);
    void SortNameArray(TArray<FName>& NameList, bool IsAscendingOrder);
    void SortMyCharacterWeaponDataList(const EMyCharacterWeaponSortType SortType, TArray<FMyCharacterWeaponData>& SortList);
    void SortMapUIMenuList(TMap<FString, int32>& InOutMapSortData);
    void SortEmotionInfo(TArray<FSBEmotionInfo>& InfoList);
    void ShowSystemMessageByFlag(class UObject* InWorldContextObject, ESBSystemMessageFlag InFlag, const bool bIsLowerPosition);
    void ShowSimpleSystemMessageByNonePlayerCharacter(class UObject* InWorldContextObject, const FText& Message, const bool bIsLowerPosition);
    void ShowSimpleSystemMessage(class UObject* InWorldContextObject, const FText& Message, const bool bIsLowerPosition, const bool bDoNotSkip);
    void ShowSimpleAlertByType(const ESimpleAlertType Type, const class ASBPlayerCharacter* OwnerPlayerCharacter);
    class USBMultipleSelectDialog* ShowMultipleSelectDialog(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, const FText& Message, const TArray<FText>& Selections, FShowMultipleSelectDialogEndDelegate EndDelegate);
    void ShowMouseCursor(class UObject* InWorldContextObject);
    FSBCursorStateHandle ShowCursor(class UObject* InWorldContextObject);
    void SetZOrderInViewport(class UUserWidget* UserWidget, const TEnumAsByte<EUIZOrder::Type> Priority);
    bool setZOrder_CheckLog(class UWidget* pWidget, int32 ZOrder);
    void SetupSoftwareCursor(class UObject* InWorldContextObject, const FSoftClassPath CursorClass);
    void SetUIVisibleSettingQuickAccessHud(class UObject* InWorldContextObject, const bool bInVisibility);
    void SetUIVisibleSettingOnScreenshot(class UObject* InWorldContextObject, const bool bInVisibility);
    void SetUIVisibleSettingOnPhotoPlayerControlMode(class UObject* InWorldContextObject, const bool bInVisibility);
    void SetUIVisibleSettingOnMissionCharacterCard(class UObject* InWorldContextObject, const bool bInVisibility);
    void SetUIVisibleSettingMenuMode(class UObject* InWorldContextObject, const bool bInVisibility, bool bInInstantly);
    void SetUIVisibleSettingDemo(class UObject* InWorldContextObject, const bool bInVisibility);
    void SetUIVisibleSetting(class UObject* InWorldContextObject, const ESBUIType InUIType, const bool bInVisibility);
    void SetUICurrentGameSetting(class UObject* InWorldContextObject, const bool bInVisibility);
    void SetUICollapseByWarpAroundEffect(class UObject* InWorldContextObject, const bool bInCollapse);
    void SetUICollapseByULTSkill(class UObject* InWorldContextObject, const bool bInCollapse);
    void SetSoftwareCursorAvailable(class UObject* InWorldContextObject, const bool bInAvailable);
    void SetSelectWidgetToMousePoint(class UObject* InWorldContextObject, class UWidget* InWidget);
    void SetSecondPasswordStatus(class UObject* WorldContextObject, ESkyBlueSecondPasswordStatus Status);
    void SetScrollBarTransparency(class UScrollBox* ScrollBox, const float Value);
    void SetQuestListFilterEnable(FSBQuestListFilterSetting& InFilterSetting, const EQuestListFilterType InFilterType, const bool bInEnable);
    void SetMouseCursorPositionByWidget(const class UWidget* InWidget, const TEnumAsByte<EHorizontalAlignment> InHorizontalAlignment, const TEnumAsByte<EVerticalAlignment> InVerticalAlignment);
    void SetMouseCursorPosition(class UObject* InWorldContextObject, class UWidget* InWidget);
    void SetMenuMusicVolume();
    void SetMenuMode(class UObject* InWorldContextObject, const bool bInShowMouseCursor, const bool bInDisablePlayerControl, const bool bSetMusicVolume, bool bInInstantly);
    void SetInputMode_GameAndUI(class UObject* InWorldContextObject, class UWidget* InWidgetToFocus);
    void SetFontOutlineTransparency(class UTextBlock* InTextBlock, const float InValue);
    void SetFontOutlineColor(class UTextBlock* InTextBlock, const FLinearColor& Color);
    void SetEnablePadCursorMove(class UObject* InWorldContextObject, bool bValue);
    FSBCursorStateHandle SetCursorState(class UObject* InWorldContextObject);
    void SetCursorInput(class UObject* InWorldContextObject, bool bInbIsCursorInput);
    void SetBrushImageSize(class UImage* Image, const FVector2D ImageSize);
    void ResetQuestListFilterEnable(FSBQuestListFilterSetting& InFilterSetting, const bool bInEnable);
    void ResetMenuMusicVolume();
    void ResetMenuMode(class UObject* InWorldContextObject, const bool bInShowedMouseCursor, const bool bInDisablePlayerControl, const bool bSetMusicVolume);
    void ResetInputMode_GameAndUI(class UObject* InWorldContextObject);
    void ResetCursorState(class UObject* InWorldContextObject, FSBCursorStateHandle& InOutHandle);
    void Request_DeleteDownloadImage(const class UObject* InWorldContextObject, FString InURL);
    void RegistShopWeaponItemList(const FName InListName);
    void RegistShopItemListByItemType(const FName InListName, const EItemType InItemType);
    void RegistReadedIdByInt(class UObject* WorldContextObject, bool& bIsValid, TEnumAsByte<ENewMarkContentType::Type> InCategory, const int32& InId, bool bSkipSave);
    void RegistReadedID(bool& bIsValid, FString InPlayerId, FString InCharacterId, TEnumAsByte<ENewMarkContentType::Type> InCategory, FString InId, bool bSkipSave);
    void ReadedIDSave(FString InPlayerId, FString InCharacterId);
    bool ProjectWorldToScreen(class APlayerController* Player, const FVector& WorldPosition, FVector2D& OutScreenPosition, float& OutDepth, float& OutRHW, bool bPlayerViewportRelative);
    void PrioritizePositiveAkEvent();
    int32 PlaySE(class UObject* InWorldContextObject, class UAkAudioEvent* AkEvent, bool bStopWhenAttachedToDestroyed);
    void OpenLogFolder();
    void OpenFileDialog(EFileDialogResult& OutResult, TArray<FString>& FilePath, FString DialogTitle, FString DefaultPath, FString DefaultFile, FString FileType, bool IsMultiple);
    void OpenDirectoryDialog(EFileDialogResult& OutResult, FString& FilePath, FString DialogTitle, FString DefaultPath);
    FString MakeMoviePath(FString Filename, FString Prefix);
    int32 LoopSub(const int32 CurrentValue, const int32 MaxValue);
    int32 LoopAdd(const int32 CurrentValue, const int32 MaxValue);
    void LoadFileAndGetCharaCreateParameter(FString InFilePath, FSBCharaCreateParameter& OutCharaCreateParameter, bool& bIsSuccess);
    void LeaveShopAmbientMode(class UObject* InWorldContextObject);
    bool IsTraverse(const class UObject* WorldContextObject, FString TraversedPoint);
    bool IsTimeoutTargetRecepi(const class UObject* InWorldContextObject, const int32 RecepiId);
    bool IsTimeoutTargetImagineRecepi(const class UObject* InWorldContextObject, const int32 RecepiId);
    bool IsTimeoutItem(const class UObject* InWorldContextObject, const int32 ItemId, EItemType Type);
    bool isTargetMarkerShooterType(ESBClassType ClassType);
    bool IsTalkModeShortCycle(class UObject* InWorldContextObject);
    bool IsSyntheableAbility(const class UObject* InWorldContextObject, FString WeaponUID, int32 StorageNo, FString ImagineUID, int32 ImagineStorageNo);
    bool isStorageItemLockedSimple(const class UObject* WorldContextObject, FString InItemUniqueId);
    bool isStorageItemLocked(const class UObject* WorldContextObject, const int32 InItemIdx, const int32 InRequiredNum, bool& OutRequiredCnt);
    bool IsSkipLogo(class UObject* WorldContextObject);
    ESBRmShopErrorStatus IsShopCheckStatusRetCode(int32 InRetCode);
    bool IsScbPopupEnable();
    bool IsReadedIdByInt(class UObject* WorldContextObject, bool& bIsValid, TEnumAsByte<ENewMarkContentType::Type> InCategory, const int32& InId);
    bool IsReadedID(bool& IsValid, FString InPlayerId, FString InCharacterId, TEnumAsByte<ENewMarkContentType::Type> InCategory, FString InId);
    bool IsPlayerEmotePossession(class UObject* WorldContextObject, int32 EmoteId);
    bool IsPlayerClassChangeable(class UObject* InWorldContextObject);
    bool IsParentMapFld004(const FString MapId);
    bool IsParentMapFld003(const FString MapId);
    bool IsParentMapFld002(const FString MapId);
    bool IsParentMapFld001(const FString MapId);
    bool IsOpenMapUI(const class UObject* WorldContextObject);
    bool IsMapUIWarpPointListUse(const class UObject* WorldContextObject);
    bool IsMapUIMarkerPinListUse(const class UObject* WorldContextObject);
    bool IsMapUIMapSelectListUse(const class UObject* WorldContextObject);
    bool IsMapUIMapBlure(const class UObject* WorldContextObject);
    bool IsMapUILocationIconUse(const class UObject* WorldContextObject);
    bool IsInventoryStorageNumber(const int32 StorageNumber);
    bool isInventoryItemLockedSimple(const class UObject* WorldContextObject, FString InItemUniqueId);
    bool isInventoryItemLocked(const class UObject* WorldContextObject, const int32 InItemIdx, const int32 InRequiredNum, bool& OutRequiredCnt);
    bool isImagineCraftRecepiMaterialLocked(const class UObject* WorldContextObject, const int32 InRecepiId);
    bool IsHaveAdventureBoard(class UObject* InWorldContextObject, int32 InBoardId);
    bool IsFangExpeditionUsing(const class UObject* WorldContextObject, FString InItemUniqueId);
    bool IsExistingTraversal(const class UObject* WorldContextObject, const FString TraversedPoint, class UDataTable* TraversePointDataTable);
    bool IsEnableOpenRmShopMenu(class UObject* WorldContextObject);
    bool IsEnableMasterySkill(int32 SkillId);
    bool IsDebug();
    bool IsCursorOverScrollBox(class UObject* InWorldContextObject);
    bool IsCursorOverScrollableWidget(class UObject* InWorldContextObject);
    bool IsCursorOverInteractableWidget(class UObject* InWorldContextObject);
    bool isCraftRecepiMaterialLocked(const class UObject* WorldContextObject, const int32 InRecepiId);
    bool isCraftMaterialLocked(const class UObject* WorldContextObject, const int32 InItemIndex, const int32 InRequiredNum);
    bool IsCraftableRecepi(class UObject* InWorldContextObject, const FCharacterCraftRecepi& InRecepi, bool bIsImagineRecepi);
    TEnumAsByte<ESBCharacterEquipsOrSkillsOrCostumesChangeableRetValues> IsCharacterEquipsOrSkillsOrCostumesChangeable(class UObject* InWorldContextObject);
    bool IsBuffStatusAliment(const ESBBattleEffective StatusAliment);
    bool IsBppIrredeemable(const class UObject* WorldContextObject, FString InItemUniqueId, int32 StorageNumber);
    bool IsAnyReadedItemStorage(class UObject* InWorldContextObject, bool& IsValid, FString InPlayerId, FString InCharacterId, int32 StorageNumber);
    bool IsAnyReaded(bool& IsValid, FString InPlayerId, FString InCharacterId, TEnumAsByte<ENewMarkContentType::Type> InCategory);
    bool IsActiveStatusAliment(const class ASBCharacter* InCharacter, const ESBBattleEffective InStatusAliment);
    bool IsActiveAdventureBoard(class UObject* InWorldContextObject);
    void InsertNewLineEachCountRef(FString& InOutString, const int32 InCount);
    FString InsertNewLineEachCount(FString inString, const int32 InCount);
    void InitNotificationSaveData(class UObject* WorldContextObject);
    void HideMouseCursor(class UObject* InWorldContextObject);
    void HideCursor(class UObject* InWorldContextObject, FSBCursorStateHandle& InOutHandle);
    bool HasTimelimtRecepi(const class UObject* InWorldContextObject, int32 RecepiId);
    bool HasTimelimtImagineRecepi(const class UObject* InWorldContextObject, int32 RecepiId);
    bool HasTimelimit(int32 Index, EItemType Type);
    ESBWorldUIType GetWorldUIType(class UObject* WorldContextObject);
    int32 GetUIZOrder(const TEnumAsByte<EUIZOrder::Type> Type);
    class USBUIVisibleSettings* GetUIVisibleSettings(class UObject* InWorldContextObject);
    bool GetUIVisibleSetting(class UObject* InWorldContextObject, const ESBUIType InUIType);
    FVector2D GetUIPosition(class UWidget* InWidget);
    class ASBUIController* GetUIController(const class UObject* InWorldContextObject);
    class USBTickerMessageManager* GetTickerMessageManager(class UObject* InWorldContextObject);
    int32 GetTextNumFromAsset(const class USBTextTableAsset* InTextTableAsset);
    FString GetTextFromAssetByName(const class USBTextTableAsset* InTextTableAsset, const FName InTextId);
    FString GetTextFromAssetAt(const class USBTextTableAsset* InTextTableAsset, const int32 InIndex);
    FString GetTextFromAsset(const class USBTextTableAsset* InTextTableAsset, const int32 InTextId);
    FString GetText(const FName& InTextTableName, const FSBTextTableHash& InTextId);
    bool GetTermStartDateString(class UObject* WorldContextObject, FString& OutString, FString InTermId);
    bool GetTermStartDate(class UObject* WorldContextObject, FDateTime& OutTermDate, FString InTermId);
    bool GetTermEndDateString(class UObject* WorldContextObject, FString& OutString, FString InTermId);
    bool GetTermEndDate(class UObject* WorldContextObject, FDateTime& OutTermDate, FString InTermId);
    float getTargetMarkerNearRange(class ASBPlayerCharacter* Player);
    FString GetSystemSESoundName(const ESystemSE SEId);
    TSoftObjectPtr<UAkAudioEvent> GetSystemSEEvent(const ESystemSE SEId);
    int32 GetStatusAlimentShowPriority(const ESBBattleEffective StatusAliment);
    bool GetStampName(FString& OutString, const int32 InStampId);
    TArray<ESBClassType> GetSortedPlayerClassList();
    ESBSkillType GetSkillType(int32 SkillId);
    void GetSkillIdBySkillType(const ESBClassType InClassType, const TArray<ESBSkillType>& InSkilTypes, TArray<int32>& OutSkillIds);
    TArray<FSBClassChangeBattleCode> GetSelectableBattleCodes(class UObject* InWorldContextObject, const ESBClassType ClassType);
    ESkyBlueSecondPasswordStatus GetSecondPasswordStatus(class UObject* WorldContextObject);
    int32 GetSeasonRankPointMax();
    class USBTelopManager* GetSBTelopManager(const class UObject* InWorldContextObject, bool& IsValid);
    int32 GetRoseOrbMax();
    void GetRevisionText(FString& VersionText);
    FVector2D GetReticleViewportLocation(const class UObject* WorldContextObject);
    FVector2D GetReticleLocation(const class UObject* WorldContextObject);
    bool GetRemainTimeLimitGuideText(const class USBTextTableAsset* InTextTableAsset, const int32 InDaysLeft, const FString InTimesLeft, FText& OutRemainGuideText);
    TArray<int32> GetQuestUnlockAdventurerRank(class UObject* InWorldContextObject, int32 InAdventurerRank, EQuestCategory2 InCategory);
    int32 GetPlayerNumTraversePointInMap(const class UObject* WorldContextObject, FName MapName);
    class USBPlayerGaugeBaseWidget* GetPlayerGaugeBaseWidget(const class UObject* WorldContextObject);
    bool GetPlatformIconTextureAssetByType(const class UObject* WorldContextObject, const ESBPlatformType PlatformType, const bool bIsOnline, class UTexture2D*& LoadedTexture);
    bool GetPlatformIconTextureAssetByIndex(const class UObject* WorldContextObject, const int32 platformId, const bool bIsOnline, class UTexture2D*& LoadedTexture);
    FString GetPartySystemText(const ESBPartySystemTextType InType);
    bool GetOwnPlatformInfo(const class UObject* WorldContextObject, FSBPlatformInfo& OutPlatformInfo);
    int32 GetNotificationMenuDataExNum(class UObject* WorldContextObject);
    void GetNotificationMenuDataEx(class UObject* WorldContextObject, TArray<FSBNotificationMenuData>& DataList);
    class USBStepList* GetNewStepListWidget(const class UObject* WorldContextObject);
    class USBNetworkCafeMessageManager* GetNetworkCafeMessageManager(class UObject* InWorldContextObject);
    int32 GetMoneyMax();
    TArray<FName> GetMissionIdsUnlockAdventurerRank(class UObject* InWorldContextObject, int32 InAdventurerRank);
    int32 GetMaxNumTraversePointInMap(const class UObject* WorldContextObject, FName MapName);
    TEnumAsByte<ESBMapUIType> GetMapUIType(const class UObject* WorldContextObject);
    void GetMapInfoByMapName(FString MapName, FSBMapInfo& MapInfo, bool& IsExists);
    void GetMapInfo(const FName& MapId, FSBMapInfo& MapInfo, bool& IsExists);
    bool GetMapContentIdtoMapName(const FString MapContentId, FString& MapName);
    int32 GetMainQuestUnlockAdventurerRank(class UObject* InWorldContextObject, int32 InAdventurerRank);
    bool GetLocalPlayerLoginCharacterId(class ASBCharacter* PlayerCharacter, FString& OutCharacterId);
    float GetListScrollSpeed();
    bool GetLineRectIntersect(const FVector4& InRect, const FVector2D& InLineStart, const FVector2D& InLineEnd, FVector2D& OutIntersect);
    bool GetIsAbilityDBIconTypeAttributeResistUp(const ESBStatusAilmentIconType& InIconType);
    bool GetIsAbilityDBIconTypeAttributeResistDown(const ESBStatusAilmentIconType& InIconType);
    bool GetIsAbilityDBIconTypeAttributeResist(const ESBStatusAilmentIconType& InIconType);
    bool GetIsAbilityDBIconTypeAttributeAttackPowerUp(const ESBStatusAilmentIconType& InIconType);
    bool GetIsAbilityDBIconTypeAttributeAttackPowerDown(const ESBStatusAilmentIconType& InIconType);
    bool GetIsAbilityDBIconTypeAttributeAttackPower(const ESBStatusAilmentIconType& InIconType);
    bool GetIntersectionCircleLine(const FVector2D Center, const float Radius, const FVector2D Start, const FVector2D End, FVector2D& Ret1, FVector2D& Ret2);
    FSlateColor GetImpossibleColor();
    TArray<int32> GetImagineRecepiIdsUnlockAdventurerRank(class UObject* InWorldContextObject, int32 InAdventurerRank);
    int32 GetGuildOrganizedAfterDate(const FGuildData& InGuildData);
    int32 GetGuildMemberRoleTextId(TEnumAsByte<EGuildMemberRole::Type> Role);
    bool GetGameConfigValueString(const FString InSection, const FString InKey, FString& OutValue);
    void GetFangExpeditionUsingId(const class UObject* WorldContextObject, TArray<FString>& OutUniqueIds);
    int32 GetExpMax();
    int32 GetExchangeShopAdventurerRankCount(class UObject* InWorldContextObject, int32 InAdventurerRank, ESBMerchandiseCounterType Type);
    bool GetEnvText(FString& EnvText);
    FString GetEmoteName(const FName& EmoteId);
    FAutoStampWordData GetDefaultAutoStampDataEx(const EAutoWordEventType InEventType);
    void GetCursorNavigationCheckHistory(class UObject* InWorldContextObject, bool& bOutResut, FVector2D& OutCursorPos, FVector2D& OutDirection);
    FString GetCurrentMapParentId(class UObject* WorldContextObject);
    TEnumAsByte<EMouseCursor::Type> GetCurrentCursorType();
    bool GetCraftRecepiUnlockPerkSlotMinMax(const FCraftMasterData& InMasterData, int32& RetMin, int32& RetMax);
    TArray<int32> GetCraftRecepiIdsUnlockAdventurerRank(class UObject* InWorldContextObject, int32 InAdventurerRank);
    void GetClimbingPointActorList(class UObject* WorldContextObject, TArray<class AActor*>& OutList);
    FString GetClassNameText(ESBClassType InClassType);
    bool GetCharaEquipTypeFromProtectorCategory(const EProtectorCategory InProtectorCategory, ESBCharaEquipType& OutCharaEquipType);
    int32 GetCharacterStorageNumber();
    int32 GetBPPointSafeMax();
    int32 GetBPPointMax();
    int32 GetBPMax();
    int32 GetBlockListMax();
    void GetAutoDeliveryQuestDesc(FString& OutMessage, const FSBTextTableHash& TextId, const ESBSeasonPassQuestCycleType Cycle);
    FText GetAdventurerRankText(class UObject* InWorldContextObject, int32 InAdventurerRank);
    int32 GetAdventurerRank(class UObject* InWorldContextObject);
    void GetActivityTargets(const FGuildActivity& Activity, bool& Valid, FString& TargetUserID1, FString& TargetCharacterID1, FString& TargetName1, bool& valid2, FString& TargetUserID2, FString& TargetCharacterID2, FString& TargetName2);
    int32 GetActivityRole(const FGuildActivity& Activity);
    int32 GetActivityRank(const FGuildActivity& Activity);
    FString GetActivityNewGuildName(const FGuildActivity& Activity);
    void GetAbilityPartsName(bool& IsValid, const int32 InAbilityEffectId, FName& AbilityParts1Name, FName& AbilityParts2Name);
    ESBStatusAilmentIconType GetAbilityDBIconTypeByRowName(const FName& InRowName);
    void GetAbilityConfigByAbilityDBRowName(const FName& InRowName, bool& IsValid, FSBAbilityConfig& OutAbilityConfig);
    int32 GetAbilitryNameToUIElementResistanceIndex(const FName& InObjectName, bool& OutIsParamUp);
    FLinearColor FromHexToLinearColor(const FString InHexString);
    FString FormatStringToSpecifiedLineCountAndWordCount(FString inString, const int32 InWordCountPerLine, const int32 InLineCount);
    FString FormatNumberToCommaFormat(const int32 InNumber);
    FString FormatNumber(const int32 InNumber, const FString InFormatString);
    bool ForceReadMarkMission(class UObject* WorldContextObject);
    bool ForceReadMarkEquipment(class UObject* WorldContextObject);
    void FlushPressedKeys(class UObject* InWorldContextObject);
    void FindSyntheAbilityPickupMasterDataFromP2P(int32 ID, FSBSyntheAbilityData& MinAccuracy, FSBSyntheAbilityData& MaxAccuracy);
    FSBSyntheAbilityData FindSyntheAbilityPickupMasterDataFromAccuracy(int32 ID, int32 Accuracy);
    bool EqualEqual_GuildData_GuildChangeData(const FGuildData& lfs, const FGuildChangeData& rhs);
    bool EqualEqual_GuildChangeData_GuildData(const FGuildChangeData& lfs, const FGuildData& rhs);
    bool EqualEqual_GuildChangeData(const FGuildChangeData& lfs, const FGuildChangeData& rhs);
    void EnterShopAmbientMode(class UObject* InWorldContextObject);
    void DummyCursorUnderWidgetMouseEnter(class UObject* InWorldContextObject);
    class USBDownloadImageImpl* DownloadImage(class UObject* WorldContextObject, FLatentActionInfo LatentInfo, FString URL);
    void DeleteReadedID(bool& bIsValid, FString InPlayerId, FString InCharacterId, TEnumAsByte<ENewMarkContentType::Type> InCategory, FString InId);
    void DeleteAllReadedID(bool& bIsValid, FString InPlayerId, FString InCharacterId, TEnumAsByte<ENewMarkContentType::Type> InCategory);
    class USpacer* CreateSpacer();
    class USizeBox* CreateSizeBox();
    FName ConvertParentMapIdName(FName MapId);
    FString ConvertParentMapId(FString MapId);
    void ConvertDateFormat(FString inString, FString& OutString);
    FString ConvertAlphanumericZenToHan(FString inString);
    FString ConvertAbilityEffectValueText(const FName& RowName, const int32 Value);
    bool ContainsTimeoutRecepiMaterial(const class UObject* InWorldContextObject, const int32 RecepId);
    bool ContainsTimeoutImagineRecepiMaterial(const class UObject* InWorldContextObject, const int32 RecepId);
    int32 ComvertAbilitryElementToUIElementResistance(const ESBAttribute InAttributeType);
    void CheckTermStamp(class UObject* WorldContextObject);
    bool CheckQuestListFilter(const FSBQuestListFilterSetting& InFilterSetting, const int32 InQuestIndex);
    void CheckNotificationMenuDataAll(class UObject* WorldContextObject, const TArray<FSBNotificationMenuData>& DataAll);
    void CheckNotificationMenuData(class UObject* WorldContextObject, const FSBNotificationMenuData& Data);
    void CheckNotificationHistory(class UObject* WorldContextObject);
    bool CheckItemLevelSyncWeaponStorageItem(const class UObject* WorldContextObject, FString InItemUniqueId);
    bool CheckItemLevelSyncWeaponItemId(const class UObject* WorldContextObject, const int32 InWeaponItemId);
    bool CheckItemLevelSyncWeapon(const class UObject* WorldContextObject, FString InItemUniqueId);
    bool CheckItemLevelSyncImagineStorageItem(const class UObject* WorldContextObject, FString InItemUniqueId, const bool InUseClassTypeForLevelSync, const ESBClassType InClassTypeForLevelSync);
    bool CheckItemLevelSyncImagine(const class UObject* WorldContextObject, FString InItemUniqueId, const bool InUseClassTypeForLevelSync, const ESBClassType InClassTypeForLevelSync);
    bool CheckItemLevelStorageItem(const class UObject* WorldContextObject, FString InItemUniqueId);
    bool CheckItemLevel(const class UObject* WorldContextObject, FString InItemUniqueId);
    bool CheckIfTacticalSkillOrAbilityIsActive(class UObject* InWorldContextObject, const int32 InSkillId);
    bool CheckIfEquipmentIsExpired(const class UObject* WorldContextObject, const FSBExpiredEquipmentData& InExpiredEquipmentData, FString InEquipmentUniqueId);
    ESBItemUseStatus CanUseItem_ItemID(class UObject* WorldContextObject, int32 ItemId, bool& TypeA);
    ESBItemUseStatus CanUseItem(class UObject* WorldContextObject, FString InItemUniqueId, bool& TypeA, bool bStorageCheck);
    ESBCommandMenuType BookmarkTypeToCommandMenuType(FString InBookmark);
    void ApplyStatusAliment(class ASBCharacter* TargetCharacter, FDataTableRowHandle StatusAliment);
    bool AnyQuestListFilterEnable(const FSBQuestListFilterSetting& InFilterSetting);
    void AddToViewport(class UUserWidget* UserWidget, const TEnumAsByte<EUIZOrder::Type> Priority);
}; // Size: 0x28

class USBUICheatCommand : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)

    void TelopStatusCheck();
    void TelopPlayValue(ESBTelopPlayType Type, int32 Value, int32 ValueMax);
    void TelopPlayStr(ESBTelopPlayType Type, FText Title, FText Subtitle);
    void TelopPlayIcon(ESBTelopPlayType Type, ESBRewardItemType RewardItemType, int32 ID, int32 Amount);
    void TelopPlayBG(ESBTelopPlayType Type, int32 Index);
    void TelopPlay(ESBTelopPlayType Type);
    void TelopPause(bool IsPause);
    void SetWholeMapPhaseCount(int32 Value);
    void SetMiniMapPhaseCount(int32 Value);
    void SetGashaRankUpDemoProbability(const FName& InRowName, const float InProbability);
    void SetGashaItemRarity(const ESBRarity InRarity);
    void SetGashaExpectDemoOverride(const ESBGashaExpectDemoType InDemoType, const ESBGashaDemoRank InDemoRank);
    void ResetGashaRankUpDemoProbability();
    void ResetGashaItemRarity();
    void ResetGashaExpectDemoOverride();
    void RemoveUIDebugTag(FString InTag);
    void ReadedDataAllDump();
    void QuestListDebug();
    void PushSystemLog(const FName& InId, const ESBChatLogOption InOption);
    void PushBattleLog(const int32 InId, const ESBChatLogOption InOption);
    void PlayGashaSpecialCut(const ESBRarity InDemoRarity, const ESBRarity InActualRarity);
    void PlayGashaDemo(const int32 InNum, const bool bInSkip);
    void OpenCmdMenu();
    void LibraryEnemyListFullOpen(const bool bOpen);
    bool IsQuestListDebug();
    void HasUIDebugTag(FString InTag);
    void GetDeliveredTickerMessage();
    void ForceReloadSaveData();
    void DumpUIVisibleState(const bool bVerbose);
    void DumpTickerMessage();
    void DumpTelopList();
    void DumpLibraryData();
    void DebugSetMenuMode(const bool bMode);
    void AddUIDebugTag(FString InTag);
    void AddTickerMessage(const int32 InId, FString InMessage, FString InStartDateTime, FString InEndDateTime);
}; // Size: 0x38

class USBUIGuildActivityUMGBase : public UUserWidget
{
    FSBUIGuildActivityUMGBaseOnRequestCharacterCard OnRequestCharacterCard;           // 0x0278 (size: 0x10)
    void CallCharacterCard(FString UserId, FString CharacterId, FString Name);
    FGuildActivity Activity;                                                          // 0x0288 (size: 0xA0)

    void SetActivity_Internal(const FGuildActivity& Other);
    void SetActivity(const FGuildActivity& Other);
    void Request_CharacterCard(FString UserId, FString CharacterId, FString Name);
    void CallCharacterCard__DelegateSignature(FString UserId, FString CharacterId, FString Name);
}; // Size: 0x328

class USBUIManager : public UObject
{
    float EmotionCoolTime;                                                            // 0x0118 (size: 0x4)
    float StampCoolTime;                                                              // 0x011C (size: 0x4)
    float CloseAreaDistSquared;                                                       // 0x0120 (size: 0x4)
    char padding_0[0x4];                                                              // 0x0124 (size: 0x4)
    TMap<class ESBChatLogType, class FMssageRestrictionParam> MssageRestrictionParams; // 0x0128 (size: 0x50)
    TMap<class FString, class FSBUIAkEventSetting> AkEventSettingMap;                 // 0x0178 (size: 0x50)
    TArray<FSBUIAkEventRequest> AkEventRequestList;                                   // 0x01C8 (size: 0x10)
    char padding_1[0x10];                                                             // 0x01D8 (size: 0x10)
    TMap<int32, UUserWidget*> CachedToolTip;                                          // 0x01E8 (size: 0x50)
    float ServerReconnectionWaitTime;                                                 // 0x0238 (size: 0x4)
    char padding_2[0x4];                                                              // 0x023C (size: 0x4)
    TArray<FString> DebugTags;                                                        // 0x0240 (size: 0x10)

    void ShowMouseCursor(class UObject* InWorldContextObject);
    void SetTargetCommandName(FString TargetName);
    void SetStepListViewIndex(int32 Index);
    void SetSelectItemIndex(int32 Index);
    void SetLastCommandMenuType(const ESBCommandMenuType InType);
    void SetCurrMouseCursorType(const ESBMouseCursorType InType);
    void SetCurrMouseCursorMapPinId(const uint8 InMapPinId);
    void SetCommandMenuTutorialHelpID(const FName& InId);
    void SetChatSenderData(const FSBChatSenderData& InChatSenderData);
    void RunGarbageCollectionIfNeeded();
    void RemoveDirectChatSenderLog(class UObject* InWorldContextObject, FString CharacterId);
    void RegisterSubWidget(class UUserWidget* MainWidget, class UUserWidget* SubWidget);
    bool IsValidChatUnreadNotify();
    bool IsHudVisible();
    void HideMouseCursor(class UObject* InWorldContextObject);
    bool HasDebugTag(FString InTag);
    int32 GetStepListViewIndex();
    float GetServerReconnectionWaitTime();
    int32 GetSelectItemIndex();
    int32 GetRandomLoadingImageIndex(const int32 InMaxPatternNum);
    int32 GetRandomDungeonLoadingImageIndex(const int32 InMaxPatternNum);
    ESBCommandMenuType GetLastCommandMenuType();
    TArray<FSBDirectChatSenderLogData> GetDirectChatSenderLog();
    ESBMouseCursorType GetCurrMouseCursorType();
    uint8 GetCurrMouseCursorMapPinId();
    FName GetCommandMenuTutorialHelpID();
    FSBChatSenderData GetChatSenderData();
    class UUserWidget* GetCachedToolTip(int32 ToolTipID);
    void DestructSubWidget(class UUserWidget* MainWidget);
    void ClearCommandMenuTutorialHelpID();
    void ClearCache(class UObject* InWorldContextObject);
    void CacheToolTip(int32 ToolTipID, class UUserWidget* SubWidget);
    void AddDirectChatSenderLog(class UObject* InWorldContextObject, const FSBDirectChatSenderLogData& DirectChatSenderLogData);
}; // Size: 0x268

class USBUIMapBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void SetMapOptionMode(const class UObject* WorldContextObject, bool IsEditMode);
    void SetMapInitial(const class UObject* WorldContextObject, const FSBPlayerMiniMapInfo& Info);
    void SetMapBG(const class UObject* WorldContextObject, const FName BGConfigName);
    bool MapIconVisibleSettingCheck(class UObject* WorldContextObject, const FSBMapIconVisibleSettingTableRow& SettingData);
    bool IsQuestDisableShowIcon(const class UObject* WorldContextObject, int32 QuestIndex);
    bool IsCurrentLevelArea(const class UObject* WorldContextObject, FName GameContentId);
    bool IsActivatedDungeon(const class UObject* WorldContextObject, ESBLocationInfoType Type, FName DungeonId);
    class USBWholeMap* GetWholemapWidget(const class UObject* WorldContextObject);
    bool GetShortPinLocation(const class UObject* WorldContextObject, const FSBShortPinInfo& PinInfo, FVector& WorldLocation);
    void GetQuestStepListData(class UObject* WorldContextObject, TArray<int32>& IndexList);
    bool GetQuestLocation(const class UObject* WorldContextObject, int32 QuestIndex, FVector& WorldLocation);
    void GetPartyMember(const class UObject* WorldContextObject, TArray<class USBPartyMemberState*>& OutPartyMembers, TArray<class ASBPlayerState*>& OutGroupMembers);
    class USBMiniMapWidget* GetMinimapWidget(const class UObject* WorldContextObject);
    int32 GetMiniMapQuestIconZOrder(EQuestCategory2 InCategory, EQuestIconType InQuestType);
    int32 GetMiniMapNpcIconZOrder(ESBFacilityType InType);
    int32 GetMiniMapIconZOrder(TEnumAsByte<ESBMiniMapIconType> IconType);
    int32 GetMapNpcIconZOrder(ESBFacilityType InNpcType);
    int32 GetMapIconZOrderOfPinForComment();
    int32 GetMapIconZOrder(EMapSymbolIconType InIconType);
}; // Size: 0x28

class USBUIVisibleSettings : public UObject
{
    FSBUIVisibleSettingsUIVisibleSettingChangeDelegate UIVisibleSettingChangeDelegate; // 0x0170 (size: 0x10)
    void UIVisibleSettingChangeDelegate(ESBUIType InUIType, bool bInVisibility, bool bInInstantly);

    void SetVisibleSetting(const ESBUIType InUIType, const bool bInVisibility, bool bInInstantly);
    void SetCollapseFlag(const ESBUIType InUIType, const TEnumAsByte<ESBUIVisibleSettingOwner> InOwner);
    void ResetCollapseFlag(const ESBUIType InUIType, const TEnumAsByte<ESBUIVisibleSettingOwner> InOwner);
    bool GetVisibleSetting(const ESBUIType InUIType);
}; // Size: 0x180

class USBUIWeaponCustomBase : public USBUserWidget
{
    FSBUIWeaponCustomBaseOnCloseDelegate OnCloseDelegate;                             // 0x02B0 (size: 0x10)
    void OnClose(bool isUsed);
    char padding_0[0x200];                                                            // 0x02C0 (size: 0x200)
    FSBUIWeaponCustomBaseOnCompleteDataLoad OnCompleteDataLoad;                       // 0x04C0 (size: 0x10)
    void OnCompleteDataLoad(bool Loaded);

    void SetUsed(bool IsFlag);
    void SetUpdateEquipWeapon(bool IsFlag);
    void SetSelectedTokenId(int32 TokenID);
    void SetEnableESCKey(bool IsFlag);
    void SelectWeapon(const FOwnItemInfo& SelectWeapon);
    void SelectToken();
    void SelectPerk(int32 SlotNo);
    void Reset();
    void Request_MasterDatas(class ASBPlayerController* InPlayerController);
    void PlayAnimOut();
    void PlayAnimIn();
    void PlayAnimDetailIn();
    void OnUnbind();
    void OnTerm();
    void OnSelectWeapon();
    void OnSelectPerk();
    void OnRequest();
    void OnInit();
    void OnCompleteDataLoad__DelegateSignature(bool Loaded);
    void OnComplete(int32 ErrorCode);
    void OnClose__DelegateSignature(bool isUsed);
    void OnBind();
    bool isUsed();
    bool isUpdateEquipWeapon();
    bool IsEnableESCKey();
    bool IsAllMasterDataLoaded();
    FOwnItemInfo GetSelectedWeapon();
    int32 GetSelectedTokenId();
    int32 GetSelectedPerkSlotNo();
    FSBCharacterWeaponPerkData GetSelectedPerk();
    FOwnItemInfo GetAfterWeapon();
    void GenerateTokens();
    void End();
    void Complete(int32 ErrorCode, const FOwnItemInfo& InWeapon);
    void ClickedDecide();
    void ClickedBack();
    int32 CalculateFusionPrice(const FOwnItemInfo& Info, const int32 FusionItemId, const class USBPlayerWeaponEnhancementComponent* Component);
}; // Size: 0x4D0

class USBUMGSoundTracNode : public UWidget
{
    FName SeName;                                                                     // 0x0120 (size: 0x8)
    bool PlayRequest;                                                                 // 0x0128 (size: 0x1)

    void SetPlayRequest(bool InValue);
}; // Size: 0x140

class USBUVScrollFacialComponent : public UActorComponent
{
    int32 ElementIndex;                                                               // 0x00B8 (size: 0x4)
    FVector2D UV;                                                                     // 0x00BC (size: 0x8)
    int32 FaceId;                                                                     // 0x00C4 (size: 0x4)

    void ChangeFace(int32 FaceId, int32 ElementIndex, FVector2D UV);
}; // Size: 0xC8

class USBUkemiSkillInfo : public USBSkillInfoClass
{
    TArray<FSBCurveMoveSetting> CurveMoveSettingList;                                 // 0x02A8 (size: 0x10)

}; // Size: 0x2B8

class USBUncheater : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBUncheaterCheatCommand : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UncheaterServerInit();
    void UncheaterServerExit();
    void UncheaterExit();
    void UncheaterEnter();
    void SetUncheaterServerPrintServerLogEnable(const bool bInEnable);
    void SetUncheaterServerErrorPolicy(const int32 InPolicy);
    void OnUncheaterEnterCompleted(const bool bSucceeded);
    void HackDetected(FString InCode);
}; // Size: 0x28

class USBUncheaterComponent : public USBPlayerPropertyComponent
{
    char padding_0[0x108];                                                            // 0x0000 (size: 0x0)

    void Server_ReceiveVerifyCookie(const TArray<int8>& InCookie);
    void Server_OnCheckUser();
    void Client_RequestVerifyCookie(const TArray<uint8>& InCookie, const uint64 InRequestTime);
    void Client_PrintServerMessage(FString InMessage);
    void Client_OnGetCookieComplete(bool bInResult, const TArray<int8>& InCookie, class USBUncheaterComponent* InRequester, const FDateTime InRequestTime);
}; // Size: 0x108

class USBUncheaterServer : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBUpdateQuestProgressEventParam : public UObject
{
    bool bResult;                                                                     // 0x0028 (size: 0x1)
    char padding_0[0x7];                                                              // 0x0029 (size: 0x7)
    FAcceptedQuestInfo PrevAcceptedQuestInfo;                                         // 0x0030 (size: 0x60)

}; // Size: 0x90

class USBUserImageBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    FString GetFullBodyImageURL(const FString InCharacterId);
    FString GetFaceImageURL(const FString InCharacterId);
    FString GetBustUpImageURL(const FString InCharacterId);
}; // Size: 0x28

class USBUserImageComponent : public USBPlayerPropertyComponent
{
    FSBUserImageComponentOnUploadUserImageCompleteDelegate OnUploadUserImageCompleteDelegate; // 0x00B8 (size: 0x10)
    void OnUploadUserImageCompleteDelegate(const bool bResult, const int32 RetCode);

    bool UploadFullBodyImage_Request(FString InCharacterId, class UTextureRenderTarget2D* InRenderTarget2D, bool IsPublicAPI);
    bool UploadFaceImage_Request(FString InCharacterId, class UTextureRenderTarget2D* InRenderTarget2D, bool IsPublicAPI);
    bool UploadBustUpImage_Request(FString InCharacterId, class UTextureRenderTarget2D* InRenderTarget2D, bool IsPublicAPI);
}; // Size: 0xC8

class USBUserWidget : public UUserWidget
{
    bool bHandleOptionKeys;                                                           // 0x02A8 (size: 0x1)
    bool bAutoFocusChange;                                                            // 0x02A9 (size: 0x1)

    void SetFocusWidget(class UWidget* InWidget);
    void SetFocusAt(const int32 InIndex);
    void SetBlockInputByName(const FName& InName);
    void SetBlockInputByAction(const ESBUIKeyConfigAction InAction);
    void SetBlockInput();
    void ResetFocusIfFocused(class UWidget* InWidget);
    void ResetFocus();
    void ResetBlockInputByName(const FName& InName);
    void ResetBlockInputByAction(const ESBUIKeyConfigAction InAction);
    void ResetBlockInput();
    void ReRegisterInputComponent();
    void RemoveFocusableWidget(class UWidget* InWidget);
    void ProcVisibleSettingChange(ESBUIType InUIType, const bool bInVisibility, bool bInInstantly);
    void OnVisibleSettingChange(ESBUIType InUIType, bool bInVisibility, bool bInInstantly);
    void OnRepeat_Up();
    void OnRepeat_Right();
    void OnRepeat_Left();
    void OnRepeat_Down();
    void OnPress_QuickAccess(TEnumAsByte<ESBKeyConfigAction::Type> QuickAccess);
    void OnPress_Ok();
    void OnPress_MainMenu();
    void OnPress_Cancel();
    void OnInput_GamepadRightStickY(float Val);
    void OnInput_GamepadRightStickX(float Val);
    void OnInput_GamepadLeftStickY(float Val);
    void OnInput_GamepadLeftStickX(float Val);
    void OnDestructMainWidget();
    void Native_OnRepeat_Up();
    void Native_OnRepeat_Right();
    void Native_OnRepeat_Left();
    void Native_OnRepeat_Down();
    void Native_OnPress_QuickAccess(TEnumAsByte<ESBKeyConfigAction::Type> QuickAccess);
    void Native_OnPress_Ok();
    void Native_OnPress_MainMenu();
    void Native_OnPress_Interaction(bool bPressed);
    void Native_OnPress_Cancel();
    void Native_OnInput_GamepadRightStickY(float Val);
    void Native_OnInput_GamepadRightStickX(float Val);
    void Native_OnInput_GamepadLeftStickY(float Val);
    void Native_OnInput_GamepadLeftStickX(float Val);
    void Native_DummyAxisEvent(float Val);
    void Native_DummyActionEvent();
    void HandleKeyReleased(FKey InKey);
    void HandleKeyPress(FKey InKey);
    class ASBPlayerState* GetOwningPlayerState();
    int32 GetFocusWidgetIndex();
    class UWidget* GetFocusWidget();
    void FocusChangeByKey(const FKey InKey);
    void BP_SetVisibility(ESlateVisibility InVisibility);
    bool AddInputHandleWidget(class UWidget* InWidget);
    bool AddFocusableWidget(class UWidget* InWidget);
}; // Size: 0x2B0

class USBUtilityAction : public UObject
{
    char padding_0[0x38];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x38

class USBUtilityAction_AITask : public USBUtilityAction
{
    TSubclassOf<class UAITask> TaskClass;                                             // 0x0040 (size: 0x8)
    class AAIController* AIOwner;                                                     // 0x0048 (size: 0x8)

}; // Size: 0x50

class USBUtilityAction_BehaviorTree : public USBUtilityAction
{
    FAIFwParameterizedBTRequest BehaviorTree;                                         // 0x0038 (size: 0x18)
    bool bLooping;                                                                    // 0x0050 (size: 0x1)

}; // Size: 0x60

class USBUtilityAction_Group : public USBUtilityAction
{
    FSBUtilitySystem UtilitySystem;                                                   // 0x0038 (size: 0x40)

}; // Size: 0x78

class USBUtilityAction_HTN : public USBUtilityAction
{
    FString TaskName;                                                                 // 0x0038 (size: 0x10)
    bool bLooping;                                                                    // 0x0048 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0049 (size: 0x3)
    float ReplanningInterval;                                                         // 0x004C (size: 0x4)
    class UAIFwHTNPlanningComponent* HTNComponent;                                    // 0x0050 (size: 0x8)

}; // Size: 0x58

class USBUtilityBrainComponent : public UBrainComponent
{
    FSBUtilitySystem UtilitySystem;                                                   // 0x0110 (size: 0x40)

    void ResumeDelegate__DelegateSignature();
    void AddScriptedOption(class USBUtilityOption* Option);
    void AddOption(class USBUtilityOption* Option);
    void AddChildOption(FName ParentOptionName, class USBUtilityOption* Option);
}; // Size: 0x1C8

class USBUtilityDataProvider : public UObject
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x28

class USBUtilityDataProvider_Attention : public USBUtilityDataProvider
{
    float AttentionRange;                                                             // 0x0028 (size: 0x4)
    float AttentionAngle;                                                             // 0x002C (size: 0x4)
    bool bUseTrace;                                                                   // 0x0030 (size: 0x1)
    bool bRestrictTerritory;                                                          // 0x0031 (size: 0x1)
    char padding_0[0x2];                                                              // 0x0032 (size: 0x2)
    float AttackTime;                                                                 // 0x0034 (size: 0x4)
    float ReleaseTime;                                                                // 0x0038 (size: 0x4)
    float AttentionTime;                                                              // 0x003C (size: 0x4)
    FString BlackboardKey;                                                            // 0x0040 (size: 0x10)
    class USBUtilityBrainComponent* OwnerComponent;                                   // 0x0050 (size: 0x8)
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0058 (size: 0x8)

}; // Size: 0x70

class USBUtilityDataProvider_Blackboard : public USBUtilityDataProvider
{
    FString Key;                                                                      // 0x0028 (size: 0x10)
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0038 (size: 0x8)

}; // Size: 0x50

class USBUtilityDataProvider_BlueprintBase : public USBUtilityDataProvider
{
    bool bNeedsUpdate;                                                                // 0x0028 (size: 0x1)

    void ReceiveInitialize(class USBUtilityBrainComponent* OwnerComponent);
    float ReceiveFetchValue();
}; // Size: 0x30

class USBUtilityDataProvider_Constant : public USBUtilityDataProvider
{
    float Value;                                                                      // 0x0028 (size: 0x4)

}; // Size: 0x30

class USBUtilityDataProvider_HasRoleMember : public USBUtilityDataProvider
{
    TSubclassOf<class USBAIRoleBase> RoleClass;                                       // 0x0028 (size: 0x8)
    class USBAIRoleDistributionComponent* RoleDistributionComponent;                  // 0x0030 (size: 0x8)

}; // Size: 0x38

class USBUtilityDataProvider_IsSiege : public USBUtilityDataProvider
{
    class ASBCombatCoordinator* CombatCoordinator;                                    // 0x0028 (size: 0x8)

}; // Size: 0x30

class USBUtilityOption : public UDataAsset
{
    TArray<FSBUtilityCondition> Conditions;                                           // 0x0030 (size: 0x10)
    TArray<class USBUtilityService*> Services;                                        // 0x0040 (size: 0x10)
    class USBUtilityAction* Action;                                                   // 0x0050 (size: 0x8)
    ESBUtilityScoreOperator Operation;                                                // 0x0058 (size: 0x1)
    bool bAllowAbortByHighScore;                                                      // 0x0059 (size: 0x1)
    char padding_0[0x1E];                                                             // 0x005A (size: 0x1E)
    TArray<FName> ExecutionTags;                                                      // 0x0078 (size: 0x10)
    bool bAllowOtherOption;                                                           // 0x0088 (size: 0x1)
    char padding_1[0x7];                                                              // 0x0089 (size: 0x7)
    TArray<FName> RestrictionTags;                                                    // 0x0090 (size: 0x10)
    FName OptionName;                                                                 // 0x00A0 (size: 0x8)
    class USBUtilityOption* SourceOption;                                             // 0x00A8 (size: 0x8)

}; // Size: 0xB0

class USBUtilityService : public UObject
{
    char padding_0[0x30];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x30

class USBUtilityService_BlueprintBase : public USBUtilityService
{
    class USBUtilityBrainComponent* OwnerComponent;                                   // 0x0030 (size: 0x8)

    void ReceiveOnTick(float DeltaTime);
    void ReceiveOnDeactivate();
    void ReceiveOnActivate();
}; // Size: 0x38

class USBUtilityService_PreventPlanning : public USBUtilityService
{
    char padding_0[0x40];                                                             // 0x0000 (size: 0x0)
}; // Size: 0x40

class USBUtilityService_RunPerceptionTree : public USBUtilityService
{
    FAIFwParameterizedBTRequest PerceptionTree;                                       // 0x0030 (size: 0x18)
    FString BlackboardKey;                                                            // 0x0048 (size: 0x10)
    float MinInterval;                                                                // 0x0058 (size: 0x4)
    float MaxInterval;                                                                // 0x005C (size: 0x4)
    class UAIFwBlackboardComponent* BlackboardComponent;                              // 0x0060 (size: 0x8)

}; // Size: 0x70

class USBUtilityService_TacticalSkill : public USBUtilityService
{
    class USBAITacticalComponent* TacticalComponent;                                  // 0x0030 (size: 0x8)
    TArray<class TSubclassOf<USBAITacticalSkill>> SkillClasses;                       // 0x0038 (size: 0x10)

}; // Size: 0x48

class USBVersionFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    bool ValidVariationMission();
    bool ValidTokenOverflowQuest();
    bool ValidTokenOverflow();
    bool ValidStepUpGasha();
    bool ValidStampEmoteTermUpdate();
    bool ValidStackB();
    bool ValidSksBattle();
    bool ValidSimplycityPartyMatchTypeA();
    bool ValidSimplycityPartyImprovement();
    bool ValidSignal();
    bool ValidShortcutRingPortal();
    bool ValidShopNotAvailable();
    bool ValidReversePalletmprovement();
    bool ValidRegularSkillLV5();
    bool ValidPineVillage();
    bool ValidPartyKickVote();
    bool ValidPartyInviteImproveFriend();
    bool ValidPaidOnly();
    bool ValidMountStackB();
    bool ValidLiquidMemoryImprovement();
    bool ValidLimitedRecepi();
    bool ValidKiwami();
    bool ValidKeyConfigWarnMsg();
    bool ValidItemWarning();
    bool ValidHideOthersPlayerAtFishing();
    bool ValidGashaResultRoseOrb();
    bool ValidGashaBonusDetail();
    bool ValidForceMatching();
    bool ValidFangExpedition();
    bool ValidFaceIconEdit();
    bool ValidEquipmentSeries();
    bool ValidDxBattle();
    bool ValidDsState();
    bool ValidContentsRandom();
    bool ValidClassP022();
    bool ValidClassP021();
    bool ValidClassP020();
    bool ValidClassAbility7();
    bool ValidAutoStackBStep();
    bool ValidAmazonPayPayment();
    bool ValidAmazonPay1Click();
    bool ValidAdventureCardModifi();
    bool ValidAddLibraryPic();
    int32 GetMaxClassLevel();
}; // Size: 0x28

class USBWarehouseAbilityComponent : public USBPlayerControllerComponentBase
{
    TArray<FSBWarehouseAbilityCharacterInfo> CharacterInfoList;                       // 0x00B8 (size: 0x10)
    TArray<FSBWarehouseAbilityCharacterInfo> UpdatedCharacterInfoList;                // 0x00C8 (size: 0x10)
    FSBWarehouseAbilityComponentOnWarehouseAbilityUpdateDelegate OnWarehouseAbilityUpdateDelegate; // 0x00D8 (size: 0x10)
    void OnWarehouseAbilityUpdateDelegate(const TArray<FSBWarehouseAbilityNotifyUIInfo>& UIInfo);

    void Server_OnUpdateCharacerInfo(const bool bIsAtCharacterJoin);
    void OnWarehouseAbilityUpdateDelegate__DelegateSignature(const TArray<FSBWarehouseAbilityNotifyUIInfo>& UIInfo);
    void GetShouldBeDisplayedLevelList(const ESBWarehouseAbilityCategory InCategory, TArray<int32>& OutLevelList);
    void GetLevelButtonUIInfo(const int32 InLevelMin, const int32 InLevelMax, const ESBWarehouseAbilityCategory InCategory, FSBWarehouseAbilityLevelButtonUiInfo& OutInfo);
    FText GetAbilityNameTextByRecipeId(const int32 InRecipeId);
    void GetAbilityListUIInfo(const int32 Level, const ESBWarehouseAbilityCategory Category, TArray<FSBWarehouseAbilityListUIInfo>& OutArray);
    FText GetAbilityEffectTextByRecipeId(const int32 InRecipeId);
    void GetAbilityConditionUIInfo(const class USBTextTableAsset* InTextTableAsset, const int32 InRecipeId, TArray<FSBWarehouseAbilityConditionUIInfo>& OutArray);
    FSBWarehouseAbilityCharacterInfo FindCharacterInfoByRecipeId(const int32 InRecipeId, bool& bExist);
    void Client_SyncCharacterInfo(const TArray<FSBWarehouseAbilityCharacterInfo>& Infos);
    void Client_OnUpdateCharacterInfo(const TArray<FSBWarehouseAbilityCharacterInfo>& InfoList, const bool bIsAtCharacterJoin);
    bool CheckMasteredByRecipeId(const int32 RecipeId);
    bool CheckAbilityNewByCategory(const ESBWarehouseAbilityCategory Category);
}; // Size: 0xE8

class USBWaterDepthSoundComponent : public USceneComponent
{
    TArray<FSBWaterDepthSoundData> WaterDepthSoundDataArray;                          // 0x0208 (size: 0x10)

}; // Size: 0x220

class USBWaterFlowComponent : public UActorComponent
{
    float Priority;                                                                   // 0x00B8 (size: 0x4)

    float GetWaterFlowPriority();
    bool GetWaterFlowParams(const FVector& Location, FVector& Direction, float& power);
}; // Size: 0xC0

class USBWaterFlowListForActor : public UObject
{
    class AActor* Target;                                                             // 0x0028 (size: 0x8)
    TArray<class USBWaterFlowComponent*> WaterFlowComponents;                         // 0x0030 (size: 0x10)

}; // Size: 0x40

class USBWaterFlowManager : public UObject
{
    class ASBWaterFlowTick* ManagerActor;                                             // 0x0030 (size: 0x8)

    bool RemoveWaterFlowList(class AActor* Actor, class USBWaterFlowComponent* WaterFlow);
    bool AddWaterFlowList(class AActor* Actor, class USBWaterFlowComponent* WaterFlow);
}; // Size: 0x38

class USBWeaponBallHammerComponent : public USBWeaponBaseComponent
{
    class UDataTable* SettingDataTable;                                               // 0x00B8 (size: 0x8)
    TSoftObjectPtr<USkeletalMesh> DefaultBallSkeletalMesh;                            // 0x00C0 (size: 0x28)
    FName DefaultBallRootSocketName;                                                  // 0x00E8 (size: 0x8)
    TArray<int32> DefaultBallMaterialIndexList;                                       // 0x00F0 (size: 0x10)
    char padding_0[0x78];                                                             // 0x0100 (size: 0x78)
    class UObject* m_HoldingBallMeshAssetRef;                                         // 0x0178 (size: 0x8)

}; // Size: 0x180

class USBWeaponBaseComponent : public UActorComponent
{
    char padding_0[0xB8];                                                             // 0x0000 (size: 0x0)
}; // Size: 0xB8

class USBWeaponBendComponent : public USBWeaponBaseComponent
{
    class UCurveFloat* BendCurve;                                                     // 0x00B8 (size: 0x8)

}; // Size: 0xD0

class USBWeaponBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void WeaponLoadLog(FString func, FString Msg);
    void SetWeaponCharaPartsComponentParam(class USBCharaPartsComponent* CharaPartsComponent, class ASBWeapon* Weapon);
}; // Size: 0x28

class USBWeaponBowBImagineComponent : public USBWeaponBowComponentBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x290

class USBWeaponBowComponent : public USBWeaponBowComponentBase
{
    char padding_0[0x290];                                                            // 0x0000 (size: 0x0)
}; // Size: 0x290

class USBWeaponBowComponentBase : public USBWeaponBaseComponent
{
    TArray<FSBEffectSetting> m_BowStringEffectUpperList;                              // 0x00B8 (size: 0x10)
    TArray<FSBEffectSetting> m_BowStringEffectLowerList;                              // 0x00C8 (size: 0x10)
    FSBPlayingEffect m_PlayingBowStringEffectUpper;                                   // 0x00D8 (size: 0xC8)
    FSBPlayingEffect m_PlayingBowStringEffectLower;                                   // 0x01A0 (size: 0xC8)
    char padding_0[0x8];                                                              // 0x0268 (size: 0x8)
    FName m_HoldingArrowBaseSocket;                                                   // 0x0270 (size: 0x8)
    FName m_HoldingArrowTargetSocket;                                                 // 0x0278 (size: 0x8)
    TArray<FHoldingArrowEffectSetting> m_HoldingArrowSettingList;                     // 0x0280 (size: 0x10)

}; // Size: 0x290

class USBWeaponFishingRodComponent : public USBWeaponBaseComponent
{
    FName m_SocketName_Grip;                                                          // 0x00B8 (size: 0x8)
    FName m_SocketName_Top;                                                           // 0x00C0 (size: 0x8)
    TArray<FName> m_SocketName_Line;                                                  // 0x00C8 (size: 0x10)
    FSBEffectSetting m_FishingRodLineEffect;                                          // 0x00D8 (size: 0x150)

    void SetFishingRodLineColor(const FLinearColor& Color);
}; // Size: 0x240

class USBWeaponManager : public UObject
{
    FSBWeaponManagerOnLoadWeaponAssetDelegate OnLoadWeaponAssetDelegate;              // 0x0028 (size: 0x10)
    void OnLoadWeaponAssetDelegate(const int32 WeaponID, const bool IsMain, const TArray<class ASBWeapon*>& Weapons);
    TArray<class ASBWeapon*> LoadedWeapons;                                           // 0x0038 (size: 0x10)
    int32 LoadWeaponMax;                                                              // 0x0048 (size: 0x4)
    int32 AddProficiencyValue_EnemyAttack;                                            // 0x004C (size: 0x4)
    int32 AddProficiencyValue_EnemyKill;                                              // 0x0050 (size: 0x4)

    bool RequestLoadWeaponAsset(int32 WeaponID, bool IsMain);
    void OnLoadWeaponAssetDelegate__DelegateSignature(const int32 WeaponID, const bool IsMain, const TArray<class ASBWeapon*>& Weapons);
    TEnumAsByte<ESBWeaponType> GetWeaponTypeByWeaponID(int32 WeaponID, bool IsMain);
    TEnumAsByte<ESBWeaponType> GetWeaponTypeByWeaponAssetName(const FName& WeaponAssetName);
    int32 GetWeaponPricePlayerSells(int32 WeaponID);
    int32 GetWeaponPricePlayerBuys(int32 WeaponID);
    int32 GetWeaponLevelStatusByWeaponIDWithLevelSync(const class AController* Controller, const int32 WeaponID, const ESBWeaponStatus WeaponStatus, const bool IsLevelSync);
    int32 GetWeaponLevelStatusByWeaponID(int32 WeaponID, ESBWeaponStatus WeaponStatus);
    int32 GetWeaponLevelStatusByUniqueID(const class AController* Controller, FString UniqueId, ESBWeaponStatus WeaponStatus, bool IsLevelSync, bool IsUseStackB, ESBStackBEnableType InStackBEnableType);
    void GetWeaponIDList(TArray<int32>& IDList);
    TArray<FSBWeaponAsset> GetWeaponAssets(const FName& WeaponAssetName);
    int32 GetDefaultWeaponID(ESBClassType ClassType);
    void DestroyAllLoadedWeaponAsset();
}; // Size: 0x58

class USBWeaponShineComponent : public USBWeaponBaseComponent
{
    TArray<FSBEffectShaderParameter> m_EmissiveParamList;                             // 0x00B8 (size: 0x10)

    void ChangeColor(const FLinearColor Color, FName TagString, const TArray<int32> MaterialIndex);
}; // Size: 0xD0

class USBWeaponUIBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void GetWeaponPerkUIInfoTableByUniqueID(TArray<FSBWeaponPerkUIInfo>& OutWeaponPerkUIInfoTable, const class AController* Controller, const FString WeaponUniqueID);
    void GetWeaponPerkUIInfoTableByPerkID(TArray<FSBWeaponPerkUIInfo>& OutWeaponPerkUIInfoTable, TArray<FSBCharacterWeaponPerkData>& PerkList);
    bool GetWeaponPerkUIInfo(int32 PerkId, FSBWeaponPerkUIInfo& OutWeaponPerkUIInfo);
    float GetWeaponAttackPower(const class AController* Controller, const FString WeaponUniqueID);
}; // Size: 0x28

class USBWeaponVisibilityComponent : public UActorComponent
{
    ESBWeaponVisibleType ConfigWeaponVisibleType;                                     // 0x00DD (size: 0x1)

    void SetConfigWeaponVisibleType_Server(ESBWeaponVisibleType VisibleType);
    void SetConfigWeaponVisibleType_Multicast(ESBWeaponVisibleType VisibleType);
    void OnRep_ConfigWeaponVisibleType();
    void OnDelegated_ChangeConfigWeaponVisibleType(ESBWeaponVisibleType VisibleType);
    bool IsOptionHidden();
}; // Size: 0xE0

class USBWholeIcons : public USBMiniMapIconsBase
{
    class USBMapPlayerIcon* PlayerIcon;                                               // 0x02F8 (size: 0x8)
    TArray<class USBMapIcon*> Buddy;                                                  // 0x0300 (size: 0x10)
    TArray<class USBMapIcon*> NamedEnemy;                                             // 0x0310 (size: 0x10)
    TArray<class USBMapIcon*> PartyMember;                                            // 0x0320 (size: 0x10)
    TArray<class USBMapIcon*> Facility;                                               // 0x0330 (size: 0x10)
    TArray<class USBMapIcon*> Quest;                                                  // 0x0340 (size: 0x10)
    TArray<class USBMapIcon*> QuestNpc;                                               // 0x0350 (size: 0x10)
    TArray<class USBMapIcon*> QuestArea;                                              // 0x0360 (size: 0x10)
    TArray<class USBMapIcon*> QuestAreaInterrupt;                                     // 0x0370 (size: 0x10)
    TArray<class USBMapIcon*> QuestChallenge;                                         // 0x0380 (size: 0x10)
    TArray<class USBMapIcon*> WarpPoint;                                              // 0x0390 (size: 0x10)
    TArray<class USBMapIcon*> WarpPointDungeon;                                       // 0x03A0 (size: 0x10)
    TArray<class USBMapIcon*> ID;                                                     // 0x03B0 (size: 0x10)
    TArray<class USBMapIcon*> Camp;                                                   // 0x03C0 (size: 0x10)
    TArray<class USBMapIcon*> Fishing;                                                // 0x03D0 (size: 0x10)
    TArray<class USBMapIcon*> Pin;                                                    // 0x03E0 (size: 0x10)
    TArray<class USBMapIcon*> ShortPin;                                               // 0x03F0 (size: 0x10)

    void UpdateState();
    void SetVisiblePinComment(bool IsVisible);
    class USBMapQuestIcon* IsTypeQuestIcon(const EQuestIconType InQuestType, const FVector& InLocation);
    void DeleteEnemyIcon(class USBMapIcon* InIcon);
    class USBMapIcon* CreateEnemyIcon(class AActor* InActor);
    class USBMapIcon* AddNamedEnemyIcon(class ASBEnemyCharacter* InActor);
    class USBMapIcon* AddBuddyIcon(class ASBEnemyCharacter* InActor);
}; // Size: 0x400

class USBWholeLowerIcons : public USBMiniMapIconsBase
{
    TArray<class USBMapIcon*> WarpPointEx;                                            // 0x02F8 (size: 0x10)

    void UpdateState();
}; // Size: 0x308

class USBWholeMap : public USBMiniMapWidgetBase
{
    class UCanvasPanel* Map;                                                          // 0x0370 (size: 0x8)
    class UImage* BG_0;                                                               // 0x0378 (size: 0x8)
    class UImage* BG_1;                                                               // 0x0380 (size: 0x8)
    class USBTraverseCloudWidget* TraverseCloud;                                      // 0x0388 (size: 0x8)
    class USBMapPlayerIcon* PlayerIcon;                                               // 0x0390 (size: 0x8)

    void UpdateTraverseCloud();
    bool SetEditZoom(float InZoom);
    bool SetEditWindowSizeScaleIndex(int32 Index);
    bool SetEditWindowSize(const FVector2D& InSize);
    bool SetEditPinVisible(bool InChecked);
    bool SetEditOpacity(float InOpacity);
    bool SetEditIconSizeScale(float InScale);
    bool ResetEditParam();
    void PlayAnimOut();
    void PlayAnimIn();
    void Opened();
    void Open(bool isForce);
    void OnOpened();
    void OnOpen();
    void OnDeleteWholeMapEditWindow();
    void OnCreateWholeMapEditWindow();
    void OnClosed();
    void OnClose();
    bool IsActiveTraverseCloud();
    class USBTraverseCloudWidget* GetTraverseCloud();
    class UCanvasPanel* GetMap();
    float GetEditZoom();
    float GetEditWindowSizeScaleTable(int32 Index);
    int32 GetEditWindowSizeScaleIndex();
    FVector2D GetEditWindowSize();
    bool GetEditPinVisible();
    float GetEditOpacity();
    float GetEditIconSizeScale();
    void DeleteWholeMapEditWindow();
    void CreateWholeMapEditWindow();
    void Closed();
    void Close();
    FVector2D CalcWorldToMapPosition(const FVector& InWorld);
}; // Size: 0x3C0

class USBWholeMapSaveGame : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FSBWholeMapDatas Data;                                                            // 0x0040 (size: 0x38)

}; // Size: 0x78

class USBWidgetComponent : public UWidgetComponent
{
    char padding_0[0x5C0];                                                            // 0x0000 (size: 0x0)

    FLinearColor GetTintColorAndOpacity();
    FLinearColor GetBackgroundColor();
}; // Size: 0x5C0

class USBWidgetComponent2D : public USceneComponent
{
    TSubclassOf<class UUserWidget> WidgetClass;                                       // 0x0208 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0210 (size: 0x8)
    TEnumAsByte<EUIZOrder::Type> ZOrderType;                                          // 0x0218 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0219 (size: 0x3)
    FVector2D Anchor;                                                                 // 0x021C (size: 0x8)
    bool bDistanceScaleEnable;                                                        // 0x0224 (size: 0x1)
    char padding_1[0x3];                                                              // 0x0225 (size: 0x3)
    float DistanceScaleMaxDistance;                                                   // 0x0228 (size: 0x4)
    float DistanceScaleValueMin;                                                      // 0x022C (size: 0x4)
    bool bClippingEnable;                                                             // 0x0230 (size: 0x1)
    char padding_2[0x3];                                                              // 0x0231 (size: 0x3)
    float FarClip;                                                                    // 0x0234 (size: 0x4)
    class UUserWidget* Widget;                                                        // 0x0238 (size: 0x8)
    char padding_3[0x18];                                                             // 0x0240 (size: 0x18)
    class UMaterialInstanceDynamic* MaterialInstance;                                 // 0x0258 (size: 0x8)
    char padding_4[0x88];                                                             // 0x0260 (size: 0x88)
    class UTextureRenderTarget2D* RenderTarget;                                       // 0x02E8 (size: 0x8)

    class UUserWidget* GetUserWidgetObject();
}; // Size: 0x400

class USBWidgetComponent2DNoOSR : public USceneComponent
{
    TSubclassOf<class UUserWidget> WidgetClass;                                       // 0x0208 (size: 0x8)
    TEnumAsByte<EUIZOrder::Type> ZOrderType;                                          // 0x0210 (size: 0x1)
    char padding_0[0x3];                                                              // 0x0211 (size: 0x3)
    FVector2D Anchor;                                                                 // 0x0214 (size: 0x8)
    bool bTopLimitMode;                                                               // 0x021C (size: 0x1)
    char padding_1[0x3];                                                              // 0x021D (size: 0x3)
    float TopaActiveDistance;                                                         // 0x0220 (size: 0x4)
    float TopLimit;                                                                   // 0x0224 (size: 0x4)
    float TopCulling;                                                                 // 0x0228 (size: 0x4)
    bool bAdjustedLocationDeath;                                                      // 0x022C (size: 0x1)
    char padding_2[0x3];                                                              // 0x022D (size: 0x3)
    class UCurveFloat* AdjustedLocationDeathCurve;                                    // 0x0230 (size: 0x8)
    char padding_3[0x4];                                                              // 0x0238 (size: 0x4)
    bool bDistanceScaleEnable;                                                        // 0x023C (size: 0x1)
    char padding_4[0x3];                                                              // 0x023D (size: 0x3)
    float DistanceScaleMaxDistance;                                                   // 0x0240 (size: 0x4)
    float DistanceScaleValueMin;                                                      // 0x0244 (size: 0x4)
    bool bClippingEnable;                                                             // 0x0248 (size: 0x1)
    char padding_5[0x3];                                                              // 0x0249 (size: 0x3)
    float FarClip;                                                                    // 0x024C (size: 0x4)
    class UUserWidget* Widget;                                                        // 0x0250 (size: 0x8)

    class UUserWidget* GetUserWidgetObject();
}; // Size: 0x270

class USBWishList : public USaveGame
{
    FString SlotName;                                                                 // 0x0028 (size: 0x10)
    int32 SlotNum;                                                                    // 0x0038 (size: 0x4)
    int32 Version;                                                                    // 0x003C (size: 0x4)
    FString PlayerId;                                                                 // 0x0040 (size: 0x10)
    TMap<class FString, class FSBWishListCharacterData> Data;                         // 0x0050 (size: 0x50)

}; // Size: 0xA0

class USBWwise : public UBlueprintFunctionLibrary
{
    char padding_0[0x28];                                                             // 0x0000 (size: 0x0)

    void UpdateAkComponentOutputBusVolume(class UObject* WorldContextObject);
    void StopAkByPlayingId(int32 PlayingID, int32 FadeMilliSeconds);
    class UAkComponent* SpawnAkComponentAtLocationAndRotation(class UObject* WorldContextObject, const FAkEventVariables& AkEventVariables, const FVector Location, const FRotator Orientation);
    class UAkComponent* SpawnAkComponentAtLocation(class UObject* WorldContextObject, const FAkEventVariables& AkEventVariables, const FVector Location);
    int32 PostAkEventBySceneComponentCallBack(class USceneComponent* SceneComponent, const FAkEventVariables& AkEventVariables, int32 CallbackMask, const FPostAkEventBySceneComponentCallBackPostEventCallback& PostEventCallback);
    int32 PostAkEventBySceneComponent_Simple(class USceneComponent* SceneComponent, class UAkAudioEvent* Event);
    int32 PostAkEventBySceneComponent(class USceneComponent* SceneComponent, const FAkEventVariables& AkEventVariables);
    int32 PostAkEventByAkComponentCallBack(class UAkComponent* AkComponent, int32 CallbackMask, const FPostAkEventByAkComponentCallBackPostEventCallback& PostEventCallback);
    int32 PostAkEventByAkComponent(class UAkComponent* AkComponent);
    int32 PostAkEventByActor_Simple(class AActor* AActor, class UAkAudioEvent* Event);
    int32 PostAkEventByActor(class AActor* AActor, const FAkEventVariables& AkEventVariables);
    int32 PostAkEventAtLocationAndRotation(class USceneComponent* SceneComponent, const FAkEventVariables& AkEventVariables, const FVector Location, const FRotator Orientation);
    int32 PostAkEventAtLocation(class USceneComponent* SceneComponent, const FAkEventVariables& AkEventVariables, const FVector Location);
    void PostAkEventAsyncBySceneComponent(class USceneComponent* SceneComponent, const FAkEventVariables& AkEventVariables, TSoftObjectPtr<UAkAudioEvent> EventPtr);
    void PostAkEventAsyncByAkComponent(class UAkComponent* AkComponent, TSoftObjectPtr<UAkAudioEvent> EventPtr);
    int32 PostAkEvent(class UAkAudioEvent* Event);
}; // Size: 0x28

class USkyBlueSettings : public UObject
{
    TSoftClassPtr<ASBLevelSequenceActor> DefaultLevelSequenceClass;                   // 0x0028 (size: 0x28)
    int32 PlayerMovementReplicationFrequency_Client;                                  // 0x0050 (size: 0x4)
    int32 PlayerMovementReplicationFrequencyStopped_Client;                           // 0x0054 (size: 0x4)

}; // Size: 0x58

#endif
